#!/usr/bin/perl
#
# archivecheck.pl: script to generate a temporary makefile
#                  to check the availability of sources in make/archives.mk
#
# (C) 2012 Stefan Seyfried
# License: GPL v2 or later

use strict;
use warnings;

open(F, "< make/contrib-libs.mk") or die "can't open make/archive.mk";
my $line;
my $found = 0;
my $file;
my $targets;
my %data;
my $count = 0;
my $total = 0;
my @includes;
my %archives;
my @files = ();

while ($line = <F>) {
	next if $line =~ m/^\s*#/;
	chomp $line;
	# archives.mk contains some continuation lines, those are all
	# put into @files, they all get the same URL...
	if ($line =~ m#^\$\(ARCHIVE\)/(.*)(:|\s+\\$)#) {
		$found = 1;
		push @files, $1;
		next;
	}
	if ($found == 1) {
		if ($line =~ m#.*((http|ftp)://.+)\s*$#) {
			my $url = $1;
			# if no continuation, @files contains only one file
			foreach $file (@files) {
				$data{$file} = $url;
				$total++;
			}
		}
	}
	$found = 0;
	$file = "";
	@files = ();
}
close(F);

##
## for following implicit rules (foo%bar.tgz:), we need
## to know what's actually used. Search for $(ARCHIVE)/foo.gz
##
# find all 'include make/foo.mk' lines in Makefile
open(F, "< Makefile") or die "can't open Makefile";
@includes = <F>;
close(F);
@includes = grep(/^include\s/, @includes);
chomp(@includes);
@includes = grep(!/stlinux/, @includes);
@includes = grep(!/make\/archives.mk/, @includes);

for ($line = 0; $line < @includes; $line++) {
	$includes[$line] =~ s/^include\s+//;
}

# open each included file
foreach $file (@includes) {
	$file =~ s/\$\(BOXARCH\)/$ENV{BOXARCH}/;
	#print "file: $file\n";
	my @archivelines;
	unless (open(F, "< $file")) {
		warn "can't open included file $file";
		next;
	}
	@archivelines = <F>;
	close(F);
	# search for $(ARCHIVE)/foo
	@archivelines = grep(/\$\(ARCHIVE\)\/\S+(\s|$)/, @archivelines);
	chomp(@archivelines);
	foreach my $i (@archivelines) {
		#print "archiveline: $i\n";
		# the search/replace removes the currently found $(ARCHIVE)/foo (== $2) from $i
		while ($i =~ s/(^.*)(\$\(ARCHIVE\)\/\S+[^:\|;])(\s.*|:|\||;|$)/$1$3/) {
			$archives{$2} = 1;
		}
	}
}

# remove $(ARCHIVE)/foo-${xxx} -- those are typically in the
# "tar xf ..." parts of the Makefile and thus false positives
my @badarchives = grep(/\${/, keys %archives);
foreach my $i (@badarchives) {
	delete $archives{$i};
}

# %archives now contains the tarballs used by any rule
# %data contains the rules from archives.mk
foreach my $i (keys %data) {
	next unless ($i =~ m/%/);
	# we have a rule like foo%bar.tgz:
	my $k = $i;
	$file = $data{$i};
	delete $data{$i}; # remove foo%bar.tgz...
	$total--;
	$k =~ s/%/.*/; # let's hope this simple rule is enough
	foreach my $j (keys %archives) {
		$j =~ s@^\$\(ARCHIVE\)/@@;
		next unless ($j =~ $k);
		# the rule matched one of the really used tarballs
		# this can happen multiple times (or we wouldn't have
		# the "foo%bar.tgz" target anyway...)
		$data{$j} = $file;
		$total++;
	}
}
##
## end of expanding foo%bar.tgz rules
##

# output Makefile
print "# Makefile autogenerated by $0\n#\n";
print "include make/versions.mk\n\n";
print "# default if called without arguments\n";
print "default: archivecheck\n\n";
my $cmd_v = "-q";
$cmd_v = "" if ($ENV{V}); # "make archivecheck V=1" for verbose wget
my $cmd = "wget $cmd_v --timeout=10 --passive-ftp";

foreach $file (sort(keys %data)) {
	$count++;
	my $url = $data{$file};
	print "$file:\n";
	printf ("\t\@echo \"[%3d/%3d] checking %s...\"\n", $count, $total, $file);
	if ($file =~ m#%#) {
		print "\t\@echo \"skipping $url - cannot expand wildcards\"\n";
	} elsif ($url =~ m#\.googlecode\.com/#) {
		# googlecode does not work with --spider :-(
		# a HEAD request is always answered with 404
		if ($ENV{G}) {
			# dummy download those if called with "G=1"
			print "\t\@$cmd -O /dev/null $url\n";
		} else {
			# ...or simulate "get Headers only" with curl...
			print "\t\@( curl -v $url 2>&3 | dd of=/dev/full 2>/dev/null ) 3>&1|grep -q '^< HTTP/.*200 OK'"
		}
	} else {
		print "\t\@$cmd --spider $url\n";
	}
	print "\n";
	$targets .= " $file";
}

print "\n";
# put the list of targets last in the Makefile because it is ugly :-)
print "archivecheck:$targets\n";
print "\n";
print "PHONY =$targets\n";
