diff -Naurp linux-2.6.34_org/arch/arm/mach-apollo/include/mach/nx_uart_dma.h linux-2.6.34/arch/arm/mach-apollo/include/mach/nx_uart_dma.h
--- linux-2.6.34_org/arch/arm/mach-apollo/include/mach/nx_uart_dma.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/nx_uart_dma.h	2011-09-10 20:50:19.184219000 +0530
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2010 Trident Microsystems (Far East) Ltd. 
+ * All prior copyright rights in this work and the accompanying software 
+ * products transferred to Trident Microsystems (Far East) Ltd. by written 
+ * agreement.  All rights reserved.
+ */
+/*
+ * Copyright 2011 (C) Trident Microsystems
+ * Author: ??
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __ARCH_MACH_NX_UART_DMA_H_
+#define __ARCH_MACH_NX_UART_DMA_H_
+
+
+#include <linux/nx_dmac_1902.h>
+
+
+struct nx_uart_dma_platform_data
+{
+     int dma_enabled;
+#ifdef CONFIG_UART_NX_DMAC_1902
+     struct nx_dmac_1902_slave *slave_tx;
+     struct nx_dmac_1902_slave *slave_rx;
+     u8 dma_tx_burst;
+     u8 dma_rx_burst;
+     u8 txchan_num;
+     u8 rxchan_num;
+#endif
+};
+
+#endif /* __ARCH_MACH_NX_UART_DMA_H_*/
diff -Naurp linux-2.6.34_org/arch/arm/mach-apollo/nx_dmac_1902_dev.c linux-2.6.34/arch/arm/mach-apollo/nx_dmac_1902_dev.c
--- linux-2.6.34_org/arch/arm/mach-apollo/nx_dmac_1902_dev.c	2011-09-10 19:14:18.310212000 +0530
+++ linux-2.6.34/arch/arm/mach-apollo/nx_dmac_1902_dev.c	2011-09-10 20:50:19.186226000 +0530
@@ -63,7 +63,7 @@ struct platform_device dmac_1902_acp_dev
 
 EXPORT_SYMBOL(dmac_1902_acp_device);
 
-#ifdef CONFIG_SPI_NX_DMAC_1902
+#if defined (CONFIG_SPI_NX_DMAC_1902) || defined (CONFIG_UART_NX_DMAC_1902)
 static struct resource dmac_1902_uart_spi_resources[] = {
 	[0] = {
 		.start		= APOLLO_DMAC_1902_UART_SPI_BASE,
@@ -91,7 +91,7 @@ struct platform_device dmac_1902_uart_sp
 
 static struct platform_device *apollo_dmac_1902_platform_devs[] __initdata = {
 	&dmac_1902_acp_device,
-#ifdef CONFIG_SPI_NX_DMAC_1902
+#if defined (CONFIG_SPI_NX_DMAC_1902) || defined (CONFIG_UART_NX_DMAC_1902)
 	&dmac_1902_uart_spi_device
 #endif
 };
diff -Naurp linux-2.6.34_org/arch/arm/mach-apollo/pnx8492.c linux-2.6.34/arch/arm/mach-apollo/pnx8492.c
--- linux-2.6.34_org/arch/arm/mach-apollo/pnx8492.c	2011-09-10 19:14:18.352207000 +0530
+++ linux-2.6.34/arch/arm/mach-apollo/pnx8492.c	2011-09-10 20:50:19.189226000 +0530
@@ -57,6 +57,8 @@
 
 #include <mach/nor.h>
 
+#include <mach/nx_uart_dma.h>
+
 #ifdef CONFIG_APOLLO_SPLASH
 #include <mach/splash_logo.h>
 #endif
@@ -177,107 +179,277 @@ struct sys_timer apollo_timer = {
 	.init	= apollo_timer_init,
 };
 
-static u64 uart_dmamask = ~(u32)0;	/* The dmamask must be set for EHCI to work */
+#ifdef CONFIG_UART_NX_DMAC_1902
+
+extern struct platform_device dmac_1902_uart_spi_device;
+
+static struct  nx_dmac_1902_slave nx_uart_dmac_slv_plfdata[] = {
+/* UART0*/
+  { /* TX peripheral */
+       .dma_dev     = &(dmac_1902_uart_spi_device.dev),
+       .src_per_num = 0,
+       .dst_per_num = 2,
+       .src_burst   = nx_dmac_1902_burst_1,
+       .dst_burst   = nx_dmac_1902_burst_1,
+       .src_incr    = 1,
+       .dst_incr    = 0,
+       .flow_cntrl  = nx_dmac_1902_fcntl_DMA_M_to_P,
+       .src_select  = nx_dmac_1902_ahb_master_1,
+       .dst_select  = nx_dmac_1902_ahb_master_2,
+       .src_width   = DMA_SLAVE_WIDTH_8BIT,
+       .dst_width   = DMA_SLAVE_WIDTH_8BIT,
+  },
+  {/* RX peripheral */
+       .dma_dev     = &(dmac_1902_uart_spi_device.dev),
+       .src_per_num = 6,
+       .dst_per_num = 0,
+       .src_burst   = nx_dmac_1902_burst_1,
+       .dst_burst   = nx_dmac_1902_burst_1,
+       .src_incr    = 0,
+       .dst_incr    = 1,
+       .flow_cntrl  = nx_dmac_1902_fcntl_DMA_P_to_M,
+       .src_select  = nx_dmac_1902_ahb_master_2,
+       .dst_select  = nx_dmac_1902_ahb_master_1,
+       .src_width   = DMA_SLAVE_WIDTH_8BIT,
+       .dst_width   = DMA_SLAVE_WIDTH_8BIT,
+   },
+/* UART1*/
+   { /* TX peripheral */
+       .dma_dev     = &(dmac_1902_uart_spi_device.dev),
+       .src_per_num = 0,
+       .dst_per_num = 3,
+       .src_burst   = nx_dmac_1902_burst_1,
+       .dst_burst   = nx_dmac_1902_burst_1,
+       .src_incr    = 1,
+       .dst_incr    = 0,
+       .flow_cntrl  = nx_dmac_1902_fcntl_DMA_M_to_P,
+       .src_select  = nx_dmac_1902_ahb_master_1,
+       .dst_select  = nx_dmac_1902_ahb_master_2,
+       .src_width   = DMA_SLAVE_WIDTH_8BIT,
+       .dst_width   = DMA_SLAVE_WIDTH_8BIT,
+  },
+  {/* RX peripheral */
+       .dma_dev     = &(dmac_1902_uart_spi_device.dev),
+       .src_per_num = 7,
+       .dst_per_num = 0,
+       .src_burst   = nx_dmac_1902_burst_1,
+       .dst_burst   = nx_dmac_1902_burst_1,
+       .src_incr    = 0,
+       .dst_incr    = 1,
+       .flow_cntrl  = nx_dmac_1902_fcntl_DMA_P_to_M,
+       .src_select  = nx_dmac_1902_ahb_master_2,
+       .dst_select  = nx_dmac_1902_ahb_master_1,
+       .src_width   = DMA_SLAVE_WIDTH_8BIT,
+       .dst_width   = DMA_SLAVE_WIDTH_8BIT,
+   },
+/* UART2*/
+   { /* TX peripheral */
+       .dma_dev     = &(dmac_1902_uart_spi_device.dev),
+       .src_per_num = 0,
+       .dst_per_num = 4,
+       .src_burst   = nx_dmac_1902_burst_1,
+       .dst_burst   = nx_dmac_1902_burst_1,
+       .src_incr    = 1,
+       .dst_incr    = 0,
+       .flow_cntrl  = nx_dmac_1902_fcntl_DMA_M_to_P,
+       .src_select  = nx_dmac_1902_ahb_master_1,
+       .dst_select  = nx_dmac_1902_ahb_master_2,
+       .src_width   = DMA_SLAVE_WIDTH_8BIT,
+       .dst_width   = DMA_SLAVE_WIDTH_8BIT,
+  },
+  {/* RX peripheral */
+       .dma_dev     = &(dmac_1902_uart_spi_device.dev),
+       .src_per_num = 8,
+       .dst_per_num = 0,
+       .src_burst   = nx_dmac_1902_burst_1,
+       .dst_burst   = nx_dmac_1902_burst_1,
+       .src_incr    = 0,
+       .dst_incr    = 1,
+       .flow_cntrl  = nx_dmac_1902_fcntl_DMA_P_to_M,
+       .src_select  = nx_dmac_1902_ahb_master_2,
+       .dst_select  = nx_dmac_1902_ahb_master_1,
+       .src_width   = DMA_SLAVE_WIDTH_8BIT,
+       .dst_width   = DMA_SLAVE_WIDTH_8BIT,
+   },
+/* UART3*/
+   { /* TX peripheral */
+       .dma_dev     = &(dmac_1902_uart_spi_device.dev),
+       .src_per_num = 0,
+       .dst_per_num = 5,
+       .src_burst   = nx_dmac_1902_burst_1,
+       .dst_burst   = nx_dmac_1902_burst_1,
+       .src_incr    = 1,
+       .dst_incr    = 0,
+       .flow_cntrl  = nx_dmac_1902_fcntl_DMA_M_to_P,
+       .src_select  = nx_dmac_1902_ahb_master_1,
+       .dst_select  = nx_dmac_1902_ahb_master_2,
+       .src_width   = DMA_SLAVE_WIDTH_8BIT,
+       .dst_width   = DMA_SLAVE_WIDTH_8BIT,
+  },
+  {/* RX peripheral */
+       .dma_dev     = &(dmac_1902_uart_spi_device.dev),
+       .src_per_num = 9,
+       .dst_per_num = 0,
+       .src_burst   = nx_dmac_1902_burst_1,
+       .dst_burst   = nx_dmac_1902_burst_1,
+       .src_incr    = 0,
+       .dst_incr    = 1,
+       .flow_cntrl  = nx_dmac_1902_fcntl_DMA_P_to_M,
+       .src_select  = nx_dmac_1902_ahb_master_2,
+       .dst_select  = nx_dmac_1902_ahb_master_1,
+       .src_width   = DMA_SLAVE_WIDTH_8BIT,
+       .dst_width   = DMA_SLAVE_WIDTH_8BIT,
+   }
+};
+
+
+static struct nx_uart_dma_platform_data nx_uart_dma_platformdata = {
+    .dma_enabled = 1,
+#if defined CONFIG_IP3106_UART0_DMA
+    .slave_tx = &nx_uart_dmac_slv_plfdata[0],
+    .slave_rx = &nx_uart_dmac_slv_plfdata[1],
+#elif defined CONFIG_IP3106_UART1_DMA
+    .slave_tx = &nx_uart_dmac_slv_plfdata[2],
+    .slave_rx = &nx_uart_dmac_slv_plfdata[3],
+#elif defined CONFIG_IP3106_UART2_DMA
+    .slave_tx = &nx_uart_dmac_slv_plfdata[4],
+    .slave_rx = &nx_uart_dmac_slv_plfdata[5],
+#elif defined CONFIG_IP3106_UART3_DMA
+    .slave_tx = &nx_uart_dmac_slv_plfdata[6],
+    .slave_rx = &nx_uart_dmac_slv_plfdata[7],
+#endif
+    .dma_tx_burst = 4,
+    .dma_rx_burst = 4,
+    .txchan_num   = 0,
+    .rxchan_num   = 1,
+};
+
+static struct nx_uart_dma_platform_data nx_uart_platformdata = {
+        .dma_enabled = 0,
+};
+#else
+static struct nx_uart_dma_platform_data nx_uart_platformdata = {
+        .dma_enabled = 0,
+};
+#endif
+
+static u64 uart_dmamask = ~(u32)0;  /* The dmamask must be set for EHCI to work */
 
 static struct resource uart0_resources[] = {
-	{
-		.start	= IP3106_UART_PORT_0,
-		.end	= IP3106_UART_PORT_0 + SZ_4K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= IRQ_UART_0,
-		.end	= IRQ_UART_0,
-		.flags	= IORESOURCE_IRQ,
-	},
+    {
+        .start  = IP3106_UART_PORT_0,
+        .end    = IP3106_UART_PORT_0 + SZ_4K - 1,
+        .flags  = IORESOURCE_MEM,
+    },
+    {
+        .start  = IRQ_UART_0,
+        .end    = IRQ_UART_0,
+        .flags  = IORESOURCE_IRQ,
+    },
 };
 
 static struct platform_device uart0_device = {
-		.name			= "uart-ip3106",
-		.id			= 0,
-		.dev			= {
-		.platform_data		= NULL,
-		.dma_mask		= &uart_dmamask,
-		.coherent_dma_mask	= 0xffffffff,
-	},
-	.num_resources		= ARRAY_SIZE(uart0_resources),
-	.resource		= uart0_resources,
+    .name       = "uart-ip3106",
+    .id         = 0,
+    .dev        = {
+#ifdef CONFIG_IP3106_UART0_DMA
+            .platform_data      = &nx_uart_dma_platformdata,
+#else
+            .platform_data      = &nx_uart_platformdata,
+#endif
+            .dma_mask           = &uart_dmamask,
+            .coherent_dma_mask  = 0xffffffff,
+    },
+    .num_resources      = ARRAY_SIZE(uart0_resources),
+    .resource           = uart0_resources,
 };
 
 #ifndef CONFIG_EXECUTE_ON_SIMULATOR
 static struct resource uart1_resources[] = {
-	{
-		.start	= IP3106_UART_PORT_1,
-		.end	= IP3106_UART_PORT_1 + SZ_4K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= IRQ_UART_1,
-		.end	= IRQ_UART_1,
-		.flags	= IORESOURCE_IRQ,
-	},
+    {
+        .start  = IP3106_UART_PORT_1,
+        .end    = IP3106_UART_PORT_1 + SZ_4K - 1,
+        .flags  = IORESOURCE_MEM,
+    },
+    {
+        .start  = IRQ_UART_1,
+        .end    = IRQ_UART_1,
+        .flags  = IORESOURCE_IRQ,
+    },
 };
 
 static struct platform_device uart1_device = {
-		.name			= "uart-ip3106",
-		.id			= 1,
-		.dev			= {
-		.platform_data		= NULL,
-		.dma_mask		= &uart_dmamask,
-		.coherent_dma_mask	= 0xffffffff,
-	},
-	.num_resources	= ARRAY_SIZE(uart1_resources),
-	.resource	= uart1_resources,
+    .name       = "uart-ip3106",
+    .id         = 1,
+    .dev        = {
+#ifdef CONFIG_IP3106_UART1_DMA
+        .platform_data      = &nx_uart_dma_platformdata,
+#else
+        .platform_data      = &nx_uart_platformdata,
+#endif
+        .dma_mask           = &uart_dmamask,
+        .coherent_dma_mask  = 0xffffffff,
+    },
+    .num_resources  = ARRAY_SIZE(uart1_resources),
+    .resource       = uart1_resources,
 };
 
 static struct resource uart2_resources[] = {
-	{
-		.start	= IP3106_UART_PORT_2,
-		.end	= IP3106_UART_PORT_2 + SZ_4K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= IRQ_UART_2,
-		.end	= IRQ_UART_2,
-		.flags	= IORESOURCE_IRQ,
-	},
+    {
+        .start  = IP3106_UART_PORT_2,
+        .end    = IP3106_UART_PORT_2 + SZ_4K - 1,
+        .flags  = IORESOURCE_MEM,
+    },
+    {
+        .start  = IRQ_UART_2,
+        .end    = IRQ_UART_2,
+        .flags  = IORESOURCE_IRQ,
+    },
 };
 
 static struct platform_device uart2_device = {
-		.name			= "uart-ip3106",
-		.id			= 2,
-		.dev			= {
-		.platform_data		= NULL,
-		.dma_mask		= &uart_dmamask,
-		.coherent_dma_mask	= 0xffffffff,
-	},
-	.num_resources	= ARRAY_SIZE(uart2_resources),
-	.resource	= uart2_resources,
+    .name       = "uart-ip3106",
+    .id         = 2,
+    .dev        = {
+#ifdef CONFIG_IP3106_UART2_DMA
+        .platform_data      = &nx_uart_dma_platformdata,
+#else
+        .platform_data      = &nx_uart_platformdata,
+#endif
+        .dma_mask           = &uart_dmamask,
+        .coherent_dma_mask  = 0xffffffff,
+    },
+    .num_resources  = ARRAY_SIZE(uart2_resources),
+    .resource       = uart2_resources,
 };
 
 static struct resource uart3_resources[] = {
-	{
-		.start	= IP3106_UART_PORT_3,
-		.end	= IP3106_UART_PORT_3 + SZ_4K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= IRQ_UART_3,
-		.end	= IRQ_UART_3,
-		.flags	= IORESOURCE_IRQ,
-	},
+    {
+        .start  = IP3106_UART_PORT_3,
+        .end    = IP3106_UART_PORT_3 + SZ_4K - 1,
+        .flags  = IORESOURCE_MEM,
+    },
+    {
+        .start  = IRQ_UART_3,
+        .end    = IRQ_UART_3,
+        .flags  = IORESOURCE_IRQ,
+    },
 };
 
 static struct platform_device uart3_device = {
-		.name			= "uart-ip3106",
-		.id			= 3,
-		.dev			= {
-		.platform_data		= NULL,
-		.dma_mask		= &uart_dmamask,
-		.coherent_dma_mask	= 0xffffffff,
-	},
-	.num_resources	= ARRAY_SIZE(uart3_resources),
-	.resource	= uart3_resources,
+    .name       = "uart-ip3106",
+    .id         = 3,
+    .dev        = {
+#ifdef CONFIG_IP3106_UART3_DMA
+        .platform_data      = &nx_uart_dma_platformdata,
+#else
+        .platform_data      = &nx_uart_platformdata,
+#endif
+        .dma_mask           = &uart_dmamask,
+        .coherent_dma_mask  = 0xffffffff,
+    },
+    .num_resources  = ARRAY_SIZE(uart3_resources),
+    .resource       = uart3_resources,
 };
 #endif /* #ifndef CONFIG_EXECUTE_ON_SIMULATOR */
 
diff -Naurp linux-2.6.34_org/drivers/dma/nx_dmac_1902.c linux-2.6.34/drivers/dma/nx_dmac_1902.c
--- linux-2.6.34_org/drivers/dma/nx_dmac_1902.c	2011-09-10 19:15:17.588431000 +0530
+++ linux-2.6.34/drivers/dma/nx_dmac_1902.c	2011-09-10 20:50:19.192228000 +0530
@@ -997,11 +997,16 @@ static struct dma_async_tx_descriptor * 
 #endif
 
   // map the dma sg page
-  sg_len = dma_map_sg(chan2parent(chan), sgl, sg_len, direction);
-  if(sg_len == 0) {
-    dev_err(chan2dev(chan), "  slave_sg: dma_map_sg is failed\n");
-    return NULL;
-  }
+#ifdef CONFIG_UART_NX_DMAC_1902
+  	if( direction == 1)
+#endif
+	{
+		sg_len = dma_map_sg(chan2parent(chan), sgl, sg_len, direction);
+ 	 	if(sg_len == 0) {
+   		dev_err(chan2dev(chan), "  slave_sg: dma_map_sg is failed\n");
+    	  	return NULL;
+  	 	}
+  	}
 
   control = 0;
   control |= NX_DMAC_1902_CHAN_CNTRL_HPROT(NX_DMAC_1902_HPROT_PRIVILEGE_MODE | NX_DMAC_1902_HPROT_CACHEABLE);
@@ -1104,9 +1109,13 @@ static struct dma_async_tx_descriptor * 
       for_each_sg(sgl, sg, sg_len, i) {
         struct nx_dmac_1902_desc  *desc;
 
+#ifdef CONFIG_UART_NX_DMAC_1902
+        mem = sg->dma_address;
+        len = sg->dma_length;
+#else
         mem = sg_phys(sg);
         len = sg_dma_len(sg);
-
+#endif
         if( nxs->flow_cntrl == nx_dmac_1902_fcntl_per_P_to_M) {
           /* 
            * peripheral is the flow controller, hence DMAC does not have 
diff -Naurp linux-2.6.34_org/drivers/serial/ip3106.c linux-2.6.34/drivers/serial/ip3106.c
--- linux-2.6.34_org/drivers/serial/ip3106.c	2011-09-10 19:16:03.769702000 +0530
+++ linux-2.6.34/drivers/serial/ip3106.c	2011-09-12 20:22:25.378407000 +0530
@@ -45,6 +45,12 @@
 
 #include <asm/hardware/ip3106.h>
 
+#ifdef CONFIG_UART_NX_DMAC_1902
+#include <linux/dmaengine.h>
+#include <linux/scatterlist.h>
+#include <linux/nx_dmac_1902.h>
+#include <mach/nx_uart_dma.h>
+#endif
 
 #define PORT_UARTIP3106		(0x13)
 
@@ -91,12 +97,55 @@
  *--------------------------------------------------------------------------*/
 struct ip3106_port
 {
-	struct uart_port  port;
-	unsigned int      old_status;
-	int               flowctrl;
-	int               autortscts;
+	struct uart_port  				port;
+	unsigned int      				old_status;
+	int               				flowctrl;
+	int               				autortscts;
+#ifdef CONFIG_UART_NX_DMAC_1902
+	int  dma_enabled;
+  	struct dma_chan					*chan_tx;
+	struct dma_chan					*chan_rx;
+	struct device					*dma_dev;
+	struct dma_async_tx_descriptor	*desc_tx;
+	struct dma_async_tx_descriptor	*desc_rx[2];
+	dma_cookie_t					cookie_tx;
+	dma_cookie_t					cookie_rx[2];
+	dma_cookie_t					active_rx;
+	struct scatterlist				sg_tx;
+	unsigned int					sg_len_tx;
+	struct scatterlist				sg_rx[2];
+	size_t							buf_len_rx;
+	struct work_struct				work_tx;
+	struct work_struct				work_rx;
+	struct timer_list		   		rx_timer;
+   	struct nx_dmac_1902_slave* 		client_tx;
+	struct nx_dmac_1902_slave* 		client_rx;
+	__u8 chantx_alloted;
+	__u8 chanrx_alloted;
+   u8 txchan_num;
+   u8 rxchan_num;
+#endif
 };
 
+#ifdef CONFIG_UART_NX_DMAC_1902
+struct ip3106_dmae_regs {
+	u32 sar; /* SAR / source address */
+	u32 dar; /* DAR / destination address */
+	u32 tcr; /* TCR / transfer count */
+};
+
+struct ip3106_desc {
+	struct ip3106_dmae_regs hw;
+	struct list_head node;
+	struct dma_async_tx_descriptor async_tx;
+	enum dma_data_direction direction;
+	dma_cookie_t cookie;
+	size_t partial;
+	int chunks;
+	int mark;
+};
+#endif
+
 /* Added for serial modem notification to edwards layer */
 /* Driver notification events*/
 typedef enum
@@ -218,6 +267,282 @@ static unsigned int ip3106_get_modem_ctr
 	return status;
 }
 
+#ifdef CONFIG_UART_NX_DMAC_1902
+void ip3106_dma_tx_complete(void *arg)
+{
+	struct ip3106_port *s = (struct ip3106_port *)arg;
+	struct uart_port *port = &s->port;
+	struct circ_buf *xmit = &port->state->xmit;
+	unsigned long flags;
+
+	dev_dbg(port->dev, "%s(%d)\n", __func__, port->line);
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	xmit->tail += s->sg_tx.length;
+	xmit->tail &= UART_XMIT_SIZE - 1;
+
+	port->icount.tx += s->sg_tx.length;
+
+	async_tx_ack(s->desc_tx);
+	s->cookie_tx = -EINVAL;
+	s->desc_tx = NULL;
+
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+
+	if (uart_circ_chars_pending(xmit))
+		schedule_work(&s->work_tx);
+}
+
+/* Locking: called with port lock held */
+int ip3106_dma_rx_push(struct ip3106_port *s, struct tty_struct *tty,
+			   size_t count)
+{
+	struct uart_port *port = &s->port;
+	int i, active, room;
+
+	room = tty_buffer_request_room(tty, count);
+
+	if (s->active_rx == s->cookie_rx[0]) {
+		active = 0;
+	} else if (s->active_rx == s->cookie_rx[1]) {
+		active = 1;
+	} else {
+		dev_err(port->dev, "cookie %d not found!\n", s->active_rx);
+		return 0;
+	}
+
+	if (room < count)
+		dev_warn(port->dev, "Rx overrun: dropping %u bytes\n",
+			 count - room);
+	if (!room)
+		return room;
+
+	struct scatterlist *sg = &s->sg_rx[0];
+	for (i = 0; i < room; i++) {
+		tty_insert_flip_char(tty, ((u8 *)(sg->page_link + sg->offset))[i],
+				     TTY_NORMAL);
+	}
+	port->icount.rx += room;
+
+	return room;
+}
+
+void ip3106_dma_rx_complete(void *arg)
+{
+	struct ip3106_port *s = (struct ip3106_port *)arg;
+	struct uart_port *port = &s->port;
+	struct tty_struct *tty = port->state->port.tty;
+	unsigned long flags;
+	int count;
+
+	dev_dbg(port->dev, "%s(%d)\n", __func__, port->line);
+	spin_lock_irqsave(&port->lock, flags);
+
+	count = ip3106_dma_rx_push(s, tty, s->buf_len_rx);
+
+	mod_timer(&s->rx_timer, jiffies + msecs_to_jiffies(4));
+
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	if (count)
+		tty_flip_buffer_push(tty);
+
+	schedule_work(&s->work_rx);
+}
+
+
+static void ip3106_start_tx(struct uart_port *port);
+void ip3106_start_rx(struct uart_port *port);
+
+void ip3106_rx_dma_release(struct ip3106_port *s, bool enable_pio)
+{
+	struct dma_chan *chan = s->chan_rx;
+	struct uart_port *port = &s->port;
+	struct scatterlist *sg = &s->sg_rx[0];
+
+	s->chan_rx = NULL;
+	s->cookie_rx[0] = s->cookie_rx[1] = -EINVAL;
+	dma_sync_wait(chan,0);
+   	chan->device->device_terminate_all(chan);
+   dma_free_coherent(port->dev, s->buf_len_rx * 2, sg->page_link + sg->offset, sg->dma_address);
+	if (enable_pio)
+		ip3106_start_rx(port);
+}
+
+void ip3106_tx_dma_release(struct ip3106_port *s, bool enable_pio)
+{
+	struct dma_chan *chan = s->chan_tx;
+	struct uart_port *port = &s->port;
+
+	s->chan_tx = NULL;
+	s->cookie_tx = -EINVAL;
+	dma_sync_wait(chan,0);
+   	chan->device->device_terminate_all(chan);
+	dma_release_channel(chan);
+	if (enable_pio)
+		ip3106_start_tx(port);
+}
+
+void ip3106_dma_submit_rx(struct ip3106_port *s)
+{
+	struct dma_chan *chan = s->chan_rx;
+	int i;
+
+	for (i = 0; i < 2; i++) 
+	{
+		struct scatterlist *sg = &s->sg_rx[i];
+		struct dma_async_tx_descriptor *desc;
+
+		desc = chan->device->device_prep_slave_sg(chan,
+			sg, 1, DMA_FROM_DEVICE, DMA_PREP_INTERRUPT);
+
+		if (desc) 
+		{
+			s->desc_rx[i] = desc;
+			desc->callback = ip3106_dma_rx_complete;
+			desc->callback_param = s;
+			s->cookie_rx[i] = desc->tx_submit(desc);
+		}
+
+		if (!desc || s->cookie_rx[i] < 0) 
+		{
+			if (i) {
+				async_tx_ack(s->desc_rx[0]);
+				s->cookie_rx[0] = -EINVAL;
+			}
+			if (desc) {
+				async_tx_ack(desc);
+				s->cookie_rx[i] = -EINVAL;
+			}
+			dev_warn(s->port.dev,
+				 "failed to re-start DMA, using PIO\n");
+			ip3106_rx_dma_release(s, true);
+			return;
+		}
+	}
+	s->active_rx = s->cookie_rx[0];
+	dma_async_issue_pending(chan);
+}
+
+void work_fn_rx(struct work_struct *work)
+{
+	struct ip3106_port *s = container_of(work, struct ip3106_port, work_rx);
+	struct uart_port *port = &s->port;
+	struct dma_async_tx_descriptor *desc;
+	int new;
+
+	if (s->active_rx == s->cookie_rx[0]) 
+	{
+		new = 0;
+	}
+	else if (s->active_rx == s->cookie_rx[1])
+	{
+		new = 1;
+	}
+	else
+	{
+		dev_err(port->dev, "cookie %d not found!\n", s->active_rx);
+		return;
+	}
+	desc = s->desc_rx[new];
+
+	if (dma_async_is_tx_complete(s->chan_rx, s->active_rx, NULL, NULL) != DMA_SUCCESS)
+	{
+		/* Handle incomplete DMA receive */
+		struct tty_struct *tty = port->state->port.tty;
+		struct dma_chan *chan = s->chan_rx;
+		struct ip3106_desc *ip3106_desc = container_of(desc, struct ip3106_desc,
+						       async_tx);
+		unsigned long flags;
+		int count;
+
+		chan->device->device_terminate_all(chan);
+		dev_dbg(port->dev, "Read %u bytes with cookie %d\n",
+			ip3106_desc->partial, ip3106_desc->cookie);
+
+		spin_lock_irqsave(&port->lock, flags);
+		count = ip3106_dma_rx_push(s, tty, ip3106_desc->partial);
+		spin_unlock_irqrestore(&port->lock, flags);
+
+		if (count)
+			tty_flip_buffer_push(tty);
+	   	ip3106_dma_submit_rx(s);
+		return;
+	}
+	s->cookie_rx[new] = desc->tx_submit(desc);
+	if (s->cookie_rx[new] < 0) 
+	{
+		dev_warn(port->dev, "Failed submitting Rx DMA descriptor\n");
+		ip3106_rx_dma_release(s, true);
+		return;
+	}
+
+	dev_dbg(port->dev, "%s: cookie %d #%d\n", __func__,
+		s->cookie_rx[new], new);
+
+	s->active_rx = s->cookie_rx[!new];
+}
+
+void work_fn_tx(struct work_struct *work)
+{
+	struct ip3106_port *s = container_of(work, struct ip3106_port, work_tx);
+	struct dma_async_tx_descriptor *desc;
+	struct dma_chan *chan = s->chan_tx;
+	struct uart_port *port = &s->port;
+	struct circ_buf *xmit = &port->state->xmit;
+	struct scatterlist *sg = &s->sg_tx;
+
+	/*
+	 * DMA is idle now.
+	 * Port xmit buffer is already mapped, and it is one page... Just adjust
+	 * offsets and lengths. Since it is a circular buffer, we have to
+	 * transmit till the end, and then the rest. Take the port lock to get a
+	 * consistent xmit buffer state.
+	 */
+	spin_lock_irq(&port->lock);
+
+	sg->offset = xmit->tail & (UART_XMIT_SIZE - 1);
+	sg->length = min((int)CIRC_CNT(xmit->head, xmit->tail, UART_XMIT_SIZE),	
+                         CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE));
+	sg->dma_length = sg->length;
+	spin_unlock_irq(&port->lock);
+
+	BUG_ON(!sg->length);
+
+	desc = chan->device->device_prep_slave_sg(chan,	sg, s->sg_len_tx, DMA_TO_DEVICE, DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	if (!desc) {
+
+		/* switch to PIO */
+		ip3106_tx_dma_release(s, true);
+		return;
+	}
+
+	spin_lock_irq(&port->lock);
+	s->desc_tx = desc;
+	desc->callback = ip3106_dma_tx_complete;
+	desc->callback_param = s;
+	spin_unlock_irq(&port->lock);
+	s->cookie_tx = desc->tx_submit(desc);
+	if (s->cookie_tx < 0) 
+	{
+		dev_warn(port->dev, "Failed submitting Tx DMA descriptor\n");
+		/* switch to PIO */
+		ip3106_tx_dma_release(s, true);
+		return;
+	}
+
+	dev_dbg(port->dev, "%s: %p: %d...%d, cookie %d\n", __func__,
+		xmit->buf, xmit->tail, xmit->head, s->cookie_tx);
+	dma_async_issue_pending(chan);
+}
+#endif
+
+
+
 static void ip3106_stop_tx(struct uart_port *port)
 {
 	unsigned int ier = 0;
@@ -242,6 +567,23 @@ static void ip3106_start_tx(struct uart_
 	unsigned int status = 0;
 	struct circ_buf *xmit = &port->state->xmit;
 
+#ifdef CONFIG_UART_NX_DMAC_1902
+	struct ip3106_port *s = (struct ip3106_port *)port;
+	/* To access Interrupt Enable Register, DLab bit in LCR must be ZERO */
+	lcr = UART_GET_LCR(port);
+	lcr &= ~IP3106_UART_LCR_DLAB_MSK;
+	UART_SET_LCR(port, lcr);
+
+    if (s->dma_enabled)
+    {
+		if (s->chan_tx) 
+	    {
+			if (!uart_circ_empty(&s->port.state->xmit) && s->cookie_tx < 0)
+				schedule_work(&s->work_tx);
+	    }
+	   	return;
+	}
+#endif
 	/* To access Interrupt Enable Register, DLab bit in LCR must be ZERO */
 	lcr = UART_GET_LCR(port);
 	lcr &= ~IP3106_UART_LCR_DLAB_MSK;
@@ -687,59 +1029,147 @@ static irqreturn_t ip3106_int(int irq, v
 	unsigned int     status = 0;
 	unsigned int	 mcr = 0;
 	int              handled = 0;
+#ifdef CONFIG_UART_NX_DMAC_1902
+	int rsr = 0;
+	unsigned long tout;
+	unsigned int	   ier = 0;
+	unsigned long     flag = 0;
 
-	spin_lock_irq(&uap->port.lock);
-	status = UART_GET_IIR(port);
-	if (!(status & IP3106_UART_IIR_PENDING_MSK)) {
-		irq_status = (status & IP3106_UART_IIR_INT_MASK) >> 1;
+  	if (1 == uap->dma_enabled) 
+	{
+		struct tty_struct *tty = port->state->port.tty;
+		spin_lock_irq(&uap->port.lock);
+		status = UART_GET_IIR(port);
+		if (!(status & IP3106_UART_IIR_PENDING_MSK)) 
+		{
+			irq_status = (status & IP3106_UART_IIR_INT_MASK) >> 1;
+
+			if ((irq_status  == IP3106_UART_IIR_RLS_INT_ID) &&
+				(UART_GET_IER(port) & IP3106_UART_IER_RLSI_E_MSK)) 
+			{
+				rsr = UART_GET_LSR(port);
+				if (rsr & IP3106_UART_LSR_REG_MSK) 
+				{
+					if (rsr & IP3106_UART_LSR_BI_MSK) 
+					{
+						rsr &= ~(IP3106_UART_LSR_FE_MSK | IP3106_UART_LSR_PE_MSK);
+						port->icount.brk++;
+						if (uart_handle_break(port))
+						goto ignore_char;
+					}
+					else if (rsr & IP3106_UART_LSR_PE_MSK) 
+					{
+						port->icount.parity++;
+					}
+					else if (rsr & IP3106_UART_LSR_FE_MSK)
+					{
+						port->icount.frame++;
+					}
+
+					if (rsr & IP3106_UART_LSR_OE_MSK) 
+					{
+						port->icount.overrun++;
+					}
+
+					rsr &= port->read_status_mask;
+					if (rsr & IP3106_UART_LSR_BI_MSK)
+			 		{
+						flag = TTY_BREAK;
+					}
+					else if (rsr & IP3106_UART_LSR_PE_MSK) 
+					{
+						flag = TTY_PARITY;
+					}
+					else if (rsr & IP3106_UART_LSR_FE_MSK) 
+					{
+						flag = TTY_FRAME;
+					}
+
+					if (tty_insert_flip_char(tty, 0, flag))
+					{
+			             tty_flip_buffer_push(tty);
+					}
 
-		if ((irq_status  == IP3106_UART_IIR_RLS_INT_ID) &&
-			(UART_GET_IER(port) & IP3106_UART_IER_RLSI_E_MSK)) {
-			UART_GET_LSR(port);
-		}
-		if (((irq_status == IP3106_UART_IIR_CTI_INT_ID) ||
-			(irq_status == IP3106_UART_IIR_RDA_INT_ID)) &&
-			(UART_GET_IER(port) & IP3106_UART_IER_RDAI_E_MSK)) {
-			if (uap->flowctrl == CRTSCTS) {
-				if (uap->autortscts == 0) {
-					/* Deassert the RTS */
-					mcr = UART_GET_MCR(port);
-					mcr &= ~IP3106_UART_MCR_RTS_MSK;
-					UART_SET_MCR(port,mcr);
 				}
 			}
-			if(uap->flowctrl == (IXON|IXOFF)) {
-				UART_PUT_THR(port,0x13);
+			if (((irq_status == IP3106_UART_IIR_CTI_INT_ID) ||
+  				 (irq_status == IP3106_UART_IIR_RDA_INT_ID)) &&
+				 (UART_GET_IER(port) & IP3106_UART_IER_RDAI_E_MSK))
+			{
+       			ier = UART_GET_IER(port);
+			    ier &= ~(IP3106_UART_IER_RDAI_E_MSK);
+	    		UART_SET_IER(port, ier);
+		
+     			/* Calculate delay for 1.5 DMA buffers */
+				tout = (port->timeout - HZ / 50) * uap->buf_len_rx * 3 / port->fifosize / 2;
+				dev_dbg(port->dev, "Rx IRQ: setup timeout in %lu ms\n",
+				tout * 1000 / HZ);
+				if (tout < 2)
+					tout = 2;
+         		mod_timer(&uap->rx_timer, jiffies + tout);
 			}
-			ip3106_rx_chars(port);
+ignore_char:		
+			status = UART_GET_IIR(port);
+			handled = 1;
+		}
+		spin_unlock_irq(&uap->port.lock);
+	}
+  	else
+#endif
+  	{
+		spin_lock_irq(&uap->port.lock);
+		status = UART_GET_IIR(port);
+		if (!(status & IP3106_UART_IIR_PENDING_MSK)) {
+			irq_status = (status & IP3106_UART_IIR_INT_MASK) >> 1;
 
-			if(uap->flowctrl == CRTSCTS) {
-				if(uap->autortscts == 0) {
-					/* Assert the RTS */
-					mcr = UART_GET_MCR(port);
-					mcr |= IP3106_UART_MCR_RTS_MSK;
-					UART_SET_MCR(port,mcr);
+			if ((irq_status  == IP3106_UART_IIR_RLS_INT_ID) &&
+				(UART_GET_IER(port) & IP3106_UART_IER_RLSI_E_MSK)) {
+				UART_GET_LSR(port);
+			}
+			if (((irq_status == IP3106_UART_IIR_CTI_INT_ID) ||
+				(irq_status == IP3106_UART_IIR_RDA_INT_ID)) &&
+				(UART_GET_IER(port) & IP3106_UART_IER_RDAI_E_MSK)) {
+				if (uap->flowctrl == CRTSCTS) {
+					if (uap->autortscts == 0) {
+						/* Deassert the RTS */
+						mcr = UART_GET_MCR(port);
+						mcr &= ~IP3106_UART_MCR_RTS_MSK;
+						UART_SET_MCR(port,mcr);
+					}
+				}
+				if(uap->flowctrl == (IXON|IXOFF)) {
+					UART_PUT_THR(port,0x13);
+				}
+				ip3106_rx_chars(port);
+
+				if(uap->flowctrl == CRTSCTS) {
+					if(uap->autortscts == 0) {
+						/* Assert the RTS */
+						mcr = UART_GET_MCR(port);
+						mcr |= IP3106_UART_MCR_RTS_MSK;
+						UART_SET_MCR(port,mcr);
+					}
+				}
+				if(uap->flowctrl == (IXON|IXOFF)) {
+					UART_PUT_THR(port,0x11);
 				}
 			}
-			if(uap->flowctrl == (IXON|IXOFF)) {
-				UART_PUT_THR(port,0x11);
+			if ((irq_status == IP3106_UART_IIR_THRE_INT_ID) &&
+				(UART_GET_IER(port) & IP3106_UART_IER_THREI_E_MSK)) {
+				ip3106_tx_chars(port);
 			}
-		}
-		if ((irq_status == IP3106_UART_IIR_THRE_INT_ID) &&
-			(UART_GET_IER(port) & IP3106_UART_IER_THREI_E_MSK)) {
-			ip3106_tx_chars(port);
-		}
 #ifdef CONFIG_IP3106_UART0        
-		if ((irq_status == IP3106_UART_IIR_MSI_INT_ID) &&
-			(UART_GET_IER(port) & IP3106_UART_IER_MSI_E_MSK )) {
-			ip3106_modem_status(port);
-		}
+			if ((irq_status == IP3106_UART_IIR_MSI_INT_ID) &&
+				(UART_GET_IER(port) & IP3106_UART_IER_MSI_E_MSK )) {
+				ip3106_modem_status(port);
+			}
 #endif        
-		status = UART_GET_IIR(port);
-		handled = 1;
+			status = UART_GET_IIR(port);
+			handled = 1;
+		}
+		spin_unlock_irq(&uap->port.lock);
 	}
-	spin_unlock_irq(&uap->port.lock);
-
+  
 	return IRQ_RETVAL(handled);
 }
 
@@ -807,17 +1237,183 @@ static irqreturn_t ip3106_modem_int(int 
 }
 #endif
 
+
+#ifdef CONFIG_UART_NX_DMAC_1902
+
+void ip3106_start_rx(struct uart_port *port)
+{
+	unsigned int lcr = 0;
+	unsigned int ier  = 0;
+
+	/* To access Interrupt Enable Register, DLab bit in LCR must be ZERO */
+	lcr = UART_GET_LCR(port);
+	lcr &= ~IP3106_UART_LCR_DLAB_MSK;
+	UART_SET_LCR(port, lcr);
+
+	ier = UART_GET_IER(port);
+	ier |= (IP3106_UART_IER_RDAI_E_MSK | IP3106_UART_IER_RLSI_E_MSK );
+	UART_SET_IER(port, ier);
+}
+
+bool filter_tx(struct dma_chan *chan, void *slave)
+{
+	struct ip3106_port *uport = (struct ip3106_port *)slave;
+
+	if( chan->device->dev != uport->client_tx->dma_dev) {
+		return false;
+	}
+
+	if( chan->chan_id == uport->txchan_num) {
+		uport->chan_tx = chan;
+		chan->private =  uport->client_tx;
+		uport->chantx_alloted = 1;
+
+		return true;
+	}
+	else {
+		return false;
+	}
+}
+
+bool filter_rx(struct dma_chan *chan, void *slave)
+{
+	struct ip3106_port *uport = (struct ip3106_port *)slave;
+	if( chan->device->dev != uport->client_rx->dma_dev) {
+		return false;
+	}
+
+	if( chan->chan_id == uport->rxchan_num) {
+		uport->chan_rx = chan;
+		chan->private =  uport->client_rx;
+		uport->chanrx_alloted = 1;
+
+		return true;
+	}
+	else {
+		return false;
+	}
+
+}
+
+
+void rx_timer_fn(unsigned long arg)
+{
+	struct ip3106_port *s = (struct ip3106_port *)arg;
+	struct uart_port *port = &s->port;
+
+    unsigned int lcr = 0;
+    unsigned int ier  = 0;
+    /* To access Interrupt Enable Register, DLab bit in LCR must be ZERO */
+    lcr = UART_GET_LCR(port);
+    lcr &= ~IP3106_UART_LCR_DLAB_MSK;
+    UART_SET_LCR(port, lcr);
+
+    ier = UART_GET_IER(port);
+    ier |= (IP3106_UART_IER_RDAI_E_MSK | IP3106_UART_IER_RLSI_E_MSK );  
+    UART_SET_IER(port, ier);
+	dev_dbg(port->dev, "DMA Rx timed out\n");
+}
+
+void ip3106_request_dma(struct uart_port *port)
+{
+	struct ip3106_port *s = (struct ip3106_port *)port;
+	
+	struct dma_chan *chan;
+	dma_cap_mask_t mask;
+	int nent;
+
+	dev_dbg(port->dev, "%s: port %d DMA %p\n", __func__, port->line, s->dma_dev);
+
+    dma_cap_zero(mask);
+	dma_cap_set(DMA_SLAVE, mask);
+
+	s->cookie_tx = -EINVAL;
+	chan = dma_request_channel(mask, filter_tx, s); 
+	dev_dbg(port->dev, "%s: TX: got channel %p\n", __func__, chan);
+	if (chan) {
+		s->chan_tx = chan;
+		sg_init_table(&s->sg_tx, 1);
+		/* UART circular tx buffer is an aligned page. */
+		BUG_ON((int)port->state->xmit.buf & ~PAGE_MASK);
+
+		sg_set_page(&s->sg_tx, virt_to_page(port->state->xmit.buf),
+			    UART_XMIT_SIZE, (int)port->state->xmit.buf & ~PAGE_MASK);
+		nent = dma_map_sg(port->dev, &s->sg_tx, 1, DMA_TO_DEVICE);
+		if (!nent)
+			ip3106_tx_dma_release(s, false);
+		else {
+			dev_dbg(port->dev, "%s: mapped %d@%p to %x\n", __func__,
+				sg_dma_len(&s->sg_tx),
+				port->state->xmit.buf, sg_dma_address(&s->sg_tx));
+        }
+		s->sg_len_tx = nent;
+		INIT_WORK(&s->work_tx, work_fn_tx);
+	}		
+
+	chan = dma_request_channel(mask, filter_rx, s);
+	dev_dbg(port->dev, "%s: RX: got channel %p\n", __func__, chan);
+	if (chan) {
+		dma_addr_t dma[2];
+		void *buf[2];
+		int i;
+
+		s->chan_rx = chan;
+
+      	s->buf_len_rx = (int)port->fifosize;
+		buf[0] = dma_alloc_coherent(port->dev, s->buf_len_rx * 2,
+					    &dma[0], GFP_KERNEL);
+
+		if (!buf[0]) {
+			dev_warn(port->dev,
+				 "failed to allocate dma buffer, using PIO\n");
+			ip3106_rx_dma_release(s, true);
+			return;
+		}
+
+		buf[1] = buf[0] + s->buf_len_rx;
+		dma[1] = dma[0] + s->buf_len_rx;
+
+		for (i = 0; i < 2; i++) {
+			struct scatterlist *sg = &s->sg_rx[i];
+			sg->page_link   = buf[i];
+			sg->offset	    = (int)buf[i]  & ~PAGE_MASK;
+			sg->length      = s->buf_len_rx;
+			sg->dma_address = dma[i];
+			sg->dma_length  = sg->length;
+		}
+
+		INIT_WORK(&s->work_rx, work_fn_rx);
+		setup_timer(&s->rx_timer, rx_timer_fn, (unsigned long)s);
+
+		ip3106_dma_submit_rx(s);
+	}
+}
+
+void ip3106_free_dma(struct uart_port *port)
+{
+	struct ip3106_port *s = (struct ip3106_port *)port;
+
+	if (!s->dma_enabled)
+		return;
+
+	if (s->chan_tx)
+		ip3106_tx_dma_release(s, false);
+	//if (s->chan_rx)
+	//	ip3106_rx_dma_release(s, false);
+}
+#endif
+
 static int ip3106_startup(struct uart_port *port)
 {
 	unsigned int       retval = 0;
 	unsigned int       divisor = 0;
 	__u8               dll = 0;
-	__u8		   dlm = 0;
+	__u8		          dlm = 0;
 	unsigned int       lcr = 0;
-	unsigned int	   fcr = 0;
-	unsigned int	   ier = 0;
+	unsigned int	    fcr = 0;
+	unsigned int	    ier = 0;
 	unsigned int       baud = BASE_BAUD;
-	unsigned int	   osr = 0;
+	unsigned int	    osr = 0;
 	struct ip3106_port *uport = (struct ip3106_port *)port;
 
 	/* Initilize the Line Control Settings
@@ -868,10 +1464,23 @@ static int ip3106_startup(struct uart_po
 	 * bootup if user enters a key (the interrupt is pending but
 	 * no char in the RX FIFO)
 	 */
+#ifdef CONFIG_UART_NX_DMAC_1902
+	fcr =((IP3106_UART_FCR_FIF_ENA_MSK)	|		/* Bit 0 FIFO Enable */
+		  (IP3106_UART_FCR_TXF_RES_MSK)  |
+		  (IP3106_UART_FCR_RXF_RES_MSK) |
+    	  (IP3106_UART_FCR_RX_TRIG_LEVEL_3
+           << IP3106_UART_FCR_RX_TRIGGER_POS));		/* TX FIFO Reset */
+        if (1 == uport->dma_enabled)
+        {
+            fcr |= (IP3106_UART_FCR_DMA_MSK); 
+        }
+#else
 	fcr =((IP3106_UART_FCR_FIF_ENA_MSK)	|		/* Bit 0 FIFO Enable */
 		  (IP3106_UART_FCR_TXF_RES_MSK)	|		/* TX FIFO Reset */
 		  (IP3106_UART_FCR_RX_TRIG_LEVEL_3
 		<< IP3106_UART_FCR_RX_TRIGGER_POS));
+#endif
+	   
 	UART_SET_FCR(port,fcr);
 
 	/* Clear the Interrupt status signals */
@@ -900,6 +1509,15 @@ static int ip3106_startup(struct uart_po
 		return retval;
 	}
 
+#ifdef CONFIG_UART_NX_DMAC_1902
+	if (1 == uport->dma_enabled)
+    {
+		ip3106_request_dma(port);
+		ip3106_start_tx(port);
+		ip3106_start_rx(port);
+    }
+#endif	   
+
 	/* Finally enable the receive interrupts interrupts */
 	ier = (IP3106_UART_IER_RDAI_E_MSK | IP3106_UART_IER_RLSI_E_MSK );
 	UART_SET_IER(port, ier);
@@ -908,6 +1526,7 @@ static int ip3106_startup(struct uart_po
 
 static void ip3106_shutdown(struct uart_port *port)
 {
+
 	unsigned int lcr = 0;
 
 	/* Free the interrupt */
@@ -929,6 +1548,14 @@ static void ip3106_shutdown(struct uart_
 
 	/* Disable the FIFOs */
 	UART_SET_FCR(port, 0);
+
+#ifdef CONFIG_UART_NX_DMAC_1902
+	struct ip3106_port *uport = (struct ip3106_port *)port;
+    if (1 == uport->dma_enabled)
+    {
+    	ip3106_free_dma(port);
+    }
+#endif
 }
 
 static void ip3106_set_termios(struct uart_port *port,
@@ -996,11 +1623,23 @@ static void ip3106_set_termios(struct ua
 		}
 	}
 	if (port->fifosize > 1) {
+#ifdef CONFIG_UART_NX_DMAC_1902
 		fcr =((IP3106_UART_FCR_FIF_ENA_MSK)	|	/* Bit 0 FIFO Enable */
 			(IP3106_UART_FCR_RXF_RES_MSK)	|	/* RX FIFO Reset */
 			(IP3106_UART_FCR_TXF_RES_MSK)	|	/* TX FIFO Reset */
 			(IP3106_UART_FCR_RX_TRIG_LEVEL_3
 				<< IP3106_UART_FCR_RX_TRIGGER_POS));
+        if (1 == uport->dma_enabled)
+        {
+            fcr |= (IP3106_UART_FCR_DMA_MSK);
+        }
+#else
+      fcr =((IP3106_UART_FCR_FIF_ENA_MSK) |  /* Bit 0 FIFO Enable */
+         (IP3106_UART_FCR_RXF_RES_MSK) |  /* RX FIFO Reset */
+         (IP3106_UART_FCR_TXF_RES_MSK) |  /* TX FIFO Reset */
+         (IP3106_UART_FCR_RX_TRIG_LEVEL_3
+            << IP3106_UART_FCR_RX_TRIGGER_POS));
+#endif
 	}
 
 	spin_lock_irqsave(&port->lock, flags);
@@ -1473,6 +2112,8 @@ static int ip3106_probe(struct platform_
 	struct ip3106_port *uap = NULL;
 	struct resource *res;
 	void __iomem *base;
+
+
 	int ret = -ENODEV;
 
 	res = platform_get_resource(dev, IORESOURCE_MEM, 0);
@@ -1504,6 +2145,29 @@ static int ip3106_probe(struct platform_
 	uap->port.line  = ip3106_line;
 	uap->autortscts = 0;
 	uap->flowctrl   = 0;
+#ifdef CONFIG_UART_NX_DMAC_1902
+    struct nx_uart_dma_platform_data *plfdata;
+    plfdata = (struct nx_uart_dma_platform_data*)(dev->dev.platform_data);
+          
+   	uap->dma_enabled = plfdata->dma_enabled;
+    if (1 == uap->dma_enabled)
+    {
+    	uap->client_rx = plfdata->slave_rx;
+        uap->client_tx = plfdata->slave_tx;
+		uap->chantx_alloted = false;
+		uap->chanrx_alloted = false;
+
+	    uap->txchan_num = plfdata->txchan_num;
+	    uap->rxchan_num = plfdata->rxchan_num;
+
+        uap->chan_rx = NULL;
+        uap->chan_tx = NULL;
+
+        uap->client_tx->tx_reg =  (u32)((uap->port.mapbase & 0xffff) + IP3106_UART_THR_REG);
+        uap->client_rx->rx_reg =  (u32)((uap->port.mapbase& 0xffff) + IP3106_UART_RBR_REG);
+
+	}
+#endif
 
 	spin_lock_init(&uap->port.lock);
 	platform_set_drvdata(dev, uap);
diff -Naurp linux-2.6.34_org/drivers/serial/Kconfig linux-2.6.34/drivers/serial/Kconfig
--- linux-2.6.34_org/drivers/serial/Kconfig	2011-09-10 19:16:02.927786000 +0530
+++ linux-2.6.34/drivers/serial/Kconfig	2011-09-12 19:52:44.736504000 +0530
@@ -1531,28 +1531,63 @@ config SERIAL_IP3106_CONSOLE
           your boot loader (lilo or loadlin) about how to pass options to the
           kernel at boot time.)
 
+config UART_NX_DMAC_1902
+   bool
+
 config IP3106_UART0
 	bool "IP3106 UART0 at 0xe06e1000"
         depends on IP3106
 	help
 	  Enable support for the IP3106 UART0.
 
+config IP3106_UART0_DMA
+   bool "IP3106 UART0 DMA"
+	select UART_NX_DMAC_1902
+   depends on IP3106_UART0
+	default n
+   help
+     Enable DMA support for UART0.
+
 config IP3106_UART1
 	bool "IP3106 UART1 at 0xe06e2000"
         depends on IP3106
 	help
 	  Enable support for the IP3106 UART1.
 
+config IP3106_UART1_DMA
+   bool "IP3106 UART1 DMA"
+   select UART_NX_DMAC_1902
+   depends on IP3106_UART1
+	default n
+   help
+     Enable DMA support for UART1.
+
 config IP3106_UART2
 	bool "IP3106 UART2 at 0xe06e3000"
         depends on IP3106
 	help
 	  Enable support for the IP3106 UART2.
 
+config IP3106_UART2_DMA
+   bool "IP3106 UART2 DMA"
+   select UART_NX_DMAC_1902
+   depends on IP3106_UART2
+	default n
+   help
+     Enable DMA support for UART2.
+
 config IP3106_UART3
 	bool "IP3106 UART3 at 0xe06e4000"
         depends on IP3106
 	help
 	  Enable support for the IP3106 UART3.
 
+config IP3106_UART3_DMA
+   bool "IP3106 UART3 DMA"
+   select UART_NX_DMAC_1902
+   depends on IP3106_UART3
+	default n
+   help
+     Enable DMA support for UART3.
+
 endmenu
