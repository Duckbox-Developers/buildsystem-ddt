diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/candd-common.mk linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/candd-common.mk
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/candd-common.mk	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/candd-common.mk	2012-09-14 14:51:36.753990000 +0530
@@ -0,0 +1,57 @@
+################################################################################
+#                        Entropic Communications, Inc.                         #
+#                         Copyright (c) 2001-2008                              #
+#                          All rights reserved.                                #
+################################################################################
+
+################################################################################
+# This file is licensed under GNU General Public license, except that if you   #
+# have entered into a signed, written license agreement with Entropic covering #
+# this file, that agreement applies to this file instead of the GNU General    #
+# Public License.                                                              #
+#                                                                              #
+# This file is free software: you can redistribute and/or modify it under the  #
+# terms of the GNU General Public License, Version 2, as published by the Free #
+# Software Foundation, unless a different license applies as provided above.   #
+#                                                                              #
+# This program is distributed in the hope that it will be useful, but AS-IS and#
+# WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,#
+# FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, #
+# except as permitted by the GNU General Public License or another license     #
+# agreement between you and Entropic, is prohibited.                           #
+#                                                                              #
+# You should have received a copy of the GNU General Public License, Version 2 #
+# along with this file; if not, see <http://www.gnu.org/licenses/>.            #
+################################################################################
+
+##############################################
+# PCI eth driver makefile for a non operating system build
+##############################################
+
+##############################################
+# Common definitions for all builds of PCI.  At this time, these 
+#  lists are not used in operating system builds.
+export ENTROPIC_CANDD_C_FILES =              \
+  Src/Clnk_ctl_candd.c                       \
+  Src/ClnkBus_iface_candd.c                  \
+  Src/CandD_util.c                           \
+  ../Common/Src/ClnkIo.c                     \
+  ../Common/Src/ctx_setup.c                  \
+  ../Common/Src/ClnkIo_common.c              \
+  ../Common/Src/ClnkMbx_dvr.c                \
+  ../Common/Src/ClnkMbx_call.c               \
+  ../Common/Src/ClnkMbx_ttask.c              \
+  ../Common/Src/ctx_abs.c                    \
+  ../Common/Src/util_dvr.c                   \
+
+export ENTROPIC_CANDD_H_FILES =              \
+
+export ENTROPIC_CANDD_INC_DIRS =             \
+ Inc                                         \
+ ../Common/Inc                               \
+
+export ENTROPIC_CANDD_EXTRA_CFLAGS =         \
+  -DCANDD_DRVR_SUPPORT                       \
+
+
+include candd-osnone.mk
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/candd-osnone.mk linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/candd-osnone.mk
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/candd-osnone.mk	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/candd-osnone.mk	2012-09-14 14:51:36.757987000 +0530
@@ -0,0 +1,75 @@
+################################################################################
+#                        Entropic Communications, Inc.                         #
+#                         Copyright (c) 2001-2008                              #
+#                          All rights reserved.                                #
+################################################################################
+
+################################################################################
+# This file is licensed under GNU General Public license, except that if you   #
+# have entered into a signed, written license agreement with Entropic covering #
+# this file, that agreement applies to this file instead of the GNU General    #
+# Public License.                                                              #
+#                                                                              #
+# This file is free software: you can redistribute and/or modify it under the  #
+# terms of the GNU General Public License, Version 2, as published by the Free #
+# Software Foundation, unless a different license applies as provided above.   #
+#                                                                              #
+# This program is distributed in the hope that it will be useful, but AS-IS and#
+# WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,#
+# FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, #
+# except as permitted by the GNU General Public License or another license     #
+# agreement between you and Entropic, is prohibited.                           #
+#                                                                              #
+# You should have received a copy of the GNU General Public License, Version 2 #
+# along with this file; if not, see <http://www.gnu.org/licenses/>.            #
+################################################################################
+
+##############################################
+# CANDD eth driver makefile for a non operating system build
+##############################################
+
+
+
+##############################################
+# Specific additions for non-operating system builds
+ENTROPIC_CANDD_C_FILES +=                      \
+  ../Common/Src/hostos_stubs.c                 \
+  ../Common/Src/misc_driver_stubs.c            \
+ 
+ENTROPIC_CANDD_H_FILES +=                      \
+
+ENTROPIC_CANDD_INC_DIRS +=                     \
+
+ENTROPIC_CANDD_EXTRA_CFLAGS +=                 \
+
+TARGET = pci-osnone
+OBJ    = $(patsubst %.c, %.o, $(ENTROPIC_CANDD_C_FILES))
+LIBS   =
+
+CXXFLAGS += $(ENTROPIC_COMMON_CFLAGS)
+CXXFLAGS += $(ENTROPIC_CANDD_EXTRA_CFLAGS)
+CXXFLAGS += $(patsubst %, -I $(CURDIR)/%, $(ENTROPIC_CANDD_INC_DIRS))
+CXXFLAGS += -DLICENSE_ENTROPIC_ONLY_STUBS
+
+OBJ_LCL = $(notdir $(OBJ))
+
+.PHONY: default
+default: $(TARGET)
+
+.PHONY: $(TARGET)
+$(TARGET): $(OBJ) $(LIBS)
+	@echo Creating $@ linked object...
+	gcc -o $@.a $(OBJ_LCL)
+	@echo Skipped.
+
+.PHONY: %.o
+%.o : 
+	@echo Rule $@ Compiling for item $<...
+	gcc -c $(CXXFLAGS) $(patsubst %.o, %.c, $@) -o $(notdir $@)
+	@echo Rule $@ Compiled item $<
+
+clean:
+	-rm -f *.o *.a $(OBJ)
+
+
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Inc/apollo_hdr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Inc/apollo_hdr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Inc/apollo_hdr.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Inc/apollo_hdr.h	2012-09-14 14:51:36.760993000 +0530
@@ -0,0 +1,70 @@
+/*******************************************************************************
+*
+* Apollo/Inc/apollo_hdr.h
+*
+* Description: Apollo driver main compilation control
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __apollo_hdr_h__
+#define __apollo_hdr_h__
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "driverversion.h"
+#include "HostOS_Spec_apollo.h"
+#include "inctypes_dvr.h"
+
+#include "common_dvr.h"
+#include "Clnk_ctl_dvr.h"
+#include "ClnkBus_iface.h"
+#include "ClnkMbx_dvr.h"
+#include "hw_z2_dvr.h"
+
+#include "control_context.h"
+#include "drv_ctl_opts.h"
+#include "clnkiodefs.h"
+
+#include "debug.h"
+
+/*******************************************************************************
+*                            P R O T O T Y P E S                               *
+********************************************************************************/
+
+#include "com_abs_proto.h"
+#include "HostOS_proto.h"
+
+#include "Apollo_proto.h"
+#include "Common_proto.h"
+
+
+#endif // __apollo_hdr_h__
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Inc/Apollo_proto.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Inc/Apollo_proto.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Inc/Apollo_proto.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Inc/Apollo_proto.h	2012-09-14 14:51:36.763992000 +0530
@@ -0,0 +1,12 @@
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/ClnkBus_iface.c ***/
+
+/*** public prototypes from Src/Clnk_ctl_apollo.c ***/
+
+/*** public prototypes from Src/mdio.c ***/
+int clnk_write( void *vctx, SYS_UINT32 addr, SYS_UINT32 data);
+int clnk_read( void *vctx, SYS_UINT32 addr, SYS_UINT32 *data);
+int clnk_write_burst( void *vctx, SYS_UINT32 addr, SYS_UINT32 *data, unsigned int size, int inc);
+int clnk_read_burst( void *vctx, SYS_UINT32 addr, SYS_UINT32 *data, unsigned int size, int inc);
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Inc/control_context_apollo.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Inc/control_context_apollo.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Inc/control_context_apollo.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Inc/control_context_apollo.h	2012-09-14 14:51:36.766997000 +0530
@@ -0,0 +1,84 @@
+/*******************************************************************************
+*
+* Apollo/Inc/control_context_apollo.h
+*
+* Description: Apollo Driver context definition
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __control_context_apollo_h__
+#define __control_context_apollo_h__
+
+#if 1 // added for MID RF (DEBUG_EPP)
+#include "common_dvr.h"
+
+#define EPP_CAP_FLAGS_RAW_DATA  1
+#define EPP_CAP_FLAGS_CORR_DATA 2
+#endif
+// Control plane Context Structure
+struct _control_context
+{
+    void                *p_dg_ctx ;     // pointer to driver gpl context
+    void                *p_dk_ctx ;     // pointer to driver kernel context
+
+    SYS_UINTPTR         baseAddr;
+    Clnk_MBX_Mailbox_t  mailbox;
+    SYS_UINT8           mailboxInitialized;
+
+    SYS_UINT32          pSwUnsolQueue;      // Software unsolicited queue pointer
+    SYS_UINT32          swUnsolQueueSize;
+
+    void                *at_lock_link;          // spinlock for address translation
+    void                *ioctl_sem_link;
+    void                *mbx_cmd_lock_link;     // mailbox cmd spin lock - referenced in !GPL side
+    void                *mbx_swun_lock_link;    // mailbox sw unsol spin lock - referenced in !GPL side
+    void                *ms_cmd_lock_link;      // moca shell command spin lock - referenced in !GPL side
+
+    SYS_UINT32          clnkThreadID;
+    SYS_UINT32          clnkThreadStop;
+
+    SYS_UINT8           clnk_ctl_in[   CLNK_CTL_MAX_IN_LEN];
+    SYS_UINT8           clnk_ctl_out[  CLNK_CTL_MAX_OUT_LEN];
+
+    SYS_UINT32          at3_base;   // Address translator 3 base address
+    ClnkDef_EvmData_t *         evmData;
+#if 1 // added for MID RF (DEBUG_EPP)
+    ClnkDef_EppData_t           eppData;
+    ClnkDef_EppCapCfg_t         eppCapCfg;
+#endif
+#if FEATURE_FEIC_PWR_CAL
+    ClnkDef_FeicStatus_t      FeicStatus;
+#endif
+    SYS_UINT32          freqBand;
+} ;
+
+typedef struct _control_context dc_context_t;
+
+#endif /* __control_context_apollo_h__ */
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Inc/driverversion_apollo.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Inc/driverversion_apollo.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Inc/driverversion_apollo.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Inc/driverversion_apollo.h	2012-09-14 14:51:36.777993000 +0530
@@ -0,0 +1 @@
+#define DRV_VERSION "0.0.0.0"
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Inc/HostOS_Spec_apollo.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Inc/HostOS_Spec_apollo.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Inc/HostOS_Spec_apollo.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Inc/HostOS_Spec_apollo.h	2012-09-14 14:51:36.780996000 +0530
@@ -0,0 +1,64 @@
+/*******************************************************************************
+*
+* Apollo/Inc/HostOS_Spec_apollo.h
+*
+* Description: Host OS Specifications
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __HostOS_Spec_h__
+#define __HostOS_Spec_h__
+
+/*
+ * USER CONFIGURABLES
+ */
+
+#define DRV_NAME    "Apollo"
+
+
+// HostOS print control -- This is the lowest priority (numerically highest level) that will print
+#define HOST_OS_PRINTLOG_THRESHOLD   L_INFO
+
+// Mailbox Queue Constants
+#define CLNK_MBX_CMD_QUEUE_SIZE     32  // Must be a multiple of 2
+#define CLNK_MBX_SWUNSOL_QUEUE_SIZE 32  // Must be a multiple of 2
+#define SW_UNSOL_HW_QUEUE_SIZE      12  // set by HW
+
+#define CLNK_ETH_MRT_TRANSACTION_TIMEOUT    3         // in seconds
+
+#define TT_TASK_SLEEP       15  // in milliseconds
+
+#define DEBUG_IOCTL_PRIV    0   // define for IOCTL debug prints
+#define DEBUG_IOCTL_CMDQ    0   // define for IOCTL debug prints
+#define DEBUG_IOCTL_MEM     0   // define for IOCTL debug prints
+#define DEBUG_IOCTL_UNSOLQ  0   // define for IOCTL debug prints
+
+#endif /* __HostOS_Spec_h__ */
+
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Makefile linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Makefile
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Makefile	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Makefile	2012-09-14 14:51:36.788991000 +0530
@@ -0,0 +1,121 @@
+################################################################################
+#                        Entropic Communications, Inc.                         #
+#                         Copyright (c) 2001-2008                              #
+#                          All rights reserved.                                #
+################################################################################
+
+################################################################################
+# This file is licensed under GNU General Public license, except that if you   #
+# have entered into a signed, written license agreement with Entropic covering #
+# this file, that agreement applies to this file instead of the GNU General    #
+# Public License.                                                              #
+#                                                                              #
+# This file is free software: you can redistribute and/or modify it under the  #
+# terms of the GNU General Public License, Version 2, as published by the Free #
+# Software Foundation, unless a different license applies as provided above.   #
+#                                                                              #
+# This program is distributed in the hope that it will be useful, but AS-IS and#
+# WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,#
+# FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, #
+# except as permitted by the GNU General Public License or another license     #
+# agreement between you and Entropic, is prohibited.                           #
+#                                                                              #
+# You should have received a copy of the GNU General Public License, Version 2 #
+# along with this file; if not, see <http://www.gnu.org/licenses/>.            #
+################################################################################
+
+# CandD module makefile
+#
+# Makefile for mini driver to drive Clock and Data lines       ##
+#
+
+
+ifndef DVR_CWD
+    export DVR_CWD := $(CURDIR)
+    #$(warning ~~~~~~~~~~~ top DVR_CWD=$(DVR_CWD))
+endif
+
+ifeq ($(SNAPGEAR_KERN_VER), 26)
+DRV_INCLUDES  = -I $(DVR_CWD)/drivers/clink/Inc \
+                -I $(DVR_CWD)/drivers/clink/../GPL/CandD \
+                -I $(DVR_CWD)/drivers/clink/../Common/Inc \
+                -I $(DVR_CWD)/drivers/clink/../GPL/Common \
+                -I $(DVR_CWD)/include/linux 
+else
+DRV_INCLUDES  = -I $(DVR_CWD)/Inc \
+                -I $(DVR_CWD)/../GPL/CandD \
+                -I $(DVR_CWD)/../Common/Inc \
+                -I $(DVR_CWD)/../GPL/Common
+endif
+
+olist := Src/Clnk_ctl_candd.o \
+         Src/ClnkBus_iface_candd.o \
+         Src/CandD_util.o \
+         ../Common/Src/ClnkIo.o \
+         ../Common/Src/ctx_setup.o \
+         ../Common/Src/ClnkMbx_dvr.o \
+         ../Common/Src/ClnkMbx_call.o \
+         ../Common/Src/ClnkIo_common.o \
+         ../Common/Src/ctx_abs.o \
+         ../Common/Src/util_dvr.o \
+         ../GPL/CandD/CandD.o \
+         ../GPL/CandD/mdio.o \
+         ../GPL/Common/gpl_ctx_setup.o \
+         ../GPL/Common/gpl_ctx_abs.o \
+         ../GPL/Common/hostos_linux.o
+
+
+EXTRA_CFLAGS +=  $(DRV_INCLUDES)
+EXTRA_CFLAGS += -DCANDD_DRVR_SUPPORT
+EXTRA_CFLAGS += -DCLNK_HOST_SEM -DMV_CPU_LE
+
+ifeq ($(SNAPGEAR_KERN_VER), 26)
+
+# clnkdvr components
+  CandDdvr-objs := $(olist)
+
+  # final LKM objects
+  obj-$(CONFIG_NET_CLINK) += CandDdvr.o
+  
+  ifeq ($(DEBUG),y)
+    DEBFLAGS = -O -g # "-O" is needed to expand inlines
+  else
+    DEBFLAGS = -O2
+  endif
+  
+  EXTRA_CFLAGS += $(DEBFLAGS)
+  EXTRA_CFLAGS += $(DRV_INCLUDES)
+  
+else # KERN 24
+export-objs :=
+obj-y       :=
+obj-n       :=
+obj-m       :=
+obj-        :=
+O_TARGET    := CandDdvr.ko
+obj-y       += $(olist)
+ 
+obj-$(CONFIG_NET_CLINK) += CandDdvr.ko
+
+include $(TOPDIR)/Rules.make
+endif # KERN 26
+
+EXTRA_CFLAGS_nostdinc += $(DEBFLAGS)
+##EXTRA_CFLAGS_nostdinc += -I../../inc -I.
+
+
+KSRC ?= /usr/src/linux
+
+# V=1 for verbose showing of commands
+kern:   clean
+	$(MAKE) modules -C $(KSRC) KBUILD_EXTMOD=`pwd` V=1
+
+clean:
+	@echo "CLEAN $(DVR_CWD)"
+	-$(MAKE) clean -C $(KSRC) KBUILD_EXTMOD=`pwd`
+	rm -f ../GPL/CandD/*.o 
+	rm -f Src/*.o 
+	rm -f ../Common/Src/*.o
+	rm -f ../GPL/Common/*.o 
+	rm -f *.ko
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Rules.make linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Rules.make
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Rules.make	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Rules.make	2012-09-14 14:51:36.792987000 +0530
@@ -0,0 +1,92 @@
+################################################################################
+#                        Entropic Communications, Inc.
+#                         Copyright (c) 2001-2008
+#                          All rights reserved.
+################################################################################
+################################################################################
+# This file is licensed under the terms of your license agreement(s) with      #
+# Entropic covering this file. Redistribution, except as permitted by the      #
+# terms of your license agreement(s) with Entropic, is strictly prohibited.    #
+################################################################################
+
+# -*-makefile-*-
+#
+# This file is part of the sample code for the book "Linux Device Drivers",
+# second edition. It is meant to be generic and is designed to be recycled
+# by other drivers. The comments should be clear enough.
+# It partly comes from Linux Makefile, and needs GNU make. <rubini@linux.it>
+
+# TOPDIR is declared by the Makefile including this file.
+ifndef TOPDIR
+	TOPDIR = .
+endif
+
+# Set the CROSS COMPILE prefix and directory for source
+CROSS_COMPILE=y
+
+ifeq ($(CROSS_COMPILE),y)
+	KERNELDIR = /exports/coyote/usr/src/linux
+	X_COMPILE=xscale_be-
+else
+	KERNELDIR = /usr/src/linux
+	X_COMPILE=
+endif
+
+
+# The headers are taken from the kernel
+	INCLUDEDIR = $(KERNELDIR)/include
+
+# We need the configuration file, for CONFIG_SMP and possibly other stuff
+# (especiall for RISC platforms, where CFLAGS depends on the exact
+# processor being used).
+#ifeq ($(KERNELDIR)/.config,$(wildcard $(KERNELDIR))/.config)
+#	include $(KERNELDIR)/.config
+#else
+#	MESSAGE := $(shell echo "WARNING: no .config file in $(KERNELDIR)")
+#endif
+
+# ARCH can be speficed on the comdline or env. too, and defaults to this arch
+# Unfortunately, we can't easily extract if from kernel configuration
+# (well, we could look athe asm- symlink... don't know if worth the effort)
+ifndef ARCH
+  ARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ \
+		-e s/arm.*/arm/ -e s/sa110/arm/)
+endif
+
+
+
+# This is useful if cross-compiling. Taken from kernel Makefile (CC changed)
+AS      =$(X_COMPILE)as
+LD      =$(X_COMPILE)ld
+CC      =$(X_COMPILE)gcc
+CPP     =$(CC) -E
+AR      =$(X_COMPILE)ar
+NM      =$(X_COMPILE)nm
+STRIP   =$(X_COMPILE)strip
+OBJCOPY =$(X_COMPILE)objcopy
+OBJDUMP =$(X_COMPILE)objdump
+
+# The platform-specific Makefiles include portability nightmares.
+# Some platforms, though, don't have one, so check for existence first
+ARCHMAKEFILE = $(TOPDIR)/Makefile.$(ARCH)
+ifeq ($(ARCHMAKEFILE),$(wildcard $(ARCHMAKEFILE)))
+  include $(ARCHMAKEFILE)
+endif
+
+# CFLAGS: all assignments to CFLAGS are inclremental, so you can specify
+# the initial flags on the command line or environment, if needed.
+CFLAGS +=  -DCLINK_LINUX -Wall -D__KERNEL__ -DMODULE -I$(INCLUDEDIR)
+
+ifdef CONFIG_SMP
+	CFLAGS += -D__SMP__ -DSMP
+endif
+
+# Prepend modversions.h if we're running with versioning.
+ifdef CONFIG_MODVERSIONS
+	CFLAGS += -DMODVERSIONS -include $(KERNELDIR)/include/linux/modversions.h
+endif
+
+#Install dir
+VERSIONFILE = $(INCLUDEDIR)/linux/version.h
+VERSION     = $(shell awk -F\" '/REL/ {print $$2}' $(VERSIONFILE))
+INSTALLDIR = /lib/modules/$(VERSION)/misc
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Src/ClnkBus_iface_apollo.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Src/ClnkBus_iface_apollo.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Src/ClnkBus_iface_apollo.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Src/ClnkBus_iface_apollo.c	2012-09-14 14:51:36.803989000 +0530
@@ -0,0 +1,51 @@
+/*******************************************************************************
+*
+* Apollo/Src/ClnkBus_iface_apollo.c
+*
+* Description: Apollo Bus interface layer
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+
+void clnk_bus_read( void *vctx, SYS_UINTPTR addr, SYS_UINT32 *data)
+{
+    clnk_read( vctx, addr & 0x0fffffff, data) ;
+}
+
+void clnk_bus_write( void *vctx, SYS_UINTPTR addr, SYS_UINT32 data)
+{
+    clnk_write( vctx, addr & 0x0fffffff, data) ;
+}
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Src/Clnk_ctl_apollo.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Src/Clnk_ctl_apollo.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Src/Clnk_ctl_apollo.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Src/Clnk_ctl_apollo.c	2012-09-14 14:51:36.812987000 +0530
@@ -0,0 +1,419 @@
+/*******************************************************************************
+*
+* Apollo/Src/Clnk_ctl_apollo.c
+*
+* Description: ioctl layer
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+/*******************************************************************************
+*                             # D e f i n e s                                  *
+********************************************************************************/
+
+
+/*******************************************************************************
+*            S t a t i c   M e t h o d   P r o t o t y p e s                   *
+********************************************************************************/
+
+static int do_clnk_ctl_dvr(dc_context_t *dccp, int cmd, struct clnk_io *io);
+
+
+int clnk_ctl_drv(void *vdkcp, int cmd, struct clnk_io *io)
+{
+    dc_context_t        *dccp = dk_to_dc( vdkcp ) ;
+    Clnk_MBX_Mailbox_t  *pMbx = &dccp->mailbox ;
+
+    switch (cmd)
+    {
+        case CLNK_CTL_NET_CARRIER_OK:
+            break;
+
+        case CLNK_CTL_RESET_DEVICE:
+            break;
+
+        case CLNK_CTL_STOP_DEVICE:
+            Clnk_Kern_Task_Kill((void *)dccp); 
+            break;
+
+        case CLNK_CTL_NET_CARRIER_ON:
+            break;
+        
+        case CLNK_CTL_NET_CARRIER_OFF:
+            // Turn off mailbox processing
+            pMbx->mbxOpen = SYS_FALSE;
+            Clnk_Kern_Task_Stop((void *)dccp);
+            break;
+        
+        case CLNK_CTL_SOC_INIT_BUS:
+            break; 
+        
+        case CLNK_CTL_SOC_BOOTED:
+        {
+            ClnkDef_dataPlaneVars_t *in = (void *)io->in;
+            int                     stat ;
+
+            if (io->in_len < sizeof( *in)) 
+            {
+                return(-SYS_INPUT_OUTPUT_ERROR);
+                break;
+            }
+
+            if (pMbx->mbxOpen == SYS_TRUE)
+            {
+                pMbx->mbxOpen = SYS_FALSE;
+                Clnk_Kern_Task_Stop((void *)dccp);
+            }
+
+            //mailbox reset initialization
+            dccp->pSwUnsolQueue = in->unsol_msgbuf;
+            dccp->swUnsolQueueSize = SW_UNSOL_HW_QUEUE_SIZE;
+            dccp->freqBand = in->freqBand;
+
+            if (dccp->pSwUnsolQueue != SYS_NULL)
+            {
+                // set mbxopen
+                stat = Clnk_MBX_Initialize( pMbx, dccp, CLNK_MBX_ETHERNET_TYPE );
+
+                if (stat != SYS_SUCCESS)
+                {
+                    HostOS_PrintLog(L_ERR, "Clink Reset MBX failed, stat=%d.\n", stat);
+                    return (stat);
+                }
+
+                dccp->mailboxInitialized = SYS_TRUE;
+
+                Clnk_MBX_Control(&dccp->mailbox, CLNK_MBX_CTRL_SET_REPLY_RDY_CB,
+                         0, (SYS_UINTPTR)MbxReplyRdyCallback, (SYS_UINTPTR)dccp);
+                // set unsol mbox pointer
+                Clnk_MBX_Control(&dccp->mailbox, CLNK_MBX_CTRL_SET_SW_UNSOL_Q, 
+                         0, dccp->pSwUnsolQueue, dccp->swUnsolQueueSize);
+                Clnk_MBX_Control(&dccp->mailbox, CLNK_MBX_CTRL_SET_SW_UNSOL_RDY_CB,
+                         0, (SYS_UINTPTR)MbxSwUnsolRdyCallback, (SYS_UINTPTR)dccp);
+
+                if(Clnk_Kern_Task_Init((void *)dccp) != 0)
+                    HostOS_PrintLog(L_ERR, "MBX open, Start TT task failed!\n");
+            }
+            else
+                HostOS_PrintLog(L_ERR, "ERROR: mailbox unsolicited queue is NULL!!\n");
+
+            break;
+        }
+        case CLNK_CTL_TC_DIC_INIT:
+        {
+            struct mb_return *mb = (void *)io->in; 
+ 
+            if (io->in_len < sizeof(*mb) )
+            {
+                return(-SYS_INPUT_OUTPUT_ERROR);
+                break;
+            }
+            // mailbox reset initialization  
+            dccp->pSwUnsolQueue= mb->unsol_msgbuf; 
+            break;
+        }
+        case CLNK_CTL_HW_DESC_INIT:
+            break;
+        case CLNK_CTL_GET_SOC_STATUS:
+        {   
+            int retval;
+            SYS_UINT32 *status = (void*)io->out;
+
+            if((retval = Clnk_ETH_Control_drv(dccp, CLNK_ETH_CTRL_GET_SOC_STATUS,
+               0, (SYS_UINTPTR)status, 0)) != SYS_SUCCESS)
+            {
+                HostOS_PrintLog(L_INFO,"failed CLNK_CTL_GET_SOC_STATUS, stat=%d.\n", *status);
+                return(retval);
+            }
+            break;
+        }
+        case CLNK_CTL_GET_LINK_STATUS:
+        {   
+            int retval;
+            SYS_UINT32 *status = (void*)io->out;
+
+            if((retval = Clnk_ETH_Control_drv(dccp, CLNK_ETH_CTRL_GET_LINK_STATUS,
+               0, (SYS_UINTPTR)status, 0)) != SYS_SUCCESS)
+            {
+                HostOS_PrintLog(L_INFO,"failed CLNK_CTL_GET_LINK_STATUS\n");
+                return(retval);
+            }
+            break;
+        }
+        case CLNK_CTL_SET_MAC_ADDRESS:
+            break;
+        default:
+            return(-SYS_INVALID_ARGUMENT_ERROR);
+    }
+    return(SYS_SUCCESS);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Controls the operation of the Common Ethernet Module.
+*
+* Inputs:
+*       dccp      - Pointer to the control context
+*       option    - Driver option to control
+*       reg       - Register offset or pointer to register offsets
+*       val       - Register value or pointer to register values
+*       length    - Length of data for bulk data
+*
+* Outputs:
+*       CLNK_ETH_RET_CODE_SUCCESS
+*       CLNK_ETH_RET_CODE_GEN_ERR
+*       CLNK_ETH_RET_CODE_RESET_ERR
+*       CLNK_ETH_RET_CODE_LINK_DOWN_ERR
+*
+*******************************************************************************/
+int Clnk_ETH_Control_drv(void *vdccp, 
+                         int option, 
+                         SYS_UINTPTR reg, 
+                         SYS_UINTPTR val,  // io block pointer or register value
+                         SYS_UINTPTR length)
+{
+    dc_context_t *dccp = vdccp;
+    int status = CLNK_ETH_RET_CODE_SUCCESS;
+
+    switch (option)
+    {
+        case CLNK_ETH_CTRL_DO_CLNK_CTL:
+            status = do_clnk_ctl_dvr(dccp, (SYS_INT32)reg, (struct clnk_io *)val);
+            break;
+
+        default:
+            status = CLNK_ETH_RET_CODE_GEN_ERR;
+            break;
+    }
+    return (status);
+}
+
+void clnk_ctl_postprocess(void *vcp, IfrDataStruct *kifr, struct clnk_io *kio)
+{
+    SYS_UINT32 cmd = kifr->cmd;
+    SYS_UINT32 subcmd = (SYS_UINT32)kifr->param1;
+
+    switch (cmd)
+    {
+        case CLNK_MBX_ETH_DATA_BUF_CMD:
+        {
+            switch (subcmd)
+            {
+                case CLNK_CTL_GET_MY_NODE_INFO:
+                {
+                    ClnkDef_MyNodeInfo_t *out = (void *)kio->out;
+                    SYS_UINT32  rev1=0, rev2=0, rev3=0, rev4=0;
+                    
+                    HostOS_Sscanf(DRV_VERSION, "%d.%d.%d.%d", 
+                                  &rev1, &rev2, &rev3, &rev4);
+                    out->SwRevNum = ((rev1 & 0xff) << 24) | 
+                                    ((rev2 & 0xff) << 16) |
+                                    ((rev3 & 0xff) << 8)  | 
+                                    ((rev4 & 0xff) );
+                    break;
+                }
+            }
+            break;
+        }
+    }
+}
+
+/**
+* 
+*   Purpose:    Handle clnk_ctl operations originating from within the driver
+*               or from an ioctl.
+*
+*               io->in_len words are used as arguments to the function call.  
+*               Special case:
+*                 if io->in_len is 0, io->in is treated as a single argument 
+*                 rather than a pointer to an argument list.
+*
+*               Up to io->out_len words will be copied as the result of the call.
+*
+*   Imports:    dccp - ClnkEth context struct
+*               cmd  - CLNK_CTL_* command
+*               io   - Inputs and outputs for the CLNK_CTL command
+*
+*   Exports:    CLNK_ETH_RET_CODE_SUCCESS Success.
+*               CLNK_ETH_RET_CODE_GEN_ERR Failure.
+*
+*******************************************************************************/
+static int do_clnk_ctl_dvr(dc_context_t *dccp, int cmd, struct clnk_io *io)
+{
+    int ret = CLNK_ETH_RET_CODE_GEN_ERR ;
+    //SYS_UINT32 arg0 = io->in_len ? io->in[0] : ((SYS_UINTPTR)io->in);
+
+    /* cmd is processed by the common driver */
+    switch(cmd)
+    {
+#if defined(CLNK_ETH_BRIDGE) 
+        case CLNK_CTL_GET_BRIDGE_TABLE:
+        {
+            ClnkDef_BridgeTable_t *tbl = (void *)io->out;
+            SYS_UINT32 entries;
+
+            if(io->out_len < sizeof(*tbl))
+            {
+                ret = CLNK_ETH_RET_CODE_GEN_ERR;
+                break;
+            }
+
+            entries = Cam_Get(&dccp->cam, &tbl->ent[0], arg0, BRIDGE_ENTRIES);
+            tbl->num_entries = entries;
+            ret = CLNK_ETH_RET_CODE_SUCCESS;
+            break;
+        }
+#endif
+#if 1
+        case CLNK_CTL_GET_EVM_DATA:
+        {
+            ClnkDef_EvmData_t *out = (void *)io->out;
+
+            if (io->out_len < sizeof(*out))
+            {   // Bad Specification
+                ret = CLNK_ETH_RET_CODE_GEN_ERR;
+            }
+            else if (!dccp->evmData)
+            {   // First time, alloc space and return
+                dccp->evmData = (ClnkDef_EvmData_t *)
+                    HostOS_Alloc(sizeof(ClnkDef_EvmData_t));
+                if (dccp->evmData)
+                {
+                    dccp->evmData->valid = 0;
+                    dccp->evmData->NodeId = 0;
+                }
+                ret = CLNK_ETH_RET_CODE_GEN_ERR;
+            }
+            else if (!dccp->evmData->valid)
+            {   // Waiting for New Data
+                ret = CLNK_ETH_RET_CODE_GEN_ERR;
+            }
+            else
+            {   // Actually got new data
+                HostOS_Memcpy((void *)out, dccp->evmData, sizeof(*out));
+                dccp->evmData->valid = 0;
+                ret = CLNK_ETH_RET_CODE_SUCCESS;
+            }
+            break;
+        }
+#endif
+#if 1 // modified for MID RF (DEBUG_EPP)
+        case CLNK_CTL_GET_EPP_DATA:
+        {
+            ClnkDef_EppData_t *out = (void *)io->out;
+
+            HostOS_PrintLog(L_DEBUG, 
+                                "CLNK_CTL_GET_EPP_DATA: valid=%x, flags=%x\n",
+                                dccp->eppData.valid, 
+                                dccp->eppCapCfg.flags);
+	    if ((dccp->eppData.valid != dccp->eppCapCfg.flags) || 
+                    (io->out_len < sizeof(*out)))
+            {
+                ret = CLNK_ETH_RET_CODE_GEN_ERR;
+                break;
+            }
+            HostOS_Memcpy((void *)out, &dccp->eppData, sizeof(*out));
+            dccp->eppData.valid = 0;
+            ret = CLNK_ETH_RET_CODE_SUCCESS;
+            break;
+        }
+#endif
+#if ECFG_FLAVOR_VALIDATION==1
+        case CLNK_CTL_VAL_GET_MBOX_HOST_COUNTS:
+        {
+            eclair_ValMboxHostCounts_t *out = (void*)io->out;
+
+            INCTYPES_SAFE_PTR_COPY(out, &clnkEth_valMboxHostCounts);
+
+            ret = CLNK_ETH_RET_CODE_SUCCESS;
+        }
+#endif
+#if 1 // added for MID RF (DEBUG_EPP)
+	case CLNK_CTL_GET_EPP_CAP_CFG:
+        {
+                ClnkDef_EppCapCfg_t *out = (void *)io->out;
+
+                if (io->out_len < sizeof(*out))
+                {
+                    ret = CLNK_ETH_RET_CODE_GEN_ERR;
+                    break;
+                }
+                HostOS_Memcpy((void *)out, &dccp->eppCapCfg, sizeof(*out));
+                ret = CLNK_ETH_RET_CODE_SUCCESS;
+                break;
+        }
+
+        case CLNK_CTL_SET_EPP_CAP_CFG:
+        {
+                ClnkDef_EppCapCfg_t *in = (void *)io->in;
+                //Clnk_MBX_Msg_t mbxMsg;
+                //SYS_UINT8 transID;
+
+                if(io->in_len < sizeof(*in))
+                {
+                    ret = CLNK_ETH_RET_CODE_GEN_ERR;
+                    HostOS_PrintLog(L_INFO, "Error in length of EPP config \n");
+      
+                    break;
+                }
+#if 0
+                mbxMsg.msg.ethCmd.cmd      =
+                    CLNK_MBX_SET_CMD(CLNK_MBX_ETH_SET_EPP_CAP_CFG);
+                mbxMsg.msg.ethCmd.param[0] = in->nodeId;
+                mbxMsg.msg.ethCmd.param[1] = in->flags;
+                Clnk_MBX_SendRcvMsg(&pContext->mailbox, &mbxMsg, &mbxMsg,
+                                    3, MBX_POLL_TIMEOUT_IN_US);
+#endif //0
+                /* 
+                 * Set the new EPP capture config and clear out existing data
+                 * valid flags related to previous captures
+                 */
+                clnk_blk_write(dccp, DEV_SHARED(eppCapSrcId),
+                            (SYS_UINT32 *)in, sizeof(ClnkDef_EppCapCfg_t));
+                dccp->eppCapCfg = *in;
+                dccp->eppData.valid = 0;
+
+                ret = CLNK_ETH_RET_CODE_SUCCESS;
+                HostOS_PrintLog(L_INFO, "EPP_CAP_CFG: nodeId=%u, flags=%x\n",
+                                in->nodeId, in->flags);
+                break;
+        }
+#endif
+    }
+
+    return(ret);
+}
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/ClnkBus_iface.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/ClnkBus_iface.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/ClnkBus_iface.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/ClnkBus_iface.h	2012-09-14 14:51:36.826989000 +0530
@@ -0,0 +1,42 @@
+/*******************************************************************************
+*
+* Common/Inc/ClnkBus_iface.h
+*
+* Description: Bus interface layer
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __CLNKBUS_IFACE_H__
+#define __CLNKBUS_IFACE_H__
+
+void clnk_bus_read( void *vctx, SYS_UINTPTR addr, SYS_UINT32 *data);
+void clnk_bus_write( void *vctx, SYS_UINTPTR addr, SYS_UINT32 data);
+
+#endif /* __CLNKBUS_IFACE_H__ */
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/Clnk_ctl_dvr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/Clnk_ctl_dvr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/Clnk_ctl_dvr.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/Clnk_ctl_dvr.h	2012-09-14 14:51:36.829990000 +0530
@@ -0,0 +1,47 @@
+/*******************************************************************************
+*
+* Common/Inc/Clnk_ctl_dvr.h
+*
+* Description: c.LINK control interface layer
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __CLNK_CTL_DVR_H__
+#define __CLNK_CTL_DVR_H__
+
+int clnk_ctl_drv(void *vdkcp, int cmd, struct clnk_io *io);
+int Clnk_ETH_Control_drv(void *vdccp, 
+                         int option, 
+                         SYS_UINTPTR reg, 
+                         SYS_UINTPTR val,  // io block pointer or register value
+                         SYS_UINTPTR length);
+void clnk_ctl_postprocess(void *vcp, IfrDataStruct *kifr, struct clnk_io *kio);
+
+#endif /* __CLNK_CTL_DVR_H__ */
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/clnkiodefs.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/clnkiodefs.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/clnkiodefs.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/clnkiodefs.h	2012-09-14 14:51:36.833990000 +0530
@@ -0,0 +1,55 @@
+/*******************************************************************************
+*
+* Common/Inc/clnkiodefs.h
+*
+* Description: Driver IO definitions
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __clnkiodefs_h__
+#define __clnkiodefs_h__
+
+
+
+// from sockios.h : #define SIOCDEVPRIVATE  0x89F0  /* to 89FF */
+#define SIOCETHTOOL	0x8946		/* Ethtool interface		*/
+
+#define SIOCCLINKDRV	(SIOCDEVPRIVATE+1)  // Control plane commands for the driver
+#define SIOCGCLINKMEM	(SIOCDEVPRIVATE+2)  // Reads registers/memory in c.LINK address space
+#define SIOCSCLINKMEM	(SIOCDEVPRIVATE+3)  // Sets registers/memory in c.LINK address space
+#define SIOCGCLNKCMD    (SIOCDEVPRIVATE+10) // pass thru c.LINK command that expects a response
+#define SIOCSCLNKCMD    (SIOCDEVPRIVATE+11) // pass thru c.LINK command that expects no response
+#define SIOCLNKDRV      (SIOCDEVPRIVATE+12) // a. Initialize Mailbox Queue Handler b. Get Unsolicited Message 
+#define SIOCHDRCMD	    (SIOCDEVPRIVATE+13)  // Resets the SoC , Control the diplexer switch etc.
+#define SIOCMSCMD       (SIOCDEVPRIVATE+15)  // MoCA Shell command
+
+
+
+
+#endif /* __clnkiodefs_h__ */
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/ClnkMbx_dvr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/ClnkMbx_dvr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/ClnkMbx_dvr.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/ClnkMbx_dvr.h	2012-09-14 14:51:36.837987000 +0530
@@ -0,0 +1,417 @@
+/*******************************************************************************
+*
+* Common/Inc/ClnkMbx_dvr.h
+*
+* Description: Common Mailbox Module
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __ClnkMbx_dvr_h__
+#define __ClnkMbx_dvr_h__
+
+/*******************************************************************************
+*                             # i n c l u d e s                                *
+********************************************************************************/
+
+#include "inctypes_dvr.h"
+#include "common_dvr.h"
+
+/*******************************************************************************
+*                             # d e f i n e s                                  *
+********************************************************************************/
+
+// Common Mailbox Module Configuration
+//#define CLNK_MBX_AUTO_REPLY  // Auto reply (for debugging only)
+
+#define MAX_UNSOL_MSG       8
+#define MAX_MBX_MSG         100
+
+// Mailbox Type Constants
+#define CLNK_MBX_ETHERNET_TYPE  0
+#define CLNK_MBX_MPEG_TYPE      1
+
+// Mailbox Polling Rate
+#define MBX_POLL_TIMEOUT_IN_US    (20*1000)
+
+// Mailbox Queue Constants
+// queue sizes are in HostOS_Spec.h
+
+// Mailbox Command Code Definitions
+#define CLNK_MBX_CMD_CODE_OFFSET      0
+#define CLNK_MBX_CMD_CODE_MASK        0xff
+#define CLNK_MBX_CMD_TRANS_ID_OFFSET  8
+#define CLNK_MBX_CMD_TRANS_ID_MASK    0xff
+#define CLNK_MBX_CMD_VER_NUM_OFFSET   16
+#define CLNK_MBX_CMD_VER_NUM_MASK     0xf
+#define CLNK_MBX_CMD_PORT_OFFSET      20
+#define CLNK_MBX_CMD_PORT_MASK        0xf
+#define CLNK_MBX_CMD_LEN_OFFSET       24
+#define CLNK_MBX_CMD_LEN_MASK         0xff
+
+#define CLNK_MBX_SET_CMD(x)       (((x) & CLNK_MBX_CMD_CODE_MASK)     << \
+                                   CLNK_MBX_CMD_CODE_OFFSET)
+#define CLNK_MBX_SET_TRANS_ID(x)  (((x) & CLNK_MBX_CMD_TRANS_ID_MASK) << \
+                                   CLNK_MBX_CMD_TRANS_ID_OFFSET)
+#define CLNK_MBX_SET_VER_NUM(x)   (((x) & CLNK_MBX_CMD_VER_NUM_MASK)  << \
+                                   CLNK_MBX_CMD_VER_NUM_OFFSET)
+#define CLNK_MBX_SET_PORT(x)      (((x) & CLNK_MBX_CMD_PORT_MASK)     << \
+                                   CLNK_MBX_CMD_PORT_OFFSET)
+#define CLNK_MBX_SET_LEN(x)       (((x) & CLNK_MBX_CMD_LEN_MASK)      << \
+                                   CLNK_MBX_CMD_LEN_OFFSET)
+
+#define CLNK_MBX_GET_CMD(x)       (((x) >> CLNK_MBX_CMD_CODE_OFFSET) &   \
+                                   CLNK_MBX_CMD_CODE_MASK)
+#define CLNK_MBX_GET_CMD_LEN(x)   (((x) >> CLNK_MBX_CMD_LEN_OFFSET) &    \
+                                   CLNK_MBX_CMD_LEN_MASK)
+
+
+// Mailbox Reply Status Definitions
+#define CLNK_MBX_REPLY_TRANS_ID_OFFSET  0
+#define CLNK_MBX_REPLY_TRANS_ID_MASK    0xff
+#define CLNK_MBX_REPLY_STATUS_OFFSET    8
+#define CLNK_MBX_REPLY_STATUS_MASK      0xff
+#define CLNK_MBX_REPLY_ARG1_OFFSET      16
+#define CLNK_MBX_REPLY_ARG1_MASK        0xff
+#define CLNK_MBX_REPLY_LEN_OFFSET       24
+#define CLNK_MBX_REPLY_LEN_MASK         0xff
+
+#define CLNK_MBX_GET_TRANS_ID(x)  (((x) >> CLNK_MBX_REPLY_TRANS_ID_OFFSET) & \
+                                   CLNK_MBX_REPLY_TRANS_ID_MASK)
+#define CLNK_MBX_GET_STATUS(x)    (((x) >> CLNK_MBX_REPLY_STATUS_OFFSET)   & \
+                                   CLNK_MBX_REPLY_STATUS_MASK)
+#define CLNK_MBX_GET_ARG1(x)      (((x) >> CLNK_MBX_REPLY_ARG1_OFFSET)     & \
+                                   CLNK_MBX_REPLY_ARG1_MASK)
+#define CLNK_MBX_GET_REPLY_LEN(x) (((x) >> CLNK_MBX_REPLY_LEN_OFFSET)      & \
+                                   CLNK_MBX_REPLY_LEN_MASK)
+
+// CLNK Kernel Thread Status Definition
+#define CLNK_TASK_RUNNING       0
+#define CLNK_TASK_STOPPED       1
+#define CLNK_TASK_SLEEP         2
+
+/*******************************************************************************
+*                       G l o b a l   D a t a   T y p e s                      *
+********************************************************************************/
+
+// Mailbox Status Codes
+typedef enum
+{
+    CLNK_MBX_STATUS_SUCCESS = SYS_SUCCESS,
+
+    CLNK_MBX_STATUS_MAX  // This must always be last
+}
+CLNK_MBX_STATUS;
+
+// Mailbox Control Options
+typedef enum
+{
+    CLNK_MBX_CTRL_ENABLE_INTERRUPT,
+    CLNK_MBX_CTRL_DISABLE_INTERRUPT,
+    CLNK_MBX_CTRL_CLEAR_INTERRUPT,
+    CLNK_MBX_CTRL_SET_SW_UNSOL_Q,
+    CLNK_MBX_CTRL_SET_REPLY_RDY_CB,
+    CLNK_MBX_CTRL_SET_UNSOL_RDY_CB,
+    CLNK_MBX_CTRL_SET_SW_UNSOL_RDY_CB,
+
+    CLNK_MBX_CTRL_MAX  // This must always be last
+}
+CLNK_MBX_CTRL_OPTIONS;
+
+// Command Codes
+typedef enum
+{
+    // Ethernet commands
+    CLNK_MBX_ETH_RESET_CMD                        = 0x00,   /* Alias: ETH_MB_RESET,                             */
+    CLNK_MBX_ETH_ALLOC_TX_FIFO_CMD                = 0x01,   /* Alias: ETH_MB_ALLOCATE_TX_FIFO,                  */
+    CLNK_MBX_ETH_ALLOC_RX_FIFO_CMD                = 0x02,   /* Alias: ETH_MB_ALLOCATE_RX_FIFO,                  */
+    CLNK_MBX_ETH_JOIN_MCAST_CMD                   = 0x03,   /* Alias: ETH_MB_JOIN_MULTICAST,                    */
+    CLNK_MBX_ETH_LEAVE_MCAST_CMD                  = 0x04,   /* Alias: ETH_MB_LEAVE_MULTICAST,                   */
+    CLNK_MBX_ETH_REGISTER_MCAST_CMD               = 0x05,   /* Alias: ETH_MB_REGISTER_MULTICAST,                */
+    CLNK_MBX_ETH_GET_STATS_CMD                    = 0x06,   /* Alias: ETH_MB_QUERY_RCV_STATS,                   */
+    CLNK_MBX_ETH_SET_RCV_MODE_CMD                 = 0x07,   /* Alias: ETH_MB_SET_RCV_MODE,                      */
+    CLNK_MBX_ETH_GET_RCV_MODE_CMD                 = 0x08,   /* Alias: ETH_MB_GET_RCV_MODE,                      */
+    CLNK_MBX_ETH_PUB_UCAST_CMD                    = 0x09,   /* Alias: ETH_MB_PUBLISH_UNICAST_ADDR,              */
+    CLNK_MBX_ETH_DEREGISTER_MCAST_CMD             = 0x0a,   /* Alias: ETH_MB_DEREGISTER_MULTICAST,              */
+    CLNK_MBX_ETH_DATA_BUF_CMD                     = 0x0b,   /* Alias: ETH_MB_DATA_BUF_CMD,                      */
+    CLNK_MBX_ETH_GET_STATUS_CMD                   = 0x0c,   /* Alias: ETH_MB_GET_STATUS,                        */
+    CLNK_MBX_ETH_SET_SW_CONFIG_CMD                = 0x0d,   /* Alias: ETH_MB_SET_SW_CONFIG,                     */
+    CLNK_MBX_ETH_ECHO_PROFILE_PROBE_RESPONSE      = 0x0e,   /* Alias: ETH_MB_ECHO_PROFILE_PROBE_RESPONSE,       */
+    CLNK_MBX_ETH_GET_CMD                          = 0x0f,   /* Alias: ETH_MB_GET_CMD,                           */
+    CLNK_MBX_ETH_SET_CMD                          = 0x10,   /* Alias: ETH_MB_SET_CMD,                           */
+    CLNK_MBX_ETH_CLINK_ACCEPT_SMALL_ROUTED_MESSAGE = 0x11,  /* Alias: ETH_MB_CLINK_ACCEPT_SMALL_ROUTED_MESSAGE, */
+    CLNK_MBX_ETH_SET_BEACON_POWER_LEVEL_CMD       = 0x12,   /* Alias: ETH_MB_SET_BEACON_POWER_LEVEL_CMD,        */
+    CLNK_MBX_ETH_QOS_ASYNC_REQ_BLOB               = 0x13,   /* Alias: ETH_MB_QOS_ASYNC_REQ_BLOB,                */
+    CLNK_MBX_ETH_QFM_RESP_BLOB                    = 0x14,   /* Alias: ETH_MB_QFM_RESP_BLOB,                     */
+    CLNK_MBX_ETH_SET_MIXED_MODE_ACTIVE            = 0x15,   /* Obsolete */
+    CLNK_MBX_ETH_GET_MIXED_MODE_ACTIVE            = 0x16,   /* Obsolete */
+    CLNK_MBX_ETH_QFM_CAM_DONE                     = 0x17,   /* Alias: ETH_MB_QFM_CAM_DONE,                      */
+    // MPEG commands
+    CLNK_MBX_MPEG_CREATE_INPUT_CHANNEL_CMD        = 0x20,
+    CLNK_MBX_MPEG_JOIN_CHANNEL_CMD                = 0x21,
+    CLNK_MBX_MPEG_JOIN_AS_PASSIVE_LISTENER_CMD    = 0x22,
+    CLNK_MBX_MPEG_SUBSCRIPTION_REQUEST_CMD        = 0x23,
+    CLNK_MBX_MPEG_MODIFY_INPUT_CHANNEL_CMD        = 0x24,
+    CLNK_MBX_MPEG_MODIFY_OUTPUT_CHANNEL_CMD       = 0x25,
+    CLNK_MBX_MPEG_LEAVE_INPUT_CHANNEL_CMD         = 0x26,
+    CLNK_MBX_MPEG_LEAVE_OUTPUT_CHANNEL_CMD        = 0x27,
+    CLNK_MBX_MPEG_CREATE_OUTPUT_CHANNEL_CMD       = 0x28,
+    CLNK_MBX_MPEG_RESERVED_CMD_FROM               = 0x29,
+    CLNK_MBX_MPEG_RESERVED_CMD_TO                 = 0x2F,
+    CLNK_MBX_MPEG_READ_TRANSMIT_STATS_CMD         = 0x30,
+    CLNK_MBX_MPEG_READ_RECEIVE_STATS_CMD          = 0x31,
+    CLNK_MBX_MPEG_SUBSCRIPTION_REPORT_REQUEST_CMD = 0x32,
+
+    CLNK_MBX_MAX_CMD  // This must always be last
+}
+CLNK_MBX_CMD_CODES;
+
+// Unsolicited message types
+typedef enum
+{
+    CLNK_MBX_UNSOL_MSG_UCAST_PUB                    = 0,     /* Alias: UNSOL_MSG_UCAST_PUB_TYPE               */
+    CLNK_MBX_UNSOL_MSG_EVM_DATA_READY               = 1,     /* Alias: UNSOL_MSG_EVM_DATA_READY_TYPE          */
+    CLNK_MBX_UNSOL_MSG_ECHO_PROFILE_PROBE           = 2,     /* Alias: UNSOL_MSG_ECHO_PROFILE_PROBE           */
+    CLNK_MBX_UNSOL_MSG_ADMISSION_STATUS             = 3,     /* Alias: UNSOL_MSG_ADMISSION_STATUS             */
+    CLNK_MBX_UNSOL_MSG_BEACON_STATUS                = 4,     /* Alias: UNSOL_MSG_BEACON_STATUS                */
+    CLNK_MBX_UNSOL_MSG_RESET                        = 5,     /* Alias: UNSOL_MSG_MAC_RESET                    */
+    CLNK_MBX_UNSOL_MSG_TABOO_INFO                   = 6,     /* Alias: UNSOL_MSG_TABOO_INFO                   */
+    CLNK_MBX_UNSOL_MSG_ACCESS_CHK_MAC               = 7,     /* Alias: UNSOL_MSG_CHK_MAC_ADDRESS              */
+    CLNK_MBX_UNSOL_MSG_NODE_ADDED                   = 8,     /* Alias: UNSOL_MSG_NODE_ADDED                   */
+    CLNK_MBX_UNSOL_MSG_NODE_DELETED                 = 9,     /* Alias: UNSOL_MSG_NODE_DELETED                 */
+    CLNK_MBX_UNSOL_MSG_UCAST_UNPUB                  = 10,    /* Alias: UNSOL_MSG_UCAST_UNPUB_TYPE             */
+    CLNK_MBX_UNSOL_MSG_ROUTE_SMALL_MESSAGE_TO_HOST  = 11,    /* Alias: UNSOL_MSG_ROUTE_SMALL_MESSAGE_TO_HOST  */
+    CLNK_MBX_UNSOL_MSG_LOG_SMALL_MESSAGE_TO_HOST    = 12,    /* Alias: UNSOL_MSG_LOG_SMALL_MESSAGE_TO_HOST    */
+    CLNK_MBX_UNSOL_MSG_LOG_MESSAGE_INDIRECT_TO_HOST = 13,    /* Alias: UNSOL_MSG_LOG_MESSAGE_INDIRECT_TO_HOST */
+    CLNK_MBX_UNSOL_MSG_FSUPDATE                     = 14,    /* Alias: UNSOL_MSG_FSUPDATE                     */
+    CLNK_MBX_UNSOL_MSG_ADD_CAM_FLOW_ENTRY           = 20,    /* Alias: UNSOL_MSG_ADD_CAM_ENTRY                */
+    CLNK_MBX_UNSOL_MSG_DELETE_CAM_FLOW_ENTRIES      = 21,    /* Alias: UNSOL_MSG_DELETE_CAM_FLOW_ENTRIES      */
+
+#if ECFG_FLAVOR_VALIDATION==1
+    CLNK_MBX_UNSOL_MSG_VAL_ISOC_EVENT               = 22,    /* Alias: UNSOL_MSG_VAL_ISOC_EVENT               */
+#endif
+
+/* Following definitions are used to get rid of the compile warning of this h file */
+#if ! defined(FEATURE_FEIC_PWR_CAL)
+#define    FEATURE_FEIC_PWR_CAL 0
+#endif
+
+#if FEATURE_FEIC_PWR_CAL
+    CLNK_MBX_UNSOL_MSG_FEIC_STATUS_READY            = 23,    /* Alias: UNSOL_MSG_FEIC_STATUS_READY_TYPE          */
+#endif
+
+    CLNK_MBX_MAX_UNSOL_MSG_TYPE // This must always be last
+}
+CLNK_MBX_UNSOL_MSG_TYPES;
+
+// Maximum Message Structure
+typedef struct
+{
+    SYS_UINT32 msg[MAX_MBX_MSG];
+}
+Clnk_MBX_MaxMsg_t;
+
+// Ethernet Command Structure
+typedef struct
+{
+    SYS_UINT32 cmd;
+    SYS_UINT32 param[7];
+}
+Clnk_MBX_EthCmd_t;
+
+// Ethernet Reply Structure
+typedef struct
+{
+    SYS_UINT32 status;
+    SYS_UINT32 param[7];
+}
+Clnk_MBX_EthReply_t;
+
+// MPEG Command Structure
+typedef struct
+{
+    SYS_UINT32  cmd;
+    SYS_UINT32  param[7];
+}
+Clnk_MBX_MpegCmd_t;
+
+// MPEG Reply Structure
+typedef struct
+{
+    SYS_UINT32 status;
+    SYS_UINT32 param;
+}
+Clnk_MBX_MpegReply_t;
+
+// Generic Mailbox Message Structure
+typedef struct
+{
+    union
+    {
+        Clnk_MBX_MaxMsg_t           maxMsg;
+        SYS_UINT32                  cmdCode;
+        SYS_UINT32                  replyStatus;
+
+        // Ethernet mailbox command
+        Clnk_MBX_EthCmd_t           ethCmd;
+
+        // Ethernet mailbox reply
+        Clnk_MBX_EthReply_t         ethReply;
+
+        // MPEG mailbox command
+        Clnk_MBX_MpegCmd_t          mpegCmd;
+
+        // MPEG mailbox reply
+        Clnk_MBX_MpegReply_t        mpegReply;
+    }
+    msg;
+}
+Clnk_MBX_Msg_t;
+
+// Reply and Unsolicited Ready Callback Function
+typedef void (*Clnk_MBX_RdyCallback)(void* pvParam, Clnk_MBX_Msg_t* pMsg);
+typedef int (*Clnk_MBX_SwUnsolRdyCallback)(void* pvParam, Clnk_MBX_Msg_t* pMsg);
+
+// Command Queue Entry Structure
+typedef struct
+{
+    Clnk_MBX_Msg_t          sendMsg;
+    Clnk_MBX_Msg_t          rcvMsg;
+    SYS_UINT8               transID;
+    volatile int            isReplyRdy;
+    volatile int            isReplyTimedOut;
+    void                    *msg_wqt ;
+ //   struct hostos_timer     msg_timer;
+ //   wait_queue_head_t       msg_wq;
+} Clnk_MBX_CmdQueueEntry_t;
+
+// Unsolicited Queue Entry Structure
+typedef struct
+{
+    Clnk_MBX_Msg_t msg;
+    SYS_UINT8      transID;
+}
+Clnk_MBX_UnsolQueueEntry_t;
+
+// Sw Unsolicited Queue Entry Structure
+typedef struct
+{
+    Clnk_MBX_Msg_t msg;
+}
+Clnk_MBX_SwUnsolQItem_t;
+
+// Software unsolicited Queue Entry Structure
+typedef struct
+{
+    SYS_UINT32     ownership;
+    SYS_UINT32     transID;
+    SYS_UINT32     msg[MAX_UNSOL_MSG];
+}
+Clnk_MBX_SwUnsolQueueEntry_t;
+
+
+// Mailbox Structure
+typedef struct
+{
+    void                          *dc_ctx; // driver control ctx
+    SYS_UINT32                    type;
+    SYS_UINT32                    mbxOpen;
+
+    // Callback functions
+    Clnk_MBX_RdyCallback          replyRdyCallback;
+    void                          *replyParam;
+    Clnk_MBX_SwUnsolRdyCallback   swUnsolRdyCallback;
+    void                          *swUnsolParam;
+
+    // Command queue
+    Clnk_MBX_CmdQueueEntry_t      cmdQueue[CLNK_MBX_CMD_QUEUE_SIZE];
+    SYS_UINT8                     cmdHeadIndex;   // dequeue point
+    SYS_UINT8                     cmdTailIndex;   // enqueue point
+    SYS_UINT8                     cmdCurrTransID;
+    void                          *mbx_lock;      // referenced here from GPL side
+
+    // Software unsolicited queue
+    SYS_UINT32                    swUnsolQueueSlaveMap;
+    SYS_UINT32                    pSwUnsolQueue; // ptr to array of Clnk_MBX_SwUnsolQueueEntry_t in pci space
+    SYS_UINT32                    swUnsolQueueSize;
+    SYS_UINT8                     swUnsolReadIndex;
+    SYS_UINT8                     swUnsolCurrTransID;
+    Clnk_MBX_SwUnsolQItem_t       swUnsolQueue[CLNK_MBX_SWUNSOL_QUEUE_SIZE];
+    SYS_UINT8                     swUnsolHeadIndex;
+    SYS_UINT8                     swUnsolTailIndex;
+    SYS_UINT8                     swUnsolCount;
+    SYS_UINT8                     swUnsolOverrun;
+    void                          *swUnsolLock;     // referenced here from GPL side
+
+    // Register offsets and bit masks
+    SYS_UINT32                    writeMbxCsrOffset;
+    SYS_UINT32                    readMbxCsrOffset;
+    SYS_UINT32                    writeMbxRegOffset;
+    SYS_UINT32                    readMbxRegOffset;
+    SYS_UINT32                    writeMbxSize;
+    SYS_UINT32                    readMbxSize;
+}
+Clnk_MBX_Mailbox_t;
+
+
+int Clnk_MBX_Initialize(Clnk_MBX_Mailbox_t *pMbx, void *dcctx, SYS_UINT32 type);
+void Clnk_MBX_Free_wqts( Clnk_MBX_Mailbox_t *pMbx );
+void Clnk_MBX_Terminate(Clnk_MBX_Mailbox_t* pMbx);
+int Clnk_MBX_Control(Clnk_MBX_Mailbox_t* pMbx, 
+                     int option, 
+                     SYS_UINTPTR reg,
+                     SYS_UINTPTR val, 
+                     SYS_UINTPTR length);
+void Clnk_MBX_HandleInterrupt(Clnk_MBX_Mailbox_t* pMbx, SYS_UINT32 pciIntStatus);
+int Clnk_MBX_SendMsg(Clnk_MBX_Mailbox_t *pMbx, 
+                     Clnk_MBX_Msg_t     *pMsg,
+                     SYS_UINT8          *pTransID, 
+                     SYS_UINT32          len);
+int Clnk_MBX_RcvUnsolMsg(Clnk_MBX_Mailbox_t *pMbx, 
+                         SYS_UINT32         *pbuf);
+                   
+int Clnk_MBX_SendRcvMsg(Clnk_MBX_Mailbox_t  *pMbx, 
+                        Clnk_MBX_Msg_t      *pSendMsg,
+                        Clnk_MBX_Msg_t      *pRcvMsg, 
+                        SYS_UINT32          len,
+                        SYS_UINT32          timeoutInUs);
+void Clnk_MBX_Read_ISR( Clnk_MBX_Mailbox_t *pMbx );
+void Clnk_MBX_Write_ISR( Clnk_MBX_Mailbox_t *pMbx );
+void Clnk_MBX_Unsol_ISR( Clnk_MBX_Mailbox_t* pMbx );
+int Clnk_MBX_Read_Hw_Mailbox_Check_Ready(Clnk_MBX_Mailbox_t* pMbx);
+int Clnk_MBX_Write_Hw_Mailbox_Check_Ready(Clnk_MBX_Mailbox_t* pMbx);
+int Clnk_MBX_Send_Mailbox_Check_Empty(Clnk_MBX_Mailbox_t* pMbx);
+int Clnk_MBX_Unsol_Hw_Mailbox_Check_Ready(Clnk_MBX_Mailbox_t* pMbx);
+#if defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT) || defined(APOLLO_DRVR_SUPPORT)
+int Clnk_Kern_Task_Init(void *data);
+int Clnk_Kern_Task_Stop(void *data);
+int Clnk_Kern_Task_Kill(void *data);
+#endif
+
+#endif /* __ClnkMbx_dvr_h__ */
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/com_abs_proto.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/com_abs_proto.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/com_abs_proto.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/com_abs_proto.h	2012-09-14 14:51:36.840992000 +0530
@@ -0,0 +1,13 @@
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/Clnk_setup.c ***/
+int Clnk_init_dev(void **ddcp_dgcp, void *ddcp, void *dkcp, unsigned long dev_base );
+void Clnk_exit_dev( void *vdgcp );
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/ctx_abs.c ***/
+void *dc_to_dg( void *dccp );
+void *dc_to_dk( void *dccp );
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/common_dvr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/common_dvr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/common_dvr.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/common_dvr.h	2012-09-14 14:51:36.845989000 +0530
@@ -0,0 +1,1766 @@
+/*******************************************************************************
+*
+* Common/Inc/common_dvr.h
+*
+* Description: Driver stuff shared across modules
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __common_dvr_h__
+#define __common_dvr_h__
+
+#include "inctypes_dvr.h"
+#include "entropic-config.h"
+
+/***************** definitions originally from ClnkDefs.h ********************/
+
+#define NETWORK_TYPE_ACCESS       ECFG_NETWORK_ACCESS
+#define NETWORK_TYPE_HIRF_MESH    ECFG_NETWORK_HIRF_MESH
+#define NETWORK_TYPE_MIDRF_MESH   ECFG_NETWORK_MIDRF_MESH
+#define NETWORK_TYPE_MIDHIRF_MESH ECFG_NETWORK_MIDHIRF_MESH
+#define NODE_TYPE_ACCESS_HEADEND  ECFG_NODE_HEADEND
+#define NODE_TYPE_ACCESS_CPE      ECFG_NODE_CPE
+#define NODE_TYPE_ACCESS_TCPE     ECFG_NODE_TCPE
+#define NODE_TYPE_MESH_MOCA  ((ECFG_NETWORK_HIRF_MESH||ECFG_NETWORK_MIDRF_MESH|| \
+                               ECFG_NETWORK_MIDHIRF_MESH) && ECFG_NODE_MOCA)
+
+typedef enum 
+{
+    FREQ_BAND_A_TO_D                     = 1,    //ALL PASS (A TO D bands)
+    FREQ_BAND_D                          = 2,    //band D only
+    FREQ_BAND_E                          = 3,    //band E only
+    FREQ_BAND_F                          = 4,    //band F only
+    FREQ_BAND_TRIKA                      = 5,    //combination of bands D & E
+} FREQ_BAND_TYPE;
+
+#if ! defined(NETWORK_TYPE_ACCESS)
+#define NETWORK_TYPE_ACCESS                0
+#endif
+
+#if ! defined(HAS_FAST_IMPLEMENTATION_OF_FFS)
+#define HAS_FAST_IMPLEMENTATION_OF_FFS     0
+#endif
+
+#if ! defined(HAS_FAST_IMPLEMENTATION_OF_FFZ)
+#define HAS_FAST_IMPLEMENTATION_OF_FFZ     0
+#endif
+
+#if ! defined(CLNK_ETH_PER_PACKET)
+#define CLNK_ETH_PER_PACKET                1
+#endif
+
+#if ! defined(ECFG_FLAVOR_VALIDATION)
+#define ECFG_FLAVOR_VALIDATION             0
+#endif
+
+#define FEATURE_SPECTRAL_SCULPTING  1
+#define FEATURE_INGRESS_MARGIN      1
+
+#if ! defined(FEATURE_IQM)
+#define FEATURE_IQM                        0
+#endif
+
+/**
+ * This marks code belonging to the baseband filter tuning feature.
+*/
+#if ! defined(FEATURE_BASEBAND_FLT_TUNING)
+#define FEATURE_BASEBAND_FLT_TUNING         0
+#endif
+/**
+ * This marks code belonging to the VCO maintenance feature.
+*/
+#if ! defined(MAINTEN_VCO)
+#define MAINTEN_VCO                        0
+#endif
+/**
+ * This marks code belonging to the TX power temperature maintenance feature.
+*/
+#if ! defined(TX_PWR_MAINT)
+#define TX_PWR_MAINT                        0
+#endif
+/** 
+ * This marks code belonging to the Pre UPnP PQoS NMS project.
+ */
+#if ! defined(FEATURE_PUPQ_NMS)
+#define FEATURE_PUPQ_NMS                   1
+#endif
+
+/**
+ * This marks code added to round out last minute customer requests. 
+ */
+#if ! defined(FEATURE_PUPQ_NMS_QUICK_APIS)
+#define FEATURE_PUPQ_NMS_QUICK_APIS        1
+#endif
+
+/** 
+ * This marks code belonging to the Pre UPnP PQoS NMS project- 
+ * new configuration items.  It is not tested disabled.
+ */
+#if ! defined(FEATURE_PUPQ_NMS_CONF)
+#define FEATURE_PUPQ_NMS_CONF              1
+#endif
+
+/**
+ * This marks code (in progress) used to collect items using 
+ * the L2ME Gather Queryable operation
+ */
+#if ! defined(FEATURE_PUPQ_GQ)
+#define FEATURE_PUPQ_GQ                    1
+#endif
+
+/**
+ * This marks code used to collect per-node statistics on receiver
+ * received packet errors, both sync and async.
+ */
+#if ! defined(FEATURE_PUPQ_RX_NODE_STATS)
+#define FEATURE_PUPQ_RX_NODE_STATS         1
+#endif
+
+/** 
+ * Toggle this to see how code size changes when feature disabled
+ */
+#if ! defined(FEATURE_QOS_CCPU_ENTRY)
+#define FEATURE_QOS_CCPU_ENTRY             1
+#endif
+
+/** 
+ * Toggle this to see how code size changes when feature disabled
+ */
+#if ! defined(FEATURE_CCPU_FMR_ENTRY)
+#define FEATURE_CCPU_FMR_ENTRY             1
+#endif
+
+/** 
+ * Toggle this to see how code size changes when feature disabled
+ */
+#if ! defined(FEATURE_CCPU_GENERIC_L2ME_ENTRY)
+#define FEATURE_CCPU_GENERIC_L2ME_ENTRY    1
+#endif
+
+/** 
+ * Marks code that should be COMPLETELY removed from the codebase.  This
+ * variable should absolutely never set to 1.  The only reason this code
+ * remains in the codebase is that several projects must merge to a common
+ * tree; until this merge has happened, the diffs created by deletions
+ * would slow parallel progress.
+ */
+#define NEVER_USE_AGAIN_ECLAIR_LEGACY_TESTING  0
+
+#define DATAPATH_PCI_ENABLE 0
+
+/* Following definitions are used to get rid of the compile warning of this h file */
+#if ! defined(ECFG_BOARD_ECB_4M_L3)
+#define   ECFG_BOARD_ECB_4M_L3  0
+#endif
+#if ! defined(FEATURE_FEIC_PWR_CAL)
+#define   FEATURE_FEIC_PWR_CAL  0
+#endif
+
+#if 0                                        \
+    || ECFG_BOARD_PC_DVT2_PCI_ZIP2==1        \
+    || ECFG_BOARD_PC_DVT_MII_ZIP2==1         \
+    || ECFG_BOARD_PC_DVT_TMII_ZIP2==1        \
+    || ECFG_BOARD_PC_DVT_GMII_ZIP2==1        \
+    || ECFG_BOARD_COLDFIRE_DVT_FLEX_ZIP2==1  \
+    || ECFG_BOARD_ECB_PCI_ZIP2==1            \
+    || ECFG_BOARD_PC_PCI_ZIP2==1             \
+    || ECFG_BOARD_PC_PCI_ZIP1==1             \
+    || ECFG_BOARD_ECB_ROW==1                 \
+    || ECFG_BOARD_PC_PCIE_MAVERICKS==1        \
+    || ECFG_BOARD_PC_XMII_BALBOA==1        \
+    || ECFG_BOARD_ECB_4M_L3==1                 \
+    || ECFG_BOARD_ECB_3M_L3==1               \
+    || ECFG_BOARD_ECB_6M_L3==1               \
+    || 0
+#define L2_DONGLE 0
+#else
+#error NOT A KNOWN BOARD!
+#endif
+
+/**
+ * Warning! this value must exactly match the value used in the ccpu image that
+ * was compiled using this file.
+ */
+#if   (NETWORK_TYPE_ACCESS)
+    #define MAX_NUM_NODES        32
+    #error
+#elif (NETWORK_TYPE_HIRF_MESH || NETWORK_TYPE_MIDRF_MESH || NETWORK_TYPE_MIDHIRF_MESH)
+
+/* Protem pQOS/NMS specific.  Set to 8 for
+ * PROTEM builds or 16 for ADVANCED builds. 
+ */
+#if (ECFG_FLAVOR_PRODUCTION_PROTEM)
+    #define MAX_NUM_NODES   8
+#else
+    #define MAX_NUM_NODES   16
+#endif
+
+#else
+#error unsupported.
+#endif
+
+/* 
+    log levels for HostOS_PrintLog 
+    0 is highest priority
+
+    See also:
+        HOST_OS_PRINTLOG_THRESHOLD 
+
+ */
+enum
+{
+    L_EMERG      ,
+    L_ALERT      ,
+    L_CRIT       ,
+    L_ERR        ,
+    L_WARNING    ,
+    L_NOTICE     ,
+    L_INFO       ,
+    L_DEBUG      ,
+};
+
+
+// rudimentary back-cast macro
+#ifndef offsetof
+#define offsetof(x, y)          ((int)&(((x *)SYS_NULL)->y))
+#endif
+
+
+// OS timer expiration callback function
+typedef void (*timer_function_t)(unsigned long);
+
+// Wait Q Timer exit condition function
+typedef int (*HostOS_wqt_condition)(void *vp);
+
+// Wait Q exit condition function
+typedef int (*HostOS_waitq_condition)(void *vp);
+
+
+/*******************************************************************************
+*           G L O B A L   B I T F I E L D   M A N I P U L A T O R S            *
+********************************************************************************/
+
+/**
+ * Utility to create a mask given a number of bits
+ */
+#define CLNKDEFS_BITMASK(num_bits)   \
+   ((unsigned)(((num_bits) >= 32) ? 0xFFFFFFFF : ((1 << (num_bits)) - 1)))
+
+/**
+ * Utility to create a shifted mask given a high and low bit position
+ */
+#define CLNKDEFS_SHIFTED_BITMASK(bit_high, bit_low) \
+   ((unsigned)(CLNKDEFS_BITMASK(1 + (bit_high) - (bit_low)) << (bit_low)))
+
+/**
+ * Utility to create a value that alters a particular set of bits
+ * within a processor word
+ */
+#define CLNKDEFS_SUBSTITUTE_FIELD(original, bit_high, bit_low, new_field)                 \
+((unsigned)(                                                                              \
+    ((original)                  & (~CLNKDEFS_SHIFTED_BITMASK((bit_high), (bit_low)))) |  \
+     (((new_field) << (bit_low)) &   CLNKDEFS_SHIFTED_BITMASK((bit_high), (bit_low)))     \
+)          )
+
+/**
+ * Utility that alters an LVALUE with a substituted field.
+ */
+#define CLNKDEFS_REPLACE_FIELD(lvalue, bit_high, bit_low, new_field)            \
+   do { ((lvalue)) = CLNKDEFS_SUBSTITUTE_FIELD((lvalue), (bit_high),            \
+                                             (bit_low), (new_field));           \
+   } while (0)
+
+/**
+ * Utility to extract a particular field from a word
+ */
+#define CLNKDEFS_EXTRACT_FIELD(original, bit_high, bit_low) \
+     ((unsigned)(((original) & CLNKDEFS_SHIFTED_BITMASK((bit_high), (bit_low))) >> (bit_low)))
+
+// Firmware download constants
+#define ISPRAM_START    0x0c040000
+#define DSPRAM_START    0x0c000000
+#define ISPRAM_SIZE     0x40000
+#define DSPRAM_SIZE     0x20000
+
+/* for hw_z2_pci and clnkEth */
+#define SYS_GET_PARAM(x, p, mask, offset) (((x)->p >> (offset)) & (mask))
+#define SYS_SET_PARAM(x, p, mask, offset, val) do \
+            { \
+                (x)->p = ((x)->p & ~((mask) << (offset))) | \
+                         (((val) & (mask)) << (offset)); \
+            } while(0)
+#define WR_LINEBUF_PDU_SIZE(x, y)   SYS_SET_PARAM((x), packed_0, 0xffff, 0, (y))
+#define WR_LINEBUF_ENTRY_SIZE(x, y) SYS_SET_PARAM((x), packed_0, 0xff, 16, (y))
+#define WR_LINEBUF_PTR_MODE(x, y)   SYS_SET_PARAM((x), packed_0, 0x1, 24, (y))
+/* end for hw_z2_pci and clnkEth */
+
+#define NUM_DEBUG_REG               8
+#define NUM_MAILBOX_RD_REG          8
+#define NUM_MAILBOX_WR_REG          8
+#define NUM_MAILBOX_REG             (NUM_MAILBOX_RD_REG + NUM_MAILBOX_WR_REG)
+
+/// Returns the SoC memory address of element 'x' in dev_shared
+#define DEV_SHARED(x) ((SYS_UINT32)(SYS_UINTPTR)(&(((struct shared_data *)DSPRAM_START)->x)))
+
+#define MOCA_SHELL_RESP_FLAG_OWNER_MASK    0xff
+#define MOCA_SHELL_RESP_FLAG_OWNER_OFFSET  0
+#define MOCA_SHELL_RESP_FLAG_MORE_MASK     0xff00
+#define MOCA_SHELL_RESP_FLAG_MORE_OFFSET   8
+#define MOCA_SHELL_RESP_FLAG_LEN_MASK      0xffff0000
+#define MOCA_SHELL_RESP_FLAG_LEN_OFFSET    16
+
+#define MOCA_SHELL_RESP_OWNER(x)   (((x) & MOCA_SHELL_RESP_FLAG_OWNER_MASK) >> MOCA_SHELL_RESP_FLAG_OWNER_OFFSET)
+#define MOCA_SHELL_RESP_MORE(x)    (((x) & MOCA_SHELL_RESP_FLAG_MORE_MASK) >> MOCA_SHELL_RESP_FLAG_MORE_OFFSET)
+#define MOCA_SHELL_RESP_LEN(x)     (((x) & MOCA_SHELL_RESP_FLAG_LEN_MASK) >> MOCA_SHELL_RESP_FLAG_LEN_OFFSET)
+
+#define MOCA_SHELL_SOC_CONSTRUCT_RESP_FLAG(len, more, owner) \
+	( (((len) << MOCA_SHELL_RESP_FLAG_LEN_OFFSET ) & MOCA_SHELL_RESP_FLAG_LEN_MASK) \
+    | (((more) << MOCA_SHELL_RESP_FLAG_MORE_OFFSET) & MOCA_SHELL_RESP_FLAG_MORE_MASK) \
+    | (((owner) << MOCA_SHELL_RESP_FLAG_OWNER_OFFSET) & MOCA_SHELL_RESP_FLAG_OWNER_MASK))
+
+#define OWNER_SOC  1
+#define OWNER_HOST 2
+
+enum clnk_ms_session_mdio
+{
+    MS_SESSION_INIT_MDIO     = 0,
+	MS_SESSION_REQ_MDIO      = 1,
+	MS_SESSION_RESP_MDIO     = 2,
+	MS_SESSION_RESP_ACK_MDIO = 3,
+};
+
+struct clnk_hw_params
+{
+    SYS_UINT32              numRxHostDesc;
+    SYS_UINT32              numTxHostDesc;
+#if ECFG_CHIP_ZIP1
+    SYS_UINT32              *minRxLens;
+#endif
+    void                    *at_lock;
+};
+
+typedef struct
+{
+    SYS_UINT32      zip_major;
+    SYS_UINT32      zip_minor;
+    SYS_UINT32      datapath;
+}
+ClnkDef_ZipInfo_t;
+
+//linebuffer descriptor
+struct linebuf
+{
+    SYS_UINT32      packed_0;       /* offset 0x0 */
+    SYS_UINT32      n_entries;      /* offset 0x4 */
+    SYS_UINT32      buffer_base;    /* offset 0x8 */
+    SYS_UINT32      buffer_len;     /* offset 0xc */
+    SYS_UINT32      entry_wptr;     /* offset 0x10 */
+    SYS_UINT32      entry_rptr;     /* offset 0x14 */
+    SYS_UINT32      entry_windex;   /* offset 0x18 */
+    SYS_UINT32      entry_rindex;   /* offset 0x1c */
+    SYS_UINT32      packed_8;       /* offset 0x20 */
+};
+
+#define BRIDGE_ENTRIES      192
+#define CAM_ENTRIES         160
+#define DATABUF_CAM_ENTRIES 16
+
+typedef struct
+{
+    SYS_UINT32 macAddrHigh;
+    SYS_UINT32 macAddrLow;
+}
+ClnkDef_BridgeEntry_t; 
+
+/* dumps out a portion of the software CAM (ClnkCam.c) */
+typedef struct
+{
+    SYS_UINT32 num_entries;
+    ClnkDef_BridgeEntry_t   ent[BRIDGE_ENTRIES];
+}
+ClnkDef_BridgeTable_t;
+
+#define NUM_TX_PRIO         3
+// clnk_set_eth_fifo_size struct
+typedef struct
+{
+    SYS_UINT32 tx_prio[NUM_TX_PRIO];
+}
+ClnkDef_TxFifoCfg_t;
+
+#if FEATURE_IQM
+// Increase the trace buffer size when DEBUG_DUMP_FFT_VALUES enabled in ccpu code (iqm.h)
+#define CLNK_DEF_TRACE_ENTRIES      /*2505*/ 50
+#else
+#define CLNK_DEF_TRACE_ENTRIES      50
+#endif
+typedef struct
+{
+    SYS_UINT32 ctc_time;
+    SYS_UINT32 info1;
+    SYS_UINT32 info2;
+}
+ClnkDef_TraceEntry_t;
+
+typedef struct
+{
+    SYS_UINT32 dropped;
+    SYS_UINT32 ent_valid;
+    ClnkDef_TraceEntry_t ent;
+}
+ClnkDef_TraceBuf_t;
+
+/*
+ * Frequency Scanning (FS) configuration data
+ */
+typedef struct 
+{
+    SYS_UINT32    scan_mask;
+    SYS_UINT32    prod_mask;
+    SYS_UINT32    chanl_mask;
+    SYS_UINT32    chanl_plan;
+    SYS_UINT32    bias_and_max_passes;
+    SYS_UINT32    cm_ratio;
+    SYS_UINT32    taboo_info;
+    SYS_INT32     lof;
+    SYS_UINT32    beacon_mask;
+    SYS_UINT32    tl_cycles;		// Only 8 lsbs used
+} fs_config_t;
+
+/*
+ * Frequency Scanning status flags
+ */
+typedef struct
+{
+    SYS_UINT8    lof_avail:1;     // LOF available (1:true, 0:false) 
+    SYS_UINT8    lof_scan:1;      // LOF scan status (1:true, 0:false)
+    SYS_UINT8    single_chanl:1;  // Single channel prod mask (1:true, 0:false)
+    SYS_UINT8    listen_once:1;   // Listen only channel (1:true, 0:false)
+    SYS_UINT8    fs_reset:1;      // FS state machine reset (1:true, 0:false)
+    SYS_UINT8    reserved:3;      // Reserved for future usage
+} fs_flags_t;
+
+/*
+ * Frequency Scanning context data
+ */
+typedef union 
+{
+    SYS_UINT32    word[8];
+    struct 
+    {
+        fs_flags_t   flags;         // FS status flags
+        SYS_UINT8    scan_count;    // Number of full scans
+        SYS_INT8     scan_dir;      // Scan direction (+1:lo->hi, -1:hi->lo)
+        SYS_INT8     tune_idx;      // Tuned freq index
+        SYS_INT8     last_idx;      // Last freq index
+        SYS_INT8     low_idx;       // lowest freq index for scan in single dir
+        SYS_INT8     high_idx;      // highest freq index for scan in single dir
+        SYS_INT8     lof_idx;       // LOF index
+        SYS_UINT8    fs_state;      // Current FS state
+        SYS_UINT8    upd_cause;     // FS state update cause
+        SYS_UINT16   hop_count;     // Running count of frequency hops
+        SYS_UINT32   chanl_qual[2]; // Channel quality array
+    } members;
+} fs_context_t;
+
+/** Structure for storing cached pqos maintenace values in shared
+ *  data. */
+typedef struct {
+    SYS_UINT32 ioc_nodemask;
+    SYS_UINT32 allocated_stps;
+    /** Top 16 bits store the allocated txps received (but thresholded
+     *  in the error event that the value exceeded 16 bits) and the 
+     *  bottom 16 bits store the count of maintenance events since
+     *  joining the network. */
+    SYS_UINT32 trunc_alloc_txps_hi__ctr_lo;
+} shared_qos_maint_cache_t;
+
+#if FEATURE_PUPQ_NMS_CONF
+// pqos NMS initialization structure.
+typedef struct
+{
+    /** This member contains the vendor id 16 bit value in the high
+     * 16 bits and the personality in the low 16 bits. Saves CCPU space. */
+    SYS_UINT32 mfrVendorIdHi_personalityLo;
+    SYS_UINT32 mfrHwVer;
+    SYS_UINT32 mfrSwVer;
+} pupq_nms_init_context_t;
+#endif /* FEATURE_PUPQ_NMS_CONF */
+
+#if FEATURE_PUPQ_RX_NODE_STATS
+// per-node based statistics
+typedef struct
+{
+    /** Number of received MoCA transmissions from this node which were
+     *  NOT correctly received or processed. */
+    SYS_UINT32 mtrans_p2p_rx_count_error;
+
+    /** Number of received MoCA transmissions from this node which were
+     *  correctly received and processed. */
+    SYS_UINT32 mtrans_p2p_rx_count_good;
+}                           clnkdefs_per_node_stats_t;
+INCTYPES_VERIFY_STRUCT_SIZE(clnkdefs_per_node_stats_t, 8);
+
+typedef struct
+{
+    clnkdefs_per_node_stats_t nodes[MAX_NUM_NODES];
+}                           clnkdefs_all_node_stats_t;
+#if MAX_NUM_NODES == 16
+INCTYPES_VERIFY_STRUCT_SIZE(clnkdefs_all_node_stats_t, 128);
+#else
+INCTYPES_VERIFY_STRUCT_SIZE(clnkdefs_all_node_stats_t, 64);
+#endif
+#endif /* FEATURE_PUPQ_RX_NODE_STATS */
+
+#if FEATURE_FEIC_PWR_CAL
+// defines for FEIC Profiles
+#define NUM_ADC_MEASUREMENTS       64       // must be mustiple of 4
+#define MAX_FEIC_PROFILES          (10+1)   // feic.conf must not have more profiles than this
+#define MAX_RF_BAND_STR_SIZE       (7+1)    // null terminated
+#define MAX_FEIC_TYPE_STR_SIZE     (15+1)   // null terminated
+#define MAX_FREQ_INDEXES           8        // 8 frequencies interpolated to 29
+                                            // by the SoC firmware
+#define MAX_FREQ_WORDS             ((MAX_FREQ_INDEXES + sizeof(SYS_UINT32) - 1) / sizeof(SYS_UINT32))   // 2
+                                            // by the SoC firmware
+#define MAX_TEMPERATURE_INDEXES    5        // 5 temperatures interpolated to 32
+                                            // by the SoC firmware
+                                            // use 9, 13, 17, 21, 25
+
+typedef struct
+{
+    SYS_CHAR    rfBandStr[MAX_RF_BAND_STR_SIZE];
+    SYS_CHAR    feicTypeStr[MAX_FEIC_TYPE_STR_SIZE];
+    SYS_INT32   feicProfileId;      // only used to pass pid through API calls
+    SYS_UINT32  tempClass;          // 0=Industrial (-40 degC to +85 degC)
+                                    // 1=Commercial (0 degC to +70 degC)
+    SYS_UINT32  M0Vars;             // bits0-7=adcOffCorrection, bits8-15=m0DeltaAdcOn;
+    SYS_INT32   targetLsbBias;      // same for all profiles
+    SYS_UINT32  nominalGainsPacked; // profile 0 specific nominal gains packed
+    SYS_UINT32  feicFileFound;      // indicates feic.conf file found
+    union
+    {
+        struct
+        {
+            SYS_INT8    errThreshold2[4];
+            SYS_INT8    errThreshold3[4];
+            SYS_INT8    errThreshold4[4];
+            SYS_UINT8   tgtDeltaAdcEsf[MAX_FREQ_INDEXES];
+            SYS_INT8    tgtDeltaAdcDbm[MAX_TEMPERATURE_INDEXES][MAX_FREQ_INDEXES];
+            SYS_UINT8   tgtDeltaAdcLsb[MAX_TEMPERATURE_INDEXES][MAX_FREQ_INDEXES];
+        } bytes;
+        struct
+        {
+            SYS_UINT32  errThreshold2;
+            SYS_UINT32  errThreshold3;
+            SYS_UINT32  errThreshold4;
+            SYS_UINT32  tgtDeltaAdcEsf[MAX_FREQ_WORDS];
+            SYS_UINT32  tgtDeltaAdcDbm[MAX_TEMPERATURE_INDEXES][MAX_FREQ_WORDS];
+            SYS_UINT32  tgtDeltaAdcLsb[MAX_TEMPERATURE_INDEXES][MAX_FREQ_WORDS];
+        } words;
+    };
+} feic_profile_t;
+
+typedef struct
+{
+    SYS_INT32       cfgFeicProfileId;
+    feic_profile_t  profiles[MAX_FEIC_PROFILES];
+} feic_cfg_t;
+
+typedef struct
+{
+    SYS_UINT8   tempAdc;
+    SYS_UINT8   freqIndex;                  // frequency index
+    SYS_INT8    targetLsbBias;              // signed, units of 1/8th LSB
+                                            // from feic.conf
+    SYS_UINT8   tLsbPlusTargetLsbBias;      // units of lsb, lookup from
+                                            // TargetDeltaAdcLsb in feic.conf +
+                                            // targetLsbBias
+    SYS_INT8    targetPwrDbmT10;            // signed, units of 1/10th dBm
+                                            // from feic.conf
+    SYS_UINT8   dummy1;
+    SYS_UINT8   dummy2;
+    SYS_UINT8   dummy3;
+} TargetPwrStatus_t;
+
+typedef struct
+{
+    SYS_INT8        m0TxdCGainSel;
+    SYS_UINT8       m0RficTxCal;
+    SYS_UINT8       m0FeicAtt1;
+    SYS_UINT8       m0FeicAtt2;
+    SYS_UINT8       m0TxOn[NUM_ADC_MEASUREMENTS];
+    SYS_UINT8       m0TxOnAvg;
+    SYS_UINT8       m0TxOffAvg;
+    SYS_UINT8       m0DeltaAdcBelowMin;
+    SYS_INT8        m0ErrorQtrDb;
+    SYS_INT8        m1TxdCGainSel;
+    SYS_UINT8       m1RficTxCal;
+    SYS_UINT8       m1FeicAtt1;
+    SYS_UINT8       m1FeicAtt2;
+    SYS_UINT8       m1TxOn[NUM_ADC_MEASUREMENTS];
+    SYS_UINT8       m1TxOnAvg;
+    SYS_INT8        m1ErrorQtrDb;
+    SYS_INT8        m2TxdCGainSel;
+    SYS_UINT8       m2RficTxCal;
+    SYS_UINT8       m2FeicAtt1;
+    SYS_UINT8       m2FeicAtt2;
+    SYS_UINT8       m2Dummy1;
+    SYS_UINT8       m2Dummy2;
+    SYS_UINT8       m2TxOn[NUM_ADC_MEASUREMENTS];
+    SYS_UINT8       m2TxOnAvg;
+    SYS_INT8        m2DcOffset;
+    SYS_INT8        m2Dummy;
+    SYS_UINT8       m0m1ErrorSmall;
+    SYS_INT8        m3TxdCGainSel;
+    SYS_UINT8       m3RficTxCal;
+    SYS_UINT8       m3FeicAtt1;
+    SYS_UINT8       m3FeicAtt2;
+    SYS_UINT8       m3TxOn[NUM_ADC_MEASUREMENTS];
+    SYS_UINT8       m3TxOnAvg;
+    SYS_INT8        m3ErrorQtrDb;
+    SYS_UINT8       m3ErrorSmall;
+    SYS_INT8        m4TxdCGainSel;
+    SYS_UINT8       m4RficTxCal;
+    SYS_UINT8       m4FeicAtt1;
+    SYS_UINT8       m4FeicAtt2;
+    SYS_UINT8       m4Dummy1;
+    SYS_UINT8       m4TxOn[NUM_ADC_MEASUREMENTS];
+    SYS_UINT8       m4TxOnAvg;
+    SYS_INT8        m4ErrorQtrDb;
+    SYS_UINT8       m4Dummy2;
+    SYS_UINT8       m4Dummy3;
+} IntermediateDetectorStatus_t;
+
+typedef struct
+{
+    SYS_INT8        feicProfileId;
+    SYS_UINT8       feicFileFound;          // 0=No, 1=Yes
+    SYS_UINT8       tempClass;
+    SYS_UINT8       CalDisabled;
+    SYS_UINT8       CalBypassed;
+    SYS_INT8        targetLsbBias;          // signed
+    SYS_INT8        txdCGainSel;            // signed
+    SYS_UINT8       rficTxCal;
+    SYS_UINT8       feicAtt1;
+    SYS_UINT8       feicAtt2;
+    SYS_INT8        pwrEstimateT10;         // signed, units of 1/10th dBm
+    SYS_UINT8       calErr;                 // 0=No, 1=Yes
+    SYS_UINT8       freqIndex;              // frequency index
+    SYS_UINT8       dummy1;
+    SYS_UINT8       dummy2;
+    SYS_UINT8       dummy3;
+    SYS_CHAR        rfBandStr[MAX_RF_BAND_STR_SIZE];
+} FinalConfigStatus_t;
+
+// this structure is sent to host via unsolicited ctl msg for output
+typedef struct
+{
+    TargetPwrStatus_t               targetPwrStatus;            // only when pwr cal enabled
+    IntermediateDetectorStatus_t    intermediateDetectorStatus; // always reported
+    FinalConfigStatus_t             finalConfigStatus;          // always reported
+} FeicStatusData_t;
+
+typedef struct
+{
+    FinalConfigStatus_t finalConfigStatus;
+} feic_final_results_t;
+#endif /* FEATURE_FEIC_PWR_CAL */
+
+#if 1 // added for MID RF (DEBUG_EPP)
+typedef struct
+{
+    SYS_UINT32 nodeId;
+    SYS_UINT32 flags;
+}
+ClnkDef_EppCapCfg_t;
+
+// Echo Profile Structures
+typedef struct
+{
+    SYS_UINT32 valid;
+    SYS_UINT32 nodeId;
+    SYS_UINT32 probeId;
+    SYS_UINT32 cpLen;
+    SYS_UINT32 sysBias;
+    SYS_UINT32 status;
+    SYS_UINT32 rawData[(256 + 3*(256+64))];    /* 0x4c0 words = 4864 bytes */
+    SYS_UINT8  corrData[256];
+    SYS_UINT8  corrEnergy[256];
+}
+ClnkDef_EppData_t;
+
+typedef struct
+{   // OBSOLETE
+    SYS_UINT32 NodeId;
+    SYS_UINT8  cpLen;
+    SYS_UINT8  systemBias;
+    SYS_UINT8  ftmgThresh;
+    SYS_UINT32 ftmgThresh2;
+    SYS_UINT8  ftmgBias;
+}
+ClnkDef_EppResult_t;
+#endif
+
+// shared data between the host and SoC (Zip2 only)
+struct shared_data
+{
+    SYS_UINT32      mailbox_reg[NUM_MAILBOX_REG];
+    SYS_UINT32      debug_reg[NUM_DEBUG_REG];
+    SYS_UINT32      read_csr_reg;
+    SYS_UINT32      write_csr_reg;
+
+    SYS_UINT32      linebuf_host_rx;
+    SYS_UINT32      linebuf_host_tx[4]; /* 4 priorities */
+
+    SYS_UINT32      mac_addr_hi;
+    SYS_UINT32      mac_addr_lo;
+
+    SYS_UINT32      rx_active;
+
+    SYS_UINT32      trace_dropped;
+    ClnkDef_TraceEntry_t trace_buf[CLNK_DEF_TRACE_ENTRIES];
+
+    SYS_UINT32      pll_unlocked;         // command sent to host
+    SYS_UINT32      ms_session_req;       // MoCA Shell session request
+    SYS_UINT32      ms_cmd_buf_addr;      // Buffer address to store MoCA Shell
+    SYS_UINT32      ms_resp_owner_flag;   // MoCA Shell response buffer owner flag
+    SYS_UINT32      ms_resp_buf_addr;     // Buffer to receive moca shell result
+
+    SYS_UCHAR       moca_password[20];    // Initial password
+    SYS_UINT32      freq_band;            // 1 all pass; 2 D band; 3 E band; 4 F band;
+    SYS_UINT32      aggr_level;           //aggr level
+    SYS_UINT32      mac_mode;             // 0- phy mode; 1- mac mode
+    SYS_UINT32      mii_speed;            // 1- 10M; 2/3- MII half/full duplex; 4- TMII full duplex; 5- GMII; 6-RGMII
+
+    fs_config_t     fs_cfg;                // Frequency Scan config parameters
+    fs_context_t    fs_ctx;                // Frequency Scan context data
+
+    SYS_UINT32      dbgMask;     
+    SYS_UINT32      watchdog_delay;
+    SYS_UINT32      defaultSeqNum;        // Used for MoCA RESET
+
+    SYS_UINT32      unsol_msg_queue;
+// added for MID RF (DEBUG_EPP)
+    SYS_UINT32      eppCapSrcId;
+    SYS_UINT32      eppCapFlags;
+    SYS_UINT32      target_phy_rate;
+    SYS_UINT32      node_adm_req_rx_ctr;
+    SYS_UINT32      node_link_up_event_ctr;
+    SYS_UINT32      lmo_advanced_ctr;
+    SYS_UINT32      ingr_routing_conflict_ctr;
+    /** This counter counts in tenths of a second. */
+    SYS_UINT32      node_link_time_bad_deciseconds;
+
+    SYS_UINT32      mtrans_tx_pkt_ctr;
+
+#if FEATURE_FEIC_PWR_CAL
+    SYS_INT32       feicProfileId;
+    feic_profile_t  feic_profile;
+    feic_final_results_t  feic_final_results;
+    SYS_INT32       feic_m2DcOffset;
+    SYS_UINT32      feic_m0TxOffAvg;
+    SYS_UINT32      feic_tempAdc;
+#endif
+
+#if L2_DONGLE
+    SYS_UINT32      version_id; 
+#endif  
+
+#if FEATURE_PUPQ_RX_NODE_STATS
+    /** ONLY MODIFIED BY CCPU.  Kept here as a convenience since
+     *  the host may want to do a fast read of these statistics without
+     *  mailbox op.  */
+    clnkdefs_all_node_stats_t  all_node_stats;
+#endif
+
+#if FEATURE_PUPQ_NMS_CONF
+    pupq_nms_init_context_t  pni_ctx;
+#endif /* FEATURE_PUPQ_NMS_CONF */
+
+#if FEATURE_PUPQ_NMS_QUICK_APIS
+    SYS_UINT32      pqos_mode;
+    SYS_UINT32      hard_reset;
+    /* added shared_data entries 
+     *   vinirn is (UINT16 vendor_id << 16) | (UINT8 node_id << 8) | UINT8 request_number
+     */
+    SYS_UINT32      vinirn;    // vendor id, node id, request number
+
+    /* eventually fit this in a byte somewhere else in shared_data 
+     * Both nmspush_change_ctr and nmspush_change_ack are 
+     * each only 8 bits 
+     */
+    SYS_UINT32      nmspush_change_ctr;
+    SYS_UINT32      nmspush_change_ack;
+    SYS_UINT32      dword_array[6];
+#endif
+
+#if FEATURE_IQM
+    SYS_UINT32      iqm_debug_mask1;
+    SYS_UINT32      iqm_debug_mask2;
+    SYS_UINT32      iqm_debug_mask3;
+#endif
+    SYS_UINT32      iqmEnable;
+    SYS_UINT32      pwrCalEnable;
+    SYS_UINT32      lomEnable;
+
+    shared_qos_maint_cache_t  qos_maint_cache;
+};
+
+struct shared_data_in_text
+{
+#if FEATURE_INGRESS_MARGIN 
+    SYS_UINT32      ingress_cfg[65/*MAX_rxLevel*//4 + 1];	 
+#endif 
+
+#if FEATURE_SPECTRAL_SCULPTING
+    SYS_UINT32      ss_thr;                // Spectral Sculpting threshold
+    SYS_UINT32      ss_table[64];          // Spectral Sculpting margin adjustments
+#endif
+};
+
+
+#define FEATURE_ECLAIR                     1
+
+#if (NETWORK_TYPE_ACCESS)
+    #define FEATURE_FREQ_SCAN              0      // 0: disable
+    #define FEATURE_OLDQOS                 0
+    #define FEATURE_MRT                    0
+    #define FEATURE_QOS                    0
+    #define ENTROPIC_ECLAIR                0
+    #define BROADCAST_LMO                  0
+#else
+    #define FEATURE_FREQ_SCAN              1      // 1: enable
+    #define FEATURE_OLDQOS                 0
+    #define FEATURE_MRT                    1
+    #define FEATURE_QOS                    1
+    #define ENTROPIC_ECLAIR                1
+    #define BROADCAST_LMO                  1
+
+    /** Expect this flag to be set from the build file *.bld */
+    #ifndef FEATURE_ECLAIR_WHITE_BOX_TEST
+        #define FEATURE_ECLAIR_WHITE_BOX_TEST  0
+    #endif
+
+#endif
+
+// C.Link Ethernet Statistics Structureyy
+typedef struct
+{
+    // Driver stats
+    SYS_UINT32 drvSwRevNum;
+    SYS_UINT32 embSwRevNum;
+    SYS_UINT32 upTime;
+    SYS_UINT32 linkUpTime;
+    SYS_UINT32 socResetCount;       // Number of C.Link resets
+    SYS_UINT32 socResetHistory;     // Reason for last 4 resets
+
+    // Transmit and recieve stats
+    SYS_UINT32 rxPackets;           // Total packets received
+    SYS_UINT32 txPackets;           // Total packets transmitted
+    SYS_UINT32 rxBytes;             // Total bytes received
+    SYS_UINT32 txBytes;             // Total bytes transmitted
+    SYS_UINT32 rxPacketsGood;       // Packet receive with no errors
+    SYS_UINT32 txPacketsGood;       // Packet transmitted with no errors
+    SYS_UINT32 rxPacketErrs;        // Packets received with errors
+    SYS_UINT32 txPacketErrs;        // Packets transmitted with errors
+    SYS_UINT32 rxDroppedErrs;       // Packets dropped with no host buffers
+    SYS_UINT32 txDroppedErrs;       // Packet dropped with no host buffers
+    SYS_UINT32 rxMulticastPackets;  // Total multicast packets received
+    SYS_UINT32 txMulticastPackets;  // Total multicast packets transmitted
+    SYS_UINT32 rxMulticastBytes;    // Total multicast bytes received
+    SYS_UINT32 txMulticastBytes;    // Total multicast bytes transmitted
+
+    // Detailed receive errors
+    SYS_UINT32 rxLengthErrs;
+    SYS_UINT32 rxCrc32Errs;         // Packets rx'd with CRC-32 errors
+    SYS_UINT32 rxFrameHeaderErrs;   // Packets rx'd with frame header errors
+    SYS_UINT32 rxFifoFullErrs;      // Packets rx'd with FIFO full
+    SYS_UINT32 rxListHaltErr[3];
+
+    // Detailed transmit errors
+    SYS_UINT32 txCrc32Errs;         // Packets tx'd with CRC-32 errors
+    SYS_UINT32 txFrameHeaderErrs;   // Packets tx'd with frame header errors
+    SYS_UINT32 txFifoFullErrs;      // Packets tx'd with FIFO full
+    SYS_UINT32 txFifoHaltErr[8];
+}
+ClnkDef_EthStats_t;
+
+// EVM Data Structure
+typedef struct
+{
+    SYS_UINT32 valid;
+    SYS_UINT32 NodeId;
+    SYS_UINT32 Data[256];
+}
+ClnkDef_EvmData_t;
+
+#if FEATURE_FEIC_PWR_CAL
+// FEIC Status Structure
+typedef struct
+{
+    SYS_UINT32 valid;
+    FeicStatusData_t Data;
+}
+ClnkDef_FeicStatus_t;
+#endif
+
+#if 0 // modified for MID RF (DEBUG_EPP)
+// Echo Profile Structures
+typedef struct
+{
+    SYS_UINT32 valid;
+    SYS_UINT32 NodeId;
+    SYS_UINT32 Data[(256 + 3*(256+64))];    /* 0x4c0 words = 4864 bytes */
+}
+ClnkDef_EppData_t;      
+#endif
+
+//values returned to the host in the initial mailbox
+struct mb_return
+{
+    SYS_UINT32 linebuf0_soc_tx;         /* word 0 */
+    SYS_UINT32 linebuf1_soc_tx;         /* word 1 */
+    SYS_UINT32 linebuf2_soc_tx;         /* word 2 */
+    SYS_UINT32 extra_pkt_mem;           /* word 3 */
+    SYS_UINT32 linebuf3_soc_tx;         /* word 4 */
+    SYS_UINT32 linebuf_soc_rx;          /* word 5 */
+#if DATAPATH_PCI_ENABLE
+    SYS_UINT32 tx_did;                  /* word 6 */
+    SYS_UINT32 rx_did;                  /* word 7 */
+#endif
+    SYS_UINT32 tx_gphy_desc;            /* word 8 */
+    SYS_UINT32 rx_gphy_desc;            /* word 9 */
+    SYS_UINT32 pd_queue_0;              /* word 10 */
+    SYS_UINT32 pd_queue_1;              /* word 11 */
+    SYS_UINT32 pd_queue_2;              /* word 12 */
+    SYS_UINT32 pd_queue_3;              /* word 13 */
+    SYS_UINT32 pd_entries;              /* word 14 */
+    SYS_UINT32 unsol_msgbuf;            /* word 15 - also the semaphore */
+};
+////////// END defines needed by ClnkEth.h
+
+////////// defines for ClnkCam
+
+#define    CLNKMAC_BCAST_ADDR      0x3F
+#define    QOS_MAX_FLOWS           24
+
+/* Enums for PQOS Classification mode */
+enum {
+    CLNK_PQOS_MODE_UNKNOWN       = -1,
+    CLNK_PQOS_MODE_MOCA_11       = 0,
+    CLNK_PQOS_MODE_PUPQ_CLASSIFY = 1,
+};
+typedef SYS_UINT32 clnk_pqos_mode_t;
+
+////////// end defines for ClnkCam
+
+////////// defines for eth_ioctl
+
+// Software Configuration Bits
+#define CLNK_DEF_SW_CONFIG_SOFTCAM_BIT                 (1 << 14)
+#define CLNK_DEF_SW_CONFIG_AGGREGATION_METHOD_BIT      (1 << 24)  // used in hw_z2_pci.c
+                                                                   
+// SOC Status Values
+typedef enum
+{
+    CLNK_DEF_SOC_STATUS_SUCCESS           = 0,
+    CLNK_DEF_SOC_STATUS_EMBEDDED_TIMEOUT  = 1,
+    CLNK_DEF_SOC_STATUS_EMBEDDED_FAILURE  = 2,
+    CLNK_DEF_SOC_STATUS_LINK_CTRL_RESTART = 3,
+    CLNK_DEF_SOC_STATUS_LINK_DOWN_FAILURE = 4,
+    CLNK_DEF_SOC_STATUS_TX_HALTED_FAILURE = 5,
+    CLNK_DEF_SOC_STATUS_RX_HALTED_FAILURE = 6,
+    CLNK_DEF_SOC_STATUS_FORCED_RESET      = 7,
+
+    CLNK_DEF_SOC_STATUS_MAX  // This must always be last
+}
+CLNK_DEF_SOC_STATUS_VALUES;
+
+// a subset Embedded failure reasons
+typedef enum                                    // Hex
+{
+#if (FEATURE_FREQ_SCAN)
+    CLNK_DEF_FREQ_RESET_BAD_CRC       = 23,     // 17
+    CLNK_DEF_FREQ_RESET_FTM_EXPIRE    = 24,     // 18
+    CLNK_DEF_FREQ_RESET_CHNL_MISMATCH = 25,     // 19
+    CLNK_DEF_FREQ_ADM_FAILURE         = 26,     // 1A
+    CLNK_DEF_FREQ_PREAMBLE_MISS       = 27,     // 1B
+    CLNK_DEF_FREQ_SCAN_TABOO_ONLY     = 28,     // 1C
+#endif /* FEATURE_FREQ_SCAN */
+    CLNK_DEF_ACCESS_DENY              = 29,     // 1D
+    CLNK_DEF_LINK_CTRL_RESTART_MAX  // This must always be last
+
+}
+CLNK_DEF_LINK_CTRL_RESTART_EVENTS;
+
+//variables to be used by driver
+typedef struct
+{
+    SYS_UINT32 swConfig;     // data plane variables for PCI driver
+    SYS_UINT32 unsol_msgbuf; // for mailbox init
+    SYS_UINT32 pqosClassifyMode;
+    SYS_UINT32 pSwUnsolQueue;
+    SYS_UINT32 swUnsolQueueSize;
+    SYS_UINT32 freqBand;
+}
+ClnkDef_dataPlaneVars_t;
+
+// C.Link Node Statistics Structure
+typedef struct
+{
+    SYS_UINT32 NumOfMapTx;
+    SYS_UINT32 NumOfRsrvTx;
+    SYS_UINT32 NumOfLCTx;
+    SYS_UINT32 NumOfAdmTx;
+    SYS_UINT32 NumOfProbeTx;
+    SYS_UINT32 NumOfAsyncTx;
+
+    SYS_UINT32 NumOfMapTxErr;
+    SYS_UINT32 NumOfRsrvTxErr;
+    SYS_UINT32 NumOfLCTxErr;
+    SYS_UINT32 NumOfAdmTxErr;
+    SYS_UINT32 NumOfProbeTxErr;
+    SYS_UINT32 NumOfAsyncTxErr;
+
+    SYS_UINT32 NumOfMapRx;
+    SYS_UINT32 NumOfRsrvRx;
+    SYS_UINT32 NumOfLCRx;
+    SYS_UINT32 NumOfAdmRx;
+    SYS_UINT32 NumOfProbeRx;
+    SYS_UINT32 NumOfAsyncRx;
+
+    SYS_UINT32 NumOfMapRxErr;
+    SYS_UINT32 NumOfRsrvRxErr;
+    SYS_UINT32 NumOfLCRxErr;
+    SYS_UINT32 NumOfAdmRxErr;
+    SYS_UINT32 NumOfProbeRxErr;
+    SYS_UINT32 NumOfAsyncRxErr;
+
+    SYS_UINT32 NumOfMapRxDropped;
+    SYS_UINT32 NumOfRsrvRxDropped;
+    SYS_UINT32 NumOfLCRxDropped;
+    SYS_UINT32 NumOfAdmRxDropped;
+    SYS_UINT32 NumOfProbeRxDropped;
+    SYS_UINT32 NumOfAsyncRxDropped;
+
+    SYS_UINT32 NumOfBadIsocTx;
+    SYS_UINT32 NumOfCtlDescrFailed;
+    SYS_UINT32 NumOfUpdateDescrFailed;
+    SYS_UINT32 NumOfStatDescrFailed;
+    SYS_UINT32 NumOfBufferAllocFailed;
+    SYS_UINT32 NumOfRSCorrectedBytes;
+    SYS_UINT32 Events;
+    SYS_UINT32 Interrupts;
+
+    SYS_UINT32 InternalWarnings;
+    SYS_UINT32 InternalErrors;
+
+    SYS_UINT32 qosRcvdSubmits;
+    SYS_UINT32 qosRcvdRequests;
+    SYS_UINT32 qosRcvdResponses;
+    SYS_UINT32 qosAcceptedSubmits;
+    SYS_UINT32 qosDroppedSubmits;
+    SYS_UINT32 qosIssuedWaves;
+    SYS_UINT32 qosSkippedWaves;
+    SYS_UINT32 qosSuccessWaves;
+    SYS_UINT32 qosFailedWaves;
+
+    SYS_UINT32 qosIssuedTxns;
+    SYS_UINT32 qosSuccessTxns;
+    SYS_UINT32 qosEarlyTerminatedTxns;
+    SYS_UINT32 qosEntryCancelledTxns;
+    SYS_UINT32 qosTxnErrors;
+    SYS_UINT32 qosPerformedEntryCancels;
+    SYS_UINT32 qosRcvdTxnErrors;
+
+    SYS_UINT32 qosTotalEgressBurst;
+    SYS_UINT32 qosMaxEgressBurst;
+}
+ClnkDef_Stats_t;
+
+// C.Link My Node Info Structure
+typedef struct
+{
+    SYS_UINT32      ClearStats;
+    SYS_UINT32      SwRevNum;
+    SYS_UINT32      EmbSwRevNum;
+    SYS_UINT32      LinkStatus;
+    SYS_UINT32      TxChannelBitMask;
+    SYS_UINT32      RxChannelBitMask;
+    SYS_UINT32      IsCyclemaster;
+    SYS_UINT32      RFChanFreq;
+    SYS_UINT32      CurrNetworkState;
+    SYS_UINT32      NetworkType;
+    SYS_UINT32      NodeId;
+    SYS_UINT32      CMNodeId;
+    SYS_UINT32      BestCMNodeId;
+    SYS_UINT32      BackupCMNodeId;
+    SYS_UINT32      NetworkNodeBitMask;
+    SYS_UINT32      TxIsocChanInfo;
+    SYS_UINT32      RxIsocChanInfo;
+    SYS_UINT32      PrivacyStat;
+    SYS_UINT32      MocaField;
+    SYS_UINT32      TxIQImbalance;
+    SYS_UINT32      RxIQImbalance;
+    SYS_UINT32      RxIQImbalance2;
+    ClnkDef_Stats_t Stats;
+    SYS_UINT32      TabooChanMask;
+    SYS_UINT32      TabooMaskStart;
+}
+ClnkDef_MyNodeInfo_t;
+// end defines for eth_ioctl
+// **********************************************
+// END Inserting all ClnkDefs.h neeeded by driver 
+
+/**********    Common to ClnkCAM and ClnkETH   ***************/
+#if (NETWORK_TYPE_ACCESS)
+
+    #error not tested for a long time
+
+    #define CLNK_ETH_VLAN_ACTUAL      (2)
+    #define MAX_TX_FIFOS              (CLNK_ETH_VLAN_ACTUAL)     /* HW Queues */
+    #define MAX_TX_PRIORITY           (32*CLNK_ETH_VLAN_ACTUAL)  /* SW Queues */
+    #define TX_ADVERTIZE_SIZE         (162)                      //- (200)
+    #define TX_MAPPING_SIZE           ((TX_ADVERTIZE_SIZE+8) * 32)
+    #define MAP_PRIO_TO_FIFO(PRIO)    ((PRIO) >> 5)
+    #define TMR_2_JIFFIES             (2456)
+
+#else
+
+  #define  CLNK_VLAN_MODE_HWVLAN   1  /* Nominal: 3 SW Q ---> 3 HW Q */
+  #define  CLNK_VLAN_MODE_SWVLAN   0  /* Alternate: 3 SW Q ---> 1 HW Q */
+
+  #if (CLNK_VLAN_MODE_HWVLAN)
+
+    #define CLNK_ETH_VLAN_ACTUAL      3 /* Nominal 3 but any value up to 8 */
+    #define MAX_TX_FIFOS              (CLNK_ETH_VLAN_ACTUAL+FEATURE_QOS)  /* HW Qs*/
+    #define MAX_TX_PRIORITY           (CLNK_ETH_VLAN_ACTUAL+FEATURE_QOS)  /* SW Qs*/
+    #define TX_ADVERTIZE_SIZE         256
+#if ECFG_CHIP_ZIP1
+    #define TX_MAPPING_SIZE           400
+    #define CAM_TMR_JIFFIES           TMR_2_JIFFIES
+#else
+    #define TX_MAPPING_SIZE           ((TX_ADVERTIZE_SIZE + 1) * MAX_TX_PRIORITY)
+    #define CAM_TMR_JIFFIES           100               /* 100 clocks/sec = 10ms period */
+#endif
+    #define MAP_PRIO_TO_FIFO(PRIO)    (PRIO)
+    #if (CLNK_ETH_PER_PACKET)
+      #define TMR_2_JIFFIES             (1111)
+   #else
+      #define TMR_2_JIFFIES             (3333)
+   #endif
+
+  #elif (CLNK_VLAN_MODE_SWVLAN)
+
+    #error not tested for a long time
+
+    #define CLNK_ETH_VLAN_ACTUAL      8
+    #define MAX_TX_FIFOS              1                                   /* HW Qs */
+    #define MAX_TX_PRIORITY           (CLNK_ETH_VLAN_ACTUAL+FEATURE_QOS)  /* SW Qs */
+    #define TX_ADVERTIZE_SIZE         128
+    #define TX_MAPPING_SIZE           (TX_ADVERTIZE_SIZE * MAX_TX_PRIORITY)
+    #define MAP_PRIO_TO_FIFO(PRIO)    (0)
+    #if (CLNK_ETH_PER_PACKET)
+      #define TMR_2_JIFFIES             (1111)
+   #else
+      #define TMR_2_JIFFIES             (2468)
+   #endif
+
+  #endif
+
+#endif
+
+#if 0
+#if NETWORK_TYPE_MIDRF_MESH
+#define CLNK_ETH_ECHO_PROFILE  1 // for collecting data during field trials 
+                                 // should be turned off eventually
+#endif
+#endif
+/************* End definitions originally from ClnkDefs.h ********************/
+
+
+/************************** original common.h defines ************************/
+// Number of VLANs
+#define CLNK_ETH_VLAN_8021Q 8      // Number Logical 802.1Q VLAN Queues
+//#define CLNK_ETH_VLAN_ACTUAL xx  // See ClnkEth.h
+#define MAX_POSSIBLE_FIFOS    8
+
+/* Firmware image struct
+ *
+ * fw.pFirmware can point to one of three things:
+ *
+ * 1) the builtin firmware
+ * 2) a user-supplied firmware image
+ * 3) NULL (don't download firmware)
+ *
+ * All fields are native-endian.
+ */
+struct fw_img
+{
+    SYS_UINT32  *fw_text;       // instruction memory image
+    SYS_UINT32  fw_text_size;   // image size
+    SYS_UINT32  *fw_data;       // initialized data memory image
+    SYS_UINT32  fw_data_size;   // image size
+    SYS_UINT32  version;        // firmware version
+    SYS_UINT8   builtin;        // 1=built in to the driver, 0 if user-supplied
+    SYS_UINT8   native;         // 1=native endianness, 0=SoC (BE) endianness
+};
+
+// Firmware Structure
+typedef struct
+{
+    const struct fw_img *pFirmware; // Pointer to firmware info struct
+    SYS_UINT32  DistanceMode;
+    SYS_UINT32  privacyKey[4];  // MMK and PMKi
+    SYS_UINT32  cmRatio;        // Cycle master ratio (0% to 100%)
+    SYS_UINT32  txPower;        // Transmit power
+    SYS_UINT32  phyMargin;      // Phy margin settings
+    SYS_UINT32  phyBitMask;     // Phy #bits
+    SYS_UINT32  swConfig;       // Software configuration
+#if defined(L3_DONGLE_HIRF)
+    SYS_UINT32  Diplexer_;	// Diplxere Mode
+#endif    
+    SYS_UINT32  beaconPwrLevel; // Beacon power level setting. 
+    SYS_UINT32* pRFIC_Tuning_Data; // pointer to RFIC tuning data channel table for all channels
+    SYS_UINT32* pAGC_Gain_Table;// pointer to AGC gain table
+    SYS_UINT32  macAddrHigh;    // C.Link MAC address high (bytes 0-3)
+    SYS_UINT32  macAddrLow;     // C.Link MAC address low (bytes 4-5)
+    SYS_UINT8   txFifoLut[CLNK_ETH_VLAN_8021Q]; // Priority Mapping
+#if ECFG_CHIP_ZIP1
+    SYS_UINT16  txFifoPct[MAX_POSSIBLE_FIFOS]; // Tx fifo size (initial, backup)
+    SYS_UINT16  txFifoSize[MAX_POSSIBLE_FIFOS]; // Tx fifo size (w/o flows)
+#if FEATURE_QOS
+    SYS_UINT16  txFifoSizeQos[MAX_POSSIBLE_FIFOS]; // Tx fifo size (w/ flows)
+#endif /* FEATURE_QOS */
+    SYS_UINT16  txFifoChunks[MAX_POSSIBLE_FIFOS]; // Tx fifo size (runtime,  in chunks)
+    SYS_UINT32  rxFifoSize;      // Rx fifo size
+#endif /* ECFG_CHIP_ZIP1 */
+    SYS_UINT32  channelMask;     // Tunable RF Channel Mask
+    SYS_UINT32  productMask;     // Product Mask
+    SYS_UINT32  scanMask;        // Scan mask
+    SYS_UINT32  lof;             // LOF
+    SYS_UINT32  beaconMask;	 // Beacon Mask, only on which channel beacons can be transmitted
+    SYS_UINT32  TLCycles;	 // Time limitation cycles. Programmable time limitation in 
+    				 // listening-only mode of network search process
+    SYS_UINT32  bias;            // Bias
+    SYS_UINT32  channelPlan;     // Channel Plan
+    SYS_UINT32  tabooInfo;       // Taboo mask + taboo offset
+    SYS_UINT32  PowerCtlPhyRate; // Power control PHY rate
+    SYS_UINT32  MiiPausePriLvl;  // MII Pause Priority Level
+    SYS_UINT32  PQoSClassifyMode;// PQoS Classification Mode
+
+#if FEATURE_PUPQ_NMS_CONF
+    SYS_UINT32  mfrVendorId;     // Manufacturer Vendor Id (See MoCA 1.1) [we only use 16 lsbs]
+    SYS_UINT32  mfrHwVer;        // Manufacturer Hardware Version (vendor specific)
+    SYS_UINT32  mfrSwVer;        // Manufacturer Software Version (vendor specific)
+    SYS_UINT32  personality;     // Manufacturer node personality
+#endif /* FEATURE_PUPQ_NMS_CONF */
+
+    SYS_UINT32  dbgMask;     
+    SYS_UINT32  master_mode;
+    SYS_UINT32      defaultSeqNum;             // Used for MoCA RESET
+#if FEATURE_IQM
+    SYS_UINT32      iqmDebugMask1;
+    SYS_UINT32      iqmDebugMask2;
+    SYS_UINT32      iqmDebugMask3;
+#endif
+
+#if FEATURE_FEIC_PWR_CAL
+    SYS_UINT32  feicProfileId;
+#endif
+}
+Clnk_ETH_Firmware_t;
+
+// List Entry Structure
+// This defines the structure for an entry in the linked list.
+typedef struct ListEntry_t
+{
+    struct ListEntry_t* pNext;
+    struct ListEntry_t* pPrev;
+}
+ListEntry_t;
+
+// List Header Structure
+// This defines the header structure for the linked list.
+typedef struct ListHeader_t
+{
+    ListEntry_t* pHead;
+    ListEntry_t* pTail;
+    SYS_UINT32   numElements;
+}
+ListHeader_t;
+
+
+// { StaticUsageCount: AH=4 AT=12 RH=15 RT=2 RN=2 MH=1 }
+#define COMMON_LIST_INIT(list)      (list)->pHead = SYS_NULL; \
+                             (list)->pTail = SYS_NULL;        \
+                             (list)->numElements = 0
+#define COMMON_LIST_SIZE(list)      ((list)->numElements)
+#define COMMON_LIST_EMPTY(list)     ((list)->pHead == SYS_NULL)
+#define COMMON_LIST_HEAD(T,L)       ((T *) ((L)->pHead))
+#define COMMON_LIST_TAIL(T,L)       ((T *) ((L)->pTail))
+#define COMMON_LIST_NEXT(T,E)       ((T *) (((ListEntry_t *) (E))->pNext))
+#define COMMON_LIST_PREV(T,E)       ((T *) (((ListEntry_t *) (E))->pPrev))
+#define COMMON_LIST_ADD_HEAD(list, entry)                     \
+            ((ListEntry_t *)(entry))->pNext = (list)->pHead;  \
+            ((ListEntry_t *)(entry))->pPrev = SYS_NULL;       \
+            if (!COMMON_LIST_EMPTY(list))                     \
+            {                                                 \
+                ((ListEntry_t *)(entry))->pNext->pPrev =      \
+                    (ListEntry_t *)(entry);                   \
+            }                                                 \
+            else                                              \
+            {                                                 \
+                (list)->pTail = (ListEntry_t *)(entry);       \
+            }                                                 \
+            (list)->pHead = (ListEntry_t *)(entry);           \
+            (list)->numElements++
+#define COMMON_LIST_ADD_TAIL(list, entry)                     \
+            ((ListEntry_t *)(entry))->pNext = SYS_NULL;       \
+            ((ListEntry_t *)(entry))->pPrev = (list)->pTail;  \
+            if (!COMMON_LIST_EMPTY(list))                     \
+            {                                                 \
+                ((ListEntry_t *)(entry))->pPrev->pNext =      \
+                    (ListEntry_t *)(entry);                   \
+            }                                                 \
+            else                                              \
+            {                                                 \
+                (list)->pHead = (ListEntry_t *)(entry);       \
+            }                                                 \
+            (list)->pTail = (ListEntry_t *)(entry);           \
+            (list)->numElements++
+#define COMMON_LIST_REM_HEAD(list)                            \
+            (list)->pHead;                                    \
+            if (!COMMON_LIST_EMPTY(list))                     \
+            {                                                 \
+                if ((list)->pHead == (list)->pTail)           \
+                {                                             \
+                    (list)->pHead = SYS_NULL;                 \
+                    (list)->pTail = SYS_NULL;                 \
+                }                                             \
+                else                                          \
+                {                                             \
+                    (list)->pHead = (list)->pHead->pNext;     \
+                    (list)->pHead->pPrev = SYS_NULL;          \
+                }                                             \
+                (list)->numElements--;                        \
+            }
+#define COMMON_LIST_REM_TAIL(list)                            \
+            (list)->pTail;                                    \
+            if (!COMMON_LIST_EMPTY(list))                     \
+            {                                                 \
+                if ((list)->pHead == (list)->pTail)           \
+                {                                             \
+                    (list)->pHead = SYS_NULL;                 \
+                    (list)->pTail = SYS_NULL;                 \
+                }                                             \
+                else                                          \
+                {                                             \
+                    (list)->pTail = (list)->pTail->pPrev;     \
+                    (list)->pTail->pNext = SYS_NULL;          \
+                }                                             \
+                (list)->numElements--;                        \
+            }
+#define COMMON_LIST_MOVE_TO_HEAD(list,entry)                  \
+            if (!COMMON_LIST_EMPTY(list) &&                   \
+                ((ListEntry_t*)(entry) != (list)->pHead))     \
+            {                                                 \
+                ListEntry_t *pCurr = (ListEntry_t *)(entry);  \
+                ListEntry_t *pNext = pCurr->pNext;            \
+                ListEntry_t *pPrev = pCurr->pPrev;            \
+                /* Remove Node */                             \
+                if (pNext) {                                  \
+                    pNext->pPrev = pPrev;                     \
+                } else {                                      \
+                    (list)->pTail = pPrev;                    \
+                }                                             \
+                pPrev->pNext = pNext;                         \
+                /* Add to Head */                             \
+                pNext = (list)->pHead;                        \
+                pCurr->pNext = pNext;                         \
+                pNext->pPrev = pCurr;                         \
+                (list)->pHead = pCurr;                        \
+            }
+#define COMMON_LIST_REM_NODE(list,entry)                      \
+            if (!COMMON_LIST_EMPTY(list))                     \
+            {                                                 \
+                ListEntry_t *pCurr = (ListEntry_t*)entry;     \
+                if ((list)->pHead == (list)->pTail)           \
+                {                                             \
+                    (list)->pHead = SYS_NULL;                 \
+                    (list)->pTail = SYS_NULL;                 \
+                }                                             \
+                else if ((list)->pHead == pCurr)              \
+                {                                             \
+                    (list)->pHead = (list)->pHead->pNext;     \
+                    (list)->pHead->pPrev = SYS_NULL;          \
+                }                                             \
+                else if ((list)->pTail == pCurr)              \
+                {                                             \
+                    (list)->pTail = (list)->pTail->pPrev;     \
+                    (list)->pTail->pNext = SYS_NULL;          \
+                }                                             \
+                else                                          \
+                {                                             \
+                    ListEntry_t *tPrev,*tNext;                \
+                    tPrev = pCurr->pPrev;                     \
+                    tNext = pCurr->pNext;                     \
+                    tNext->pPrev = pCurr->pPrev;              \
+                    tPrev->pNext = pCurr->pNext;              \
+                }                                             \
+                (list)->numElements--;                        \
+            }
+
+/* end *************** original common.h defines ************************/
+
+/******************* ClnkEth_Vlan.h definitions *************************/
+// used in hw_z2_pci.c
+#define CLNK_ETH_GET_DST_MAC_HI(buf)                                  \
+            ((((Clnk_ETH_EthHdr_t *)(buf))->dstMacAddr[0] << 24) |    \
+             (((Clnk_ETH_EthHdr_t *)(buf))->dstMacAddr[1] << 16) |    \
+             (((Clnk_ETH_EthHdr_t *)(buf))->dstMacAddr[2] << 8)  |    \
+             (((Clnk_ETH_EthHdr_t *)(buf))->dstMacAddr[3]))
+
+#define CLNK_ETH_GET_DST_MAC_LO(buf)                                  \
+            ((((Clnk_ETH_EthHdr_t *)(buf))->dstMacAddr[4] << 24) |    \
+             (((Clnk_ETH_EthHdr_t *)(buf))->dstMacAddr[5] << 16))
+
+#define CLNK_ETH_GET_SRC_MAC_HI(buf)                                  \
+            ((((Clnk_ETH_EthHdr_t *)(buf))->srcMacAddr[0] << 24) |    \
+             (((Clnk_ETH_EthHdr_t *)(buf))->srcMacAddr[1] << 16) |    \
+             (((Clnk_ETH_EthHdr_t *)(buf))->srcMacAddr[2] << 8)  |    \
+             (((Clnk_ETH_EthHdr_t *)(buf))->srcMacAddr[3]))
+
+#define CLNK_ETH_GET_SRC_MAC_LO(buf)                                  \
+            ((((Clnk_ETH_EthHdr_t *)(buf))->srcMacAddr[4] << 24) |    \
+             (((Clnk_ETH_EthHdr_t *)(buf))->srcMacAddr[5] << 16))
+
+#define CLNK_ETH_GET_VLAN_PRIORITY_FROM_BUF(buf)                      \
+            ((((Clnk_ETH_EthHdr_t *)(buf))->lenType[0] == 0x81) ?     \
+             (((Clnk_ETH_EthHdr_t *)(buf))->tagCtrlInfo[0] >> 5) : 0)
+
+#define IS_CLNK_ETH_PKT_TAGGED(buf)                                   \
+	    ((((Clnk_ETH_EthHdr_t *)(buf))->lenType[0] == 0x81)  &&   \
+             (((Clnk_ETH_EthHdr_t *)(buf))->lenType[1] == 0x00)  ?    \
+              SYS_TRUE : SYS_FALSE)
+
+/// Ethernet Header
+typedef struct
+{
+    SYS_UINT8  dstMacAddr[6];
+    SYS_UINT8  srcMacAddr[6];
+    SYS_UINT8  lenType[2];
+    SYS_UINT8  tagCtrlInfo[2];
+}
+Clnk_ETH_EthHdr_t;
+/* end ********* ClnkEth_Vlan.h definitions *****************/
+
+/************ clnkdvrapi.h definitions **********************/
+// driver/API structure definitions
+#define DRV_CLNK_CTL             55
+typedef struct
+{
+    SYS_UINT32 cmd;
+    void*      param1;
+    void*      param2;
+    void*      param3;
+}
+IfrDataStruct;
+
+struct clnk_soc_opt
+{
+    /* copied from conf file */
+    SYS_UINT32      CMRatio;
+    SYS_UINT32      DistanceMode;
+    SYS_UINT32      TxPower;
+    SYS_UINT32      phyMargin;
+    SYS_UINT32      phyMBitMask;
+    SYS_UINT32      SwConfig;
+#if (defined(L3_DONGLE_HIRF) || defined(L3_DONGLE_MIDHIRF))
+    SYS_UINT32	    Diplexer;
+#endif        
+    SYS_UINT32      channelPlan;
+    SYS_UINT32      scanMask;
+    SYS_UINT32      productMask;
+    SYS_UINT32      tabooMask;
+    SYS_UINT32      tabooOffset;
+    SYS_UINT32      channelMask;
+    SYS_UINT32      lof;
+    SYS_UINT32      beaconMask;
+    SYS_UINT32      TLCycles;		// Only 8 lsbs used
+    SYS_UINT32      bias;
+    SYS_UINT32      PowerCtlPhyRate;
+    SYS_UINT32      BeaconPwrLevel;
+    SYS_UINT32      MiiPausePriLvl;
+    SYS_UINT32      PQoSClassifyMode;  /* PQoS Classification Mode */
+
+#if FEATURE_FEIC_PWR_CAL
+    SYS_UINT32      feicProfileId;
+#endif
+
+#if FEATURE_PUPQ_NMS_CONF
+    SYS_UINT32      mfrVendorId;        /* we only use 16 lsbs */
+    SYS_UINT32      mfrHwVer;
+    SYS_UINT32      mfrSwVer;
+    SYS_UINT32      personality;
+#endif /* FEATURE_PUPQ_NMS_CONF */
+
+    SYS_UINT32      dbgMask;
+    SYS_UINT32      master_mode;
+    SYS_UINT32      defaultSeqNum;             // Used for MoCA RESET
+#if FEATURE_IQM
+    SYS_UINT32      iqmDebugMask1;
+    SYS_UINT32      iqmDebugMask2;
+    SYS_UINT32      iqmDebugMask3;
+#endif
+
+    /* derived from conf file */
+    SYS_UINT32      pmki_lo;
+    SYS_UINT32      pmki_hi;
+    SYS_UINT32      mmk_lo;
+    SYS_UINT32      mmk_hi;
+};
+
+/* end *********** clnkdvrapi.h definitions **********************/
+
+/*************** ClnkCtl.h definitions **********************/
+
+// ClnkEth.c dependecies below
+#define MIN_VAL(x, y) (((x) > (y)) ? (y) : (x))
+
+// eth.c dependecies below
+struct clnk_io
+{
+    SYS_UINT32      *in;
+    SYS_UINT32      in_len;
+    SYS_UINT32      *out;
+    SYS_UINT32      out_len;
+};
+typedef enum
+{
+    DATA_BUF_MY_NODE_INFO_CMD_TYPE      = 0,
+    DATA_BUF_NETWORK_NODE_INFO_CMD_TYPE = 1,
+    DATA_BUF_NODE_PHY_DATA_CMD_TYPE     = 2,
+    DATA_BUF_TEST_PORT_CMD_TYPE         = 3,
+    DATA_BUF_RFIC_TUNING_DATA_CMD_TYPE  = 4,
+    DATA_BUF_RX_ERR_DATA_CMD_TYPE       = 5,
+    DATA_BUF_PRIV_INFO                  = 6,
+    DATA_BUF_PRIV_STATS                 = 7,
+    DATA_BUF_PRIV_NODE_INFO             = 8,
+    DATA_BUF_DUMP_CAM                   = 9,
+    DATA_BUF_GET_MIXED_MODE_ACTIVE      = 10, // obsolete
+    DATA_BUF_SET_MIXED_MODE_ACTIVE      = 11, // obsolete
+    DATA_BUF_GET_PEER_RATES             = 12,
+    DATA_BUF_GET_DYN_PARAMS             = 13,
+    DATA_BUF_SET_DYN_PARAMS             = 14,
+    DATA_BUF_GET_AGGR_STATS             = 15,
+    DATA_BUF_SEND_GCAP                  = 16,
+    DATA_BUF_obsolete                   = 17, 
+    DATA_BUF_GET_EPHY_STATS             = 18,
+
+#if FEATURE_QOS
+    DATA_BUF_CREATE_FLOW                = 19,
+    DATA_BUF_UPDATE_FLOW                = 20,
+    DATA_BUF_DELETE_FLOW                = 21,
+    DATA_BUF_QUERY_INGRESS_FLOW         = 22,
+    DATA_BUF_LIST_INGRESS_FLOWS         = 23,
+    DATA_BUF_QUERY_NODES                = 24,
+    DATA_BUF_QUERY_INTERFACE_CAPS       = 26,
+    DATA_BUF_GET_EVENT_COUNTS           = 27,
+#endif
+
+#if FEATURE_ECLAIR
+    DATA_BUF_ECLAIR_GET_HINFO          ,
+    DATA_BUF_ECLAIR_SET_TWEAKABLE      ,
+    DATA_BUF_ECLAIR_RESET_TEST_CONTEXT ,
+
+#if NEVER_USE_AGAIN_ECLAIR_LEGACY_TESTING
+    DATA_BUF_ECLAIR_PUSH_COMMAND       ,
+    DATA_BUF_ECLAIR_GET_COMMAND        ,
+    DATA_BUF_ECLAIR_SET_RECEIPT        ,
+    DATA_BUF_ECLAIR_PULL_RECEIPT       ,
+#endif /* NEVER_USE_AGAIN_ECLAIR_LEGACY_TESTING */
+
+
+#if FEATURE_ECLAIR_WHITE_BOX_TEST
+    DATA_BUF_ECLAIR_MORPH_CFG          ,
+    DATA_BUF_ECLAIR_MORPH_EXEC         ,
+    DATA_BUF_ECLAIR_MULTINODE_QUERY    ,
+    DATA_BUF_ECLAIR_MULTINODE_COMMIT   ,
+#endif
+
+#if ECFG_FLAVOR_VALIDATION==1
+    DATA_BUF_VAL_GET_MBOX_HOST_COUNTS  , 
+    DATA_BUF_VAL_GET_MBOX_CCPU_COUNTS  , 
+    DATA_BUF_VAL_TRIGGER_MBOX_EVENT    ,   
+#endif
+
+#endif
+
+    MAX_DATA_BUF_TYPE // This must always be last
+} DATA_BUF_CMD_TYPE;
+
+#define CLNK_CTL_VERSION                    0x01
+
+#define CLNK_CTL_MAX_IN_LEN                 0x4000
+#define CLNK_CTL_MAX_OUT_LEN                0x4000
+
+#define CLNK_CTL_SOC_CMD                    0x00000000
+#define CLNK_CTL_ETH_CMD                    0x00000100
+#define CLNK_CTL_DRV_CMD                    0x00000200
+
+#define CLNK_CMD_DST_MASK                   0x00000f00
+
+#define CLNK_CMD_BYTE_MASK                 (0x000000ff)
+
+#define CLNK_CTL_FOR_DRV(x) ((((x) & CLNK_CMD_DST_MASK) == CLNK_CTL_DRV_CMD) ? 1 : 0)
+#define CLNK_CTL_FOR_SOC(x) ((((x) & CLNK_CMD_DST_MASK) == CLNK_CTL_SOC_CMD) ? 1 : 0)
+#define CLNK_CTL_FOR_ETH(x) ((((x) & CLNK_CMD_DST_MASK) == CLNK_CTL_ETH_CMD) ? 1 : 0)
+
+#define CLNK_CTL_GET_MY_NODE_INFO           (CLNK_CTL_SOC_CMD | DATA_BUF_MY_NODE_INFO_CMD_TYPE)
+#define CLNK_CTL_GET_NET_NODE_INFO          (CLNK_CTL_SOC_CMD | DATA_BUF_NETWORK_NODE_INFO_CMD_TYPE)
+#define CLNK_CTL_GET_PHY_DATA               (CLNK_CTL_SOC_CMD | DATA_BUF_NODE_PHY_DATA_CMD_TYPE)
+#define CLNK_CTL_GET_RFIC_TUNING_DATA       (CLNK_CTL_SOC_CMD | DATA_BUF_RFIC_TUNING_DATA_CMD_TYPE)
+#define CLNK_CTL_GET_RX_ERR_DATA            (CLNK_CTL_SOC_CMD | DATA_BUF_RX_ERR_DATA_CMD_TYPE)
+#define CLNK_CTL_GET_PRIV_INFO              (CLNK_CTL_SOC_CMD | DATA_BUF_PRIV_INFO)
+#define CLNK_CTL_GET_PRIV_STATS             (CLNK_CTL_SOC_CMD | DATA_BUF_PRIV_STATS)
+#define CLNK_CTL_GET_PRIV_NODE_INFO         (CLNK_CTL_SOC_CMD | DATA_BUF_PRIV_NODE_INFO)
+#define CLNK_CTL_GET_CAM                    (CLNK_CTL_SOC_CMD | DATA_BUF_DUMP_CAM)
+#define CLNK_CTL_GET_PEER_RATES             (CLNK_CTL_SOC_CMD | DATA_BUF_GET_PEER_RATES)
+#define CLNK_CTL_GET_DYN_PARAMS             (CLNK_CTL_SOC_CMD | DATA_BUF_GET_DYN_PARAMS)
+#define CLNK_CTL_SET_DYN_PARAMS             (CLNK_CTL_SOC_CMD | DATA_BUF_SET_DYN_PARAMS)
+#define CLNK_CTL_GET_MIXED_MODE_ACTIVE      (CLNK_CTL_SOC_CMD | DATA_BUF_GET_MIXED_MODE_ACTIVE)
+#define CLNK_CTL_SET_MIXED_MODE_ACTIVE      (CLNK_CTL_SOC_CMD | DATA_BUF_SET_MIXED_MODE_ACTIVE)
+#define CLNK_CTL_GET_AGGR_STATS             (CLNK_CTL_SOC_CMD | DATA_BUF_GET_AGGR_STATS)
+#define CLNK_CTL_SEND_GCAP                  (CLNK_CTL_SOC_CMD | DATA_BUF_SEND_GCAP)
+#define CLNK_CTL_GET_EPHY_STATS             (CLNK_CTL_SOC_CMD | DATA_BUF_GET_EPHY_STATS)
+
+
+#if FEATURE_QOS
+#define CLNK_CTL_CREATE_FLOW                (CLNK_CTL_SOC_CMD | DATA_BUF_CREATE_FLOW)
+#define CLNK_CTL_UPDATE_FLOW                (CLNK_CTL_SOC_CMD | DATA_BUF_UPDATE_FLOW)
+#define CLNK_CTL_DELETE_FLOW                (CLNK_CTL_SOC_CMD | DATA_BUF_DELETE_FLOW)
+#define CLNK_CTL_QUERY_INGRESS_FLOW         (CLNK_CTL_SOC_CMD | DATA_BUF_QUERY_INGRESS_FLOW)
+#define CLNK_CTL_LIST_INGRESS_FLOWS         (CLNK_CTL_SOC_CMD | DATA_BUF_LIST_INGRESS_FLOWS)
+#define CLNK_CTL_QUERY_NODES                (CLNK_CTL_SOC_CMD | DATA_BUF_QUERY_NODES)
+#define CLNK_CTL_QUERY_INTERFACE_CAPS       (CLNK_CTL_SOC_CMD | DATA_BUF_QUERY_INTERFACE_CAPS)
+#define CLNK_CTL_GET_EVENT_COUNTS           (CLNK_CTL_SOC_CMD | DATA_BUF_GET_EVENT_COUNTS)
+#endif /* FEATURE_QOS */
+
+#if FEATURE_ECLAIR
+#define CLNK_CTL_ECLAIR_GET_HINFO           (CLNK_CTL_SOC_CMD | DATA_BUF_ECLAIR_GET_HINFO)
+#define CLNK_CTL_ECLAIR_SET_TWEAKABLE       (CLNK_CTL_SOC_CMD | DATA_BUF_ECLAIR_SET_TWEAKABLE)
+#define CLNK_CTL_ECLAIR_RESET_TEST_CONTEXT  (CLNK_CTL_SOC_CMD | DATA_BUF_ECLAIR_RESET_TEST_CONTEXT)
+
+#if NEVER_USE_AGAIN_ECLAIR_LEGACY_TESTING
+#define CLNK_CTL_ECLAIR_PUSH_COMMAND        (CLNK_CTL_SOC_CMD | DATA_BUF_ECLAIR_PUSH_COMMAND  | CLNK_CTL_ASYNC_CMD)
+#define CLNK_CTL_ECLAIR_GET_COMMAND         (CLNK_CTL_SOC_CMD | DATA_BUF_ECLAIR_GET_COMMAND)
+#define CLNK_CTL_ECLAIR_SET_RECEIPT         (CLNK_CTL_SOC_CMD | DATA_BUF_ECLAIR_SET_RECEIPT)
+#define CLNK_CTL_ECLAIR_PULL_RECEIPT        (CLNK_CTL_SOC_CMD | DATA_BUF_ECLAIR_PULL_RECEIPT  | CLNK_CTL_ASYNC_CMD)
+#endif /* NEVER_USE_AGAIN_ECLAIR_LEGACY_TESTING */
+
+#endif /* FEATURE_ECLAIR */
+
+#if ECFG_FLAVOR_VALIDATION==1
+#define CLNK_CTL_VAL_GET_MBOX_CCPU_COUNTS   (CLNK_CTL_SOC_CMD | DATA_BUF_VAL_GET_MBOX_CCPU_COUNTS)
+#define CLNK_CTL_VAL_TRIGGER_MBOX_EVENT     (CLNK_CTL_SOC_CMD | DATA_BUF_VAL_TRIGGER_MBOX_EVENT)
+#endif
+
+#if FEATURE_IQM
+#define CLNK_CTL_GET_IQM_DATA               (CLNK_CTL_SOC_CMD | DATA_BUF_GET_IQM_DATA)
+#endif
+
+#define CLNK_CTL_GET_ZIP_INFO               (CLNK_CTL_ETH_CMD | 0x00)
+#define CLNK_CTL_GET_SOC_OPT                (CLNK_CTL_ETH_CMD | 0x01)
+#define CLNK_CTL_SET_SOC_OPT                (CLNK_CTL_ETH_CMD | 0x02)
+#define CLNK_CTL_GET_MEM                    (CLNK_CTL_ETH_CMD | 0x03)
+#define CLNK_CTL_SET_MEM                    (CLNK_CTL_ETH_CMD | 0x04)
+#define CLNK_CTL_GET_TRACEBUF               (CLNK_CTL_ETH_CMD | 0x05)
+#define CLNK_CTL_GET_ETH_STATS              (CLNK_CTL_ETH_CMD | 0x06)
+#define CLNK_CTL_GET_BRIDGE_TABLE           (CLNK_CTL_ETH_CMD | 0x07)
+#define CLNK_CTL_SET_ETH_FIFO_SIZE          (CLNK_CTL_ETH_CMD | 0x08)
+#define CLNK_CTL_GET_EVM_DATA               (CLNK_CTL_ETH_CMD | 0x09)
+#define CLNK_CTL_GET_EPP_DATA               (CLNK_CTL_ETH_CMD | 0x0a)
+#define CLNK_CTL_SET_EPP_DATA               (CLNK_CTL_ETH_CMD | 0x0b) // OBSOLETE
+#if FEATURE_FEIC_PWR_CAL
+#define CLNK_CTL_GET_FEIC_STATUS            (CLNK_CTL_ETH_CMD | 0x0e)
+#endif
+#define CLNK_CTL_SET_DBG_MASK_DYN           (CLNK_CTL_ETH_CMD | 0x21)
+#if 1 // added for MID RF (DEBUG_EPP)
+#define CLNK_CTL_GET_EPP_CAP_CFG            (CLNK_CTL_ETH_CMD | 0x22)
+#define CLNK_CTL_SET_EPP_CAP_CFG            (CLNK_CTL_ETH_CMD | 0x23)
+#endif
+#if ECFG_FLAVOR_VALIDATION==1
+#define CLNK_CTL_VAL_GET_MBOX_HOST_COUNTS   (CLNK_CTL_ETH_CMD | 0x28)
+#endif
+#if FEATURE_IQM
+#define CLNK_CTL_SET_DBG_MASK_IQM           (CLNK_CTL_ETH_CMD | 0x29)
+#endif
+
+#define CLNK_CTL_RESET_DEVICE               (CLNK_CTL_DRV_CMD | 0x00)
+#define CLNK_CTL_STOP_DEVICE                (CLNK_CTL_DRV_CMD | 0x01)
+#define CLNK_CTL_NET_CARRIER_ON             (CLNK_CTL_DRV_CMD | 0x02) 
+#define CLNK_CTL_NET_CARRIER_OFF            (CLNK_CTL_DRV_CMD | 0x03) 
+#define CLNK_CTL_NET_CARRIER_OK             (CLNK_CTL_DRV_CMD | 0x04) 
+#define CLNK_CTL_SOC_INIT_BUS               (CLNK_CTL_DRV_CMD | 0x05) 
+#define CLNK_CTL_SOC_BOOTED                 (CLNK_CTL_DRV_CMD | 0x06) 
+#define CLNK_CTL_HW_DESC_INIT               (CLNK_CTL_DRV_CMD | 0x07) 
+#define CLNK_CTL_TC_DIC_INIT                (CLNK_CTL_DRV_CMD | 0x08) 
+#define CLNK_CTL_GET_SOC_STATUS             (CLNK_CTL_DRV_CMD | 0x09) 
+#define CLNK_CTL_GET_LINK_STATUS            (CLNK_CTL_DRV_CMD | 0x0a) 
+#define CLNK_CTL_SET_MAC_ADDRESS            (CLNK_CTL_DRV_CMD | 0x0b) 
+#define CLNK_CTL_GET_NMS_LOCAL_MSG          (CLNK_CTL_DRV_CMD | 0x0c) /* NMS */
+#define CLNK_CTL_SET_DATA_PLANE_VARS        (CLNK_CTL_DRV_CMD | 0x0d) /* PQoS */
+#define CLNK_CTL_SOC_WAKEUP                 (CLNK_CTL_DRV_CMD | 0x0e) 
+
+/* end *************** ClnkCtl.h definitions **********************/
+
+// Driver Return Codes
+typedef enum
+{
+    CLNK_ETH_RET_CODE_SUCCESS            = 0,
+    CLNK_ETH_RET_CODE_GEN_ERR            = 1,
+    CLNK_ETH_RET_CODE_MEM_ALLOC_ERR      = 2,
+    CLNK_ETH_RET_CODE_RESET_ERR          = 3,
+    CLNK_ETH_RET_CODE_NOT_OPEN_ERR       = 4,
+    CLNK_ETH_RET_CODE_LINK_DOWN_ERR      = 5,
+    CLNK_ETH_RET_CODE_NO_HOST_DESC_ERR   = 6,
+    CLNK_ETH_RET_CODE_UCAST_FLOOD_ERR    = 7,
+    CLNK_ETH_NO_KEY_ERROR                = 8,
+    CLNK_ETH_MRT_TRANSACTION_IN_PROGRESS = 9,
+    CLNK_ETH_RET_CODE_PKT_LEN_ERR        = 10,
+
+    CLNK_ETH_RET_CODE_MAX  // This must always be last
+}
+CLNK_ETH_RET_CODES;
+
+
+
+
+#endif /* __common_dvr_h__ */
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/Common_proto.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/Common_proto.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/Common_proto.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/Common_proto.h	2012-09-14 14:51:36.853989000 +0530
@@ -0,0 +1,63 @@
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/ClnkIo.c ***/
+unsigned long clnkioc_driver_cmd( void *dkcp, void *arg );
+//unsigned long clnkioc_mbox_cmd_request( void *dkcp, void *arg, int response );
+//unsigned long clnkioc_mbox_unsolq_retrieve( void *dkcp, void *arg );
+unsigned long clnkioc_mem_read( void *dkcp, void *arg );
+unsigned long clnkioc_mem_write( void *dkcp, void *arg );
+unsigned long clnkioc_moca_shell_cmd( void *dkcp, void *arg );
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/ClnkIo_common.c ***/
+int clnk_cmd_msg_send_recv( dc_context_t *dccp,    // control context
+                            SYS_UINT32 rq_cmd,     // request command
+                            SYS_UINT32 rq_scmd,    // subcommand
+                            struct clnk_io *iob );
+void clnk_blk_read( dc_context_t *dccp, 
+                    SYS_UINT32 sourceClinkAddr, 
+                    SYS_UINT32 *destHostAddr, 
+                    SYS_UINT32 length);
+void clnk_blk_write(dc_context_t  *dccp, 
+                    SYS_UINT32 destClnkAddr, 
+                    SYS_UINT32 *sourceHostAddr, 
+                    SYS_UINT32 length);
+int clnk_cmd_msg_send( dc_context_t *dccp,    // control context
+                       SYS_UINT32 rq_cmd,     // request command
+                       SYS_UINT32 rq_scmd,    // subcommand
+                       struct clnk_io *iob );
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/ClnkMbx_call.c ***/
+int MbxSwUnsolRdyCallback(void *vcp, Clnk_MBX_Msg_t *pMsg);
+void MbxReplyRdyCallback(void *vcp, Clnk_MBX_Msg_t* pMsg);
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/ClnkMbx_dvr.c ***/
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/ClnkMbx_ttask.c ***/
+SYS_VOID clnketh_tt_timer(SYS_ULONG data);
+SYS_VOID clnketh_tt_cmtask(SYS_ULONG data);
+SYS_VOID clnketh_tt_umtask(SYS_ULONG data);
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/util_dvr.c ***/
+void clnk_reg_read(void *vcp, SYS_UINT32 addr, SYS_UINT32 *val);
+void clnk_reg_write(void *vcp, SYS_UINT32 addr, SYS_UINT32 val);
+void clnk_reg_write_nl(void *vcp, SYS_UINT32 addr, SYS_UINT32 val);
+void clnk_reg_read_nl(void *vcp, SYS_UINT32 addr, SYS_UINT32 *val);
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Src/ctx_setup.c ***/
+int Clnk_init_dev(void **ddcp_dgcp, void *ddcp, void *dkcp, unsigned long dev_base );
+void Clnk_exit_dev( void *vdgcp );
+void *ctx_alloc_dc_context( void );
+void ctx_free_dc_context( void *dccp );
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/control_context.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/control_context.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/control_context.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/control_context.h	2012-09-14 14:51:36.856990000 +0530
@@ -0,0 +1,52 @@
+/*******************************************************************************
+*
+* Common/Inc/control_context.h
+*
+* Description: control context selector
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+#ifndef __control_context_h__
+#define __control_context_h__
+
+#if defined(PCI_DRVR_SUPPORT)
+#include "control_context_pci.h"
+#endif
+#if defined(E1000_DRVR_SUPPORT) 
+#include "control_context_e1000.h"
+#endif
+#if defined(CANDD_DRVR_SUPPORT) 
+#include "control_context_candd.h"
+#endif
+#if defined(APOLLO_DRVR_SUPPORT)
+#include "control_context_apollo.h"
+#endif
+
+#endif // __control_context_h__
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/debug.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/debug.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/debug.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/debug.h	2012-09-14 14:51:36.859994000 +0530
@@ -0,0 +1,51 @@
+/*******************************************************************************
+*
+* Common/Inc/debug.h
+*
+* Description: debug macros and such
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __debug_h__
+#define __debug_h__
+
+
+
+#ifdef IOCTL_DEBUG
+static void _ioctl_dbg(dk_context_t *dkcp, char *str)
+{
+    HostOS_PrintLog(L_ERR, "%s: %s failed!\n", dkcp->name, str);
+}
+#else
+//static inline void _ioctl_dbg(char *name, char *str) { }
+#define _ioctl_dbg(NAME,STR)   do { } while (0)
+#endif
+
+
+#endif // __debug_h__
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/driverversion.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/driverversion.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/driverversion.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/driverversion.h	2012-09-14 14:51:36.862992000 +0530
@@ -0,0 +1 @@
+#define DRV_VERSION "0.90.17.73"
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/drv_ctl_opts.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/drv_ctl_opts.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/drv_ctl_opts.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/drv_ctl_opts.h	2012-09-14 14:51:36.865986000 +0530
@@ -0,0 +1,173 @@
+/*******************************************************************************
+*
+* Common/Inc/drv_ctl_opts.h
+*
+* Description: driver (io)control options
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+#ifndef __drv_ctl_opts_h__
+#define __drv_ctl_opts_h__
+
+#include "common_dvr.h"
+
+#ifndef FEATURE_QOS
+#define FEATURE_QOS     0
+#endif
+
+
+
+
+// Driver Control Options
+typedef enum
+{
+    CLNK_ETH_CTRL_GET_REG,
+    CLNK_ETH_CTRL_SET_REG,
+    CLNK_ETH_CTRL_GET_MEM,
+    CLNK_ETH_CTRL_SET_MEM,
+    CLNK_ETH_CTRL_GET_TRACE,
+    CLNK_ETH_CTRL_GET_BRIDGE_SRC_TABLE, // COMBINE THESE 4 !!!!
+    CLNK_ETH_CTRL_GET_BRIDGE_DST_TABLE,
+    CLNK_ETH_CTRL_GET_BRIDGE_BCAST_TABLE,
+    CLNK_ETH_CTRL_GET_BRIDGE_MCAST_TABLE,
+    CLNK_ETH_CTRL_GET_EPP_DATA,
+    CLNK_ETH_CTRL_GET_EVM_DATA,
+    CLNK_ETH_CTRL_GET_MY_NODE_INFO,
+    CLNK_ETH_CTRL_GET_NET_NODE_INFO,
+    CLNK_ETH_CTRL_GET_PHY_DATA,
+    CLNK_ETH_CTRL_GET_RX_ERR_DATA,
+    CLNK_ETH_CTRL_GET_TX_FIFO_SIZE,
+    CLNK_ETH_CTRL_GET_RX_FIFO_SIZE,
+    CLNK_ETH_CTRL_GET_LINK_STATUS,
+    CLNK_ETH_CTRL_GET_MAC_ADDR,
+    CLNK_ETH_CTRL_GET_MULTICAST_TABLE,
+    CLNK_ETH_CTRL_GET_NUM_TX_HOST_DESC,
+    CLNK_ETH_CTRL_GET_SOC_STATUS,  /* OBSOLETE/DO_NOT_REUSE */  
+    CLNK_ETH_CTRL_GET_STATS,
+    CLNK_ETH_CTRL_GET_SW_REV_NUM,
+    CLNK_ETH_CTRL_SET_CM_RATIO,
+    CLNK_ETH_CTRL_SET_EPP_DATA,    /* OBSOLETE/DO_NOT_REUSE */
+    CLNK_ETH_CTRL_SET_TX_FIFO_SIZE,
+    CLNK_ETH_CTRL_SET_RX_FIFO_SIZE,
+    CLNK_ETH_CTRL_SET_FIRMWARE,
+    CLNK_ETH_CTRL_SET_MAC_ADDR,
+    CLNK_ETH_CTRL_SET_PHY_MARGIN,
+    CLNK_ETH_CTRL_SET_PRIVACY_MODE, /* OBSOLETE/DO_NOT_REUSE */
+    CLNK_ETH_CTRL_SHA_PRIVACY_KEY,
+    CLNK_ETH_CTRL_SET_PRIVACY_KEY,
+    CLNK_ETH_CTRL_SET_SW_CONFIG,
+    CLNK_ETH_CTRL_SET_TX_POWER,
+    CLNK_ETH_CTRL_TEST_PORT,
+    CLNK_ETH_CTRL_RESET,
+    CLNK_ETH_CTRL_ENABLE_INTERRUPT,
+    CLNK_ETH_CTRL_DISABLE_INTERRUPT,
+    CLNK_ETH_CTRL_RD_CLR_INTERRUPT,
+    CLNK_ETH_CTRL_DETACH_SEND_PACKET,
+    CLNK_ETH_CTRL_DETACH_RCV_PACKET,
+    CLNK_ETH_CTRL_JOIN_MULTICAST,
+    CLNK_ETH_CTRL_LEAVE_MULTICAST,
+    CLNK_ETH_CTRL_SET_SEND_CALLBACK,
+    CLNK_ETH_CTRL_SET_RCV_CALLBACK,
+    CLNK_ETH_CTRL_SET_UNSOL_CALLBACK,
+    CLNK_ETH_CTRL_GET_RFIC_TUNING_DATA,
+    CLNK_ETH_CTRL_SET_RFIC_TUNING_DATA, /* OBSOLETE/DO_NOT_REUSE */
+    CLNK_ETH_CTRL_SET_AGC_GAIN_TABLE,   /* OBSOLETE/DO_NOT_REUSE */
+    CLNK_ETH_CTRL_SET_CHANNEL_MASK,
+    CLNK_ETH_CTRL_GET_RANDOM_BITS,  /* OBSOLETE/DO_NOT_REUSE */
+   // CLNK_SOFTCAM
+    CLNK_ETH_CTRL_GET_SOFT_CAMDATA,
+
+    CLNK_ETH_CTRL_SET_LOF,
+    CLNK_ETH_CTRL_GET_LOF,
+    CLNK_ETH_CTRL_SET_BIAS,
+    CLNK_ETH_CTRL_FS_UPDATE,  /* OBSOLETE */
+    CLNK_ETH_CTRL_SET_CHANNEL_PLAN,
+    CLNK_ETH_CTRL_SET_TABOO_INFO,
+    CLNK_ETH_CTRL_SET_SCAN_MASK,
+
+    CLNK_ETH_CTRL_SET_DISTANCE_MODE,
+    CLNK_ETH_CTRL_SET_POWERCTL_PHYRATE,
+
+    CLNK_ETH_CTRL_CLINK_ACCEPT_SMALL_ROUTED_MESSAGE,
+    CLNK_ETH_CTRL_DEFINE_CLM_INIT_SETTINGS,
+
+    /* OBSOLETE/DO_NOT_REUSE */
+    CLNK_ETH_CTRL_PRIVACY_SEND,
+    CLNK_ETH_CTRL_PRIVACY_SET_KEY,
+    CLNK_ETH_CTRL_PRIVACY_UPDATE,
+
+    /* OBSOLETE/DO_NOT_REUSE */
+    CLNK_ETH_CTRL_GET_PRIVACY_EVENT,
+    CLNK_ETH_CTRL_GET_PRIVACY_STAT,
+    CLNK_ETH_CTRL_GET_PRIVACY_KEY,
+    CLNK_ETH_CTRL_GET_PRIVACY_DATA,
+    CLNK_ETH_CTRL_GET_PRIVACY_RANDBIT,
+
+    CLNK_ETH_CTRL_NODEMANAGE_ADD ,
+    CLNK_ETH_CTRL_NODEMANAGE_DELETE ,
+    CLNK_ETH_CTRL_NODEMANAGE_GET,
+
+    CLNK_ETH_CTRL_SET_TIMER_SPEED,
+
+    CLNK_ETH_CTRL_GET_PRIV_INFO,
+    CLNK_ETH_CTRL_GET_PRIV_STATS,
+    CLNK_ETH_CTRL_GET_PRIV_NODE_INFO,
+
+    CLNK_ETH_CTRL_DO_CLNK_CTL,
+    CLNK_ETH_CTRL_SET_BEACON_POWER_LEVEL, // added for DIP feature.
+
+#if FEATURE_QOS
+    CLNK_ETH_CTRL_CREATE_FLOW,
+    CLNK_ETH_CTRL_UPDATE_FLOW,
+    CLNK_ETH_CTRL_DELETE_FLOW,
+    CLNK_ETH_CTRL_QUERY_FLOW,
+    CLNK_ETH_CTRL_LIST_FLOWS,
+    CLNK_ETH_CTRL_GET_EVENT_COUNTS,
+    CLNK_ETH_CTRL_QUERY_IF_CAPS,
+    CLNK_ETH_CTRL_QUERY_NODES,
+    CLNK_ETH_CTRL_QUERY_PATH_INFO,
+    CLNK_ETH_CTRL_EXPIRE_FLOW,
+#if ECFG_CHIP_ZIP1
+    CLNK_ETH_CTRL_SET_TFIFO_RESIZE_CALLBACK,
+#endif /* ECFG_CHIP_ZIP1 */
+#endif
+
+    CLNK_ETH_CTRL_GET_PEER_RATES,
+    CLNK_ETH_CTRL_STOP,
+
+    CLNK_ETH_CTRL_MAX  // This must always be last
+}
+CLNK_ETH_CTRL_OPTIONS;
+
+
+
+
+
+#endif // __drv_ctl_opts_h__
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/drv_hdr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/drv_hdr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/drv_hdr.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/drv_hdr.h	2012-09-14 14:51:36.868981000 +0530
@@ -0,0 +1,62 @@
+/*******************************************************************************
+*
+* Common/Inc/drv_hdr.h
+*
+* Description: Generic driver compilation control
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*
+* This file simply includes the driver's main compilation control file.
+* That file will be named after the driver in some way.
+*
+* The reason for this is to allow both local and common .c and .h files 
+* to include a file specific to a single driver thus customizing the
+* compilation for the selected driver.
+*
+*******************************************************************************/
+
+#ifndef __drv_hdr_h__
+#define __drv_hdr_h__
+
+#if defined(PCI_DRVR_SUPPORT)
+#include "pci_hdr.h"
+#endif
+#if defined(E1000_DRVR_SUPPORT) 
+#include "mii_hdr.h"
+#endif
+#if defined(CANDD_DRVR_SUPPORT) 
+#include "candd_hdr.h"
+#endif
+#if defined(APOLLO_DRVR_SUPPORT)
+#include "apollo_hdr.h"
+#endif
+
+#endif // __drv_hdr_h__
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/entropic-config.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/entropic-config.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/entropic-config.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/entropic-config.h	2012-09-14 14:51:36.871982000 +0530
@@ -0,0 +1,69 @@
+#ifndef __entropic_config_h_
+#define __entropic_config_h_
+/*     ###########    W A R N I N G ! ! !    ##########     */
+/*     ##  Do not edit this file! it is generated!   ##     */
+/*     ###########    W A R N I N G ! ! !    ##########     */
+#define ECFG_CHIP_ZIP1    0
+#define ECFG_CHIP_ZIP2    0
+#define ECFG_CHIP_MAVERICKS    0
+#define ECFG_CHIP_SWAMIS    0
+#define ECFG_CHIP_JAWS    0
+#define ECFG_CHIP_BALBOA    1
+#define ECFG_CHIP_STRING     "ECFG_CHIP_BALBOA"
+
+#define ECFG_BOARD_ECB_PCI_ZIP2    0
+#define ECFG_BOARD_PC_PCI_ZIP2    0
+#define ECFG_BOARD_PC_PCI_ZIP1    0
+#define ECFG_BOARD_PC_DVT_MII_ZIP2    0
+#define ECFG_BOARD_PC_DVT_TMII_ZIP2    0
+#define ECFG_BOARD_PC_DVT_GMII_ZIP2    0
+#define ECFG_BOARD_PC_DVT2_PCI_ZIP2    0
+#define ECFG_BOARD_PC_PCIE_MAVERICKS    0
+#define ECFG_BOARD_PC_XMII_BALBOA    1
+#define ECFG_BOARD_COLDFIRE_DVT_FLEX_ZIP2    0
+#define ECFG_BOARD_ECB_ROW    0
+#define ECFG_BOARD_GPC    0
+#define ECFG_BOARD_ECB_3M_L3    0
+#define ECFG_BOARD_ECB_5M_L3    0
+#define ECFG_BOARD_ECB_6M_L3    0
+#define ECFG_BOARD_ECB_PCIE_MAVERICKS    0
+#define ECFG_BOARD_HOSTLESS    0
+#define ECFG_BOARD_STRING     "ECFG_BOARD_PC_XMII_BALBOA"
+
+#define ECFG_NETWORK_ACCESS    0
+#define ECFG_NETWORK_MIDRF_MESH    0
+#define ECFG_NETWORK_HIRF_MESH    1
+#define ECFG_NETWORK_STRING     "ECFG_NETWORK_HIRF_MESH"
+
+#define ECFG_NODE_CPE    0
+#define ECFG_NODE_HEADEND    0
+#define ECFG_NODE_TCPE    0
+#define ECFG_NODE_MOCA    1
+#define ECFG_NODE_STRING     "ECFG_NODE_MOCA"
+
+#define ECFG_OS_LINUX_TYPICAL    1
+#define ECFG_OS_NONE    0
+#define ECFG_OS_STRING     "ECFG_OS_LINUX_TYPICAL"
+
+#define ECFG_FLAVOR_PRODUCTION    1
+#define ECFG_FLAVOR_PRODUCTION_PROTEM    0
+#define ECFG_FLAVOR_PHYSVT    0
+#define ECFG_FLAVOR_VALIDATION    0
+#define ECFG_FLAVOR_STRING     "ECFG_FLAVOR_PRODUCTION"
+
+#define ECFG_DATAPATH_GMII    1
+#define ECFG_DATAPATH_RGMII    0
+#define ECFG_DATAPATH_TMII    0
+#define ECFG_DATAPATH_MII    0
+#define ECFG_DATAPATH_PCI    0
+#define ECFG_DATAPATH_PCIE    0
+#define ECFG_DATAPATH_FLEX    0
+#define ECFG_DATAPATH_STRING     "ECFG_DATAPATH_GMII"
+
+#define ECFG_MISC_REF_XTAL_25M_CLOCK    0
+#define ECFG_MISC_REF_SOC_25M_CLOCK    1
+#define ECFG_MISC_STRING     "ECFG_MISC_REF_SOC_25M_CLOCK"
+
+
+#endif
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/HostOS_proto.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/HostOS_proto.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/HostOS_proto.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/HostOS_proto.h	2012-09-14 14:51:36.875978000 +0530
@@ -0,0 +1,86 @@
+/* Do Not Edit! Contents produced by script.  Wed Jul 30 19:54:39 PDT 2008  */
+
+
+/*** public prototypes from Common/gpl_ctx_abs.c ***/
+void *dk_to_dd( void *dkcp );
+void *dd_to_dg( void *ddcp );
+void *dg_to_dc( void *dgcp );
+void *dg_to_dd( void *dgcp );
+void *dk_to_dc( void *dkcp );
+void *dd_to_dc( void *ddcp );
+void *dk_to_dg( void *dkcp );
+void *dc_to_dd( void *dccp );
+
+/*** public prototypes from Common/gpl_ctx_setup.c ***/
+void *ctx_alloc_dg_context( void );
+void ctx_free_dg_context( void *dgcp );
+void ctx_link_dg_context( void *vdgcp, void *ddcp, void *dccp );
+void Clnk_init_os_context( void *vdgcp );
+void ctx_linkage_lister( void *dkcp, unsigned int **vp, int len );
+
+/*** public prototypes from Common/hostos.c ***/
+void HostOS_Memset(void *pMem, int val, int size);
+void HostOS_Memcpy(void *pTo, void *pFrom, int size);
+void HostOS_Sscanf(const char *buf, const char *fmt, ...);
+void* HostOS_Alloc(int size);
+void HostOS_Free(void* pMem, int size);
+void HostOS_Sleep(int timeInUsec);
+void HostOS_lock_init( void *vlk);
+void HostOS_Lock(void *vlk);
+void HostOS_Lock_Irqsave(void *vlk);
+int HostOS_Lock_Try(void *vlk);
+void HostOS_Unlock(void *vlk);
+void HostOS_Unlock_Irqrestore(void *vlk);
+void HostOS_TermLock(void *vlk);
+void HostOS_PrintLog(SYS_INT32 lev, const char *fmt, ...);
+SYS_UINT32 HostOS_Read_Word( SYS_UINT32 *addr );
+void HostOS_Write_Word( SYS_UINT32 val, SYS_UINT32 *addr );
+void HostOS_timer_init( void *vtmr );
+int HostOS_timer_del( void *vtmr );
+int HostOS_timer_del_sync( void *vtmr );
+int HostOS_timer_mod( void *vtmr, SYS_ULONG timeout );
+void HostOS_timer_add( void *vtmr );
+void HostOS_timer_setup( void *vtmr, timer_function_t func, SYS_UINTPTR data );
+void HostOS_timer_set_timeout( void *vtmr, SYS_ULONG timeout );
+SYS_ULONG HostOS_timer_expire_seconds( SYS_UINT32 future );
+SYS_ULONG HostOS_timer_expire_ticks( SYS_UINT32 future );
+void *HostOS_wqt_alloc( void );
+void HostOS_wqt_free( void *vwqt );
+void HostOS_wqt_timer_init( void *vwqt );
+void HostOS_wqt_timer_del( void *vwqt );
+int HostOS_wqt_timer_del_sync( void *vwqt );
+int HostOS_wqt_timer_mod( void *vwqt, SYS_ULONG timeout );
+void HostOS_wqt_timer_add( void *vwqt );
+void HostOS_wqt_timer_setup( void *vwqt, timer_function_t func, SYS_UINTPTR data );
+void HostOS_wqt_timer_set_timeout( void *vwqt, SYS_ULONG timeout );
+void HostOS_wqt_waitq_init( void *vwqt );
+void HostOS_wqt_waitq_wakeup_intr( void *vwqt );
+void HostOS_wqt_waitq_wait_event_intr( void *vwqt, HostOS_wqt_condition func, void *vp );
+void HostOS_ReadPciConfig_Word(void* ddev, SYS_UINT32 reg, SYS_UINT16* pVal);
+void HostOS_ReadPciConfig(void* ddev, SYS_UINT32 reg, SYS_UINT32* pVal);
+void HostOS_WritePciConfig_Word(void *ddev, SYS_UINT32 reg, SYS_UINT16 val);
+void HostOS_WritePciConfig(void* ddev, SYS_UINT32 reg, SYS_UINT32 val);
+void *HostOS_AllocDmaMem(void *ddev, int size, void **ppMemPa);
+void HostOS_FreeDmaMem(void *ddev, int size, void *pMemVa, void *pMemPa);
+void HostOS_task_init( void *vtl, void *func, unsigned long data );
+void HostOS_task_schedule( void *vtl );
+void HostOS_task_enable( void *vtl );
+void HostOS_task_disable( void *vtl );
+void HostOS_task_kill( void *vtl );
+void HostOS_mutex_init( void *vmt );
+void HostOS_mutex_release( void *vmt );
+void HostOS_mutex_acquire( void *vmt );
+int HostOS_mutex_acquire_intr( void *vmt );
+unsigned long HostOS_copy_from_user( void *to, const void *from, unsigned long nbytes );
+unsigned long HostOS_copy_to_user( void *to, const void *from, unsigned long nbytes );
+unsigned long HostOS_netif_carrier_ok( void *kdev );
+void HostOS_netif_carrier_on( void *kdev );
+void HostOS_netif_carrier_off( void *kdev );
+void HostOS_set_mac_address( void *kdev, SYS_UINT32 mac_hi, SYS_UINT32 mac_lo );
+void HostOS_open( void *kdev );
+void HostOS_close( void *kdev );
+int HostOS_signal_pending(void *pTask);
+void HostOS_msleep_interruptible(unsigned int msecs);
+int HostOS_thread_start(unsigned int *pThreadID, char *thName, void (*func)(void *), void *arg);
+int HostOS_thread_stop(unsigned long threadID);
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/hw_z2_dvr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/hw_z2_dvr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/hw_z2_dvr.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/hw_z2_dvr.h	2012-09-14 14:51:36.878977000 +0530
@@ -0,0 +1,239 @@
+/*******************************************************************************
+*
+* Common/Inc/hw_z2_dvr.h
+*
+* Description: Header file for general Zip2 support (all datapaths)
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef _HW_Z2_H_
+#define _HW_Z2_H_
+
+#include "inctypes_dvr.h"
+#include "common_dvr.h"
+
+/* Fragment Gather Support:
+ *
+ * For stock Linux implementations, 1 FRAG is necessary and sufficient. 
+ * - Standard rule of thumb is driver must support IP chksum (NETIF_F_IP_CSUM)
+ *   before it makes sense to enable scatter/gather (NETIF_F_SG) in the
+ *   dev->features flag mask.  Linux always builds a single buffer WHEN it has
+ *   to do to its own IP Checksum (defeating NETIF_F_SG) !!
+ * - Due to various restrictions (see custom), general support of _SG would
+ *   require backstop code to coalesce when restrictions are violated.  See
+ *   drivers/net/typhoon.c for some good examples.
+ *
+ * For custom implementations, Gathered Fragments can be supported. Details ...
+ * - Limit of 4 Fragments exists with current CCPU/TC code
+ * -- See CLNK_HW_MAX_FRAGMENTS compile define below.
+ * -- Common driver also limited to 4. (See CLNK_ETH_MAX_FRAGMENTS. Modifiable)
+ * -- Has been well tested up to 4 Fragments.
+ * -- Configuring more than you need wastes some host driver space
+ * -- Configuring more than you need increases ptr_list DMA size
+ * - Restrictions below this point are not validated by code!
+ * -- Minimum Fragment must be at least 32 bytes
+ * -- External Fragment data can be on any byte host address boundary.
+ * -- Internal Fragment data has to start with 4 byte aligned.
+ * -- All fragments must be multiple of 4 in length, except final.
+ * - See SIMULATE_FRAGMENTS define in eth.c for example code.
+ * -- Includes tests which set successive frag sizes to 32, 64, 128 ...
+ */
+#define CLNK_HW_MAX_FRAGMENTS   1
+#if (CLNK_HW_MAX_FRAGMENTS > 4)
+#warning "Current 1.5 (SOC,TC) Xmit Support limited to 4 Fragments"
+#endif
+struct _frag_desc
+{
+    SYS_UINT32              ptr;
+    SYS_UINT32              len;
+};
+struct ptr_list
+{
+    SYS_UINT32              n_frags;
+    struct _frag_desc       fragments[CLNK_HW_MAX_FRAGMENTS];
+    SYS_UINT32              magic;
+};
+
+#define EHI_START       0x0c100000
+#define EHI_END         0x0c1003fc
+
+#define AT1_BASE        0x0c000000
+#define AT2_BASE        0x0c080000
+#define AT3_BASE        0x0c100400
+
+#define HOST_INTR       (1 << 1)        /* interrupt bit for tx/rx/mbx */
+#define TMR_INTR        (1 << 24)       /* interrupt bit for zip2 timer 0 */
+
+#if ! defined(CLNK_ETH_ENDIAN_SWAP)
+#define SET_HOST_DESC(desc, param, val)           \
+            (desc)->param = (val)
+#else
+#define SET_HOST_DESC(desc, param, val)           \
+            (desc)->param = HOST_OS_ENDIAN_SWAP(val)
+
+#endif /* ! defined(CLNK_ETH_ENDIAN_SWAP) */
+
+#define RX_STATUS_PTR(ctx, idx) ((ctx)->rx_linebuf + sizeof(struct linebuf) + ((idx) << 2))
+
+#define TX_STATUS_PTR(ctx, pri, idx) ((ctx)->tx_linebuf[pri] + sizeof(struct linebuf) + ((idx) << 2))
+
+
+/*
+ * CLNK_REG_*() and soc*Mem() take full Sonics addresses on Zip2,
+ * and handle the translation themselves for buses on which it is necessary
+ */
+#define SETUP_ATRANS(pContext, addr) do { } while(0)
+
+/*
+ * ZIP2 REGISTERS
+ */
+
+#define CLNK_ETH_INTERRUPT_FLAG  0x01
+
+// PCI device/vendor ID
+#define CLNK_ETH_PCI_DEVICE_ID  0x002117e6
+
+// Unused macro (Zip1b only)
+#define SEM_INIT_DONE_BITS() do { } while(0)
+
+#define CLNK_REG_ETH_MAC_ADDR_HIGH              DEV_MAC_ADDRESS0H
+#define CLNK_REG_ETH_MAC_ADDR_LOW               DEV_MAC_ADDRESS0L
+
+#define CSC_BASE                    0x0c100400
+#define CCPU_BASE                   0x0c100800
+#define DIC_CSR_BASE                0x0c100c00
+#define ETH_CSR_BASE                0x0c103000
+#define GPHY_BASE                   0x0c103800
+#define DIC_BASE                    0x0c104000
+#define CPC_BASE                    0x0c108000
+#define RFIC_BASE                   0x0c109000
+#define FEC_BASE                    0x0c10a000
+#define CPC_TC_BASE                 0x0c10c000
+#define PHY_RX_BASE                 0x0c110000
+#define PHY_TX_BASE                 0x0c118000
+#define PCIE_CSR_BASE               0x0c102000
+#define HOST_INTR_TO_INTX           (1 << 10)
+#define PCIE_CSC_CORE_CTL           (PCIE_CSR_BASE + 0xc00)
+
+#define ETH_VERSION                 (ETH_CSR_BASE + 0x00)
+#define DEV_MAC_ADDRESS0L           (ETH_CSR_BASE + 0xd0)
+#define DEV_MAC_ADDRESS0H           (ETH_CSR_BASE + 0xd4)
+#define ETH_ERR_DET                 (ETH_CSR_BASE + 0x1c)
+
+#define CLNK_REG_CPU_COLD_RESET_BIT (1 << 0)
+#define CLNK_REG_CPU_RESET          (CCPU_BASE + 0x04)
+#define CLNK_SYS_RST_CONTROL        (CCPU_BASE + 0x7c)
+
+#define CSC_INTR_BUS                (CSC_BASE + 0xc)
+
+#define CPC_TC_INST_MEM             (CPC_TC_BASE + 0x0)
+#define CPC_TC_INST_MEM_SZ          0x3000
+#define CPC_TC_DATA_MEM_SZ          0x2000
+#define CPC_TC_DATA_MEM             (CPC_TC_BASE + CPC_TC_INST_MEM_SZ)
+
+#define DIC_TC_CTL_0                (DIC_CSR_BASE + 0x50)
+#define DIC_MISC_CTL_0              (DIC_CSR_BASE + 0x40)
+#define DIC_ATRANS0_CTL0            (DIC_CSR_BASE + 0x70)
+#define DIC_ATRANS1_CTL0            (DIC_CSR_BASE + 0x78)
+#define DIC_TC_NOTIFY_SET           (DIC_CSR_BASE + 0x5c)
+
+#define DIC_TC_INST_MEM             (DIC_BASE + 0x00)
+#define DIC_TC_INST_MEM_SZ          0x2800
+#define DIC_TC_DATA_MEM_SZ          0x1800
+#define DIC_TC_DATA_MEM             (DIC_BASE + DIC_TC_INST_MEM_SZ)
+
+#define DIC_D_STATUS                (DIC_TC_DATA_MEM + 0x00)
+#define DIC_D_DESC_TX_PTR           (DIC_TC_DATA_MEM + 0x04)
+#define DIC_D_DESC_RX_PTR           (DIC_TC_DATA_MEM + 0x08)
+#define DIC_D_MISC_CFG              (DIC_TC_DATA_MEM + 0x0c)
+#define DIC_D_PROC_STATE            (DIC_TC_DATA_MEM + 0x10)
+#define DIC_D_LINEBUF_SOC_RX        (DIC_TC_DATA_MEM + 0x20)
+#define DIC_D_MIN_PKT_SIZE          (DIC_TC_DATA_MEM + 0x38)
+#define DIC_D_LINEBUF_HOST_RX       (DIC_TC_DATA_MEM + 0x24)
+#define DIC_D_LINEBUF0_SOC_TX       (DIC_TC_DATA_MEM + 0x2c)
+#define DIC_D_ETH_SPU_LEN_W_FCS_MAX (DIC_TC_DATA_MEM + 0x30)
+#define DIC_D_AGGR_HDR_SPU_CNT_MAX  (DIC_TC_DATA_MEM + 0x34)
+#define DIC_D_RX_DST_PTR            (DIC_TC_DATA_MEM + 0x68)
+#define DIC_D_RX_DST_IDX            (DIC_TC_DATA_MEM + 0x6c)
+#define DIC_D_TX_DMA_CTL            (DIC_TC_DATA_MEM + 0x78)
+#define DIC_D_RX_DMA_CTL            (DIC_TC_DATA_MEM + 0x7c)
+
+
+#define DIC_CFG_USAGE_MODE_PCI      0x00000000
+#define DIC_CFG_USAGE_MODE_MII      0x00000001
+#define DIC_CFG_BAD_PKT_FLTR_OFF    0x00000000
+#define DIC_CFG_BAD_PKT_FLTR_ON     0x00000010
+#define DIC_CFG_SPU_FCS_ENABLED     0x00000020
+#define DIC_CFG_SPU_FCS_DISABLED    0x00000000
+#define DIC_CFG_AGGR_DST_ONLY       0x00000040
+#define DIC_CFG_AGGR_DST_AND_PRI    0x00000000
+#define DIC_CFG_TX_BUF_PROF_WAN     0x00000080
+#define DIC_CFG_TX_BUF_PROF_LAN     0x00000000
+#define DIC_CFG_MII_SPEED_MASK      0x000FFF00
+#define DIC_CFG_PQOS_MODE_MASK      0x00F00000
+#define DIC_CFG_PQOS_MODE_MOCA_11   0x00000000
+#define DIC_CFG_PQOS_MODE_PUPQ      0x00100000
+
+#define DIC_TX_DMA_CTL_WORD         0x00048000
+#define DIC_RX_DMA_CTL_WORD         0x00048100
+
+#define CSC_CLK_CTL1                (CSC_BASE + 0xe4)
+
+#define CSC_SYS_TMR_LO              (CSC_BASE + 0x70)
+#define CSC_TMR_TIMEOUT_0           (CSC_BASE + 0x80)
+#define CSC_TMR_MASK_0              (CSC_BASE + 0x84)
+
+#define GPHY_MAC_CONFIG             (GPHY_BASE + 0x00)
+#define GPHY_FILTER                 (GPHY_BASE + 0x04)
+#define GPHY_FLOW                   (GPHY_BASE + 0x18)
+
+#define GPHY_FLOW_MAC_LO	    (GPHY_BASE + 0x40)		// Low 2 bytes of mac address as (xx xx MM ZZ) where MM is lowest byte
+#define GPHY_FLOW_MAC_HI	    (GPHY_BASE + 0x44)		// High 4 bytes of mac address in reverse order 
+                                                                //             (AA BB CC DD) where DD is highest byte.
+#define GPHY_BMCR                   (GPHY_BASE + 0x100)
+#define GPHY_ENH_CTRL               (GPHY_BASE + 0x168)
+#define GPHY_BUS_MODE               (GPHY_BASE + 0x200)
+#define GPHY_RX_DESCR_PTR           (GPHY_BASE + 0x20c)
+#define GPHY_TX_DESCR_PTR           (GPHY_BASE + 0x210)
+#define GPHY_OP_MODE                (GPHY_BASE + 0x218)
+
+#define CLNK_REG_MBX_REG_1          DEV_SHARED(mailbox_reg[0])
+#define CLNK_REG_MBX_REG_9          DEV_SHARED(mailbox_reg[8])
+#define CLNK_REG_MBX_REG_16         DEV_SHARED(mailbox_reg[15])
+#define CLNK_REG_MBX_READ_CSR       DEV_SHARED(read_csr_reg)
+#define CLNK_REG_MBX_WRITE_CSR      DEV_SHARED(write_csr_reg)
+#define CLNK_REG_MBX_SEMAPHORE_BIT  0x80000000UL
+
+#define CLNK_REG_DEBUG_0            DEV_SHARED(debug_reg[0])
+#define CLNK_REG_DEBUG_1            DEV_SHARED(debug_reg[1])
+
+#define CLNK_REG_MBX_FIRST          CLNK_REG_MBX_REG_1
+#define CLNK_REG_MBX_LAST           CLNK_REG_MBX_REG_16
+
+#endif /* ! _HW_Z2_H_ */
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/inctypes_dvr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/inctypes_dvr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/inctypes_dvr.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc/inctypes_dvr.h	2012-09-14 14:51:36.882969000 +0530
@@ -0,0 +1,300 @@
+/*******************************************************************************
+*
+* Common/Inc/inctypes_dvr.h
+*
+* Description: System definitions
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __INCTYPES_H__
+#define __INCTYPES_H__
+
+/*******************************************************************************
+*                             # d e f i n e s                                  *
+********************************************************************************/
+
+//  System Constants
+#define SYS_TRUE     1
+#define SYS_FALSE    0
+#define SYS_NULL     0
+#define SYS_SUCCESS  0
+
+// NOTE: The error constants defined below MUST be the same value as the 
+//       corresponding error codes defined by your specific OS.  If not, then
+//       change the values of the defines below to match your specific OS error
+//       values.
+// 
+//       Entropic has defined the error constants below to match the OS we use in
+//       our evaluation platforms and may differ from the error values defined by 
+//       your specific OS.
+#define SYS_INPUT_OUTPUT_ERROR     5
+#define SYS_OUT_OF_MEMORY_ERROR    12
+#define SYS_PERMISSION_ERROR       13
+#define SYS_INVALID_ADDRESS_ERROR  14
+#define SYS_INVALID_ARGUMENT_ERROR 22
+#define SYS_OUT_OF_SPACE_ERROR     28
+#define SYS_DIR_NOT_EMPTY_ERROR    39
+#define SYS_BAD_MSG_TYPE_ERROR     42
+#define SYS_TIMEOUT_ERROR          110
+
+
+#define DOWHILE0(x)  do { x; } while(0)
+
+#define INCTYPES_MIN(x,y)		  ((x) < (y) ? (x) : (y))
+
+/*******************************************************************************
+*                       G l o b a l   D a t a   T y p e s                      *
+********************************************************************************/
+
+// System Variable Types
+typedef void            SYS_VOID;
+typedef void*           SYS_VOID_PTR;
+
+typedef char            SYS_CHAR;
+typedef char*           SYS_CHAR_PTR;
+typedef signed char     SYS_INT8;
+typedef signed char*    SYS_INT8_PTR;
+typedef unsigned char   SYS_UCHAR;
+typedef unsigned char*  SYS_UCHAR_PTR;
+typedef unsigned char   SYS_UINT8;
+typedef unsigned char*  SYS_UINT8_PTR;
+typedef unsigned char   SYS_BOOLEAN; 
+
+/** Used in places where the type is a boolean type but 32 bit words reduce
+ * code space by avoiding the need for various masking */
+typedef unsigned char   SYS_BOOLEAN32; 
+
+typedef unsigned short  SYS_UINT16;
+typedef unsigned short* SYS_UINT16_PTR;
+typedef short           SYS_INT16;
+typedef short*          SYS_INT16_PTR;
+
+typedef int             SYS_INT32;
+typedef int*            SYS_INT32_PTR;
+typedef unsigned int    SYS_UINT32;
+typedef unsigned int*   SYS_UINT32_PTR;
+
+typedef long            SYS_LONG;
+typedef long*           SYS_LONG_PTR;
+typedef unsigned long   SYS_ULONG;
+typedef unsigned long*  SYS_ULONG_PTR;
+
+#if defined(_LP64)
+typedef unsigned long   SYS_UINTPTR;
+#else
+typedef unsigned int    SYS_UINTPTR;
+#endif
+
+typedef struct {
+	SYS_INT32 I;
+	SYS_INT32 Q;
+} SYS_COMPLEX_INT32;
+
+typedef struct {
+	SYS_UINT32 		hi;
+	SYS_UINT32 		lo;
+} mac_addr_t;
+
+typedef void (*SYS_VDFCVD_PTR) (void *);
+
+/** Query if the mac address represents a multicast */
+#define INCTYPES_MAC_ADDR_IS_MULTICAST( _mac_addr ) \
+  (((_mac_addr).hi & 0x01000000) ? SYS_TRUE : SYS_FALSE)
+
+
+/** Query if two mac address match (low order bits masked off) */
+#define INCTYPES_MAC_ADDR_MATCH( _mac_addr_a, _mac_addr_b )              \
+  ((                                                                     \
+      (_mac_addr_a).hi == (_mac_addr_b).hi                               \
+   ) &&                                                                  \
+   (                                                                     \
+      ((_mac_addr_a).lo & 0xFFFF0000) == ((_mac_addr_b).lo & 0xFFFF0000) \
+   ))
+
+
+typedef struct {
+    SYS_UINT32 hi;  // Bytes 5432 of flow id
+    SYS_UINT32 lo;  // Bytes 10xx of flow id, bottom 2 bytes zeroed always
+} clink_flow_id_t;
+
+typedef clink_flow_id_t flow_id_t;
+
+/* persistent name for a clink node, may differ from devices mac address */
+typedef mac_addr_t guid_mac_t;
+
+typedef mac_addr_t clink_guid_t;
+
+typedef SYS_UINT8 clink_node_id_t;
+
+typedef SYS_UINT32 clink_nodemask_t;
+
+typedef SYS_UINT8  moca_version_t;
+
+#define MOCA_FROM_NPS(_nps) ((moca_version_t)(((_nps) >> 24) & 0xFF))
+
+#define MOCA_01  ((moca_version_t)0x01)
+#define MOCA_10  ((moca_version_t)0x10)
+#define MOCA_11  ((moca_version_t)0x11)
+#define MOCA_1C  ((moca_version_t)0x1C) /* Future compatibility testing */
+
+/** Used internally to indicate that the true node protocol support field
+ * values are not yet known. */
+#define MOCA_UNSPECIFIED  ((moca_version_t)0x02)
+
+#define MOCA_TO_NPS(moca_version) ((moca_version) << 24)
+
+#define MOCA_VERSION_SPECIFIED(nps) (MOCA_FROM_NPS(nps)!=MOCA_UNSPECIFIED)
+
+/** Causes a compile time error if a condition is not true at compile time
+ * from within a function definition.
+ * 
+ * Note that the arguments to this must be evaluatable at compile time. If
+ * this check fails, you will see an error like: 'the size of an array must
+ * be greater than zero'. 
+ */
+#define INCTYPES_COMPILE_TIME_ASSERT(_condition)      \
+do                                                    \
+{                                                     \
+    extern int inctypes_assert[(_condition) ? 1 : 0]; \
+    (void)inctypes_assert;                            \
+} while (0)
+
+
+/** Given a reference to an array of definite size, return num elements */
+#define INCTYPES_ARRAY_LEN(_arrayVar) ( sizeof(_arrayVar) / sizeof(*_arrayVar) )
+
+/**
+ * A special macro that when passed the name of a structure and a size (in 
+ * units of size_t (i.e. bytes) will cause a compilation error if the 
+ * structure is larger than the specified size.  
+ * 
+ * This is used as a verification against structures declared in C code
+ * exceeding the size of their MoCA counterparts (indicating bad assumptions
+ * about byte packing or bit packing).
+ */
+#define INCTYPES_VERIFY_STRUCT_LESS_OR_EQUAL(_struct,_size)    \
+struct _struct##_size_verify_lte_t                             \
+{                                                              \
+    int lo[(int)1 + (int)(_size) - (int)sizeof(_struct)];      \
+};
+
+/**
+ * A special macro that when passed the name of a structure and a size (in 
+ * units of size_t (i.e. bytes) will cause a compilation error if the 
+ * structure is smaller than the specified size.  
+ * 
+ * This is used as a verification against structures declared in C code
+ * exceeding the size of their MoCA counterparts (indicating bad assumptions
+ * about byte packing or bit packing).
+ */
+#define INCTYPES_VERIFY_STRUCT_GREATER_OR_EQUAL(_struct,_size) \
+struct _struct##_size_verify_gte_t                             \
+{                                                              \
+    int hi[(int)1 + (int)sizeof(_struct) - (int)(_size)];      \
+};
+
+/**
+ * A special macro that when passed the name of a structure and a size (in 
+ * units of size_t (i.e. bytes) will cause a compilation error if the 
+ * structure is not equal to the specified size.  
+ * 
+ * This is used as a verification against structures declared in C code
+ * exceeding the size of their MoCA counterparts (indicating bad assumptions
+ * about byte packing or bit packing).
+ */
+#define INCTYPES_VERIFY_STRUCT_SIZE(_struct,_size)          \
+    INCTYPES_VERIFY_STRUCT_LESS_OR_EQUAL(_struct,_size)     \
+    INCTYPES_VERIFY_STRUCT_GREATER_OR_EQUAL(_struct,_size)
+
+/**
+ * A special macro that when passed the name of an enumeration or define
+ * will cause a compilation error if the value is larger than another 
+ * value.
+ */
+#define INCTYPES_VERIFY_TOKEN_LESS_THAN(_token,_size) \
+struct _token##_size_verify_lt_t                      \
+{                                                     \
+    int lo[(int)(_size) - (int)(_token)];             \
+};
+
+/**
+ * Utility to safely copy pointers to structures of the same size. This only 
+ * works in evironments implementing memcpy.
+ */
+#define INCTYPES_SAFE_PTR_COPY(_destPtr,_srcPtr)                             \
+do                                                                           \
+{                                                                            \
+    INCTYPES_COMPILE_TIME_ASSERT(sizeof(*(_destPtr)) == sizeof(*(_srcPtr))); \
+                                                                             \
+    memcpy((_destPtr),(_srcPtr),sizeof(*(_destPtr)));                        \
+} while (0)
+
+/**
+ * Utility to safely copy variables of the same size.  This only works in 
+ * evironments implementing memcpy.
+ */
+#define INCTYPES_SAFE_VAR_COPY(_dest,_src) \
+        INCTYPES_SAFE_PTR_COPY((&(_dest)),(&(_src)))
+
+/**
+ * Utility to safely zero a structure referred to by a typed pointer. This only 
+ * works in evironments implementing memset.
+ */
+#define INCTYPES_SAFE_PTR_ZERO(_destPtr)        \
+    memset((_destPtr),0,sizeof(*(_destPtr)))    
+
+/**
+ * Utility to safely zero a variable. This only works in evironments 
+ * implementing memset.
+ */
+#define INCTYPES_SAFE_VAR_ZERO(_destVar)        \
+    memset(&(_destVar),0,sizeof(_destVar))
+
+
+
+/*******************************************************************************
+*                        G l o b a l   C o n s t a n t s                       *
+********************************************************************************/
+
+/* None */
+
+/*******************************************************************************
+*                           G l o b a l   D a t a                              *
+********************************************************************************/
+
+/* None */
+
+/*******************************************************************************
+*                            I n t e r f a c e s                               *
+********************************************************************************/
+
+
+#endif /* __INCTYPES_H__ */
+
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ClnkIo.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ClnkIo.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ClnkIo.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ClnkIo.c	2012-09-14 14:51:36.892959000 +0530
@@ -0,0 +1,966 @@
+/*******************************************************************************
+*
+* Common/Src/ClnkIo.c
+*
+* Description: ioctl layer
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+//#include <linux/string.h>
+extern int strncmp(char *, char *, int);
+extern int strlen(char *);
+/*******************************************************************************
+*                             # D e f i n e s                                  *
+********************************************************************************/
+
+
+
+
+
+/*******************************************************************************
+*            S t a t i c   M e t h o d   P r o t o t y p e s                   *
+********************************************************************************/
+
+static SYS_INT32 clnkioc_driver_cmd_work( void *dkcp, IfrDataStruct *kifr );
+//static SYS_INT32 clnkioc_mbox_cmd_request_work( void *dkcp, IfrDataStruct *kifr, int response );
+//static SYS_INT32 clnkioc_mbox_unsolq_retrieve_work( void *dkcp, IfrDataStruct *kifr );
+static SYS_INT32 clnkioc_mem_read_work( void *dkcp, IfrDataStruct *kifr );
+static SYS_INT32 clnkioc_mem_write_work( void *dkcp, IfrDataStruct *kifr );
+static SYS_INT32 clnkioc_copy_request_block( void *arg, IfrDataStruct *kifr );
+static SYS_INT32 clnkioc_io_block_setup( dc_context_t *dccp, IfrDataStruct *kifr,
+        struct clnk_io *uio, struct clnk_io *kio );
+static SYS_INT32 clnkioc_io_block_return( void *dkcp, struct clnk_io *uio,
+        struct clnk_io *kio, SYS_UINTPTR us_ioblk,
+        void *odata );
+static SYS_INT32 clnkioc_moca_shell_io_block_setup( dc_context_t *dccp, IfrDataStruct *kifr,
+        struct clnk_io *uio, struct clnk_io *kio );
+static SYS_INT32 clnkioc_moca_shell_io_block_return( void *dkcp, struct clnk_io *uio,
+        struct clnk_io *kio, SYS_UINTPTR us_ioblk,
+        void *odata );
+static SYS_INT32 clnkioc_moca_shell_cmd_work( void *dkcp, IfrDataStruct *kifr );
+
+
+/****************************************************************************
+*                      IOCTL Methods                                        *
+*****************************************************************************/
+
+
+/**
+ *  Purpose:    IOCTL entry point for SIOCCLINKDRV
+ *
+ *  Imports:    dkcp - driver kernel context pointer
+ *              arg - request structure from user via kernel
+ *
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*PUBLIC***************************************************************************/
+unsigned long clnkioc_driver_cmd( void *dkcp, void *arg )
+{
+    dc_context_t    *dccp = dk_to_dc( dkcp ) ;
+    SYS_INT32       error = SYS_SUCCESS;
+    IfrDataStruct   kifr;
+
+    // copy the user's request block to kernel space
+    error = clnkioc_copy_request_block( arg, &kifr ) ;
+    if( !error )
+    {
+
+        //HostOS_Lock(dccp->ioctl_lock_link);
+        error = HostOS_mutex_acquire_intr( dccp->ioctl_sem_link ) ;
+        if( !error ) {
+
+            // do the real IOCTL work
+            error = clnkioc_driver_cmd_work( dkcp, &kifr ) ;
+
+            HostOS_mutex_release( dccp->ioctl_sem_link );
+        }
+        //HostOS_Unlock(dccp->ioctl_lock_link);
+
+    }
+
+    return( error ) ;
+}
+
+/**
+ *  Purpose:    IOCTL entry point for SIOCCLINKDRV
+ *
+ *  Imports:    dkcp - driver kernel context pointer
+ *              kifr - kernel ifr pointer
+ *
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*STATIC***************************************************************************/
+static SYS_INT32 clnkioc_driver_cmd_work( void *dkcp, IfrDataStruct *kifr )
+{
+    dc_context_t *dccp = dk_to_dc( dkcp ) ;
+    SYS_UINTPTR  param1, param2, param3;
+    SYS_INT32    error = SYS_SUCCESS;
+    struct clnk_io uio, kio;
+    SYS_UINT32 cmd ;
+
+    param1  = (SYS_UINTPTR)kifr->param1;        // ioctl command
+    param2  = (SYS_UINTPTR)kifr->param2;        // ioctl io block
+    param3  = (SYS_UINTPTR)kifr->param3;        // version constant
+    cmd     = param1;
+
+#if DEBUG_IOCTL_PRIV
+    //HostOS_PrintLog(L_ERR, "ioctl priv %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+#endif
+
+    // copy the user's io block to kernel space
+    error = clnkioc_io_block_setup( dccp, kifr, &uio, &kio ) ;
+    if( !error ) {
+
+        if( CLNK_CTL_FOR_DRV(cmd)) {
+            error = clnk_ctl_drv( dkcp, cmd, &kio );
+        } else if( CLNK_CTL_FOR_ETH(cmd) ) {
+            error = Clnk_ETH_Control_drv( dccp, CLNK_ETH_CTRL_DO_CLNK_CTL, cmd, (SYS_UINTPTR)&kio, 0);
+
+            /* special handling for a few cmds */
+            if( !error ) {
+                clnk_ctl_postprocess( dkcp, kifr, &kio );
+            }
+        }
+
+        // send reply back to IOCTL caller
+        if( !error ) {
+            error = clnkioc_io_block_return( dkcp, &uio, &kio, param2, dccp->clnk_ctl_out ) ;
+        }
+    }
+
+#if DEBUG_IOCTL_PRIV
+    if( error ) {
+        HostOS_PrintLog(L_ERR, "ioctl priv %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+        HostOS_PrintLog(L_ERR, "ioctl err=%d.\n", error );
+    }
+#endif
+    return( error );
+}
+
+
+#if 0
+
+/**
+ *  Purpose:    IOCTL entry point for request-response command
+ *              This is a daemon sending a command mailbox request
+ *              and expecting a response.
+ *
+ *  Imports:    dkcp     - driver kernel context pointer
+ *              arg      - request structure from user via kernel
+ *              response - 1 for response expected
+ *                         0 for no response expected
+ *
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*PUBLIC***************************************************************************/
+unsigned long clnkioc_mbox_cmd_request( void *dkcp, void *arg, int response )
+{
+    dc_context_t  *dccp = dk_to_dc( dkcp ) ;
+    SYS_INT32     error = SYS_SUCCESS;
+    IfrDataStruct kifr;
+
+    // copy the user's request block to kernel space
+    error = clnkioc_copy_request_block( arg, &kifr ) ;
+    if( !error )
+    {
+
+        //HostOS_Lock(dccp->ioctl_lock_link);
+        error = HostOS_mutex_acquire_intr( dccp->ioctl_sem_link ) ;
+        if( !error ) {
+
+            // do the real IOCTL work
+            error = clnkioc_mbox_cmd_request_work( dkcp, &kifr, response ) ;
+
+            HostOS_mutex_release( dccp->ioctl_sem_link );
+        }
+        //HostOS_Unlock(dccp->ioctl_lock_link);
+
+    }
+
+    return( error );
+}
+
+/**
+ *  Purpose:    IOCTL entry point for request-response command
+ *
+ *  Imports:    dkcp     - driver kernel context pointer
+ *              kifr     - kernel ifr pointer
+ *              response - 1 for response expected
+ *                         0 for no response expected
+ *
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*STATIC***************************************************************************/
+static SYS_INT32 clnkioc_mbox_cmd_request_work( void *dkcp, IfrDataStruct *kifr, int response )
+{
+    dc_context_t   *dccp = dk_to_dc( dkcp ) ;
+    SYS_UINTPTR    param1, param2, param3;
+    SYS_INT32      error = SYS_SUCCESS;
+    struct clnk_io uio, kio;
+    SYS_UINT32     cmd ;
+
+    param1  = (SYS_UINTPTR)kifr->param1;        // ioctl command
+    param2  = (SYS_UINTPTR)kifr->param2;        // ioctl io block
+    param3  = (SYS_UINTPTR)kifr->param3;        // version constant
+    cmd     = param1;
+
+#if DEBUG_IOCTL_CMDQ
+    HostOS_PrintLog(L_INFO, "ioctl crw %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+#endif
+
+    // copy the user's io block to kernel space
+    error = clnkioc_io_block_setup( dccp, kifr, &uio, &kio ) ;
+    if( !error ) {
+
+        if( response ) {
+
+            // send MESSAGE - wait for response
+
+            error = clnk_cmd_msg_send_recv(       dccp, kifr->cmd, param1, &kio ) ;
+            /* special handling for a few cmds */
+            if( !error ) {
+                clnk_ctl_postprocess( dkcp, kifr, &kio );
+            }
+
+        } else {
+
+            // send MESSAGE
+
+            error = clnk_cmd_msg_send( dccp, kifr->cmd, param1, &kio ) ;
+
+        }
+
+        if( !error ) {
+            // send reply back to IOCTL caller
+            error = clnkioc_io_block_return( dkcp, &uio, &kio, param2, dccp->clnk_ctl_out ) ;
+        }
+    }
+
+#if DEBUG_IOCTL_CMDQ
+    if( error ) {
+        HostOS_PrintLog(L_ERR, "ioctl crw %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+        HostOS_PrintLog(L_ERR, "ioctl err=%d.\n", error );
+    }
+#endif
+    return( error );
+}
+
+
+/**
+ *  Purpose:    IOCTL entry point for unsolicited message retrieval
+ *
+ *  Imports:    dkcp - driver kernel context pointer
+ *              arg - request structure from user via kernel
+ *
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*PUBLIC***************************************************************************/
+unsigned long clnkioc_mbox_unsolq_retrieve( void *dkcp, void *arg )
+{
+    dc_context_t  *dccp = dk_to_dc( dkcp ) ;
+    SYS_INT32     error = SYS_SUCCESS;
+    IfrDataStruct kifr;
+
+    // copy the user's request block to kernel space
+    error = clnkioc_copy_request_block( arg, &kifr ) ;
+    if( !error )
+    {
+
+        //HostOS_Lock(dccp->ioctl_lock_link);
+        error = HostOS_mutex_acquire_intr( dccp->ioctl_sem_link ) ;
+        if( !error ) {
+
+            // do the real IOCTL work
+            error = clnkioc_mbox_unsolq_retrieve_work( dkcp, &kifr ) ;
+
+            HostOS_mutex_release( dccp->ioctl_sem_link );
+        }
+        //HostOS_Unlock(dccp->ioctl_lock_link);
+
+    }
+
+    return( error );
+}
+
+/**
+ *  Purpose:    IOCTL entry point for sw unsolicited retrieval
+ *
+ *  Imports:    dkcp - driver kernel context pointer
+ *              kifr - kernel ifr pointer
+ *
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*STATIC***************************************************************************/
+static SYS_INT32 clnkioc_mbox_unsolq_retrieve_work( void *dkcp, IfrDataStruct *kifr )
+{
+    dc_context_t    *dccp = dk_to_dc( dkcp ) ;
+    SYS_UINTPTR     param1, param2, param3;
+    SYS_INT32       error = SYS_SUCCESS;
+    struct clnk_io  uio, kio ;
+
+    param1  = (SYS_UINTPTR)kifr->param1;        // ioctl command
+    param2  = (SYS_UINTPTR)kifr->param2;        // ioctl io block
+    param3  = (SYS_UINTPTR)kifr->param3;        // version constant
+
+#if DEBUG_IOCTL_UNSOLQ
+    //HostOS_PrintLog(L_ERR, "ioctl urw %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+#endif
+
+    // copy the user's io block to kernel space
+    error = clnkioc_io_block_setup( dccp, kifr, &uio, &kio ) ;
+    if( !error ) {
+
+        if( uio.out_len != MAX_UNSOL_MSG )
+        {
+            _ioctl_dbg( dkcp, "SW UNSOL length");
+            error = -SYS_INVALID_ARGUMENT_ERROR;
+        } else {
+
+            error = Clnk_MBX_RcvUnsolMsg( &dccp->mailbox, (SYS_UINT32 *)dccp->clnk_ctl_out ) ;
+            if( !error ) {
+                // send reply back to IOCTL caller
+                error = clnkioc_io_block_return( dkcp, &uio, &kio, param2, dccp->clnk_ctl_out ) ;
+            }
+        }
+    }
+
+#if DEBUG_IOCTL_UNSOLQ
+    if( error ) {
+        HostOS_PrintLog(L_ERR, "ioctl urw %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+        HostOS_PrintLog(L_ERR, "ioctl err=%d.\n", error );
+    }
+#endif
+    return( error );
+}
+#endif
+
+
+/**
+ *  Purpose:    IOCTL entry point for reading clink memory/registers
+ *
+ *  Imports:    dkcp - driver kernel context pointer
+ *              arg  - request structure from user via kernel
+ *
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*PUBLIC***************************************************************************/
+unsigned long clnkioc_mem_read( void *dkcp, void *arg )
+{
+    dc_context_t    *dccp = dk_to_dc( dkcp ) ;
+    SYS_INT32       error = SYS_SUCCESS;
+    IfrDataStruct   kifr;
+
+    // copy the user's request block to kernel space
+    error = clnkioc_copy_request_block( arg, &kifr ) ;
+    if( !error )
+    {
+
+        //HostOS_Lock(dccp->ioctl_lock_link);
+        error = HostOS_mutex_acquire_intr( dccp->ioctl_sem_link ) ;
+        if( !error ) {
+
+            // do the real IOCTL work
+            error = clnkioc_mem_read_work( dkcp, &kifr ) ;
+
+            HostOS_mutex_release( dccp->ioctl_sem_link );
+        }
+        //HostOS_Unlock(dccp->ioctl_lock_link);
+
+    }
+
+    return( error );
+}
+
+/**
+ *  Purpose:    IOCTL entry point for reading clink memory/registers
+ *
+ *  Imports:    dkcp - driver kernel context pointer
+ *              kifr - kernel ifr pointer
+ *
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*STATIC***************************************************************************/
+static SYS_INT32 clnkioc_mem_read_work( void *dkcp, IfrDataStruct *kifr )
+{
+    dc_context_t *dccp = dk_to_dc( dkcp ) ;
+    SYS_UINTPTR  param1, param2, param3;
+    SYS_INT32    error = SYS_SUCCESS;
+    struct clnk_io uio, kio;
+    SYS_UINT32   addr ;
+
+    param1  = (SYS_UINTPTR)kifr->param1;        // ioctl command
+    param2  = (SYS_UINTPTR)kifr->param2;        // ioctl io block
+    param3  = (SYS_UINTPTR)kifr->param3;        // version constant
+
+#if DEBUG_IOCTL_MEM
+    //HostOS_PrintLog(L_ERR, "ioctl mrw %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+#endif
+
+    // copy the user's io block to kernel space
+    error = clnkioc_io_block_setup( dccp, kifr, &uio, &kio ) ;
+    if( !error ) {
+
+        // check stuff
+        if( (uio.out_len == 0) ) {
+            _ioctl_dbg( dkcp, "DRV_CLNK_CTL 0 out length");
+            error = -SYS_INVALID_ARGUMENT_ERROR;
+        } else {
+
+            addr = kio.in_len ? kio.in[0] : ((SYS_UINTPTR)kio.in);
+
+            // the READ
+
+            clnk_blk_read( dccp, addr, (SYS_UINT32 *)kio.out, kio.out_len ) ;
+
+            // send reply back to IOCTL caller
+            error = clnkioc_io_block_return( dkcp, &uio, &kio, param2, dccp->clnk_ctl_out ) ;
+        }
+    }
+
+#if DEBUG_IOCTL_MEM
+    if( error ) {
+        HostOS_PrintLog(L_ERR, "ioctl mrw %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+        HostOS_PrintLog(L_ERR, "ioctl err=%d.\n", error );
+    }
+#endif
+    return( error );
+}
+
+
+/**
+ *  Purpose:    IOCTL entry point for writing clink memory/registers
+ *
+ *  Imports:    dkcp - driver kernel context pointer
+ *              arg  - request structure from user via kernel
+ *
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*PUBLIC***************************************************************************/
+unsigned long clnkioc_mem_write( void *dkcp, void *arg )
+{
+    dc_context_t    *dccp = dk_to_dc( dkcp ) ;
+    SYS_INT32       error = SYS_SUCCESS;
+    IfrDataStruct   kifr;
+
+    // copy the user's request block to kernel space
+    error = clnkioc_copy_request_block( arg, &kifr ) ;
+    if( !error )
+    {
+
+        //HostOS_Lock(dccp->ioctl_lock_link);
+        error = HostOS_mutex_acquire_intr( dccp->ioctl_sem_link ) ;
+        if( !error ) {
+
+            // do the real IOCTL work
+            error = clnkioc_mem_write_work( dkcp, &kifr ) ;
+
+            HostOS_mutex_release( dccp->ioctl_sem_link );
+        }
+        //HostOS_Unlock(dccp->ioctl_lock_link);
+
+    }
+
+    return( error );
+}
+
+/**
+ *  Purpose:    IOCTL entry point for writing clink memory/registers
+ *
+ *  Imports:    dkcp - driver kernel context pointer
+ *              kifr - kernel ifr pointer
+ *
+ *  Exports:    Error status
+ *              Response data, if any, is returned via ioctl structures
+ *
+*STATIC***************************************************************************/
+static SYS_INT32 clnkioc_mem_write_work( void *dkcp, IfrDataStruct *kifr )
+{
+    dc_context_t *dccp = dk_to_dc( dkcp ) ;
+    SYS_UINTPTR  param1, param2, param3;
+    SYS_INT32    error = SYS_SUCCESS;
+    struct clnk_io uio, kio;
+    SYS_UINT32   addr, *data, len ;
+
+    param1  = (SYS_UINTPTR)kifr->param1;        // ioctl command
+    param2  = (SYS_UINTPTR)kifr->param2;        // ioctl io block
+    param3  = (SYS_UINTPTR)kifr->param3;        // version constant
+
+#if DEBUG_IOCTL_MEM
+    //HostOS_PrintLog(L_ERR, "ioctl mww %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+#endif
+
+    // copy the user's io block to kernel space
+    error = clnkioc_io_block_setup( dccp, kifr, &uio, &kio ) ;
+    if( !error ) {
+
+        addr = kio.in[0];               // first  in long is the address
+        data = &kio.in[1];              // second in long is the first data long
+        len  = kio.in_len - sizeof(SYS_UINT32);  // len is the block length less the address long
+        if( len < sizeof(SYS_UINT32) )
+        {
+            // kio.in_len includes the address (4 bytes) and the data
+            /* minimum write is 1 word */
+            _ioctl_dbg( dkcp, "DRV_CLNK_CTL min write");
+            error = -SYS_INVALID_ADDRESS_ERROR;
+        } else {
+
+            // the WRITE
+            clnk_blk_write(dccp, addr, (SYS_UINT32 *)data, len);
+
+            // send reply back to IOCTL caller
+            error = clnkioc_io_block_return( dkcp, &uio, &kio, param2, dccp->clnk_ctl_out ) ;
+        }
+    }
+
+#if DEBUG_IOCTL_MEM
+    if( error ) {
+        HostOS_PrintLog(L_ERR, "ioctl mww %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+        HostOS_PrintLog(L_ERR, "ioctl err=%d.\n", error );
+    }
+#endif
+    return( error );
+}
+
+unsigned long clnkioc_moca_shell_cmd( void *dkcp, void *arg )
+{
+    dc_context_t    *dccp = dk_to_dc( dkcp ) ;
+    SYS_INT32       error = SYS_SUCCESS;
+    IfrDataStruct   kifr;
+
+    // copy the user's request block to kernel space
+    error = clnkioc_copy_request_block( arg, &kifr ) ;
+    if( !error )
+    {
+
+        //HostOS_Lock(dccp->ioctl_lock_link);
+        error = HostOS_mutex_acquire_intr( dccp->ioctl_sem_link ) ;
+        if( !error ) {
+
+            // do the real IOCTL work
+            error = clnkioc_moca_shell_cmd_work( dkcp, &kifr ) ;
+
+            HostOS_mutex_release( dccp->ioctl_sem_link );
+        }
+        //HostOS_Unlock(dccp->ioctl_lock_link);
+
+    }
+
+    return( error );
+}
+
+SYS_UINT32 htonl(SYS_UINT32 x)
+{
+    SYS_UINT32 y = x;
+    char *p = (char *)&y;
+
+    return ((p[0]) << 24 | (p[1]) << 16 | (p[2]) << 8 | (p[3]));
+}
+
+static SYS_INT32 clnkioc_moca_shell_cmd_work( void *dkcp, IfrDataStruct *kifr )
+{
+#define MOCA_SHELL_MIN_CMD_LEN 4
+    int i;
+    dc_context_t *dccp = dk_to_dc( dkcp ) ;
+    SYS_UINTPTR  param1, param2, param3;
+    SYS_INT32    error = SYS_SUCCESS;
+    struct clnk_io uio, kio;
+    SYS_UINT32   shift, addr, *data, len, owner_flag, session, cnt;
+    SYS_UINT8    *wp;
+//    SYS_UINT32   *pout;
+
+    param1  = (SYS_UINTPTR)kifr->param1;        // ioctl command
+    param2  = (SYS_UINTPTR)kifr->param2;        // ioctl io block
+    param3  = (SYS_UINTPTR)kifr->param3;        // version constant
+
+    // copy the user's io block to kernel space
+    error = clnkioc_moca_shell_io_block_setup( dccp, kifr, &uio, &kio ) ;
+
+    if( !error ) {
+
+        clnk_reg_read(dccp, DEV_SHARED(ms_cmd_buf_addr), &addr);
+        data = &kio.in[0];
+        len  = kio.in_len;
+        if( len < MOCA_SHELL_MIN_CMD_LEN )
+        {
+            _ioctl_dbg( dkcp, "DRV_CLNK_CTL min write");
+            error = -SYS_INVALID_ARGUMENT_ERROR;
+        } else {
+
+            // WRITE MoCA Shell command to SoC
+            //HostOS_PrintLog(L_ERR, "request to write command: %s\n", data);
+            clnk_reg_write(dccp, DEV_SHARED(ms_session_req), MS_SESSION_REQ_MDIO);
+            cnt = 0;
+            while (1)
+            {
+                clnk_reg_read(dccp, DEV_SHARED(ms_session_req), &session);
+                if (MS_SESSION_RESP_MDIO == session)
+                {
+                    break;
+                }
+
+                if (cnt++ > 1000)
+                {
+#if 0
+                    strcpy(dccp->clnk_ctl_out, "\r\nerror\r\n");
+                    uio.out_len = strlen(dccp->clnk_ctl_out) + 1;
+                    goto out;
+#else
+                    return -SYS_TIMEOUT_ERROR;
+#endif
+                }
+
+                HostOS_msleep_interruptible(10);
+            }
+
+            //HostOS_PrintLog(L_ERR, "start to write command\n");
+            addr &= 0x7fffffff;
+
+            len = (len + 3) & ~3;
+            for (i = 0; i < len/4; i++)
+            {
+                data[i] = htonl(data[i]);
+            }
+            //HostOS_PrintLog(L_ERR, "write command: %s\n", (char *)data);
+            clnk_blk_write(dccp, addr, (SYS_UINT32 *)data, len);
+            clnk_reg_write(dccp, DEV_SHARED(ms_session_req), MS_SESSION_RESP_ACK_MDIO);
+
+
+            // READ MoCA Shell result from SoC
+            //HostOS_PrintLog(L_ERR, "wait for response\n");
+            uio.out_len = 0;
+            wp = (SYS_UINT8 *)dccp->clnk_ctl_out;
+            cnt = 0;
+            while (1)
+            {
+                clnk_reg_read( dccp, DEV_SHARED(ms_resp_owner_flag), &owner_flag);
+                if (OWNER_HOST == MOCA_SHELL_RESP_OWNER(owner_flag))
+                {
+                    cnt = 0;
+                    len   = MOCA_SHELL_RESP_LEN(owner_flag);
+                    shift = len & 0x3;
+                    len   = (len + 3) & ~3;
+
+                    clnk_reg_read( dccp, DEV_SHARED(ms_resp_buf_addr), &addr);
+                    addr &= 0x7fffffff;
+
+                    clnk_blk_read( dccp, addr, (SYS_UINT32 *)wp, len ) ;
+                    //HostOS_PrintLog(L_ERR, "len = %d, addr = %#x, clnk_blk_read: %s\n", owner_flag >> 16 , addr, wp);
+
+                    wp          += len;
+                    uio.out_len += len;
+                    if (shift)
+                    {
+                        wp          += shift;
+                        wp          -= 4;
+                        uio.out_len += shift;
+                        uio.out_len -= 4;
+                    }
+
+                    clnk_reg_write( dccp, DEV_SHARED(ms_resp_owner_flag), OWNER_SOC);
+
+                    if (!MOCA_SHELL_RESP_MORE(owner_flag))  // no more data, MoCA shell send error code leave this field 0
+                        break;
+                }
+
+                if (cnt++ > 1000)
+                {
+#if 0
+                    strcpy(dccp->clnk_ctl_out, "\r\nerror\r\n");
+                    uio.out_len = strlen(dccp->clnk_ctl_out) + 1;
+                    break;
+#else
+                    return -SYS_TIMEOUT_ERROR;
+#endif
+                }
+
+                HostOS_msleep_interruptible(10);
+            }
+
+#if 0
+            uio.out_len = (uio.out_len + 3) & ~3;
+            pout = (SYS_UINT32 *)uio.out;
+            for (i = 0; i < uio.out_len/4; i++)
+            {
+                pout[i] = htonl(pout[i]);
+            }
+#endif
+            /* zhu add 11/03/2011/ for BZ11168:the driver version is always 0.0.0.0 
+            0x10009 is the virtual address of MY_NODE_INFO_VADDR
+            */
+            if(strncmp((char *)uio.in, "read 0x10009", strlen("read 0x10009")) == 0)
+            {
+                ClnkDef_MyNodeInfo_t *out = (void *)kio.out;
+                SYS_UINT32  rev1=0, rev2=0, rev3=0, rev4=0;
+                    
+                HostOS_Sscanf(DRV_VERSION, "%d.%d.%d.%d", 
+                              &rev1, &rev2, &rev3, &rev4);
+                out->SwRevNum = ((rev1 & 0xff) << 24) | 
+                                ((rev2 & 0xff) << 16) |
+                                ((rev3 & 0xff) << 8)  | 
+                                ((rev4 & 0xff) );
+            }
+//out:
+            // copy to user space
+            error = clnkioc_moca_shell_io_block_return( dkcp, &uio, &kio, param2, dccp->clnk_ctl_out ) ;
+        }
+    }
+
+#if DEBUG_IOCTL_MEM
+    if( error ) {
+        HostOS_PrintLog(L_ERR, "ioctl mww %x %x %x %x\n", kifr->cmd, param1, param2, param3);
+        HostOS_PrintLog(L_ERR, "ioctl err=%d.\n", error );
+    }
+#endif
+    return( error );
+}
+/**
+ *  Purpose:    Copies the IOCTL request block to kernel space
+ *              Maybe performs some checks.
+ *
+ *  Imports:    arg  - request structure from user via kernel
+ *              kifr - kernel space block to recieve IOCTL request block
+ *
+ *  Exports:    Error status
+ *
+*STATIC***************************************************************************/
+static SYS_INT32 clnkioc_copy_request_block( void *arg, IfrDataStruct *kifr )
+{
+    SYS_INT32    error = SYS_SUCCESS;
+    // copy the user's request block to kernel space
+    if( HostOS_copy_from_user( (void *)kifr, arg, sizeof(IfrDataStruct)) ) {
+        HostOS_PrintLog(L_INFO, "fault: %p\n", arg );
+        error = -SYS_INVALID_ADDRESS_ERROR ;
+    } else {
+        // cursory checks
+        if( (SYS_INT32)kifr->param3 != CLNK_CTL_VERSION ) {
+            HostOS_PrintLog(L_INFO, "fault: version not %d\n", CLNK_CTL_VERSION );
+            error = -SYS_PERMISSION_ERROR ;
+        }
+    }
+
+    return( error );
+}
+
+/**
+ *  Purpose:    Setup io block for IOCTL
+ *
+ *              This is called after clnkioc_copy_request_block()
+ *
+ *              The io block is copied from user space to kernel space
+ *              into the uio. The uio is then used to setup the kio.
+ *
+ *  Imports:    dccp - driver control context pointer
+ *              kifr - kernel ifr pointer
+ *              uio  - io block copied from user space
+ *              kio  - kernel io block
+ *
+ *  Exports:    Error status
+ *
+*STATIC***************************************************************************/
+static SYS_INT32 clnkioc_io_block_setup( dc_context_t *dccp, IfrDataStruct *kifr,
+        struct clnk_io *uio, struct clnk_io *kio )
+{
+    SYS_UINTPTR  param1, param2 ;
+    SYS_INT32    error = SYS_SUCCESS;
+    SYS_UINT32   in_len, max_in, max_out;
+
+    param1  = (SYS_UINTPTR)kifr->param1;        // ioctl command
+    param2  = (SYS_UINTPTR)kifr->param2;        // ioctl io block pointer
+
+    // copy the user's io block to kernel space
+    if( HostOS_copy_from_user( uio, (void *)param2, sizeof(struct clnk_io)) ) {
+        _ioctl_dbg( dkcp, "DRV_CLNK_CTL copy _from_user (uio)");
+        error = -SYS_INVALID_ADDRESS_ERROR;
+    } else {
+
+        in_len = uio->in_len;
+
+        max_in  = CLNK_CTL_MAX_IN_LEN;
+        max_out = CLNK_CTL_MAX_OUT_LEN;
+
+        if( (in_len > max_in)        ||
+                (in_len & 3)             ||
+                (uio->out_len > max_out) ||
+                (uio->out_len & 3)          ) {
+            _ioctl_dbg( dkcp, "DRV_CLNK_CTL lengths");
+            error = -SYS_INVALID_ARGUMENT_ERROR;
+        } else {
+            if( in_len ) {   // 'in' to the driver
+                // copy data block to fixed buffer
+                if( HostOS_copy_from_user( dccp->clnk_ctl_in, uio->in, uio->in_len) )
+                {
+                    _ioctl_dbg( dkcp, "DRV_CLNK_CTL copy _from_user (data in)");
+                    error = -SYS_INVALID_ADDRESS_ERROR;
+                } else {
+                    // set the kio 'in' pointer
+                    kio->in     = (SYS_UINT32 *)( dccp->clnk_ctl_in );
+                    kio->in_len = in_len;
+                }
+            } else {
+                /* if in_len is 0, uio.in is an integer single argument */
+                kio->in     = uio->in;
+                kio->in_len = 0;
+            }
+            // set the kio 'out' pointer
+            kio->out     = (SYS_UINT32 *)( dccp->clnk_ctl_out );
+            kio->out_len = uio->out_len;
+            // Note that some IOCTLs require out_len non-zero - we don't check for that.
+        }
+    }
+
+    return( error ) ;
+}
+
+/**
+ *  Purpose:    Reply back to the IOCTL caller by copying the io block
+ *              and data, if any, back to user space.
+ *
+ *              This is called at the end of the IOCTL operation
+ *
+ *  Imports:    dkcp     - driver kernel context pointer
+ *              uio      - user io block pointer, in kernel space
+ *              kio      - kernel io block pointer
+ *              us_ioblk - user space pointer to user io block
+ *              odata    - out data, in kernel space
+ *
+ *  Exports:    Error status
+ *
+*STATIC***************************************************************************/
+static SYS_INT32 clnkioc_io_block_return( void *dkcp, struct clnk_io *uio,
+        struct clnk_io *kio, SYS_UINTPTR us_ioblk,
+        void *odata )
+{
+    SYS_INT32    error = SYS_SUCCESS;
+
+    /* update out length if shorter now */
+    if( kio->out_len < uio->out_len ) {
+
+        uio->out_len = kio->out_len;     // set new length
+
+        // copy length to user space - along with the rest of the io block
+        if( HostOS_copy_to_user( (void *)us_ioblk, (void *)uio, sizeof(struct clnk_io)) )
+        {
+            _ioctl_dbg( dkcp, "DRV_CLNK_CTL copy _to_user (uio)");
+            error = -SYS_INVALID_ADDRESS_ERROR;
+        }
+    }
+
+    if( uio->out_len &&       // if supposed to return data
+            HostOS_copy_to_user( uio->out, odata, uio->out_len) ) {
+        _ioctl_dbg( dkcp, "DRV_CLNK_CTL copy _to_user (out data)");
+        error = -SYS_INVALID_ADDRESS_ERROR;
+    }
+
+    return( error );
+}
+
+static SYS_INT32 clnkioc_moca_shell_io_block_setup( dc_context_t *dccp, IfrDataStruct *kifr,
+        struct clnk_io *uio, struct clnk_io *kio )
+{
+    SYS_INT32    error = SYS_SUCCESS;
+    SYS_UINT32   in_len;
+    SYS_UINTPTR  param2;
+
+    param2  = (SYS_UINTPTR)kifr->param2;        // ioctl io block
+
+    if( HostOS_copy_from_user( uio, (void *)param2, sizeof(struct clnk_io)) ) {
+        _ioctl_dbg( dkcp, "DRV_CLNK_CTL copy _from_user (uio)");
+        error = -SYS_INVALID_ADDRESS_ERROR;
+    } else {
+
+        //HostOS_PrintLog(L_ERR, "uio->in_len = %d, uio->in: %s\n", uio->in_len, uio->in);
+        uio->in_len  = (uio->in_len + 3) & ~3;
+        uio->out_len = (uio->out_len + 3) & ~3;
+        in_len = uio->in_len;
+
+        if( (in_len > CLNK_CTL_MAX_IN_LEN) ||
+                (uio->out_len > CLNK_CTL_MAX_OUT_LEN) ) {
+            _ioctl_dbg( dkcp, "DRV_CLNK_CTL lengths");
+            error = -SYS_INVALID_ARGUMENT_ERROR;
+        } else {
+            if( in_len ) {   // 'in' to the driver
+                // copy data block to fixed buffer
+                if( HostOS_copy_from_user( dccp->clnk_ctl_in, uio->in, uio->in_len) )
+                {
+                    _ioctl_dbg( dkcp, "DRV_CLNK_CTL copy _from_user (data in)");
+                    error = -SYS_INVALID_ADDRESS_ERROR;
+                } else {
+                    // set the kio 'in' pointer
+                    kio->in     = (SYS_UINT32 *)( dccp->clnk_ctl_in );
+                    kio->in_len = in_len;
+                }
+            } else {
+                /* if in_len is 0, empty moca shell commands? */
+                _ioctl_dbg( dkcp, "DRV_CLNK_CTL empty moca shell command (data in)");
+                error = -SYS_INVALID_ARGUMENT_ERROR;
+            }
+            // set the kio 'out' pointer
+            kio->out     = (SYS_UINT32 *)( dccp->clnk_ctl_out );
+            kio->out_len = uio->out_len;
+            // Note that some IOCTLs require out_len non-zero - we don't check for that.
+        }
+    }
+
+    return error;
+}
+
+static SYS_INT32 clnkioc_moca_shell_io_block_return( void *dkcp, struct clnk_io *uio,
+        struct clnk_io *kio, SYS_UINTPTR us_ioblk,
+        void *odata )
+{
+    SYS_INT32    error = SYS_SUCCESS;
+
+    if( HostOS_copy_to_user( (void *)us_ioblk, (void *)uio, sizeof(struct clnk_io)) )
+    {
+        _ioctl_dbg( dkcp, "DRV_CLNK_CTL copy _to_user (uio)");
+        error = -SYS_INVALID_ADDRESS_ERROR;
+    }
+
+    if(HostOS_copy_to_user( uio->out, odata, uio->out_len) ) {
+        _ioctl_dbg( dkcp, "DRV_CLNK_CTL copy _to_user (out data)");
+        error = -SYS_INVALID_ADDRESS_ERROR;
+    }
+
+    return error;
+}
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ClnkIo_common.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ClnkIo_common.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ClnkIo_common.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ClnkIo_common.c	2012-09-14 14:51:36.896953000 +0530
@@ -0,0 +1,258 @@
+/*******************************************************************************
+*
+* Common/Src/ClnkIo_common.c
+*
+* Description: ioctl common functions
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+/*******************************************************************************
+*                             # D e f i n e s                                  *
+********************************************************************************/
+
+
+
+
+
+/*******************************************************************************
+*            S t a t i c   M e t h o d   P r o t o t y p e s                   *
+********************************************************************************/
+
+
+
+
+/**
+* 
+*   Purpose:    Sends and receives a command message.
+*
+*   Imports:    dccp    - driver control context pointer
+*               rq_cmd  - request block command
+*               rq_scmd - request block subcommand
+*               iob     - io block pointer
+*                         Note: If io->in_len is 0, io->in is treated as a 
+*                               single argument
+*
+*   Exports:    Error status
+*
+*PUBLIC***************************************************************************/
+int clnk_cmd_msg_send_recv( dc_context_t *dccp,    // control context
+                            SYS_UINT32 rq_cmd,     // request command
+                            SYS_UINT32 rq_scmd,    // subcommand
+                            struct clnk_io *iob )  // io block pointer
+{
+    int             error ;
+    Clnk_MBX_Msg_t  mbxMsg;
+    int             len;
+    SYS_INT32       out_len ;
+
+    /* create data_buf mailbox request */
+    mbxMsg.msg.ethCmd.cmd      = CLNK_MBX_SET_CMD(rq_cmd);          /* wd 0 */
+    mbxMsg.msg.ethCmd.param[0] = rq_scmd & ~CLNK_CMD_DST_MASK;      /* wd 1 */
+    mbxMsg.msg.ethCmd.param[1] = 0;                                 /* wd 2 */
+
+    if( iob->in_len )
+    {
+        /* send a blob of data down to the SoC */
+        int i;
+        
+        len = MIN_VAL(MAX_MBX_MSG - 3, iob->in_len >> 2);  // get number of longs
+        for(i = 0; i < len; i++) {
+            mbxMsg.msg.ethCmd.param[2 + i] = iob->in[i];            /* wd 3+ */
+        }
+    } else {
+        mbxMsg.msg.ethCmd.param[2] = (SYS_UINTPTR)iob->in;          /* wd 3 */
+        len = 1;
+    }
+
+#if ECFG_FLAVOR_VALIDATION==1
+    if (cmd == CLNK_CTL_VAL_TRIGGER_MBOX_EVENT)
+    {
+        clnkEth_valMboxHostCounts.triggeredSendRcvs++;
+    }
+#endif
+
+    // send message - wait for and receive response
+
+    error = Clnk_MBX_SendRcvMsg( &dccp->mailbox, &mbxMsg, &mbxMsg,
+                                    3 + len, MBX_POLL_TIMEOUT_IN_US);
+//HostOS_PrintLog(L_INFO, "Clnk_MBX_SendRcvMsg, subcmd = %x, error = %d\n", rq_scmd, error);
+    /*
+    * status is the status of the mailbox transaction itself
+    *
+    * CLNK_MBX_GET_STATUS() reports the replyStatus from
+    *   ETH_ProcDataBufCmd() handler on the SoC (if the mailbox
+    *   transaction didn't fail)
+    */
+    if( !error &&
+        (CLNK_MBX_GET_STATUS(mbxMsg.msg.ethReply.status) == SYS_SUCCESS))
+    {
+        // extract out length
+        out_len = (CLNK_MBX_GET_REPLY_LEN(mbxMsg.msg.ethReply.status) << 2) - 4;
+
+        // adjust out length for reality
+        iob->out_len = MIN_VAL(iob->out_len, out_len);
+        if( iob->out_len )
+        {
+            // copy response to 'out' buffer
+            HostOS_Memcpy( iob->out, &mbxMsg.msg.ethReply.param[0], out_len);
+        }
+    }
+
+    return( error );
+}
+
+
+/*
+*   Purpose:    Reads a block of register address space into a buffer.
+*
+*               The block is read as longs.
+*
+*               Takes the Address Translation lock
+*
+*   Imports:    dccp            - control context
+*               sourceClinkAddr - beginning register address
+*               destHostAddr    - beginning memory buffer address
+*               length          - byte count, minimum is 4 and must be modulo 4
+*
+*   Exports:    none
+*
+*PUBLIC*****************************************************************/
+void clnk_blk_read( dc_context_t *dccp, 
+                    SYS_UINT32 sourceClinkAddr, 
+                    SYS_UINT32 *destHostAddr, 
+                    SYS_UINT32 length)
+{
+
+#if defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT) || defined(APOLLO_DRVR_SUPPORT)
+    HostOS_Lock(dccp->at_lock_link);
+
+    /*
+     * FPGA AUTO_INCR is pre-increment
+     * SoC AUTO_INCR is post-increment, here is SOC
+     */
+    clnk_read_burst( dccp, sourceClinkAddr, destHostAddr, length, 1); //1 for SOC, 0 for FPGA
+
+    HostOS_Unlock(dccp->at_lock_link);
+#else
+
+    for( ; length ; length -= 4, sourceClinkAddr += 4, destHostAddr++ ) {
+        clnk_reg_read(dccp, sourceClinkAddr, destHostAddr);
+    }
+
+#endif
+
+}
+
+/*
+*   Purpose:    Writes a buffer to a block of register address space.
+*
+*               The block is written as longs.
+*
+*               Takes the Address Translation lock
+*
+*   Imports:    dccp           - control context
+*               destClnkAddr   - beginning register address
+*               sourceHostAddr - beginning memory buffer address
+*               length         - byte count, minimum is 4 and must be modulo 4
+*
+*   Exports:    none
+*
+*PUBLIC*****************************************************************/
+void clnk_blk_write(dc_context_t  *dccp, 
+                    SYS_UINT32 destClnkAddr, 
+                    SYS_UINT32 *sourceHostAddr, 
+                    SYS_UINT32 length)
+{
+
+#if defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT) || defined(APOLLO_DRVR_SUPPORT)
+    HostOS_Lock(dccp->at_lock_link);
+
+    /*
+     * FPGA AUTO_INCR is pre-increment
+     * SoC AUTO_INCR is post-increment, here is SOC
+     */
+    clnk_write_burst( dccp, destClnkAddr, sourceHostAddr, length, 1); //for SOC
+
+    HostOS_Unlock(dccp->at_lock_link);
+#else
+
+    for( ; length ; length -= 4, destClnkAddr += 4, sourceHostAddr++ ) {
+        clnk_reg_write(dccp, destClnkAddr, *sourceHostAddr);
+    }
+#endif
+}
+
+/**
+*   Purpose:    Sends command message 
+*
+*   Imports:    dccp    - driver control context pointer
+*               rq_cmd  - request block command
+*               rq_scmd - request block subcommand
+*               iob     - io block pointer
+* 
+*   Exports:    Error status
+*
+*PUBLIC***************************************************************************/
+int clnk_cmd_msg_send( dc_context_t *dccp,    // control context
+                       SYS_UINT32 rq_cmd,     // request command
+                       SYS_UINT32 rq_scmd,    // subcommand
+                       struct clnk_io *iob )  // io block pointer
+{
+    SYS_INT32           error = SYS_SUCCESS;
+    Clnk_MBX_Msg_t      mbxMsg;
+    int                 len, i;
+    SYS_UINT8           tid ;
+
+    /* create data_buf mailbox request */
+    mbxMsg.msg.ethCmd.cmd      = CLNK_MBX_SET_CMD(rq_cmd);                  /* wd 0 */
+    mbxMsg.msg.ethCmd.param[0] = rq_scmd & CLNK_CMD_BYTE_MASK;              /* wd 1 */             
+    mbxMsg.msg.ethCmd.param[1] = 0;                                         /* wd 2 */
+
+    if( iob->in_len )   // buffer to send
+    {
+        len = MIN_VAL(MAX_MBX_MSG - 3, iob->in_len >> 2);
+        for( i = 0 ; i < len ; i++ ) {
+            mbxMsg.msg.ethCmd.param[2 + i] = iob->in[i];                    /* wd 3+ */
+        }
+    } else {            // single long to send
+        mbxMsg.msg.ethCmd.param[2] = (SYS_UINTPTR)iob->in ;                 /* wd 3 */
+        len = 1;        // len is in longs
+    }
+
+    error = Clnk_MBX_SendMsg( &dccp->mailbox, &mbxMsg, &tid, 3 + len );
+
+    return( error );
+}
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ClnkMbx_call.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ClnkMbx_call.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ClnkMbx_call.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ClnkMbx_call.c	2012-09-14 14:51:36.900949000 +0530
@@ -0,0 +1,606 @@
+/*******************************************************************************
+*
+* Common/Src/ClnkMbx_call.c
+*
+* Description: mailbox common functions
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+/*******************************************************************************
+*                             # D e f i n e s                                  *
+********************************************************************************/
+
+
+
+
+
+/*******************************************************************************
+*            S t a t i c   M e t h o d   P r o t o t y p e s                   *
+********************************************************************************/
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/**
+ * Callback function for unsolicited mailbox messages
+ *
+ * This function is called from the ClnkMbx read interrupt when an unsolicited
+ * message appears on the SW unsol queue.
+ *
+ * Unsolicited messages poked into the hardware mailbox CSRs are unsupported
+ * and should never be produced by the embedded.
+ * 
+ * vcp       - void pointer to control context
+ * pMsg      - Struct containing newly received message in DRIVER SPACE
+ *             Some of the cases in this function modify this message
+ *
+ * Returns 1 for message consumed. 0 for message NOT consumed.
+ *
+*PUBLIC***************************************************************************/
+int MbxSwUnsolRdyCallback(void *vcp, Clnk_MBX_Msg_t *pMsg)
+{
+    int consumed = 1 ;              // message consumed flag
+    dc_context_t *dccp = vcp;
+    switch (pMsg->msg.maxMsg.msg[0])
+    {
+        case CLNK_MBX_UNSOL_MSG_ADMISSION_STATUS:
+        case CLNK_MBX_UNSOL_MSG_BEACON_STATUS:
+        case CLNK_MBX_UNSOL_MSG_RESET:
+            consumed = 0 ;
+            break;
+
+#if defined(CLNK_ETH_BRIDGE) 
+        case CLNK_MBX_UNSOL_MSG_UCAST_PUB:
+            break;
+#endif
+#if defined(CLNK_ETH_BRIDGE) 
+        case CLNK_MBX_UNSOL_MSG_UCAST_UNPUB:
+            break;
+#endif
+        case CLNK_MBX_UNSOL_MSG_NODE_ADDED:
+            break;
+        case CLNK_MBX_UNSOL_MSG_NODE_DELETED:
+            break; 
+//#ifdef CLNK_ETH_PHY_DATA_LOG
+        case CLNK_MBX_UNSOL_MSG_EVM_DATA_READY:
+            //HostOS_PrintLog(L_INFO, "FSUPDATE: IMO Node = %d\n", pMsg->msg.maxMsg.msg[1]);
+               
+            if (dccp->evmData)
+            {
+                int i;
+
+                dccp->evmData->valid = SYS_FALSE;                   // Don't let others read the data while it s updated
+                dccp->evmData->NodeId = pMsg->msg.maxMsg.msg[1];    // Get the data 
+                for (i=0;i<256;i++)
+                {    
+                    dccp->evmData->Data[i]=0;
+                }
+                dccp->evmData->valid = SYS_TRUE;      
+            }            
+            consumed = 0 ;
+            break;
+//#endif
+#if FEATURE_FEIC_PWR_CAL
+        // for MII
+        case CLNK_MBX_UNSOL_MSG_FEIC_STATUS_READY:
+        {
+            int i, j, lshift;
+            SYS_UINT32 dbg_mask;
+            SYS_INT32 feic_profileID;
+            SYS_INT32 feicdata_array[sizeof(FeicStatusData_t)/4]; //= 95 words (normal)
+            FeicStatusData_t * feicstatus_data;
+            SYS_UCHAR temp_array[4];
+            SYS_UINT32 pfeicdata_src;
+
+            clnk_reg_read(dccp, DEV_SHARED(dbgMask), &dbg_mask);
+            clnk_reg_read(dccp, DEV_SHARED(feicProfileId), &feic_profileID);
+            //Code below packs feic status data from SoC to host driver in a portable fashion,
+            //such that we avoid any endianess issues.
+            pfeicdata_src = pMsg->msg.maxMsg.msg[2];
+            for (i = 0; i < sizeof(feicdata_array)/4; i++) 
+            {
+                clnk_reg_read(dccp, pfeicdata_src, (SYS_UINT32 *)temp_array); //copy one word from SoC
+                for (j = 0; j < 4; j++) 
+                {
+                    lshift = 24 - 8 * (j - (j/4)*4);
+                    feicdata_array[i] &= ~(0xff << lshift); //clear byte location
+                    feicdata_array[i] |= ((temp_array[j] & 0xff) << lshift); //store value in location
+                }
+                pfeicdata_src += 4;
+            }
+
+            feicstatus_data = (FeicStatusData_t*)feicdata_array;
+            
+            // Display FEIC status (Internal usage only)
+            if ((dbg_mask & 0x1) && (feic_profileID > 0))
+            {
+                // Display Target Power Status Variables
+#if (NETWORK_TYPE_HIRF_MESH || NETWORK_TYPE_MIDHIRF_MESH)
+#define FS_FREQ_START   800000000
+#define FS_FREQ_STEP    25000000
+#elif NETWORK_TYPE_MIDRF_MESH
+#define FS_FREQ_START   400000000
+#define FS_FREQ_STEP    (25000000/2)
+#endif
+#define IDX_TO_FREQ(i)  (FS_FREQ_START + (i) * FS_FREQ_STEP)
+                HostOS_PrintLog(L_INFO, "TempAdc: 0x%02x Freq: %4d MHz  TgtLsbBias: %3d  TgtDeltaAdc(+bias): 0x%02x  TgtPwr: %2d.%1d dBm \n\n",
+                            feicstatus_data->targetPwrStatus.tempAdc,
+                            IDX_TO_FREQ(feicstatus_data->targetPwrStatus.freqIndex) / 1000000,
+                            feicstatus_data->targetPwrStatus.targetLsbBias,
+                            feicstatus_data->targetPwrStatus.tLsbPlusTargetLsbBias,
+                            (SYS_INT8)(feicstatus_data->targetPwrStatus.targetPwrDbmT10 / 10),
+                            (feicstatus_data->targetPwrStatus.targetPwrDbmT10 < 0 ? 
+                               (feicstatus_data->targetPwrStatus.targetPwrDbmT10 * -1) % 10:
+                                feicstatus_data->targetPwrStatus.targetPwrDbmT10 % 10));
+                    
+                // Display Intermediate Detector Status Variables
+                //Iteration 0 status variables (M0)
+                if ((*(SYS_UINT32 *)&feicstatus_data->intermediateDetectorStatus.m0TxOn[0] != 0) ||
+                    (*(SYS_UINT32 *)&feicstatus_data->intermediateDetectorStatus.m0TxOn[NUM_ADC_MEASUREMENTS-4] != 0))
+                {
+#if (NETWORK_TYPE_HIRF_MESH || NETWORK_TYPE_MIDHIRF_MESH)
+                    HostOS_PrintLog(L_INFO, "M0FeicAtt2: %2d  M0Feic_Att1: %2d  M0TxCalDecrN: %2d  M0TxdCGainSel: %2d \n",
+                           feicstatus_data->intermediateDetectorStatus.m0FeicAtt2,
+#elif NETWORK_TYPE_MIDRF_MESH
+                    HostOS_PrintLog(L_INFO, "M0FeicAtt2: N/A  M0Feic_Att1: %2d  M0TxCalDecrN: %2d  M0TxdCGainSel: %2d \n",
+#endif
+                           feicstatus_data->intermediateDetectorStatus.m0FeicAtt1,
+                           feicstatus_data->intermediateDetectorStatus.m0RficTxCal,
+                           feicstatus_data->intermediateDetectorStatus.m0TxdCGainSel);
+                    for (i = 0; i < NUM_ADC_MEASUREMENTS; i += 16)
+                    {
+                        HostOS_PrintLog(L_INFO, "%s: %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x\n",
+                                        i == 0 ? "M0TxOn" : "      ",
+                                        feicstatus_data->intermediateDetectorStatus.m0TxOn[i+0],
+                                        feicstatus_data->intermediateDetectorStatus.m0TxOn[i+1],
+                                        feicstatus_data->intermediateDetectorStatus.m0TxOn[i+2],
+                                        feicstatus_data->intermediateDetectorStatus.m0TxOn[i+3],
+                                        feicstatus_data->intermediateDetectorStatus.m0TxOn[i+4],
+                                        feicstatus_data->intermediateDetectorStatus.m0TxOn[i+5],
+                                        feicstatus_data->intermediateDetectorStatus.m0TxOn[i+6],
+                                        feicstatus_data->intermediateDetectorStatus.m0TxOn[i+7],
+                                        feicstatus_data->intermediateDetectorStatus.m0TxOn[i+8],
+                                        feicstatus_data->intermediateDetectorStatus.m0TxOn[i+9],
+                                        feicstatus_data->intermediateDetectorStatus.m0TxOn[i+10],
+                                        feicstatus_data->intermediateDetectorStatus.m0TxOn[i+11],
+                                        feicstatus_data->intermediateDetectorStatus.m0TxOn[i+12],
+                                        feicstatus_data->intermediateDetectorStatus.m0TxOn[i+13],
+                                        feicstatus_data->intermediateDetectorStatus.m0TxOn[i+14],
+                                        feicstatus_data->intermediateDetectorStatus.m0TxOn[i+15]);
+                    }      
+                    HostOS_PrintLog(L_INFO, "M0AdcOn: %2d    M0AdcOff: %2d   M0DeltaAdcBelowMin:  %2d \n\n",
+                           feicstatus_data->intermediateDetectorStatus.m0TxOnAvg,
+                           feicstatus_data->intermediateDetectorStatus.m0TxOffAvg,
+                           feicstatus_data->intermediateDetectorStatus.m0DeltaAdcBelowMin);
+                }
+
+                //Iteration 1 status variables (M1)
+                if ((*(SYS_UINT32 *)&feicstatus_data->intermediateDetectorStatus.m1TxOn[0] != 0) ||
+                    (*(SYS_UINT32 *)&feicstatus_data->intermediateDetectorStatus.m1TxOn[NUM_ADC_MEASUREMENTS-4] != 0))
+                {
+#if (NETWORK_TYPE_HIRF_MESH || NETWORK_TYPE_MIDHIRF_MESH)
+                    HostOS_PrintLog(L_INFO, "M1FeicAtt2: %2d  M1Feic_Att1: %2d  M1TxCalDecrN: %2d  M1TxdCGainSel: %2d \n",
+                           feicstatus_data->intermediateDetectorStatus.m1FeicAtt2,
+#elif NETWORK_TYPE_MIDRF_MESH
+                    HostOS_PrintLog(L_INFO, "M1FeicAtt2: N/A  M1Feic_Att1: %2d  M1TxCalDecrN: %2d  M1TxdCGainSel: %2d \n",
+#endif
+                           feicstatus_data->intermediateDetectorStatus.m1FeicAtt1,
+                           feicstatus_data->intermediateDetectorStatus.m1RficTxCal,
+                           feicstatus_data->intermediateDetectorStatus.m1TxdCGainSel);
+                    for (i = 0; i < NUM_ADC_MEASUREMENTS; i += 16)
+                    {
+                        HostOS_PrintLog(L_INFO, "%s: %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x\n",
+                                        i == 0 ? "M1TxOn" : "      ",
+                                        feicstatus_data->intermediateDetectorStatus.m1TxOn[i+0],
+                                        feicstatus_data->intermediateDetectorStatus.m1TxOn[i+1],
+                                        feicstatus_data->intermediateDetectorStatus.m1TxOn[i+2],
+                                        feicstatus_data->intermediateDetectorStatus.m1TxOn[i+3],
+                                        feicstatus_data->intermediateDetectorStatus.m1TxOn[i+4],
+                                        feicstatus_data->intermediateDetectorStatus.m1TxOn[i+5],
+                                        feicstatus_data->intermediateDetectorStatus.m1TxOn[i+6],
+                                        feicstatus_data->intermediateDetectorStatus.m1TxOn[i+7],
+                                        feicstatus_data->intermediateDetectorStatus.m1TxOn[i+8],
+                                        feicstatus_data->intermediateDetectorStatus.m1TxOn[i+9],
+                                        feicstatus_data->intermediateDetectorStatus.m1TxOn[i+10],
+                                        feicstatus_data->intermediateDetectorStatus.m1TxOn[i+11],
+                                        feicstatus_data->intermediateDetectorStatus.m1TxOn[i+12],
+                                        feicstatus_data->intermediateDetectorStatus.m1TxOn[i+13],
+                                        feicstatus_data->intermediateDetectorStatus.m1TxOn[i+14],
+                                        feicstatus_data->intermediateDetectorStatus.m1TxOn[i+15]);
+                    }      
+                    HostOS_PrintLog(L_INFO, "M1AdcOn: %2d \n\n",
+                           feicstatus_data->intermediateDetectorStatus.m1TxOnAvg);
+                }
+
+                //Iteration 2 status variables (M2)
+                if ((*(SYS_UINT32 *)&feicstatus_data->intermediateDetectorStatus.m2TxOn[0] != 0) ||
+                    (*(SYS_UINT32 *)&feicstatus_data->intermediateDetectorStatus.m2TxOn[NUM_ADC_MEASUREMENTS-4] != 0))
+                {
+#if (NETWORK_TYPE_HIRF_MESH || NETWORK_TYPE_MIDHIRF_MESH)
+                    HostOS_PrintLog(L_INFO, "M2FeicAtt2: %2d  M2Feic_Att1: %2d  M2TxCalDecrN: %2d  M2TxdCGainSel: %2d \n",
+                           feicstatus_data->intermediateDetectorStatus.m2FeicAtt2,
+#elif NETWORK_TYPE_MIDRF_MESH
+                    HostOS_PrintLog(L_INFO, "M2FeicAtt2: N/A  M2Feic_Att1: %2d  M2TxCalDecrN: %2d  M2TxdCGainSel: %2d \n",
+#else
+#error It needs to define one NETWORK TYPE!!
+#endif
+                           feicstatus_data->intermediateDetectorStatus.m2FeicAtt1,
+                           feicstatus_data->intermediateDetectorStatus.m2RficTxCal,
+                           feicstatus_data->intermediateDetectorStatus.m2TxdCGainSel);
+                    for (i = 0; i < NUM_ADC_MEASUREMENTS; i += 16)
+                    {
+                        HostOS_PrintLog(L_INFO, "%s: %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x\n",
+                                        i == 0 ? "M2TxOn" : "      ",
+                                        feicstatus_data->intermediateDetectorStatus.m2TxOn[i+0],
+                                        feicstatus_data->intermediateDetectorStatus.m2TxOn[i+1],
+                                        feicstatus_data->intermediateDetectorStatus.m2TxOn[i+2],
+                                        feicstatus_data->intermediateDetectorStatus.m2TxOn[i+3],
+                                        feicstatus_data->intermediateDetectorStatus.m2TxOn[i+4],
+                                        feicstatus_data->intermediateDetectorStatus.m2TxOn[i+5],
+                                        feicstatus_data->intermediateDetectorStatus.m2TxOn[i+6],
+                                        feicstatus_data->intermediateDetectorStatus.m2TxOn[i+7],
+                                        feicstatus_data->intermediateDetectorStatus.m2TxOn[i+8],
+                                        feicstatus_data->intermediateDetectorStatus.m2TxOn[i+9],
+                                        feicstatus_data->intermediateDetectorStatus.m2TxOn[i+10],
+                                        feicstatus_data->intermediateDetectorStatus.m2TxOn[i+11],
+                                        feicstatus_data->intermediateDetectorStatus.m2TxOn[i+12],
+                                        feicstatus_data->intermediateDetectorStatus.m2TxOn[i+13],
+                                        feicstatus_data->intermediateDetectorStatus.m2TxOn[i+14],
+                                        feicstatus_data->intermediateDetectorStatus.m2TxOn[i+15]);
+                    }      
+                    if ((*(SYS_UINT32 *)&feicstatus_data->intermediateDetectorStatus.m1TxOn[0] != 0) ||
+                        (*(SYS_UINT32 *)&feicstatus_data->intermediateDetectorStatus.m1TxOn[NUM_ADC_MEASUREMENTS-4] != 0))
+                    {
+                        // display correct value for M1Error_0.25dB
+                        HostOS_PrintLog(L_INFO, "M2AdcOn: %2d   M2DcOffset: %2d   M0Error_0.25dB: %2d  M1Error_0.25dB: %2d  M0M1ErrorSmall: %2d\n\n",
+                               feicstatus_data->intermediateDetectorStatus.m2TxOnAvg,
+                               feicstatus_data->intermediateDetectorStatus.m2DcOffset,
+                               feicstatus_data->intermediateDetectorStatus.m0ErrorQtrDb,
+                               feicstatus_data->intermediateDetectorStatus.m1ErrorQtrDb,
+                               feicstatus_data->intermediateDetectorStatus.m0m1ErrorSmall);
+                    }
+                    else
+                    {
+                        // display N/A for M1Error_0.25dB
+                        HostOS_PrintLog(L_INFO, "M2AdcOn: %2d   M2DcOffset: %2d   M0Error_0.25dB: %2d  M1Error_0.25dB: N/A  M0M1ErrorSmall: %2d\n\n",
+                               feicstatus_data->intermediateDetectorStatus.m2TxOnAvg,
+                               feicstatus_data->intermediateDetectorStatus.m2DcOffset,
+                               feicstatus_data->intermediateDetectorStatus.m0ErrorQtrDb,
+                               feicstatus_data->intermediateDetectorStatus.m0m1ErrorSmall);
+                    }
+
+                }
+
+                //Iteration 3 status variables (M3)
+                if ((*(SYS_UINT32 *)&feicstatus_data->intermediateDetectorStatus.m3TxOn[0] != 0) ||
+                    (*(SYS_UINT32 *)&feicstatus_data->intermediateDetectorStatus.m3TxOn[NUM_ADC_MEASUREMENTS-4] != 0))
+                {
+                    HostOS_PrintLog(L_INFO, "M3FeicAtt2: %2d  M3Feic_Att1: %2d  M3TxCalDecrN: %2d  M3TxdCGainSel: %2d \n",
+                           feicstatus_data->intermediateDetectorStatus.m3FeicAtt2,
+                           feicstatus_data->intermediateDetectorStatus.m3FeicAtt1,
+                           feicstatus_data->intermediateDetectorStatus.m3RficTxCal,
+                           feicstatus_data->intermediateDetectorStatus.m3TxdCGainSel);
+                    for (i = 0; i < NUM_ADC_MEASUREMENTS; i += 16)
+                    {
+                        HostOS_PrintLog(L_INFO, "%s: %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x\n",
+                                        i == 0 ? "M3TxOn" : "      ",
+                                        feicstatus_data->intermediateDetectorStatus.m3TxOn[i+0],
+                                        feicstatus_data->intermediateDetectorStatus.m3TxOn[i+1],
+                                        feicstatus_data->intermediateDetectorStatus.m3TxOn[i+2],
+                                        feicstatus_data->intermediateDetectorStatus.m3TxOn[i+3],
+                                        feicstatus_data->intermediateDetectorStatus.m3TxOn[i+4],
+                                        feicstatus_data->intermediateDetectorStatus.m3TxOn[i+5],
+                                        feicstatus_data->intermediateDetectorStatus.m3TxOn[i+6],
+                                        feicstatus_data->intermediateDetectorStatus.m3TxOn[i+7],
+                                        feicstatus_data->intermediateDetectorStatus.m3TxOn[i+8],
+                                        feicstatus_data->intermediateDetectorStatus.m3TxOn[i+9],
+                                        feicstatus_data->intermediateDetectorStatus.m3TxOn[i+10],
+                                        feicstatus_data->intermediateDetectorStatus.m3TxOn[i+11],
+                                        feicstatus_data->intermediateDetectorStatus.m3TxOn[i+12],
+                                        feicstatus_data->intermediateDetectorStatus.m3TxOn[i+13],
+                                        feicstatus_data->intermediateDetectorStatus.m3TxOn[i+14],
+                                        feicstatus_data->intermediateDetectorStatus.m3TxOn[i+15]);
+                    }      
+                    HostOS_PrintLog(L_INFO, "M3AdcOn: %2d    M3Error_0.25dB: %2d    M3ErrorSmall: %2d\n\n",
+                           feicstatus_data->intermediateDetectorStatus.m3TxOnAvg,
+                           feicstatus_data->intermediateDetectorStatus.m3ErrorQtrDb,
+                           feicstatus_data->intermediateDetectorStatus.m3ErrorSmall);
+                }
+
+                //Iteration 4 status variables (M4)
+                if ((*(SYS_UINT32 *)&feicstatus_data->intermediateDetectorStatus.m4TxOn[0] != 0) ||
+                    (*(SYS_UINT32 *)&feicstatus_data->intermediateDetectorStatus.m4TxOn[NUM_ADC_MEASUREMENTS-4] != 0))
+                {
+#if (NETWORK_TYPE_HIRF_MESH || NETWORK_TYPE_MIDHIRF_MESH)
+                    HostOS_PrintLog(L_INFO, "M4FeicAtt2: %2d  M4Feic_Att1: %2d  M4TxCalDecrN: %2d  M4TxdCGainSel: %2d \n",
+                           feicstatus_data->intermediateDetectorStatus.m4FeicAtt2,
+#elif NETWORK_TYPE_MIDRF_MESH
+                    HostOS_PrintLog(L_INFO, "M4FeicAtt2: N/A  M4Feic_Att1: %2d  M4TxCalDecrN: %2d  M4TxdCGainSel: %2d \n",
+#endif
+                           feicstatus_data->intermediateDetectorStatus.m4FeicAtt1,
+                           feicstatus_data->intermediateDetectorStatus.m4RficTxCal,
+                           feicstatus_data->intermediateDetectorStatus.m4TxdCGainSel);
+                    for (i = 0; i < NUM_ADC_MEASUREMENTS; i += 16)
+                    {
+                        HostOS_PrintLog(L_INFO, "%s: %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x %2x\n",
+                                        i == 0 ? "M4TxOn" : "      ",
+                                        feicstatus_data->intermediateDetectorStatus.m4TxOn[i+0],
+                                        feicstatus_data->intermediateDetectorStatus.m4TxOn[i+1],
+                                        feicstatus_data->intermediateDetectorStatus.m4TxOn[i+2],
+                                        feicstatus_data->intermediateDetectorStatus.m4TxOn[i+3],
+                                        feicstatus_data->intermediateDetectorStatus.m4TxOn[i+4],
+                                        feicstatus_data->intermediateDetectorStatus.m4TxOn[i+5],
+                                        feicstatus_data->intermediateDetectorStatus.m4TxOn[i+6],
+                                        feicstatus_data->intermediateDetectorStatus.m4TxOn[i+7],
+                                        feicstatus_data->intermediateDetectorStatus.m4TxOn[i+8],
+                                        feicstatus_data->intermediateDetectorStatus.m4TxOn[i+9],
+                                        feicstatus_data->intermediateDetectorStatus.m4TxOn[i+10],
+                                        feicstatus_data->intermediateDetectorStatus.m4TxOn[i+11],
+                                        feicstatus_data->intermediateDetectorStatus.m4TxOn[i+12],
+                                        feicstatus_data->intermediateDetectorStatus.m4TxOn[i+13],
+                                        feicstatus_data->intermediateDetectorStatus.m4TxOn[i+14],
+                                        feicstatus_data->intermediateDetectorStatus.m4TxOn[i+15]);
+                    }      
+                    HostOS_PrintLog(L_INFO, "M4AdcOn: %2d    M4Error_0.25dB: %2d\n\n",
+                           feicstatus_data->intermediateDetectorStatus.m4TxOnAvg,
+                           feicstatus_data->intermediateDetectorStatus.m4ErrorQtrDb);
+                }
+            }
+            
+            if (dbg_mask & 0x1)
+            {
+                // Display Final Configuration Status Variables
+                HostOS_PrintLog(L_INFO, "FeicProfileID: %d ProfFound:%s  CalDisabled: %s   CalBypassed: %s\n",
+                            feicstatus_data->finalConfigStatus.feicProfileId,
+                            (feicstatus_data->finalConfigStatus.feicFileFound ? "Yes" : "No"),
+                            (feicstatus_data->finalConfigStatus.CalDisabled ? "Yes" : "No"),
+                            (feicstatus_data->finalConfigStatus.CalBypassed ? "Yes" : "No"));
+#if (NETWORK_TYPE_HIRF_MESH || NETWORK_TYPE_MIDHIRF_MESH)
+                HostOS_PrintLog(L_INFO, "FeicAtt2: %d      Att1: %d    TxCalDecrN: %d   TxdCGainSel: %2d\n",
+                            feicstatus_data->finalConfigStatus.feicAtt2,
+#elif NETWORK_TYPE_MIDRF_MESH
+                HostOS_PrintLog(L_INFO, "FeicAtt2: N/A      Att1: %d    TxCalDecrN: %d   TxdCGainSel: %2d\n",
+#endif
+                            feicstatus_data->finalConfigStatus.feicAtt1,
+                            feicstatus_data->finalConfigStatus.rficTxCal,
+                            feicstatus_data->finalConfigStatus.txdCGainSel);
+                if (!feicstatus_data->finalConfigStatus.CalDisabled && !feicstatus_data->finalConfigStatus.CalBypassed)
+                {
+                    HostOS_PrintLog(L_INFO, "TempClass: %s    TgtLsbBias: %3d   FeicPwrEst: %2d.%1d dBm  CalErr: %s\n\n",
+                            (feicstatus_data->finalConfigStatus.tempClass ? "COM" : "IND"),
+                            feicstatus_data->finalConfigStatus.targetLsbBias,       //signed
+                            (SYS_INT8)(feicstatus_data->finalConfigStatus.pwrEstimateT10 / 10),
+                            (feicstatus_data->finalConfigStatus.pwrEstimateT10 < 0 ? 
+                               (feicstatus_data->finalConfigStatus.pwrEstimateT10 * -1) % 10:
+                                feicstatus_data->finalConfigStatus.pwrEstimateT10 % 10),
+                            (feicstatus_data->finalConfigStatus.calErr ? "Yes" : "No"));       
+                }
+                else
+                {
+                    HostOS_PrintLog(L_INFO, "TempClass: N/A   TgtLsbBias: N/A   FeicPwrEst: N/A          CalErr: N/A\n\n");       
+                }
+            }
+            break;
+        }
+#endif
+// #if CLNK_ETH_ECHO_PROFILE 
+#if 1 // modified for MID RF (DEBUG_EPP)
+         #define NUMBER_OF_RX_ECHO_PROBE_SYMBOLS 3
+         #define EP_RX_PROBE_SIZE ((256 + NUMBER_OF_RX_ECHO_PROBE_SYMBOLS*(256 + 64)) * 4)
+         #define EPP_RX_CORR_SIZE 256
+        case CLNK_MBX_UNSOL_MSG_ECHO_PROFILE_PROBE:
+            consumed = 0 ;
+	{
+            int  sample;
+            
+            dccp->eppData.nodeId = pMsg->msg.maxMsg.msg[2] & 0x0000FFFF;
+            dccp->eppData.probeId = pMsg->msg.maxMsg.msg[2] >> 16;
+            dccp->eppData.cpLen = pMsg->msg.maxMsg.msg[6] & 0x0000FFFF;
+            dccp->eppData.sysBias = pMsg->msg.maxMsg.msg[6] >> 16;
+            dccp->eppData.status = pMsg->msg.maxMsg.msg[7];
+
+            if (pMsg->msg.maxMsg.msg[1] & EPP_CAP_FLAGS_RAW_DATA)
+            {
+                clnk_blk_read(dccp, pMsg->msg.maxMsg.msg[3],
+                           dccp->eppData.rawData, EP_RX_PROBE_SIZE);
+                for (sample = 0; sample < 128; sample += 127)
+                {
+                    HostOS_PrintLog(L_DEBUG,
+                            "ProbeId:%-5u  "
+                            "Sample:%-3u  "
+                            "Status:%-2u  "
+                            "EPPraw:%u\n",
+                            (SYS_UINT32)dccp->eppData.probeId,
+                            (SYS_UINT32)sample,
+                            (SYS_UINT32)dccp->eppData.status,
+                            (SYS_UINT32)dccp->eppData.rawData[sample]);
+                }
+            }
+
+            if (pMsg->msg.maxMsg.msg[1] & EPP_CAP_FLAGS_CORR_DATA)
+            {
+                clnk_blk_read(dccp, pMsg->msg.maxMsg.msg[4],
+                           (SYS_UINT32 *)dccp->eppData.corrData,
+                           EPP_RX_CORR_SIZE);
+                clnk_blk_read(dccp, pMsg->msg.maxMsg.msg[5],
+                           (SYS_UINT32 *)dccp->eppData.corrEnergy,
+                           EPP_RX_CORR_SIZE);
+                for (sample = 0; sample < 128; sample +=127)
+                {
+                    HostOS_PrintLog(L_DEBUG,
+                            "ProbeId:%-5u  "
+                            "Sample:%-3u  "
+                            "Status:%-2u  "
+                            "CP=%-2u  "
+                            "SB:%-2u  "
+                            "EPPcorr:%-3u  "
+                            "EPPenergy:%-3u\n",
+                            (SYS_UINT32)dccp->eppData.probeId,
+                            (SYS_UINT32)sample,
+                            (SYS_UINT32)dccp->eppData.status,
+                            (SYS_UINT32)dccp->eppData.cpLen,
+                            (SYS_UINT32)dccp->eppData.sysBias,
+                            (SYS_UINT32)dccp->eppData.corrData[sample],
+                            (SYS_UINT32)dccp->eppData.corrEnergy[sample]);
+                }
+            }
+
+            dccp->eppData.valid |= pMsg->msg.maxMsg.msg[1];
+            //    return;
+        }
+
+            break;
+#endif
+#if (NETWORK_TYPE_ACCESS)
+        case CLNK_MBX_UNSOL_MSG_ACCESS_CHK_MAC:
+            consumed = 0 ;
+            break;
+#endif
+        case CLNK_MBX_UNSOL_MSG_TABOO_INFO:
+            HostOS_PrintLog(L_INFO, "FSUPDATE: Taboo Mask = 0x%06x, Offset = %d\n",
+                            pMsg->msg.maxMsg.msg[1] >> 8,
+                            pMsg->msg.maxMsg.msg[1] & 0x0ff);
+            consumed = 0 ;
+            break;
+        case CLNK_MBX_UNSOL_MSG_FSUPDATE:
+#if 0 
+            HostOS_PrintLog(L_INFO, 
+                            "FSUPDATE: Pass = %2d, Tuned Freq = %4d.%1d MHz (%d)\n",
+                            pMsg->msg.maxMsg.msg[1] >> 16,
+                            400 +  ((pMsg->msg.maxMsg.msg[1] & 0x00ff) * 125/10), (((pMsg->msg.maxMsg.msg[1] & 0x00ff)% 2) ? 5: 0),
+                            (pMsg->msg.maxMsg.msg[1] >> 8) & 0x00ff);   
+#else
+#define FS_FREQ_START(band) (band <= FREQ_BAND_D ? 800 : (band == FREQ_BAND_E ? 500 : 675 /*band f*/))
+            if (dccp->freqBand == FREQ_BAND_TRIKA)
+            {
+                int trika_subband = (pMsg->msg.maxMsg.msg[1] >> 6) & 0x3; // band D or E
+                /*HostOS_PrintLog(L_INFO, "subband = %d\n", trika_subband);
+                HostOS_PrintLog(L_INFO, "start freq = %d\n", FS_FREQ_START(trika_subband));
+                HostOS_PrintLog(L_INFO, "idx = %d\n", pMsg->msg.maxMsg.msg[1] & 0x003f);*/
+                HostOS_PrintLog(L_INFO,
+                            "FSUPDATE: Pass = %2d, Tuned Freq = %4d MHz (%d)\n",
+                            pMsg->msg.maxMsg.msg[1] >> 16,
+                            FS_FREQ_START(trika_subband) +  ((pMsg->msg.maxMsg.msg[1] & 0x003f) * 25),
+                            (pMsg->msg.maxMsg.msg[1] >> 8) & 0x00ff);                
+
+            }
+            else
+            {
+                HostOS_PrintLog(L_INFO,
+                            "FSUPDATE: Pass = %2d, Tuned Freq = %4d MHz (%d)\n",
+                            pMsg->msg.maxMsg.msg[1] >> 16,
+                            FS_FREQ_START(dccp->freqBand) +  ((pMsg->msg.maxMsg.msg[1] & 0x003f) * 25),
+                            (pMsg->msg.maxMsg.msg[1] >> 8) & 0x00ff);
+            }
+#endif
+            consumed = 0 ;
+            break;
+
+        case CLNK_MBX_UNSOL_MSG_ADD_CAM_FLOW_ENTRY:
+            break;
+
+        case CLNK_MBX_UNSOL_MSG_DELETE_CAM_FLOW_ENTRIES:
+            break;
+
+#if ECFG_FLAVOR_VALIDATION==1
+        case CLNK_MBX_UNSOL_MSG_VAL_ISOC_EVENT:
+            consumed = 0 ;
+            break ;
+#endif
+        default:
+            consumed = 0 ;
+            break;
+    }
+
+    return( consumed ) ;
+}
+
+
+/**
+ * \brief Callback function for HOST_ORIG mailbox messages
+ *
+ * This function is called from the ClnkMbx read interrupt when a mailbox
+ * reply to a HOST_ORIG message is received.
+ *
+ * The only message we actually process in this callback is the
+ * ETH_MB_GET_STATUS / CLNK_MBX_ETH_GET_STATUS_CMD response.
+ * socStatusEmbedded is used later in Get SocStatus().
+ *
+ * \param[in] pvContext void pointer to our dc_context_t
+ * \param[in] pMsg Struct containing newly received message
+ *
+*PUBLIC*****************************************************************/
+void MbxReplyRdyCallback(void *vcp, Clnk_MBX_Msg_t* pMsg)
+{
+#if 000
+    dc_context_t *dccp = vcp;
+    SYS_UINT8  transID;
+
+    transID = (SYS_UINT8)CLNK_MBX_GET_TRANS_ID(pMsg->msg.ethReply.status);
+    if (transID == dccp->socStatusLastTransID)
+    {
+        /*
+         * This reply comes from ETH_MB_GET_STATUS in the embedded.
+         * If there was a reset condition, it copied the reset reason into
+         * param[0].  Otherwise, it wrote 0.
+         */
+        if (pMsg->msg.ethReply.param[0] != 0)
+        {
+            dccp->socStatusEmbedded =
+                CLNK_DEF_SOC_STATUS_EMBEDDED_FAILURE |
+                ((pMsg->msg.ethReply.param[0] & 0xffff) << 16);
+        }
+        dccp->socStatusInProgress  = SYS_FALSE;
+        dccp->socStatusLastTransID = 0;
+    }
+#endif
+}
+
+
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ClnkMbx_dvr.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ClnkMbx_dvr.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ClnkMbx_dvr.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ClnkMbx_dvr.c	2012-09-14 14:51:36.904946000 +0530
@@ -0,0 +1,1561 @@
+/*******************************************************************************
+*
+* Common/Src/ClnkMbx_dvr.c
+*
+* Description: Common Mailbox Module
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+/*******************************************************************************
+*                             # D e f i n e s                                  *
+********************************************************************************/
+
+
+// Mailbox version number
+#define VER_NUM                  0x00
+
+// Queue Constants
+#define CMD_QUEUE_MASK           (CLNK_MBX_CMD_QUEUE_SIZE-1)
+#define SWUNSOL_QUEUE_MASK       (CLNK_MBX_SWUNSOL_QUEUE_SIZE-1)
+
+// Transaction ID Constants
+#define HOST_ORIG_BIT            0x80UL
+#define UNSOL_TYPE_BIT           0x40UL
+
+#if ECFG_CHIP_ZIP1
+  #define IS_READ_INTERRUPT(y)     ((y) & \
+          (CLNK_REG_PCI_READ_MBX_SEM_SET_BIT | CLNK_REG_PCI_SW_INT_1_BIT))
+  #define IS_WRITE_INTERRUPT(y)    ((y) & (CLNK_REG_PCI_WRITE_MBX_SEM_CLR_BIT))
+  #define IS_SW_UNSOL_INTERRUPT(x) ((x) & CLNK_REG_PCI_SW_INT_1_BIT)
+  #define ACK_SW_UNSOL_INTERRUPT(x) \
+          { clnk_reg_write((x)->dc_ctx, CLNK_REG_SLAVE_1_MAP_ADDR, (x)->swUnsolQueueSlaveMap); }
+#else
+  #define IS_READ_INTERRUPT(y)     1
+  #define IS_WRITE_INTERRUPT(y)    1
+  #define IS_SW_UNSOL_INTERRUPT(x) 1
+  #define ACK_SW_UNSOL_INTERRUPT(x) {}
+#endif // ECFG_CHIP_ZIP1
+
+#define UMSG_ELEMENT(x, y)      ((x) + offsetof(Clnk_MBX_SwUnsolQueueEntry_t, y))
+
+
+/*******************************************************************************
+*                             D a t a   T y p e s                              *
+********************************************************************************/
+
+/*******************************************************************************
+*                             C o n s t a n t s                                *
+********************************************************************************/
+
+/*******************************************************************************
+*                             G l o b a l   D a t a                            *
+********************************************************************************/
+
+/*******************************************************************************
+*                       M e t h o d   P r o t o t y p e s                      *
+********************************************************************************/
+
+static void Clnk_MBX_Alloc_wqts( Clnk_MBX_Mailbox_t *pMbx );
+static int Clnk_MBX_wqt_condition( void *vmp );
+static SYS_VOID Clnk_MBX_msg_timer(SYS_ULONG data);
+static int Clnk_MBX_RcvMsg(Clnk_MBX_Mailbox_t *pMbx, 
+                           Clnk_MBX_Msg_t     *pMsg,
+                           SYS_UINT8          transID);
+static int Clnk_MBX_CheckReplyRdy(Clnk_MBX_Mailbox_t* pMbx, SYS_UINT8 transID);
+static void Clnk_MBX_Read_Hw_Mailbox_Clear_Ready(Clnk_MBX_Mailbox_t* pMbx);
+static void Clnk_MBX_Write_Hw_Mailbox_Set_Ready(Clnk_MBX_Mailbox_t* pMbx);
+static void Clnk_MBX_Read_Hw_Mailbox(Clnk_MBX_Mailbox_t* pMbx, void* pvMsg);
+static void Clnk_MBX_Write_Hw_Mailbox(Clnk_MBX_Mailbox_t* pMbx, void* pvMsg);
+
+#ifdef CLNK_MBX_AUTO_REPLY
+static void AutoReplyMsg(Clnk_MBX_Mailbox_t* pMbx);
+#endif
+
+/*******************************************************************************
+*                      M e t h o d   D e f i n i t i o n s                     *
+********************************************************************************/
+
+
+/*******************************************************************************
+*
+* Description:
+*       Initializes the Mailbox Module.
+*
+* Inputs:
+*       pMbx  - Pointer to the mailbox
+*       dcctx - pointer to the control context
+*       type  - Type of mailbox (Ethernet or MPEG)
+*
+* Outputs:
+*       SYS_SUCCESS or a nonzero error code
+*
+* Notes:
+*       It is assumed that sufficient time will elapse between the
+*       RST_STATE_INIT_CCPU and RST_STATE_INIT_MBX states of the
+*       reset state machine to allow the CCPU to initialize the
+*       mailbox registers before checking them in this routine
+*
+*******************************************************************************/
+int Clnk_MBX_Initialize(Clnk_MBX_Mailbox_t *pMbx, void *dcctx, SYS_UINT32 type)
+{
+    SYS_UINT32 reg;
+    dc_context_t *dccp = (dc_context_t *)dcctx ;
+
+    //HostOS_PrintLog(L_ERR, "Clnk_MBX_Initialize\n" );
+    // Free any wqts
+    Clnk_MBX_Free_wqts( pMbx ) ;
+
+    // Initialize mailbox block
+    HostOS_Memset(pMbx, 0, sizeof(Clnk_MBX_Mailbox_t));
+
+    pMbx->dc_ctx             = dccp;
+    pMbx->type               = type;
+    pMbx->cmdCurrTransID     = HOST_ORIG_BIT;
+
+    // Initialize mailbox locks
+    pMbx->mbx_lock          = dccp->mbx_cmd_lock_link ; 
+    pMbx->swUnsolLock       = dccp->mbx_swun_lock_link ;
+
+    // Initialize register offsets
+    if (pMbx->type == CLNK_MBX_ETHERNET_TYPE)
+    {
+        pMbx->writeMbxCsrOffset  = CLNK_REG_MBX_WRITE_CSR;
+        pMbx->readMbxCsrOffset   = CLNK_REG_MBX_READ_CSR;
+        pMbx->writeMbxRegOffset  = CLNK_REG_MBX_REG_1;
+        pMbx->readMbxRegOffset   = CLNK_REG_MBX_REG_9;
+        pMbx->readMbxSize        = MAX_MBX_MSG;
+        pMbx->writeMbxSize       = MAX_MBX_MSG;
+    }
+#if 0
+    HostOS_PrintLog(L_INFO, "Initialize register offsets\n");
+    HostOS_PrintLog(L_INFO, "unsol  = %x\n",pMbx->pSwUnsolQueue);
+    HostOS_PrintLog(L_INFO, "writeMbxCsrOffset = %x\n",CLNK_REG_MBX_WRITE_CSR);
+    HostOS_PrintLog(L_INFO, "readMbxCsrOffset = %x\n",CLNK_REG_MBX_READ_CSR);
+    HostOS_PrintLog(L_INFO, "writeMbxRegOffset = %x\n",CLNK_REG_MBX_REG_1);
+    HostOS_PrintLog(L_INFO, "readMbxRegOffset = %x\n",CLNK_REG_MBX_REG_9);
+    HostOS_PrintLog(L_INFO, "readMbxSize  = %x\n",MAX_MBX_MSG);
+    HostOS_PrintLog(L_INFO, "writeMbxSize = %x\n",MAX_MBX_MSG);
+#endif
+    // allocate all wqts, setup timers and wait queues
+    Clnk_MBX_Alloc_wqts( pMbx ) ;
+
+    // Confirm that the CCPU has initialized the mailbox registers
+    // Register was cleared by host driver before CCPU was released,
+    clnk_reg_read(pMbx->dc_ctx, CLNK_REG_MBX_REG_1, &reg);
+//    if (0 == reg) 
+//        return (~SYS_SUCCESS);
+    
+    pMbx->mbxOpen = SYS_TRUE;
+    
+    return (SYS_SUCCESS);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Frees all Mailbox message wqts.
+*
+* Inputs:
+*       pMbx            - Pointer to the mailbox
+*
+* Outputs:
+*
+*******************************************************************************/
+void Clnk_MBX_Free_wqts( Clnk_MBX_Mailbox_t *pMbx )
+{
+    int                         msg ;
+    Clnk_MBX_CmdQueueEntry_t    *mp ;
+
+    // for all messages
+    for( msg = 0 ; msg < CLNK_MBX_CMD_QUEUE_SIZE ; msg++ )
+    {
+        mp = &pMbx->cmdQueue[msg] ;
+        if( mp->msg_wqt )
+        {
+            HostOS_wqt_timer_del( mp->msg_wqt ) ;
+
+            HostOS_wqt_free( mp->msg_wqt );
+            mp->msg_wqt = 0 ;
+        }
+    }
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Terminates the Common Mailbox Module.
+*
+* Inputs:
+*       Clnk_MBX_Mailbox_t*  Pointer to the mailbox
+*
+* Outputs:
+*       None
+*
+*******************************************************************************/
+void Clnk_MBX_Terminate(Clnk_MBX_Mailbox_t* pMbx)
+{
+    // Terminate mailbox lock
+    HostOS_TermLock(pMbx->mbx_lock);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Controls the operation of the Common Mailbox Module.
+*
+* Inputs:
+*       Clnk_MBX_Mailbox_t*  Pointer to the mailbox
+*       int                  Driver option to control
+*       SYS_UINT32           Register offset or pointer to register offsets
+*       SYS_UINT32           Register value or pointer to register values
+*       SYS_UINT32           Length of data for bulk data
+*
+* Outputs:
+*       SYS_SUCCESS or a nonzero error code
+*
+* Notes:
+*       Driver option                     Parameters
+*       -------------                     ----------
+*       CLNK_MBX_CTRL_ENABLE_INTERRUPT    reg    - Not used
+*                                         val    - Not used
+*                                         length - Not used
+*       CLNK_MBX_CTRL_DISABLE_INTERRUPT   reg    - Not used
+*                                         val    - Not used
+*                                         length - Not used
+*       CLNK_MBX_CTRL_CLEAR_INTERRUPT     reg    - Not used
+*                                         val    - Not used
+*                                         length - Not used
+*       CLNK_MBX_CTRL_SET_SW_UNSOL_Q      reg    - Not used
+*                                         val    - Pointer to emb mem
+*                                         length - Number of entries
+*       CLNK_MBX_CTRL_SET_REPLY_RDY_CB    reg    - Not used
+*                                         val    - Function pointer
+*                                         length - Function parameter
+*       CLNK_MBX_CTRL_SET_UNSOL_RDY_CB    reg    - Not used
+*                                         val    - Function pointer
+*                                         length - Function parameter
+*       CLNK_MBX_CTRL_SET_SW_UNSOL_RDY_CB reg    - Not used
+*                                         val    - Function pointer
+*                                         length - Function parameter
+*
+*
+*******************************************************************************/
+int Clnk_MBX_Control(Clnk_MBX_Mailbox_t* pMbx, 
+                     int option, 
+                     SYS_UINTPTR reg,
+                     SYS_UINTPTR val, 
+                     SYS_UINTPTR length)
+{
+    int status = SYS_SUCCESS;
+
+    switch (option)
+    {
+        case CLNK_MBX_CTRL_SET_SW_UNSOL_Q:
+            // Initialize the software unsolicited queue
+        #if ECFG_CHIP_ZIP1
+            pMbx->swUnsolQueueSlaveMap = (val & 0x0ffc0000) |
+                                         CLNK_REG_ADDR_TRANS_ENABLE_BIT;
+            pMbx->pSwUnsolQueue        =  val & 0x0003ffff;
+        #else
+            pMbx->pSwUnsolQueue        = val;
+        #endif 
+            pMbx->swUnsolQueueSize     = length;
+            pMbx->swUnsolReadIndex     = 0;
+            break;
+
+        case CLNK_MBX_CTRL_SET_REPLY_RDY_CB:
+            // Set the reply ready callback function   MbxReplyRdyCallback
+            pMbx->replyRdyCallback = (Clnk_MBX_RdyCallback)val;
+            pMbx->replyParam       = (void *)length;
+            break;
+
+        case CLNK_MBX_CTRL_SET_SW_UNSOL_RDY_CB:
+            // Set the unsolicited ready callback function   MbxSwUnsolRdyCallback
+            pMbx->swUnsolRdyCallback = (Clnk_MBX_SwUnsolRdyCallback)val;
+            pMbx->swUnsolParam       = (void *)length; // context at this point
+            break;
+
+        default:
+            status = -SYS_BAD_MSG_TYPE_ERROR;
+            break;
+    }
+    return (status);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Handles the interrupt for the Common Mailbox Module.
+*
+* Inputs:
+*       Clnk_MBX_Mailbox_t*  Pointer to the mailbox
+*       SYS_UINT32           PCI interrupt status register
+*
+* Outputs:
+*       None
+*
+* Notes:
+*       None
+*
+*
+*******************************************************************************/
+void Clnk_MBX_HandleInterrupt(Clnk_MBX_Mailbox_t* pMbx, SYS_UINT32 pciIntStatus)
+{
+
+    // Check if hardware mailbox has command response
+    if (IS_READ_INTERRUPT(pciIntStatus))
+    {
+        Clnk_MBX_Read_ISR(pMbx);
+    }
+
+    // Check if hardware mailbox has unsolicited msg
+    if ( IS_SW_UNSOL_INTERRUPT(pciIntStatus) )
+    {
+        Clnk_MBX_Unsol_ISR(pMbx);
+    }
+
+    // Check if hardware mailbox can take a command
+    if (IS_WRITE_INTERRUPT(pciIntStatus))
+    {
+        Clnk_MBX_Write_ISR(pMbx);
+    }
+}
+
+/*******************************************************************************
+*
+* Description:
+*           Sends a mailbox message.
+*
+* Inputs:   pMbx     - Pointer to the mailbox
+*           pMsg     - Pointer to the message to send
+*           pTransID - Pointer to place to return the transaction ID
+*           len      - length of message in longs
+*
+* Exports:  0           - success, message queued/sent
+*           -SYS_INVALID_ADDRESS_ERROR     - mailbox not open
+*           -SYS_INVALID_ARGUMENT_ERROR    - invalid request, length
+*           -SYS_OUT_OF_SPACE_ERROR        - queue full, message dropped
+*
+*******************************************************************************/
+int Clnk_MBX_SendMsg(Clnk_MBX_Mailbox_t *pMbx, 
+                     Clnk_MBX_Msg_t     *pMsg,
+                     SYS_UINT8          *pTransID, 
+                     SYS_UINT32          len)
+{
+    SYS_UINT32 index;
+
+    if (!pMbx->mbxOpen) 
+        return(-SYS_INVALID_ADDRESS_ERROR);
+
+    if((len < 1) || (len > MAX_MBX_MSG))
+    {
+        HostOS_PrintLog(L_ERR, "warning: invalid mbx request: %d words\n", len);
+        return(-SYS_INVALID_ARGUMENT_ERROR);
+    }
+
+    // Lock the mailbox
+    HostOS_Lock(pMbx->mbx_lock);
+
+    /*  
+        Check if mailbox is (too) full.  
+        Note that we always leave two entries empty.
+        This is the only place Send messages are queued so it's safe to say
+        that this is the only place where tail may attempt to overrun head.
+    */
+    if (((pMbx->cmdTailIndex+3) & CMD_QUEUE_MASK) == pMbx->cmdHeadIndex)
+    {
+        // mailbox full - log queuing error
+        HostOS_Unlock(pMbx->mbx_lock);
+        return (-SYS_OUT_OF_SPACE_ERROR);
+    }
+
+    // Save the transaction ID for the command
+    *pTransID = pMbx->cmdCurrTransID;    // push the transID back to the caller
+    index = pMbx->cmdTailIndex;
+    pMbx->cmdQueue[index].transID    = *pTransID;
+    pMbx->cmdQueue[index].isReplyRdy = SYS_FALSE;
+    pMsg->msg.cmdCode |=                                        // byte 0 = cmd
+                         CLNK_MBX_SET_TRANS_ID(*pTransID) |     // byte 1
+                         CLNK_MBX_SET_VER_NUM(VER_NUM)    |     // byte 2 lo nybl
+                         CLNK_MBX_SET_PORT(pMbx->type)    |     // byte 2 hi nybl
+                         CLNK_MBX_SET_LEN(len);                 // byte 3  (num longs)
+
+    // Copy message to into mail box buffer
+    HostOS_Memcpy(&pMbx->cmdQueue[index].sendMsg, pMsg, len * sizeof(SYS_UINT32));
+
+    // Check if Q empty and hardware mailbox is in use
+    if ((pMbx->cmdTailIndex == pMbx->cmdHeadIndex) &&
+        Clnk_MBX_Write_Hw_Mailbox_Check_Ready(pMbx))
+    {
+        // Write message to hardware mailbox
+        Clnk_MBX_Write_Hw_Mailbox(pMbx, pMsg);
+
+        // Effectively Q the msg. There might be a response
+        // Since the Q is empty move the head along, too, so head will stay at or ahead of tail
+        pMbx->cmdHeadIndex = (pMbx->cmdHeadIndex+1) & CMD_QUEUE_MASK;
+        pMbx->cmdTailIndex = (pMbx->cmdTailIndex+1) & CMD_QUEUE_MASK;
+    }
+    else
+    {
+        //HostOS_PrintLog(L_NOTICE, "SendMsg to Q  tid=%02xx\n", *pTransID);
+
+        // Add entry to tail of command queue
+        pMbx->cmdTailIndex = (pMbx->cmdTailIndex+1) & CMD_QUEUE_MASK;
+    }
+
+    // Generate new transaction ID (make sure host originated bit is set)
+    pMbx->cmdCurrTransID++;
+    pMbx->cmdCurrTransID |= HOST_ORIG_BIT;
+
+    // Unlock the mailbox
+    HostOS_Unlock(pMbx->mbx_lock);
+
+#ifdef CLNK_MBX_AUTO_REPLY
+    // Automatically generate reply
+    AutoReplyMsg(pMbx);
+#endif
+    return (SYS_SUCCESS);
+}
+
+/*******************************************************************************
+*
+* Purpose:  Receives a sw unsolicited mailbox message.
+*           This reads messages that have not been internally
+*           consumed from the sw unsolicited Q.
+*           There may not be any such messages.
+*           There may have been a Q overrun.
+*
+* Imports:  pMbx    - Pointer to the mailbox
+*           pbuf    - Pointer to a kernel buffer to get the message
+*
+* Exports:  0           - success, no more messages
+*           -SYS_DIR_NOT_EMPTY_ERROR  - success, more messages
+*           -SYS_BAD_MSG_TYPE_ERROR   - no message, try again later
+*           -SYS_INPUT_OUTPUT_ERROR   - queue overrun, oldest message returned
+*                                       and the overrun error is cleared
+*           -SYS_INVALID_ADDRESS_ERROR- mailbox not open
+*                                       sw unsolicited Q not setup
+*                                       other
+*
+*******************************************************************************/
+int Clnk_MBX_RcvUnsolMsg(Clnk_MBX_Mailbox_t *pMbx, 
+                         SYS_UINT32         *pbuf)
+{                   
+    SYS_UINT32      index;
+    int             error = 0 ;
+
+    if( !pMbx->mbxOpen)
+    {
+        error = -SYS_INVALID_ADDRESS_ERROR ;
+    }
+
+    // Check if software unsolicited queue has been created
+    if( !error && pMbx->pSwUnsolQueue == 0)
+    {
+        error = -SYS_INVALID_ADDRESS_ERROR ;
+    }
+
+    if( !error )
+    {
+        if( pMbx->swUnsolCount ) // we have message     
+        {
+            HostOS_Lock(pMbx->swUnsolLock);
+
+            // Copy message to receive buffer
+            index = pMbx->swUnsolHeadIndex;
+            HostOS_Memcpy(pbuf, 
+                          &pMbx->swUnsolQueue[index].msg.msg.maxMsg.msg, 
+                          MAX_UNSOL_MSG * sizeof(SYS_UINT32));
+
+            pMbx->swUnsolHeadIndex = (pMbx->swUnsolHeadIndex+1) & SWUNSOL_QUEUE_MASK;
+            pMbx->swUnsolCount-- ;          // uncount an item taken
+
+            if( pMbx->swUnsolCount ) // we have more
+            {
+                error = -SYS_DIR_NOT_EMPTY_ERROR ;
+            }
+            if( pMbx->swUnsolOverrun ) // we have overrun 
+            {
+                error = -SYS_INPUT_OUTPUT_ERROR ;
+                pMbx->swUnsolOverrun = 0 ;   // and clear it
+            }
+
+            HostOS_Unlock(pMbx->swUnsolLock);
+        }
+        else
+        {
+            error = -SYS_BAD_MSG_TYPE_ERROR ;
+        }
+    }
+    return( error );
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Sends and receives a mailbox message.
+*
+* Inputs:   pMbx        - Pointer to the mailbox
+*           pSendMsg    - Pointer to the message to send
+*           pRcvMsg     - Pointer to the buffer for receiving message
+*           len         - length of send message
+*           timeoutInUs - Time to wait for reply in ms
+*
+* Exports:  0           - success, message queued/sent
+*           -SYS_INVALID_ADDRESS_ERROR - mailbox not open
+*           -SYS_INPUT_OUTPUT_ERROR    - I/O error
+*           -SYS_TIMEOUT_ERROR         - timeout waiting for response
+*           ?           - other codes from called functions
+*
+*******************************************************************************/
+int Clnk_MBX_SendRcvMsg(Clnk_MBX_Mailbox_t  *pMbx, 
+                        Clnk_MBX_Msg_t      *pSendMsg,
+                        Clnk_MBX_Msg_t      *pRcvMsg, 
+                        SYS_UINT32          len,
+                        SYS_UINT32          timeoutInUs)
+{
+    SYS_UINT8                   transID;
+    int                         status;
+    Clnk_MBX_CmdQueueEntry_t    *mp ;
+
+    if (!pMbx->mbxOpen)
+    {
+        return (-SYS_INVALID_ADDRESS_ERROR);
+    }
+
+    // Send message    (get transaction ID)
+    status = Clnk_MBX_SendMsg(pMbx, pSendMsg, &transID, len);
+    //HostOS_PrintLog(L_INFO, "Clnk_MBX_SendRcvMsg send status=%d , transid=%x.\n", status,transID );
+    if (status != SYS_SUCCESS)
+    {
+        HostOS_PrintLog(L_ERR, "Unable to send msg!!\n");
+        return (status);
+    }
+
+    // setup to wait
+    HostOS_Lock(pMbx->mbx_lock);
+
+    if( !Clnk_MBX_CheckReplyRdy(pMbx, transID) )
+    {
+        // msg not ready - start wait
+        mp = &pMbx->cmdQueue[transID & CMD_QUEUE_MASK] ;
+        mp->isReplyTimedOut = 0 ;
+        HostOS_wqt_timer_set_timeout( mp->msg_wqt, HostOS_timer_expire_seconds(2));
+        HostOS_wqt_timer_add( mp->msg_wqt);
+
+        HostOS_Unlock(pMbx->mbx_lock);
+
+        HostOS_wqt_waitq_wait_event_intr( mp->msg_wqt,
+                                          Clnk_MBX_wqt_condition,
+                                          mp );
+
+        // done waiting
+        //HostOS_PrintLog(L_INFO, "We had to sleep!!\n");
+        HostOS_wqt_timer_del( mp->msg_wqt );
+    }
+    else
+    {
+        // msg ready already
+        //HostOS_PrintLog(L_INFO, "Msg read already - did not have to sleep\n");
+        HostOS_Unlock(pMbx->mbx_lock);
+    }
+
+    // msg should be ready now
+    if( Clnk_MBX_CheckReplyRdy(pMbx, transID) )
+    {
+        // Get the reply
+        status = Clnk_MBX_RcvMsg(pMbx, pRcvMsg, transID);
+    }
+    else
+    {
+        status = -SYS_TIMEOUT_ERROR ;  // timeout - no message
+    }
+
+    return (status);
+}
+
+
+// define U_SHOW_TRAFFIC to see unsol traffic
+#define xU_SHOW_TRAFFIC
+// define Q_SHOW to see the unsol Q
+#define xQ_SHOW
+// define Q_RESYNC to try to resync the unsol Q for when the SOC overruns it
+#define xQ_RESYNC
+
+#ifdef Q_SHOW
+extern int strcpy(char *, const char *) ;
+extern int strcmp(const char *, const char *) ;
+extern unsigned long volatile jiffies;
+#endif
+
+/*******************************************************************************
+*
+* Description:
+*       Handles the read interrupt.
+*
+* Inputs:
+*       pMbx         - Pointer to the mailbox
+*
+* Outputs:
+*       None
+*
+*******************************************************************************/
+void Clnk_MBX_Read_ISR( Clnk_MBX_Mailbox_t *pMbx )
+{
+    SYS_UINT32          offset, regVal;
+    SYS_UINT8           transID, index ;
+
+    if (Clnk_MBX_Read_Hw_Mailbox_Check_Ready(pMbx))
+    {
+        // Get the transaction ID
+        clnk_reg_read(pMbx->dc_ctx, pMbx->readMbxRegOffset, &offset);
+#if ECFG_CHIP_ZIP1
+        offset &= 0x3ffff;
+#endif
+        clnk_reg_read(pMbx->dc_ctx, offset, &regVal);
+        transID = regVal & 0xff;
+
+//HostOS_PrintLog(L_INFO, "Clnk_MBX_Read_ISR transid=%d \n", transID );
+        if (transID & HOST_ORIG_BIT)
+        {
+            index = transID & CMD_QUEUE_MASK;
+
+            // Lock the mailbox
+            HostOS_Lock(pMbx->mbx_lock);
+
+            // Check if transaction ID is valid
+            if (pMbx->cmdQueue[index].transID != transID)
+            {
+                // Toss message if transaction ID is not valid
+                Clnk_MBX_Read_Hw_Mailbox(pMbx, SYS_NULL);
+
+                // Unlock the mailbox
+                HostOS_Unlock(pMbx->mbx_lock);
+
+                return;
+            }
+
+            // Read message from hardware mailbox
+            Clnk_MBX_Read_Hw_Mailbox(pMbx, &pMbx->cmdQueue[index].rcvMsg);
+
+            // Mark reply as received
+            pMbx->cmdQueue[index].isReplyRdy = SYS_TRUE;
+//HostOS_PrintLog(L_INFO, "In ClnkMBX_READ_ISR  replyRdy = true\n");
+            // Call reply ready callback function
+            if (pMbx->replyRdyCallback != SYS_NULL)
+            {           // MbxReplyRdyCallback
+                pMbx->replyRdyCallback(pMbx->replyParam,
+                                       &pMbx->cmdQueue[index].rcvMsg);
+            }
+
+            // Unlock the mailbox
+            HostOS_Unlock(pMbx->mbx_lock);
+            HostOS_wqt_waitq_wakeup_intr( pMbx->cmdQueue[index].msg_wqt );
+
+        }
+        else
+        {
+            Clnk_MBX_Read_Hw_Mailbox(pMbx, SYS_NULL);       // discard this type of unsolicited msg
+        }
+    }
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Handles the write interrupt.
+*
+* Inputs:
+*       pMbx - Pointer to the mailbox
+*
+* Outputs:
+*       None
+*
+*******************************************************************************/
+void Clnk_MBX_Write_ISR( Clnk_MBX_Mailbox_t *pMbx )
+{
+
+    if (Clnk_MBX_Write_Hw_Mailbox_Check_Ready(pMbx))
+    {
+        // Lock the mailbox
+        HostOS_Lock(pMbx->mbx_lock);
+
+        // Check if command queue is emtpy
+        if (pMbx->cmdHeadIndex == pMbx->cmdTailIndex)
+        {
+            HostOS_Unlock(pMbx->mbx_lock);
+            return;
+        }
+
+        // Write message to hardware mailbox
+        Clnk_MBX_Write_Hw_Mailbox(pMbx, &pMbx->cmdQueue[pMbx->cmdHeadIndex].sendMsg);
+
+        // Remove entry from head of command queue
+        pMbx->cmdHeadIndex = (pMbx->cmdHeadIndex+1) & CMD_QUEUE_MASK;
+
+        // Unlock the mailbox
+        HostOS_Unlock(pMbx->mbx_lock);
+    }
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Handles the unsolicited message (read) interrupt.
+*
+* Inputs:
+*       pMbx         - Pointer to the mailbox
+*
+* Outputs:
+*       None
+*
+*******************************************************************************/
+void Clnk_MBX_Unsol_ISR( Clnk_MBX_Mailbox_t* pMbx )
+{
+    SYS_UINT32          tid;
+    SYS_UINT8           index;
+    SYS_UINT32          pSwUnsolMsg;
+    SYS_UINT32          ownership, i, *up, *qp, type ;
+    int                 consumed ;
+    Clnk_MBX_Msg_t      mbuf;
+#ifdef Q_SHOW
+    int                 hit ;
+    SYS_UINT32          pSwUnsolMsgX;
+    static char         ox[SW_UNSOL_HW_QUEUE_SIZE+1] ;
+    static SYS_UINT8    dexx ;
+#endif
+    // Check if software unsolicited queue has been created
+    if (pMbx->pSwUnsolQueue == 0)
+    {
+        return;
+    }
+
+    // Process the unsolicited messages
+
+    ACK_SW_UNSOL_INTERRUPT(pMbx);
+#if 1
+// for loop with clnk_reg_read caused hang
+    for ( ; ; )
+    {
+        // get the current index
+        index = pMbx->swUnsolReadIndex;
+
+        // Check ownership bit
+        pSwUnsolMsg = pMbx->pSwUnsolQueue + index * sizeof(Clnk_MBX_SwUnsolQueueEntry_t);
+        clnk_reg_read(pMbx->dc_ctx, UMSG_ELEMENT(pSwUnsolMsg, ownership), &ownership);
+        if (!ownership)
+        {
+            break ;
+        }
+#if 1
+        // we have a message, process it
+
+        // Generate transaction ID (make sure host originated bit is clear)
+        pMbx->swUnsolCurrTransID = index;
+        pMbx->swUnsolCurrTransID &= ~HOST_ORIG_BIT;
+        pMbx->swUnsolCurrTransID |= UNSOL_TYPE_BIT;
+        tid = pMbx->swUnsolCurrTransID;
+
+        clnk_reg_write(pMbx->dc_ctx, UMSG_ELEMENT(pSwUnsolMsg, transID), tid);
+
+        // process the message
+
+        // copy from hw Q to local msg buffer
+        up   = &mbuf.msg.maxMsg.msg[0] ; 
+#if 1
+        for (i = 0; i < MAX_UNSOL_MSG; i++, up++)
+        {
+            clnk_reg_read(pMbx->dc_ctx,
+                            UMSG_ELEMENT(pSwUnsolMsg, msg[0]) + (i << 2),
+                            up);
+        }
+#endif
+        up   = &mbuf.msg.maxMsg.msg[0] ; 
+        type = *up ;
+
+        consumed = 0 ;
+#if 1
+        if (pMbx->swUnsolRdyCallback != SYS_NULL)      // if there's a callback, call it
+        {               // MbxSwUnsolRdyCallback
+            consumed = pMbx->swUnsolRdyCallback(pMbx->swUnsolParam, &mbuf);
+#ifdef U_SHOW_TRAFFIC
+            if( consumed )
+            {
+                HostOS_PrintLog(L_NOTICE, "sw unsol msg, type=%d. consumed=%d tid=%xx\n",
+                                type, consumed, tid );
+            }
+#endif
+        }
+#endif
+#if 1
+        if( !consumed )
+        {
+            // queue msg in sw Q
+
+            HostOS_Lock(pMbx->swUnsolLock);
+
+            // copy from buffer to sw Q
+            qp = &pMbx->swUnsolQueue[pMbx->swUnsolTailIndex].msg.msg.maxMsg.msg[0] ; 
+            for (i = 0; i < MAX_UNSOL_MSG; i++)
+            {
+                *qp++ = *up++ ; 
+            }
+            up = &mbuf.msg.maxMsg.msg[0] ; 
+
+            if( pMbx->swUnsolCount == SW_UNSOL_HW_QUEUE_SIZE )
+            {  // if max count pMbx->swUnsolOverrun = 1 ;      // flag an error
+                // move head to oldest
+                pMbx->swUnsolHeadIndex = (pMbx->swUnsolHeadIndex+1) & SWUNSOL_QUEUE_MASK;
+            }
+            else
+            {
+                pMbx->swUnsolCount++ ;          // count an item added
+            }
+            // move tail off newest
+            pMbx->swUnsolTailIndex = (pMbx->swUnsolTailIndex+1) & SWUNSOL_QUEUE_MASK;
+
+            HostOS_Unlock(pMbx->swUnsolLock);
+#ifdef U_SHOW_TRAFFIC
+            HostOS_PrintLog(L_NOTICE, "sw unsol msg Qd, type=%d. cnt=%d. tid=%xx\n",
+                            *up, pMbx->swUnsolCount, tid );
+#endif
+        }
+
+#endif
+        // Clear ownership
+        clnk_reg_write(pMbx->dc_ctx, UMSG_ELEMENT(pSwUnsolMsg, ownership), 0);
+
+        // Increment HW's read index
+        pMbx->swUnsolReadIndex = (pMbx->swUnsolReadIndex+1) % pMbx->swUnsolQueueSize;
+#endif
+    }
+#endif
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Checks if the hardware mailbox is available to read.
+*
+* Inputs:
+*       pMbx - Pointer to the mailbox
+*
+* Outputs:
+*       1 if mailbox is available to read, 0 otherwise
+*
+*******************************************************************************/
+int Clnk_MBX_Read_Hw_Mailbox_Check_Ready(Clnk_MBX_Mailbox_t* pMbx)
+{
+    SYS_UINT32 regVal;
+
+    // Check if mailbox available to read
+    clnk_reg_read(pMbx->dc_ctx, pMbx->readMbxCsrOffset, &regVal);
+//HostOS_PrintLog(L_INFO, "HostCheckMailboxAvailToRead: readMbxCsrOffset = %x, regVal = %x \n",
+//                pMbx->readMbxCsrOffset, regVal);
+
+    return ((regVal & CLNK_REG_MBX_SEMAPHORE_BIT) != 0);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Checks if the hardware mailbox is available to write.
+*
+* Inputs:
+*       pMbx - Pointer to the mailbox
+*
+* Outputs:
+*       1 if mailbox is available to write, 0 otherwise
+*
+*******************************************************************************/
+int Clnk_MBX_Write_Hw_Mailbox_Check_Ready(Clnk_MBX_Mailbox_t* pMbx)
+{
+    SYS_UINT32 regVal;
+
+    // Check if mailbox available to write
+    clnk_reg_read(pMbx->dc_ctx, pMbx->writeMbxCsrOffset, &regVal);
+
+    return ((regVal & CLNK_REG_MBX_SEMAPHORE_BIT) == 0);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Checks if the write cmd message mailbox is empty.
+*
+* Inputs:
+*       pMbx - Pointer to the mailbox
+*
+* Outputs:
+*       1 = empty, 0 = !empty
+*
+*******************************************************************************/
+int Clnk_MBX_Send_Mailbox_Check_Empty(Clnk_MBX_Mailbox_t* pMbx)
+{
+    int mt ;
+
+    // Lock the mailbox
+    HostOS_Lock(pMbx->mbx_lock);
+
+    // Check if command queue is emtpy
+    mt = (pMbx->cmdHeadIndex == pMbx->cmdTailIndex) ;
+    
+    // Unlock the mailbox
+    HostOS_Unlock(pMbx->mbx_lock);
+
+    return( mt ) ;
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Checks if the hardware unsolicited mailbox is available to read.
+*
+* Inputs:
+*       pMbx - Pointer to the mailbox
+*
+* Outputs:
+*       1 if mailbox is available to read, 0 otherwise
+*
+*******************************************************************************/
+int Clnk_MBX_Unsol_Hw_Mailbox_Check_Ready(Clnk_MBX_Mailbox_t* pMbx)
+{
+    SYS_UINT8           index;
+    SYS_UINT32          pSwUnsolMsg;
+    SYS_UINT32          ownership ;
+
+    ownership = 0 ;
+
+    // get the current index
+    index = pMbx->swUnsolReadIndex;
+
+    // Check ownership bit
+    pSwUnsolMsg = pMbx->pSwUnsolQueue + index * sizeof(Clnk_MBX_SwUnsolQueueEntry_t);
+//    HostOS_PrintLog(L_INFO, "In Clnk_MBX_Unsol_Hw_Mailbox_Check_Ready: pMbx->pSwUnsolQueue=%x, index=%d, sizeofSwUnsolEntry=%d\n",
+//                    pMbx->pSwUnsolQueue, index , sizeof(Clnk_MBX_SwUnsolQueueEntry_t));
+    clnk_reg_read(pMbx->dc_ctx, UMSG_ELEMENT(pSwUnsolMsg, ownership), &ownership);
+//    clnk_reg_read(pMbx->dc_ctx, 0x8c00b204, &ownership);
+if (ownership == 1)
+    return(1);
+else 
+    return(0);
+}
+
+
+/*******************************************************************************
+*
+* Description:
+*       Allocates all Mailbox message wqts.
+*       Sets up the timer and wq.
+*
+* Inputs:
+*       pMbx            - Pointer to the mailbox
+*
+* Outputs:
+*
+*******************************************************************************/
+static void Clnk_MBX_Alloc_wqts( Clnk_MBX_Mailbox_t *pMbx )
+{
+    int                         msg ;
+    Clnk_MBX_CmdQueueEntry_t    *mp ;
+
+    // for all messages
+    for( msg = 0 ; msg < CLNK_MBX_CMD_QUEUE_SIZE ; msg++ )
+    {
+        mp = &pMbx->cmdQueue[msg] ;
+        if( !mp->msg_wqt ) {
+            mp->msg_wqt = HostOS_wqt_alloc( );
+            if( mp->msg_wqt )
+            {
+                HostOS_wqt_waitq_init( mp->msg_wqt );
+                HostOS_wqt_timer_init( mp->msg_wqt );
+                HostOS_wqt_timer_setup( mp->msg_wqt , 
+                                        Clnk_MBX_msg_timer, 
+                                        (SYS_UINTPTR)mp ) ;
+            }
+            else
+            {
+                HostOS_PrintLog(L_ERR, "Cannot allocate wqt.\n" );
+                break ;
+            }
+        }
+    }
+}
+
+/*******************************************************************************
+*
+* Description:
+*           Wait q condition expression check.
+*
+* Inputs:   vmp - Pointer to a mailbox message
+*
+* Outputs:  true/false
+*
+*******************************************************************************/
+static int Clnk_MBX_wqt_condition( void *vmp )
+{
+    Clnk_MBX_CmdQueueEntry_t    *mp ;
+    int cond ;
+
+    mp = (Clnk_MBX_CmdQueueEntry_t *)vmp ;
+
+    cond = (mp->isReplyTimedOut || mp->isReplyRdy) ;
+//HostOS_PrintLog(L_NOTICE, "<wqt> cond=%d. to=%d. rdy=%d.\n",
+//                cond, mp->isReplyTimedOut, mp->isReplyRdy );
+/*
+if (cond)
+    HostOS_PrintLog(L_INFO, "reply = %x\n", mp->isReplyRdy);
+*/
+    return( cond ) ;
+}
+
+/*******************************************************************************
+*
+* Description:
+*       msg timer expiration function.
+*
+* Inputs:
+*       data    - Pointer to the mailbox message with timeout
+*
+* Outputs:
+*
+*******************************************************************************/
+static SYS_VOID Clnk_MBX_msg_timer(SYS_ULONG data)
+{
+    Clnk_MBX_CmdQueueEntry_t *mp ;
+
+    mp = (Clnk_MBX_CmdQueueEntry_t *)data ;
+    mp->isReplyTimedOut = 1 ;
+    HostOS_wqt_timer_del( mp->msg_wqt );
+    HostOS_wqt_waitq_wakeup_intr( mp->msg_wqt );
+//HostOS_PrintLog(L_NOTICE, "<msgtimer> expired\n" );
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Receives a mailbox message.
+*
+* Inputs:   pMbx    - Pointer to the mailbox
+*           pMsg    - Pointer to the buffer for receiving message
+*           transID - Transaction ID of message to receive
+*
+* Exports:  0           - success, message queued/sent
+*           -SYS_INVALID_ADDRESS_ERROR  - mailbox not open
+*           -SYS_INPUT_OUTPUT_ERROR     - I/O error
+*           -SYS_TIMEOUT_ERROR          - timeout waiting for response
+*           ?           - other codes from called functions
+*
+*******************************************************************************/
+static int Clnk_MBX_RcvMsg(Clnk_MBX_Mailbox_t *pMbx, 
+                    Clnk_MBX_Msg_t     *pMsg,
+                    SYS_UINT8          transID)
+{
+    SYS_UINT32      index;
+
+    if (!pMbx->mbxOpen) 
+        return(-SYS_INVALID_ADDRESS_ERROR);
+
+    if (transID & HOST_ORIG_BIT)
+    {
+        //HostOS_PrintLog(L_NOTICE, "Clnk_MBX_RcvMsg recv tid=%02xx\n", transID);
+        // Lock the mailbox
+        HostOS_Lock(pMbx->mbx_lock);
+
+        // Check if the transaction ID is still valid
+        index = transID & CMD_QUEUE_MASK;
+        if (pMbx->cmdQueue[index].transID != transID)
+        {
+            HostOS_Unlock(pMbx->mbx_lock);
+            return (-SYS_INPUT_OUTPUT_ERROR);
+        }
+
+        // Check if reply has been received
+        if (!pMbx->cmdQueue[index].isReplyRdy)
+        {
+            HostOS_Unlock(pMbx->mbx_lock);
+            return (-SYS_TIMEOUT_ERROR);
+        }
+
+        //HostOS_PrintLog(L_NOTICE, "Clnk_MBX_RcvMsg tid=%02xx\n", transID );
+
+        // Copy message to receive buffer
+        HostOS_Memcpy(pMsg, &pMbx->cmdQueue[index].rcvMsg, sizeof(*pMsg));
+
+        // Unlock the mailbox
+        HostOS_Unlock(pMbx->mbx_lock);
+//HostOS_PrintLog(L_NOTICE, "<rm>\n" );
+    }
+    else
+    {
+        return (-SYS_INPUT_OUTPUT_ERROR);
+    }
+
+    return (SYS_SUCCESS);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Checks if a reply has been received.
+*
+* Inputs:
+*       pMbx    - Pointer to the mailbox
+*       transID - Transaction ID of message to check
+*
+* Outputs:
+*       1 if a reply has been received, 0 otherwise
+*
+* Notes:
+*       None
+*
+*******************************************************************************/
+static int Clnk_MBX_CheckReplyRdy(Clnk_MBX_Mailbox_t* pMbx, SYS_UINT8 transID)
+{
+    SYS_UINT32  index;
+    int         rdy ;
+
+    rdy = 123456 ;
+
+    // Check if transaction ID is valid
+    if ((transID & HOST_ORIG_BIT) == 0)
+    {
+        return (0);
+    }
+
+    // we're just reading, no lock
+
+    index = transID & CMD_QUEUE_MASK;
+    if (pMbx->cmdQueue[index].transID != transID)
+    {
+        return (0);
+    }
+
+    //HostOS_PrintLog(L_NOTICE, "x\n" );
+    rdy = (volatile int)(pMbx->cmdQueue[index].isReplyRdy) ;
+    //HostOS_PrintLog(L_NOTICE, "x%d\n", rdy );
+
+    // Check if reply has been received
+    if( rdy )
+    {
+        //HostOS_PrintLog(L_INFO, "reply has been received \n");
+        return (1);
+    }
+        //HostOS_PrintLog(L_INFO, "reply has not been received \n");
+    return (0);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Clears the read mailbox ready bit.
+*
+* Inputs:
+*       pMbx - Pointer to the mailbox
+*
+* Outputs:
+*
+*******************************************************************************/
+static void Clnk_MBX_Read_Hw_Mailbox_Clear_Ready(Clnk_MBX_Mailbox_t* pMbx)
+{
+    SYS_UINT32 val;
+
+    clnk_reg_read(pMbx->dc_ctx, pMbx->readMbxCsrOffset, &val);
+    val &= ~CLNK_REG_MBX_SEMAPHORE_BIT;
+    clnk_reg_write(pMbx->dc_ctx, pMbx->readMbxCsrOffset, val);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Sets the write hardware mailbox ready bit.
+*
+* Inputs:
+*       pMbx - Pointer to the mailbox
+*
+* Outputs:
+*
+*******************************************************************************/
+static void Clnk_MBX_Write_Hw_Mailbox_Set_Ready(Clnk_MBX_Mailbox_t* pMbx)
+{
+    SYS_UINT32 val;
+
+    clnk_reg_read(pMbx->dc_ctx, pMbx->writeMbxCsrOffset, &val);
+    val |= CLNK_REG_MBX_SEMAPHORE_BIT;
+    clnk_reg_write(pMbx->dc_ctx, pMbx->writeMbxCsrOffset, val);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Reads a message from the hardware mailbox.
+*
+* Inputs:
+*       Clnk_MBX_Mailbox_t*  Pointer to the mailbox
+*       void*                Pointer to the buffer for reading message
+*
+* Outputs:
+*       None
+*
+*******************************************************************************/
+static void Clnk_MBX_Read_Hw_Mailbox(Clnk_MBX_Mailbox_t* pMbx, void* pvMsg)
+{
+    //SYS_UINT32  val;
+    SYS_UINT32* pMsg = (SYS_UINT32 *)pvMsg;
+    SYS_UINT32  len;
+
+    // Read message from mailbox
+    if (pMsg != SYS_NULL)
+    {
+        SYS_UINT32 reg, lastReg;
+
+        // Read location of mailbox message
+        clnk_reg_read(pMbx->dc_ctx, pMbx->readMbxRegOffset, &reg);
+#if ECFG_CHIP_ZIP1
+        reg &= 0x0003ffff;
+#endif
+
+        // Read first word
+        clnk_reg_read(pMbx->dc_ctx, reg, pMsg);
+        len = CLNK_MBX_GET_REPLY_LEN(*pMsg);
+        reg += 4;
+        pMsg++;
+        
+        if((len < 1) || (len > MAX_MBX_MSG))
+        {
+            HostOS_PrintLog(L_ERR, "warning: invalid mbx reply: %d words\n", len);
+            HostOS_Memset(pMsg, 0, sizeof(*pMsg));
+            return;
+        }
+
+        // Read subsequent words, if necessary
+        lastReg = reg + ((len-1) * 4);
+        for ( ; reg < lastReg; reg += 4, pMsg++)
+        {
+            clnk_reg_read(pMbx->dc_ctx, reg, pMsg);
+        }
+
+#if 0
+        SYS_UINT32 reg = pMbx->readMbxRegOffset;
+        SYS_UINT32 lastReg = reg + (pMbx->readMbxSize * 4);
+        for ( ; reg < lastReg; reg += 4, pMsg++)
+        {
+            clnk_reg_read(pMbx->dc_ctx, reg, pMsg);
+        }
+#endif
+    }
+
+    Clnk_MBX_Read_Hw_Mailbox_Clear_Ready(pMbx);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Writes a message to the hardware mailbox.
+*
+* Inputs:
+*       Clnk_MBX_Mailbox_t*  Pointer to the mailbox
+*       void*                Pointer to the message to write
+*
+* Outputs:
+*       None
+*
+* Notes:
+*       None
+*
+*
+*******************************************************************************/
+static void Clnk_MBX_Write_Hw_Mailbox(Clnk_MBX_Mailbox_t* pMbx, void* pvMsg)
+{
+    //SYS_UINT32  val;
+    SYS_UINT32* pMsg = (SYS_UINT32 *)pvMsg;
+    SYS_UINT32  len;
+    SYS_UINT32  reg, lastReg;
+
+    // Read location of mailbox message
+//HostOS_PrintLog(L_INFO, "In Clnk_MBX_Write_Hw_Mailbox: writeMbxRegOffset=%x\n",pMbx->writeMbxRegOffset);
+    clnk_reg_read(pMbx->dc_ctx, pMbx->writeMbxRegOffset, &reg);
+#if ECFG_CHIP_ZIP1
+    reg &= 0x0003ffff;
+#endif
+
+    // Write message to mailbox
+    len = CLNK_MBX_GET_CMD_LEN(*pMsg);
+    lastReg = reg + (len * 4);
+    for ( ; reg < lastReg; reg += 4, pMsg++)
+    {
+//HostOS_PrintLog(L_INFO, "C_MBX_Wr_Hw_Mbx a=%08x data=%08x\n", reg, *pMsg );
+        clnk_reg_write(pMbx->dc_ctx, reg, *pMsg);
+    }
+
+#if 0
+    SYS_UINT32* pMsg = (SYS_UINT32 *)pvMsg;
+    SYS_UINT32  reg = pMbx->writeMbxRegOffset;
+    SYS_UINT32  lastReg = reg + (8 * 4);
+    for ( ; reg < lastReg; reg += 4, pMsg++)
+    {
+        clnk_reg_write(pMbx->dc_ctx, reg, *pMsg);
+    }
+#endif
+
+    Clnk_MBX_Write_Hw_Mailbox_Set_Ready(pMbx);
+}
+
+
+#ifdef CLNK_MBX_AUTO_REPLY
+static 
+void AutoReplyMsg(Clnk_MBX_Mailbox_t* pMbx)
+{
+    SYS_UINT32 regVal;
+
+    // Check the write semaphore bit
+    for ( ; ; )
+    {
+        clnk_reg_read(pMbx->dc_ctx, CLNK_REG_MBX_WRITE_CSR, &regVal);
+        if (regVal & CLNK_REG_MBX_SEMAPHORE_BIT)
+        {
+            break;
+        }
+    }
+
+    // Loop back message
+    clnk_reg_read(pMbx->dc_ctx,  CLNK_REG_MBX_REG_1,  &regVal);
+    regVal >>= 8;
+    regVal &= 0xff;
+    clnk_reg_write(pMbx->dc_ctx, CLNK_REG_MBX_REG_9,  regVal);
+    clnk_reg_write(pMbx->dc_ctx, CLNK_REG_MBX_WRITE_CSR, 0);
+
+    // Set the read semaphore bit
+    clnk_reg_write(pMbx->dc_ctx, CLNK_REG_MBX_READ_CSR, CLNK_REG_MBX_SEMAPHORE_BIT);
+}
+#endif
+
+
+//BRJ temp to test sending of mailbox message and recieving response via interrupt
+#ifdef SEND_MBX_MSG_TEST
+int Clnk_MBX_SendTestMsg( void* pvMailBox )
+{
+    ClnkDef_MyNodeInfo_t NodeInfo;
+    Clnk_MBX_Mailbox_t* pMbx;
+    SYS_UINT32  u32Val;
+    pMbx = ( Clnk_MBX_Mailbox_t* )pvMailBox;
+
+    clnk_reg_read(pMbx->dc_ctx, CLNK_REG_MBX_WRITE_CSR, &u32Val);
+    if( 0 == ( CLNK_REG_MBX_SEMAPHORE_BIT & u32Val))
+    {
+        // mailbox is available to write to
+        // get interrupt status for debugging
+#if !ECFG_CHIP_ZIP1
+        clnk_reg_read(pMbx->dc_ctx, CLNK_MBX_INTERRUPT_REG, &u32Val);
+#endif // !ECFG_CHIP_ZIP1
+        // set command
+        NodeInfo.ClearStats = 0;
+        u32Val = CLNK_ETH_CTRL_GET_MY_NODE_INFO;
+        clnk_reg_write(pMbx->dc_ctx, CLNK_REG_MBX_REG_1, u32Val);
+        // set params 
+        u32Val = CLNK_MBX_SET_CMD( CLNK_MBX_ETH_DATA_BUF_CMD ); 
+        clnk_reg_write(pMbx->dc_ctx, CLNK_REG_MBX_REG_2, u32Val);
+    
+        u32Val = sizeof(ClnkDef_MyNodeInfo_t);
+        clnk_reg_write(pMbx->dc_ctx, CLNK_REG_MBX_REG_3, u32Val);
+    
+        u32Val = NodeInfo.ClearStats;
+        clnk_reg_write(pMbx->dc_ctx, CLNK_REG_MBX_REG_4, u32Val);
+    
+        // tell clink we wrote a message
+        u32Val = CLNK_REG_MBX_SEMAPHORE_BIT;
+        clnk_reg_write(pMbx->dc_ctx, CLNK_REG_MBX_WRITE_CSR, u32Val);
+    }
+    return (SYS_SUCCESS);
+}
+#endif // SEND_MBX_MSG_TEST
+
+
+#if defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT) || defined(APOLLO_DRVR_SUPPORT)
+/*******************************************************************************
+*
+* Description:
+*       Clnk kernel thread main loop function. it processes mbox messages etc.
+*
+* Inputs:
+*       data - Pointer to driver control context
+*
+* Outputs:
+*       None
+*
+*******************************************************************************/
+void Clnk_Kthread_Mainloop(void *data)
+{
+    dc_context_t *dccp = (dc_context_t *)data;    
+  
+    while(1)
+    {
+        if(dccp->clnkThreadStop == CLNK_TASK_RUNNING)
+        {
+            //PCI mode, CAM processing
+            //Clnk_ETH_Cam_Proc(dccp);
+        
+#if 0
+            //MBOX processing
+            Clnk_MBX_Read_ISR( &dccp->mailbox ) ;
+            Clnk_MBX_Write_ISR( &dccp->mailbox ) ;
+#endif
+            //Unsol msg processing
+            if(Clnk_MBX_Unsol_Hw_Mailbox_Check_Ready( &dccp->mailbox ))
+            {
+               Clnk_MBX_Unsol_ISR( &dccp->mailbox ) ;
+            }
+        }
+        else
+            dccp->clnkThreadStop = CLNK_TASK_SLEEP;
+
+        /* Sleep */
+        HostOS_msleep_interruptible(TT_TASK_SLEEP); 
+
+        if(HostOS_signal_pending(SYS_NULL) != 0)
+            break;
+    }
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Clnk kernel thread initialization.
+*
+* Inputs:
+*       data - Pointer to driver control context
+*
+* Outputs:
+*       OK: 0, Failed: -1
+*
+*******************************************************************************/
+int Clnk_Kern_Task_Init(void *data)
+{
+    dc_context_t *dccp = (dc_context_t *)data;
+    int ret;
+    char name[20] = "kclinkd";
+
+    //HostOS_PrintLog(L_INFO, "Clnk_Kern_Task_Init(): Entry dccp 0x%x \n", data);
+
+    if(dccp->clnkThreadID != 0)
+    {   
+        if(dccp->clnkThreadStop == CLNK_TASK_STOPPED || dccp->clnkThreadStop == CLNK_TASK_SLEEP)
+            dccp->clnkThreadStop = CLNK_TASK_RUNNING; //Running
+        return 0;
+    }
+
+    ret = HostOS_thread_start(&dccp->clnkThreadID, (char *)name, (SYS_VDFCVD_PTR)Clnk_Kthread_Mainloop, data);
+    if(ret < 0)
+    {
+        HostOS_PrintLog(L_ERR, "Failed to start kclinkd thread! \n");
+        dccp->clnkThreadID = 0;
+        return -1;
+    }
+    //else
+    //    HostOS_PrintLog(L_INFO, "Start kclinkd thread %d\n", dccp->clnkThreadID);
+
+    dccp->clnkThreadStop = CLNK_TASK_RUNNING;
+    return 0;
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Stop Clnk kernel thread.
+*
+* Inputs:
+*       data - Pointer to driver control context
+*
+* Outputs:
+*       OK: 0, Failed: -1
+*
+*******************************************************************************/
+int Clnk_Kern_Task_Stop(void *data)
+{
+    dc_context_t *dccp = (dc_context_t *)data;
+    int loopCnt = 0;
+
+    //HostOS_PrintLog(L_INFO, "Clnk_Kern_Task_Stop(): Entry \n");
+
+    if(dccp->clnkThreadID != 0)
+    {
+        dccp->clnkThreadStop = CLNK_TASK_STOPPED;
+
+        // Wait thread to stop,
+        while(1)
+        {
+            if(dccp->clnkThreadStop == CLNK_TASK_SLEEP || loopCnt > 10)
+                break;
+
+            //HostOS_PrintLog(L_INFO, "Clnk_Kern_Task_Stop(): Delay %d \n", loopCnt);
+            HostOS_msleep_interruptible(1); // 1ms
+            loopCnt++;
+        }
+    }
+    return 0;
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Kill Clnk kernel thread.
+*
+* Inputs:
+*       data - Pointer to driver control context
+*
+* Outputs:
+*       OK: 0, Failed: -1
+*
+*******************************************************************************/
+int Clnk_Kern_Task_Kill(void *data)
+{
+    dc_context_t *dccp = (dc_context_t *)data;
+    int ret = 0;
+    
+    //HostOS_PrintLog(L_INFO, "Clnk_Kern_Task_Kill(): Entry \n");
+
+    ret = HostOS_thread_stop(dccp->clnkThreadID);
+
+    if(ret != 0)
+    {
+        HostOS_PrintLog(L_ERR, "Unable to stop kclnkd thread! (thread ID %d)\n", dccp->clnkThreadID);
+        return -1;
+    }
+
+    dccp->clnkThreadID = 0;
+    dccp->clnkThreadStop = CLNK_TASK_STOPPED;
+    return 0;
+}
+#endif
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ClnkMbx_ttask.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ClnkMbx_ttask.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ClnkMbx_ttask.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ClnkMbx_ttask.c	2012-09-14 14:51:36.908939000 +0530
@@ -0,0 +1,241 @@
+/*******************************************************************************
+*
+* Common/Src/ClnkMbx_ttask.c
+*
+* Description: mailbox timer task support 
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+/*******************************************************************************
+*                             # D e f i n e s                                  *
+********************************************************************************/
+
+
+
+
+
+/*******************************************************************************
+*            S t a t i c   M e t h o d   P r o t o t y p e s                   *
+********************************************************************************/
+
+static void clnketh_tt_task_sched( dc_context_t *dccp, void *task );
+
+
+
+
+
+/****************************************************************************
+*           
+*   Purpose:    TT timer expiration function.
+*
+*   Imports:    data - timer's opaque data, driver control context
+*
+*   Exports:    
+*
+*PUBLIC**********************************************************************/
+SYS_VOID clnketh_tt_timer(SYS_ULONG data)
+{
+    dc_context_t *dccp = (dc_context_t *)data;    
+//    Clnk_MBX_Mailbox_t *pMbx = &dccp->mailbox; 
+#if 0 
+    if( Clnk_MBX_Read_Hw_Mailbox_Check_Ready(  &dccp->mailbox ) )
+        HostOS_PrintLog(L_INFO, "In clnketh_tt_timer - Pass\n");
+    else
+        HostOS_PrintLog(L_INFO, "In clnketh_tt_timer - Fail\n");
+
+#endif
+#if 0
+
+    // detect command message HW Q ready - rx
+  //  HostOS_PrintLog(L_INFO, "Check Ready -rx\n");
+    if( Clnk_MBX_Read_Hw_Mailbox_Check_Ready(  &dccp->mailbox ) )
+    {
+      //  HostOS_PrintLog(L_INFO, "In Check Ready -rx\n");
+        clnketh_tt_task_sched( dccp, dccp->tt_cmtask_link ) ;
+    }
+
+    // detect command message HW Q ready - tx
+   //     HostOS_PrintLog(L_INFO, "Check Ready -tx\n");
+    if( Clnk_MBX_Write_Hw_Mailbox_Check_Ready( &dccp->mailbox ) ) 
+    {
+        if( !Clnk_MBX_Send_Mailbox_Check_Empty( &dccp->mailbox ) )
+        {
+      //  HostOS_PrintLog(L_INFO, "In Check Ready -tx\n");
+            clnketh_tt_task_sched( dccp, dccp->tt_cmtask_link ) ;
+        }
+    }
+
+    // detect unsolicited message ready - rx
+    //    HostOS_PrintLog(L_INFO, "Check Ready -unsol\n");
+    if( Clnk_MBX_Unsol_Hw_Mailbox_Check_Ready( &dccp->mailbox ) )
+    {
+     //   HostOS_PrintLog(L_INFO, "In Check Ready -unsol\n");
+        clnketh_tt_task_sched( dccp, dccp->tt_umtask_link ) ;
+    }
+#endif
+#if 0
+    // detect command message HW Q ready - rx
+//    HostOS_PrintLog(L_INFO, "Check Ready -rx\n");
+    if( Clnk_MBX_Read_Hw_Mailbox_Check_Ready(  &dccp->mailbox ) )
+    {
+    // pass rx message
+    Clnk_MBX_Read_ISR( &dccp->mailbox ) ;
+    // pass tx message
+    Clnk_MBX_Write_ISR( &dccp->mailbox ) ;
+    }
+
+    // detect command message HW Q ready - tx
+ //       HostOS_PrintLog(L_INFO, "Check Ready -tx\n");
+    if( Clnk_MBX_Write_Hw_Mailbox_Check_Ready( &dccp->mailbox ) ) 
+    {
+        if( !Clnk_MBX_Send_Mailbox_Check_Empty( &dccp->mailbox ) )
+        {
+  //      HostOS_PrintLog(L_INFO, "In Check Ready -tx\n");
+    // pass rx message
+    Clnk_MBX_Read_ISR( &dccp->mailbox ) ;
+    // pass tx message
+    Clnk_MBX_Write_ISR( &dccp->mailbox ) ;
+
+        }
+    }
+#endif
+    Clnk_MBX_Read_ISR( &dccp->mailbox ) ;
+    Clnk_MBX_Write_ISR( &dccp->mailbox ) ;
+#if 1
+//    HostOS_Lock(pMbx->swUnsolLock);
+    // detect unsolicited message ready - rx
+//        HostOS_PrintLog(L_INFO, "Check Ready -unsol\n");
+    if( Clnk_MBX_Unsol_Hw_Mailbox_Check_Ready( &dccp->mailbox ) )
+    {
+//        HostOS_PrintLog(L_INFO, "In Check Ready -unsol\n");
+        Clnk_MBX_Unsol_ISR( &dccp->mailbox ) ;
+    }
+#endif
+ //  HostOS_Unlock(pMbx->swUnsolLock);
+
+    // go again
+    if( !dccp->tt_stopping ) {
+        HostOS_timer_mod( dccp->tt_timer_link, HostOS_timer_expire_ticks(TT_TASK_TIMEOUT) );
+    }
+}
+
+
+/****************************************************************************
+*           
+*   Purpose:    TT command message handling thread.
+*
+*               Called as a tasklet.
+*
+*   Imports:    data - context data
+*
+*   Exports:    
+*
+*PUBLIC**********************************************************************/
+SYS_VOID clnketh_tt_cmtask(SYS_ULONG data)
+{
+    dc_context_t *dccp = (dc_context_t *)data;    
+
+//HostOS_PrintLog(L_INFO, "In clnketh_tt_cmtask() \n" );
+    // pass rx message
+    Clnk_MBX_Read_ISR( &dccp->mailbox ) ;
+
+    // pass tx message
+    Clnk_MBX_Write_ISR( &dccp->mailbox ) ;
+
+#if 1
+    // possibly re-schedule
+    if( Clnk_MBX_Read_Hw_Mailbox_Check_Ready(  &dccp->mailbox ) )
+    {
+        clnketh_tt_task_sched( dccp, dccp->tt_cmtask_link ) ;
+    }
+
+    // possibly re-schedule
+    if( !Clnk_MBX_Send_Mailbox_Check_Empty( &dccp->mailbox ) )
+    {
+        clnketh_tt_task_sched( dccp, dccp->tt_cmtask_link ) ;
+    }
+#endif
+}
+
+/****************************************************************************
+*           
+*   Purpose:    TT unsolicited message handling thread.
+*
+*               Called as a tasklet.
+*
+*   Imports:    data - context data
+*
+*   Exports:    
+*
+*PUBLIC**********************************************************************/
+SYS_VOID clnketh_tt_umtask(SYS_ULONG data)
+{
+    dc_context_t *dccp = (dc_context_t *)data;    
+
+    Clnk_MBX_Unsol_ISR( &dccp->mailbox ) ;
+
+    // no re-schedule as Handle UnsolInterrupt already sucks up multiple messages 
+}
+
+/****************************************************************************
+*           
+*   Purpose:    Possibly reschedules a TT tasklet.
+*
+*   Imports:    dccp - control context
+*               task - pointer to task structure
+*
+*   Exports:    
+*
+*STATIC**********************************************************************/
+static void clnketh_tt_task_sched( dc_context_t *dccp, void *task )
+{
+
+    // possibly re-schedule
+    if( !dccp->tt_stopping )
+    {
+        HostOS_task_schedule( task ) ;
+    }
+
+}
+
+
+
+
+
+
+
+
+
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ctx_abs.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ctx_abs.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ctx_abs.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ctx_abs.c	2012-09-14 14:51:36.911940000 +0530
@@ -0,0 +1,116 @@
+/*******************************************************************************
+*
+* Common/Src/ctx_abs.c
+*
+* Description: context abstraction
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+
+/*******************************************************************************
+*                                N O T E                                       *
+********************************************************************************/
+
+
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+/*
+    The parameter  CONTEXT_DEBUG   must be defined to enable context
+    linkage checking. With it defined you'll get error checking and
+    messages about null context linkage pointers.
+*/
+#define CONTEXT_DEBUG       0   // define 1 for context linkage checking
+
+
+
+/**
+*  Purpose:    Converts a driver control context pointer to
+*              a driver gpl context pointer.
+*
+*  Imports:    dccp - pointer to a device control context
+*
+*  Exports:    pointer to the driver gpl context
+*
+*PUBLIC**************************/
+void *dc_to_dg( void *dccp )
+{
+    void *dgcp ;
+
+#if CONTEXT_DEBUG
+    if( dccp ) {
+        dgcp = ((dc_context_t *)dccp)->p_dg_ctx;
+    } else {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dc_to_dg\n" );
+        dgcp = 0 ;
+    }
+#else
+    dgcp = ((dc_context_t *)dccp)->p_dg_ctx ;
+#endif
+
+    return( dgcp ) ;
+}
+
+
+/**
+*  Purpose: Converts a driver control context pointer to
+*           a driver kernel context pointer.
+*
+*           This is the only way to get back to the dk!           
+*
+*  Imports: dccp - pointer to a device control context
+*
+*  Exports: pointer to the driver kernel context
+*
+*PUBLIC**************************/
+void *dc_to_dk( void *dccp )
+{
+    void *dkcp ;
+
+#if CONTEXT_DEBUG
+    if( dccp ) {
+        dkcp = ((dc_context_t *)dccp)->p_dk_ctx;
+    } else {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dc_to_dk\n" );
+        dkcp = 0 ;
+    }
+#else
+    dkcp = ((dc_context_t *)dccp)->p_dk_ctx ;
+#endif
+
+    return( dkcp ) ;
+}
+
+
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ctx_setup.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ctx_setup.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ctx_setup.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/ctx_setup.c	2012-09-14 14:51:36.914938000 +0530
@@ -0,0 +1,262 @@
+/*******************************************************************************
+*
+* Common/Src/ctx_setup.c
+*
+* Description: context setup support
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+
+
+/*******************************************************************************
+*            S t a t i c   M e t h o d   P r o t o t y p e s                   *
+********************************************************************************/
+
+static int Clnk_alloc_contexts(void **ddcp_dgcp, void *ddcp );
+static void Clnk_init_control_context( dc_context_t *dccp, void *dkcp, unsigned long dev_base );
+
+
+
+/*******************************************************************************
+*
+* Description:
+*       Initializes the context structures for a device.
+*       Called from the probe function for each device.
+*
+*       Allocate our context
+*       Put our context in the adapter context.
+*       Put the adapter context pointer in our context.
+*    
+* Inputs:
+*       ddcp_dgcp   - Pointer into the driver data context to the
+*                     place to save our gpl context.
+*       ddcp        - Pointer to the adapter context.
+*                     This will be saved in our context.        
+*
+* Outputs:
+*       0 or error code
+*
+*STATIC***************************************************************************/
+static int Clnk_alloc_contexts(void **ddcp_dgcp, void *ddcp )
+{
+    void         *dgcp ;
+    dc_context_t *dccp ;
+
+    // Allocate the contexts
+
+    dgcp = ctx_alloc_dg_context();
+    if( !dgcp )
+    {
+        return (-SYS_OUT_OF_MEMORY_ERROR );
+    }
+
+    dccp = (dc_context_t *)ctx_alloc_dc_context();
+    if( !dccp )
+    {
+        ctx_free_dg_context( dgcp ) ;
+        return (-SYS_OUT_OF_MEMORY_ERROR );
+    }
+
+    // linkage init
+    *ddcp_dgcp     = dgcp;   // link dd to dg
+    dccp->p_dg_ctx = dgcp;   // link dc to dg
+    ctx_link_dg_context( dgcp, ddcp, dccp ) ;
+
+    return(SYS_SUCCESS);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Initializes the control context.
+*
+* Inputs:
+*       dccp        - Pointer to the control context.
+*       dkcp        - Pointer to the kernel context.
+*       dev_base    - Device base address
+*
+* Outputs:
+*       0 = SYS_SUCCESS
+*
+*STATIC***************************************************************************/
+static void Clnk_init_control_context( dc_context_t *dccp, void *dkcp, unsigned long dev_base )
+{
+    unsigned int *linkarray[5], **vp ;
+
+    dccp->p_dk_ctx = dkcp ;  // reverse link to the kernel context
+    dccp->baseAddr = dev_base; 
+
+    vp = &linkarray[0] ;
+    ctx_linkage_lister( dkcp, vp, 5 ) ;
+
+    // the order of this list must match that in ctx_linkage_lister
+    dccp->at_lock_link                  = (void *)*vp++ ;
+    dccp->ioctl_sem_link                = (void *)*vp++ ;
+    dccp->mbx_cmd_lock_link             = (void *)*vp++ ;
+    dccp->mbx_swun_lock_link            = (void *)*vp++ ;
+    dccp->ms_cmd_lock_link              = (void *)*vp++ ;
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Initializes the clink for a device.
+*       Called from the probe function for each device.
+*
+*       Allocate our contexts
+*       Put our context in the adapter context.
+*       Put the adapter context pointer in our context.
+*       Point the control context at the gpl context.
+*    
+* Inputs:
+*       ddcp_dgcp   - Pointer into the driver data context to the
+*                     place to save our gpl context.
+*       ddcp        - Pointer to the adapter context.
+*                     This will be saved in our context.        
+*       dkcp        - Pointer to the kernel context.
+*                     This will be saved in the control context.        
+*       dev_base    - Device base address
+*
+* Outputs:
+*       0 = SYS_SUCCESS
+*       -SYS_OUT_OF_MEMORY_ERROR
+*
+*PUBLIC***************************************************************************/
+int Clnk_init_dev(void **ddcp_dgcp, void *ddcp, void *dkcp, unsigned long dev_base )
+{
+    void         *dgcp ;
+    dc_context_t *dccp ;
+    int err ;
+
+    // Allocate the contexts
+
+    err = Clnk_alloc_contexts( ddcp_dgcp, ddcp );
+    if( !err )
+    {
+        dgcp = dd_to_dg( ddcp ) ;
+        dccp = dg_to_dc( dgcp ) ;
+
+        // Initialize OS context
+
+        Clnk_init_os_context( dgcp ) ; 
+
+        // Initialize control context
+
+        Clnk_init_control_context( dccp, dkcp, dev_base ) ;
+    }
+
+    return(err);
+}
+
+/*******************************************************************************
+*
+* Description:
+*       De-Initializes the Mailbox Module for a device.
+*       Called from the remove function for each device.
+*
+*       The thinking here, based on assumptions about what the
+*       kernel does during remove, is to assume that ioctls
+*       are stopped already and that there is no need to lock
+*       them out.
+*
+*       Stops the Timer Task.
+*       Offs the mailboxes.
+*       De-Allocates everything.
+*    
+* Inputs:
+*       vdgcp - Pointer into the gpl context 
+*
+* Outputs:
+*       0 = SYS_SUCCESS
+*       -SYS_OUT_OF_MEMORY_ERROR
+*
+*PUBLIC***************************************************************************/
+void Clnk_exit_dev( void *vdgcp )
+{
+    dc_context_t *dccp ;
+
+    if( vdgcp ) {
+        dccp = dg_to_dc( vdgcp ) ;
+
+        // Free any wqts
+        Clnk_MBX_Free_wqts( &dccp->mailbox ) ;
+
+        ctx_free_dc_context( dccp ) ; 
+        ctx_free_dg_context( vdgcp ) ;
+    }
+}
+
+/*******************************************************************************
+*           
+* Purpose:  Allocates and clears a DC
+*    
+* Inputs:
+*
+* Outputs:  the context
+*
+*PUBLIC***************************************************************************/
+void *ctx_alloc_dc_context( void )
+{
+    dc_context_t *dccp ;
+
+    dccp = (dc_context_t *)HostOS_Alloc(sizeof(dc_context_t));
+    if( dccp )
+    {
+        HostOS_Memset(dccp, 0, sizeof(dc_context_t));
+    }
+
+    return(dccp);
+}
+
+/*******************************************************************************
+*           
+* Purpose:  Frees a DC
+*    
+* Inputs:   dccp - the DC context to free
+*
+* Outputs:  
+*
+*PUBLIC***************************************************************************/
+void ctx_free_dc_context( void *dccp )
+{
+
+    HostOS_Free( dccp, sizeof(dc_context_t) ) ;
+}
+
+
+
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/hostos_stubs.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/hostos_stubs.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/hostos_stubs.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/hostos_stubs.c	2012-09-14 14:51:36.918930000 +0530
@@ -0,0 +1,971 @@
+/*******************************************************************************
+*
+* Common/Src/hostos_stubs.c
+*
+* Description: Host OS abstraction support 
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+
+/**
+*   Purpose:    Sets size bytes of memory to a given byte value.
+*
+*   Imports:    pMem - pointer to block of memory to set
+*               val  - value to set each byte to
+*               size - number of bytes to set
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_Memset(void *pMem, int val, int size)
+{
+}
+
+/**
+*   Purpose:    Copies size bytes of memory from pFrom to pTo.
+*               The memory areas may not overlap.
+*
+*   Imports:    pTo   - pointer to destination memory area
+*               pFrom - pointer to source memory area
+*               size  - number of bytes to copy
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_Memcpy(void *pTo, void *pFrom, int size)
+{
+}
+
+/**
+*   Purpose:    Scans input buffer and according to format specified.
+*
+*   Imports:    buf   - input buffer
+*               fmt   - input format
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_Sscanf(const char *buf, const char *fmt, ...)
+{
+}
+
+/**
+*   Purpose:    Allocates DMA-addressable memory.
+*
+*   Imports:    size - size to allocate
+*
+*   Exports:    pointer to allocated block
+*
+*PUBLIC**************************/
+void* HostOS_Alloc(int size)
+{
+    return (0);
+}
+
+/**
+*   Purpose:    Free DMA-addressable memory.
+*
+*   Imports:    pMem - allocation pointer from get free pages
+*               size - Requested block size
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_Free(void* pMem, int size)
+{
+}
+
+/**
+*   Purpose:    Delays for about timeInUsec microseconds.
+*               The operation of this function is architecture dependent.
+*               It is probably a tight loop.
+*
+*   Imports:    timeInUsec - delay in microseconds
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_Sleep(int timeInUsec)
+{
+}
+
+/**
+*   Purpose:    Inits a spinlock.
+*               Sets the magic code for later testing.
+*
+*   Imports:    vlk - pointer to an Entropic lock structure
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_lock_init( void *vlk)
+{
+}
+
+/**
+*   Purpose:    Waits for the lock.
+*               The lock must be initialized.
+*
+*               See the macro:  HostOS_Lock
+*
+*   Imports:    vlk - pointer to an initialized Entropic lock structure
+*
+*   Exports:    none - when this returns you have the lock.
+*                      Please do an unlock later.
+*
+*PUBLIC**************************/
+void HostOS_Lock(void *vlk)
+{
+}
+
+/**
+*   Purpose:    Saves current interrupt context and waits for the lock.
+*               The lock must be initialized.
+*
+*   Imports:    vlk - pointer to an initialized Entropic lock structure
+*
+*   Exports:    none - when this returns you have the lock.
+*                      Please do an unlock later.
+*
+*PUBLIC**************************/
+void HostOS_Lock_Irqsave(void *vlk)
+{
+}
+
+/**
+*   Purpose:    Trys to get the lock.
+*               The lock must be initialized.
+*
+*   Imports:    vlk - pointer to an initialized Entropic lock structure
+*
+*   Exports:    0 - the lock was NOT acquired. Please try again.
+*               1 - the lock is yours. Please ulock it later.
+*
+*PUBLIC**************************/
+int HostOS_Lock_Try(void *vlk)
+{
+
+    return( 0 );
+}
+
+/**
+*   Purpose:    Unlocks a lock.
+*               The lock must be initialized.
+*
+*               See the macro:  HostOS_Unlock
+*
+*   Imports:    vlk - pointer to an initialized Entropic lock structure
+*
+*   Exports:    none - when this returns you have the lock.
+*
+*PUBLIC**************************/
+void HostOS_Unlock(void *vlk)
+{
+}
+
+/**
+*   Purpose:    Unlocks a lock and restores interrupt context.
+*               The lock must be initialized.
+*
+*
+*   Imports:    vlk - pointer to an initialized Entropic lock structure
+*
+*   Exports:    none - when this returns you have released the lock.
+*
+*PUBLIC**************************/
+void HostOS_Unlock_Irqrestore(void *vlk)
+{
+}
+
+/**
+*   Purpose:    Terminates a lock.
+*
+*   Imports:    vlk - pointer to an initialized Entropic lock structure
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_TermLock(void *vlk)
+{
+}
+
+/**
+*   Purpose:    Variable argument OS print.
+*
+*   Imports:    lev - severity level. See the L_* enum.
+*                     See HOST_OS_PRINTLOG_THRESHOLD
+*               fmt - printf format string
+*               ... - printf format arguments
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_PrintLog(SYS_INT32 lev, const char *fmt, ...)
+{
+}
+
+/**
+*   Purpose:    register/memory read access from kernel space.
+*
+*   Imports:    addr - address to read from
+*
+*   Exports:    32 bit value from given address
+*
+*PUBLIC**************************/
+SYS_UINT32 HostOS_Read_Word( SYS_UINT32 *addr )
+{
+
+    return( 0 ) ;
+}
+
+/**
+*   Purpose:    register/memory write access from kernel space.
+*
+*   Imports:    val  - 32 bit value to write
+*               addr - address to write to
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_Write_Word( SYS_UINT32 val, SYS_UINT32 *addr )
+{
+}
+
+/**
+*   Purpose:    Initialize a timer and register it.
+*
+*   Imports:    vtmr - pointer to the timer to initialize
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_timer_init( void *vtmr )
+{
+}
+
+/**
+*   Purpose:    Deactivate a registered timer.
+*
+*   Imports:    vtmr - pointer to the timer to deactivate
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+int HostOS_timer_del( void *vtmr )
+{
+
+    return( 0 ) ;
+}
+
+/**
+*   Purpose:    Deactivate a registered timer.
+*               And ensure the timer is not running on any CPU
+*               Can sleep
+*
+*   Imports:    vtmr - pointer to the timer to deactivate
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+int HostOS_timer_del_sync( void *vtmr )
+{
+
+    return( 0 ) ;
+}
+
+/**
+*   Purpose:    Modifies a timer.
+*
+*   Imports:    vtmr    - pointer to the timer to deactivate
+*               timeout - timeout value from HostOS_timer_expire_seconds
+*                         or HostOS_timer_expire_ticks
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+int HostOS_timer_mod( void *vtmr, SYS_ULONG timeout )
+{
+
+    return( 0 ) ;
+}
+
+/**
+*   Purpose:    Add a timer.
+*               Call this after HostOS_timer_setup
+*
+*   Imports:    vtmr - pointer to the timer to deactivate
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+void HostOS_timer_add( void *vtmr )
+{
+}
+
+/**
+*   Purpose:    Sets up a timer with function and user data.
+*
+*               See HostOS_timer_set_timeout
+*
+*   Imports:    vtmr    - pointer to the timer to deactivate
+*               func    - callback function to call at timer expiration
+*               data    - data to pass to callback
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_timer_setup( void *vtmr, timer_function_t func, SYS_UINTPTR data )   
+{
+}
+
+/**
+*   Purpose:    Sets a timer's time out.
+*
+*               See HostOS_timer_setup
+*
+*   Imports:    vtmr    - pointer to the timer to deactivate
+*               timeout - timeout value from HostOS_timer_expire_seconds
+*                         or HostOS_timer_expire_ticks
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_timer_set_timeout( void *vtmr, SYS_ULONG timeout )  
+{
+}
+
+/**
+*   Purpose:    Calculate a future expiration point.
+*               In seconds.
+*
+*   Imports:    future - number of seconds into the future
+*
+*   Exports:    A number for use in the timer expiration member
+*
+*PUBLIC**************************/
+SYS_ULONG HostOS_timer_expire_seconds( SYS_UINT32 future )
+{
+
+    return( 0 ) ;
+}
+
+/**
+*   Purpose:    Calculate a future expiration point.
+*              In jiffies.
+*
+*   Imports:    future - number of ticks into the future
+*
+*   Exports:    A number for use in the timer expiration member
+*
+*PUBLIC**************************/
+SYS_ULONG HostOS_timer_expire_ticks( SYS_UINT32 future )
+{
+
+    return( 0 ) ;
+}
+
+
+/**************************************************************
+
+    wait queue timer - support
+
+    This structure contains everything necessary to
+    use timers and wait queues from the !GPL side.
+
+    You allocate one of these wqt_t things and then
+    pass its pointer back on the various calls.
+
+***************************************************************/
+
+typedef struct hostos_w_q_t
+{
+} 
+wqt_t ;
+
+
+/**
+*   Purpose:    Allocates a wqt entry from the heap.
+*
+*   Imports:
+*
+*   Exports:    !0 = void pointer to opaque data (really a wqt_t)
+*               0 = allocation failure
+*
+*PUBLIC**************************/
+void *HostOS_wqt_alloc( void )
+{
+
+    return( (void *)0 ) ;
+}
+
+/**
+*   Purpose:    De-allocates a wqt entry from the heap.
+*
+*   Imports:    vwqt - pointer to the wqt_t to be freed
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_free( void *vwqt )
+{
+
+}
+
+/**
+*   Purpose:    Initialize a timer and register it.
+*
+*   Imports:    vwqt - pointer to the wqt_t with timer to initialize
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_timer_init( void *vwqt )
+{
+}
+
+/**
+*   Purpose:    Deactivate a wqt timer
+*
+*   Imports:    vwqt - pointer to the wqt_t with timer to deactivate
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_wqt_timer_del( void *vwqt )
+{
+}
+
+/**
+*   Purpose:    Deactivate a registered timer
+*               And ensure the timer is not running on any CPU.
+*               Can sleep.
+*
+*   Imports:    vwqt - pointer to the wqt_t with timer to deactivate
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+int HostOS_wqt_timer_del_sync( void *vwqt )
+{
+
+    return( 0 ) ;
+}
+
+/**
+*   Purpose:    Modifies a timer
+*
+*   Imports:    vwqt    - pointer to the wqt_t with timer to modify
+*               timeout - timeout value from HostOS_timer_expire_seconds
+*                        or HostOS_timer_expire_ticks
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+int HostOS_wqt_timer_mod( void *vwqt, SYS_ULONG timeout )  
+{
+
+    return( 0 ) ;
+}
+
+/**
+*   Purpose:    Add a timer
+*               Call this after HostOS_timer_setup
+*
+*   Imports:    vwqt    - pointer to the wqt_t with timer to add
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+void HostOS_wqt_timer_add( void *vwqt )
+{
+}
+
+/**
+*   Purpose:    Sets up a timer with function and user data.
+*
+*               See HostOS_timer_set_timeout
+*
+*   Imports:    vwqt    - pointer to the wqt_t with timer to  init
+*               func    - callback function to call at timer expiration
+*               data    - data to pass to callback
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_timer_setup( void *vwqt, timer_function_t func, SYS_UINTPTR data )  
+{
+}
+
+/**
+*   Purpose:    Sets a timer's time out.
+*
+*               See HostOS_timer_setup
+*
+*   Imports:    vwqt    - pointer to the wqt_t with timer to set
+*               timeout - timeout value from HostOS_timer_expire_seconds
+*                         or HostOS_timer_expire_ticks
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_timer_set_timeout( void *vwqt, SYS_ULONG timeout ) 
+{
+}
+
+/**
+*   Purpose:    Inits a wait queue head in a wqt_t.
+*
+*   Imports:    vwqt    - pointer to the wqt_t with wait q to init
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_waitq_init( void *vwqt )
+{
+}
+
+/**
+*   Purpose:    Wakes up a wait q in a wqt_t.
+*
+*   Imports:    vwqt    - pointer to the wqt_t with wait q to wake
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_waitq_wakeup_intr( void *vwqt )
+{
+}
+
+/**
+*   Purpose:    Waits for a wait q event in a wqt_t.
+*
+*   Imports:    vwqt    - pointer to the wqt_t with wait q to wait on
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_waitq_wait_event_intr( void *vwqt, HostOS_wqt_condition func, void *vp )
+{
+}
+
+#if defined(PCI_DRVR_SUPPORT)
+/**
+*   Purpose:    PCI device register access.
+*               These functions read or write the PCI bus device.
+*
+*   Imports:    ddev           - context structure with device pointer
+*               reg            - PCI device bus address/register address
+*               pVal or val    - where to put or get the data
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_ReadPciConfig_Word(void* ddev, SYS_UINT32 reg, SYS_UINT16* pVal)
+{
+
+}
+
+/**
+*   Purpose:    PCI device register access.
+*               These functions read or write the PCI bus device.
+*
+*   Imports:    ddev           - context structure with pci_dev pointer
+*               reg            - PCI device bus address/register address
+*               pVal or val    - where to put or get the data
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_ReadPciConfig(void* ddev, SYS_UINT32 reg, SYS_UINT32* pVal)
+{
+
+}
+
+/**
+*   Purpose:    PCI device register access.
+*               These functions read or write the PCI bus device.
+*
+*   Imports:    ddev           - context structure with device pointer
+*               reg            - PCI device bus address/register address
+*               pVal or val    - where to put or get the data
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_WritePciConfig_Word(void *ddev, SYS_UINT32 reg, SYS_UINT16 val)
+{
+
+}
+
+/**
+*   Purpose:    PCI device register access.
+*               These functions read or write the PCI bus device.
+*
+*   Imports:    ddev           - context structure with device pointer
+*               reg            - PCI device bus address/register address
+*               pVal or val    - where to put or get the data
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_WritePciConfig(void* ddev, SYS_UINT32 reg, SYS_UINT32 val)
+{
+
+}
+
+/**
+*   Purpose:    Allocate DMA-addressable memory.
+*
+*   Imports:    ddev    - pci_dev pointer
+*               size    - Requested block size
+*               ppMemPa - Pointer to place to return the Physical memory address
+*
+*   Exports:    Virtual memory address (and Phys address), or NULL on failure
+*
+*PUBLIC**************************/
+void *HostOS_AllocDmaMem(void *ddev, int size, void **ppMemPa)
+{
+
+    return (0);
+}
+
+/**
+*   Purpose:    Free DMA-addressable memory.
+*
+*   Imports:    ddev   - pci_dev pointer
+*               size   - Requested block size
+*               pMemVa - Virtual memory address returned by HostOS_AllocDmaMem()
+*               pMemPa - Physical memory address returned by    ditto
+*
+*   Exports:    Virtual memory address (and Phys address), or NULL on failure
+*
+*PUBLIC**************************/
+void HostOS_FreeDmaMem(void *ddev, int size, void *pMemVa, void *pMemPa)
+{
+}
+#endif
+
+/**
+*   Purpose:    Initialize a tasklet.
+*
+*   Imports:    vtl  - pointer to the tasklet structure
+*               func - tasklet function
+*               data - tasklet context data
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_task_init( void *vtl, void *func, unsigned long data )
+{
+}
+
+/**
+*   Purpose:    Schedule a tasklet.
+*               Tasklet must already be initialized.
+*
+*   Imports:    vtl - pointer to the tasklet structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_task_schedule( void *vtl )
+{
+}
+
+/**
+*   Purpose:    Enable a tasklet.
+*
+*   Imports:    vtl - pointer to the tasklet structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_task_enable( void *vtl )
+{
+}
+
+/**
+*   Purpose:    Disable a tasklet.
+*
+*   Imports:    vtl - pointer to the tasklet structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_task_disable( void *vtl )
+{
+}
+
+/**
+*   Purpose:    Kill a tasklet.
+*
+*   Imports:    vtl - pointer to the tasklet structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_task_kill( void *vtl )
+{
+}
+
+/**
+*   Purpose:    Initialize a mutex.
+*
+*   Imports:    vmt - pointer to the mutex structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_mutex_init( void *vmt )
+{
+}
+
+/**
+*   Purpose:    Release (up) a mutex.
+*
+*   Imports:    vmt - pointer to the mutex structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_mutex_release( void *vmt )
+{
+}
+
+/**
+*   Purpose:    Acquire (down) a mutex.
+*
+*   Imports:    vmt - pointer to the mutex structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_mutex_acquire( void *vmt )
+{
+}
+
+/**
+*   Purpose:    Acquire (down) a mutex (Interruptible).
+*
+*   Imports:    vmt - pointer to the mutex structure
+*
+*   Exports:    0      - you got the mutex
+*               -EINTR - you've been interrupted, no mutex
+*
+*PUBLIC**************************/
+int HostOS_mutex_acquire_intr( void *vmt )
+{
+
+    return( 0 ) ;
+}
+
+/**
+*   Purpose:    Copies a block from user space to kernel space.
+*
+*   Imports:    to     - pointer to a kernel space buffer to receive the data
+*               from   - pointer to a user space buffer to source the data
+*               nbytes - number of bytes to copy
+*
+*   Exports:    number of bytes copied 
+*
+*PUBLIC**************************/
+unsigned long HostOS_copy_from_user( void *to, const void *from, unsigned long nbytes )
+{
+
+    return( 0 ) ;
+}
+
+/**
+*   Purpose:    Copies a block from kernel space to user space.
+*
+*   Imports:    to     - pointer to a user space buffer to receive the data
+*               from   - pointer to a kernel space buffer to source the data
+*               nbytes - number of bytes to copy
+*
+*   Exports:    number of bytes copied 
+*
+*PUBLIC**************************/
+unsigned long HostOS_copy_to_user( void *to, const void *from, unsigned long nbytes )
+{
+
+    return( 0 ) ;
+}
+
+#if defined(PCI_DRVR_SUPPORT)
+/**
+*   Purpose:    Check if the carrier is ok.
+*
+*   Imports:    kdev - context structure with device pointer
+*
+*   Exports:
+*
+*PUBLIC**************************/
+unsigned long HostOS_netif_carrier_ok( void *kdev )
+{
+
+    return( 0 ) ;
+}
+
+/**
+*   Purpose:    Sets net carrier on.
+*
+*   Imports:    kdev - context structure with device pointer
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_netif_carrier_on( void *kdev )
+{
+}
+
+/**
+*   Purpose:    Sets net carrier off.
+*
+*   Imports:    kdev - context structure with device pointer
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_netif_carrier_off( void *kdev )
+{
+}
+
+/**
+*   Purpose:    Sets the MAC address in the OS.
+*
+*   Imports:    mac_hi - Bytes 0-3 of MAC address
+*               mac_lo - Bytes 4-5 of MAC address
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_set_mac_address( void *kdev, SYS_UINT32 mac_hi, SYS_UINT32 mac_lo )
+{
+}
+
+/**
+*   Purpose:    Brings up the Ethernet interface.
+*
+*   Imports:    kdev - context structure with device pointer
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_open( void *kdev )
+{
+}
+
+/**
+*   Purpose:    Shuts down the Ethernet interface.
+*
+*   Imports:    kdev - context structure with device pointer
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_close( void *kdev )
+{
+}
+#endif
+
+#if defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT)
+
+/**
+*   Purpose:    Check pending signal of task.
+*
+*   Imports:    vtask - pointer to the task
+*
+*   Exports:    0 - no pending signal
+*               1 - has pendign signal
+*
+*PUBLIC**************************/
+int HostOS_signal_pending(void *vtask)
+{
+    return 0;
+}
+
+/**
+*   Purpose:    Sleep waiting for waitqueue interruptions.
+*
+*   Imports:    msecs - Time in milliseconds to sleep for
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_msleep_interruptible(unsigned int msecs)
+{
+    
+}
+
+/**
+*   Purpose:    Create new kernel thread.
+*
+*   Imports:    pThreadID - pointer to new kernel threadID
+*               pName     - pointer to thread name string
+*               func      - pointer to thread internal function
+*               arg       - argument to pass to thread function
+*
+*   Exports:    0  - OK
+*               -1 - FAILED
+*
+*PUBLIC**************************/
+int HostOS_thread_start(unsigned int *pThreadID, char *pName, void (*func)(void *), void *arg)
+{
+    return 0;
+}
+
+/**
+*   Purpose:    Stop a kernel thread.
+*
+*   Imports:    threadID - kernel threadID that to be stopped
+*
+*   Exports:    0   - OK
+*               -1  - FAILED
+*
+*PUBLIC**************************/
+int HostOS_thread_stop(unsigned long threadID)
+{
+    return 0;
+}
+
+#endif
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/misc_driver_stubs.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/misc_driver_stubs.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/misc_driver_stubs.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/misc_driver_stubs.c	2012-09-14 14:51:36.921926000 +0530
@@ -0,0 +1,276 @@
+/*******************************************************************************
+*
+* Common/Src/misc_driver_stubs.c
+*
+* Description: Host OS abstraction support 
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include <stddef.h>
+#include "drv_hdr.h"
+
+/** Standalone link needs a main.  No useful binary is produced but at least
+ *  we know that all the referenced symbols linked.  More proof that the 
+ *  package is good.
+ */
+int main(int argc, char **argv)
+{
+    return 0;
+}
+
+
+/**
+*  Purpose:    Converts a driver kernel context pointer to
+*              a driver data context pointer.
+*
+*  Imports:    dkcp - pointer to a device kernel context
+*
+*  Exports:    pointer to the driver data context
+*
+*PUBLIC**************************/
+void *dk_to_dd( void *dkcp )
+{
+    return NULL;
+}
+
+/**
+*  Purpose:    Converts a driver data context pointer to
+*              a driver gpl context pointer.
+*
+*  Imports:    ddcp - pointer to a device data context
+*
+*  Exports:    pointer to the driver gpl context
+*
+*PUBLIC**************************/
+void *dd_to_dg( void *ddcp )
+{
+    return NULL;
+}
+
+/**
+*  Purpose:    Converts a driver gpl context pointer to
+*              a driver control context pointer.
+*
+*  Imports:    dgcp - pointer to a device gpl context
+*
+*  Exports:    pointer to the driver control context
+*
+*PUBLIC**************************/
+void *dg_to_dc( void *dgcp )
+{
+    return NULL;
+}
+
+/**
+*  Purpose:    Converts a driver gpl context pointer to
+*              a driver data context pointer.
+*
+*  Imports:    dgcp - pointer to a device gpl context
+*
+*  Exports:    pointer to the driver data context
+*
+*PUBLIC**************************/
+void *dg_to_dd( void *dgcp )
+{
+    return NULL;
+}
+
+
+
+////////////////////////////////////////////////////////////
+// === combo functions
+////////////////////////////////////////////////////////////
+
+/**
+ *  Purpose:    Converts a driver kernel context pointer to
+ *              a driver control context pointer.
+ *
+ *  Imports:    dkcp - pointer to a device kernel context
+ *
+ *  Exports:    pointer to the driver control context
+ *
+*PUBLIC**************************/
+void *dk_to_dc( void *dkcp )
+{
+    return NULL;
+}
+
+/**
+ *  Purpose:    Converts a driver data context pointer to
+ *              a driver control context pointer.
+ *
+ *  Imports:    dkcp - pointer to a device kernel context
+ *
+ *  Exports:    pointer to the driver control context
+ *
+*PUBLIC**************************/
+void *dd_to_dc( void *ddcp )
+{
+    return NULL;
+}
+
+/**
+ *  Purpose:    Converts a driver kernel context pointer to
+ *              a driver gpl context pointer.
+ *
+ *  Imports:    dkcp - pointer to a device kernel context
+ *
+ *  Exports:    pointer to the driver gpl context
+ *
+*PUBLIC**************************/
+void *dk_to_dg( void *dkcp )
+{
+    return NULL;
+}
+
+/**
+ *  Purpose:    Converts a driver control context pointer to
+ *              a driver data context pointer.
+ *
+ *  Imports:    dccp - pointer to a device control context
+ *
+ *  Exports:    pointer to the driver data context
+ *
+*PUBLIC**************************/
+void *dc_to_dd( void *dccp )
+{
+    return NULL;
+}
+
+
+/*******************************************************************************
+*           
+* Purpose:  Allocates and clears a DG
+*    
+* Inputs:
+*
+* Outputs:  the context
+*
+*PUBLIC***************************************************************************/
+void *ctx_alloc_dg_context( void )
+{
+    return NULL;
+}
+
+/*******************************************************************************
+*           
+* Purpose:  Frees a DG
+*    
+* Inputs:   dgcp - the DG context to free
+*
+* Outputs:  
+*
+*PUBLIC***************************************************************************/
+void ctx_free_dg_context( void *dgcp )
+{
+    return;
+}
+
+/*******************************************************************************
+*           
+* Purpose:  links a DG somewhere
+*    
+* Inputs:   vdgcp - void pointer to DG context 
+*           ddcp  - void pointer to DD context
+*           dccp  - void pointer to DC context
+*
+* Outputs:  
+*
+*PUBLIC***************************************************************************/
+void ctx_link_dg_context( void *vdgcp, void *ddcp, void *dccp )
+{
+    return;
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Initializes the OS context.
+*
+* Inputs:
+*       vdgcp        - void Pointer to the OS context.
+*
+* Outputs:
+*       0 = SYS_SUCCESS
+*
+*PUBLIC***************************************************************************/
+void Clnk_init_os_context( void *vdgcp )
+{
+    return;
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Initializes the control context.
+*
+* Inputs:
+*       dccp        - Pointer to the control context.
+*       dkcp        - Pointer to the kernel context.
+*       dev_base    - Device base address
+*
+* Outputs:
+*       0 = SYS_SUCCESS
+*
+*PUBLIC***************************************************************************/
+void ctx_linkage_lister( void *dkcp, unsigned int **vp, int len )
+{
+    return;
+}
+
+
+
+#if defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT)
+
+int clnk_write( void *vctx, SYS_UINT32 addr, SYS_UINT32 data)
+{
+    return 0;
+}
+
+int clnk_read( void *vctx, SYS_UINT32 addr, SYS_UINT32 *data)
+{
+    return 0;
+}
+
+int clnk_write_burst( void *vctx, SYS_UINT32 addr, SYS_UINT32 *data, unsigned int size, int inc )
+{
+    return 0;
+}
+
+int clnk_read_burst( void *vctx, SYS_UINT32 addr, SYS_UINT32 *data, unsigned int size, int inc)
+{
+    return 0;
+}
+
+#endif
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/util_dvr.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/util_dvr.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/util_dvr.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Src/util_dvr.c	2012-09-14 14:51:36.924928000 +0530
@@ -0,0 +1,239 @@
+/*******************************************************************************
+*
+* Common/Src/util_dvr.c
+*
+* Description: Ethernet Driver Utility Functions
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license, except that if you   *
+* have entered into a signed, written license agreement with Entropic covering *
+* this file, that agreement applies to this file instead of the GNU General    *
+* Public License.                                                              *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation, unless a different license applies as provided above.   *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License or another license     *
+* agreement between you and Entropic, is prohibited.                           *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "drv_hdr.h"
+
+/*******************************************************************************
+*                            P R O T O T Y P E S                               *
+********************************************************************************/
+
+#if defined(PCI_DRVR_SUPPORT)
+static volatile SYS_UINT32 *setup_atrans( dc_context_t *dccp, SYS_UINT32 addr);
+#endif
+
+
+#if defined(PCI_DRVR_SUPPORT)
+/**
+*   Purpose:    Messes with the addresses
+*
+*   Imports:    dccp - pointer to the driver control context
+*               addr - address of the register/location
+*                      this will be translated
+*               val  - pointer to place to put the data
+*
+*   Exports:    
+*
+*STATIC*******************************************************************************/
+static volatile SYS_UINT32 *setup_atrans(dc_context_t *dccp, SYS_UINT32 addr)
+{
+    SYS_UINTPTR base = dccp->baseAddr;
+    volatile SYS_UINT32 *dst;
+    SYS_UINT32 addr_hi = (addr & 0x0fff0000);
+    SYS_UINT32 addr_lo = (addr & 0x0000ffff);
+
+#if ECFG_CHIP_ZIP1
+    if(((addr & 0xffff0000) == 0x30000) || (addr_hi == 0x100000))
+    {
+        /* this is in the CSR block (Sonics 0x0010xxxx), so use SLV2MAR */
+        dst = (volatile SYS_UINT32 *)(base + (addr_lo | 0x30000));
+    } else {
+        /*
+         * not in the CSR block - configure and use SLV1MAR
+         * note: bits 16 and 17 should never be set at the same time
+         * it is unclear whether bit 17 will ever be set by the host driver
+         */
+        //SETUP_ATRANS(ctx, &addr);
+        dst = (volatile SYS_UINT32 *)(base + CLNK_REG_SLAVE_1_MAP_ADDR);
+        HostOS_Write_Word((addr & 0x0ffc0000) | CLNK_REG_ADDR_TRANS_ENABLE_BIT,
+                          (SYS_UINT32 *)dst);
+        dst = (volatile SYS_UINT32 *)(base + (addr & 0x3ffff));
+    }
+#else  /* ECFG_CHIP_ZIP2/ECFG_CHIP_MAVERICKS */
+    if ((addr >= EHI_START) && (addr <= EHI_END))
+    {
+        dst = (volatile SYS_UINT32 *)(base + 0x00000 + addr_lo);
+    } else if (addr_hi == AT1_BASE) {
+        dst = (volatile SYS_UINT32 *)(base + 0x10000 + addr_lo);
+    } else if (addr_hi == AT2_BASE) {
+        dst = (volatile SYS_UINT32 *)(base + 0x20000 + addr_lo);
+    } else {
+        if (addr_hi != dccp->at3_base)
+        {
+            dst = (volatile SYS_UINT32 *)(base + 0x00074);
+
+            clnk_bus_write( dccp, (SYS_UINTPTR)dst, addr_hi);
+
+            dccp->at3_base = addr_hi;
+        }
+        dst = (volatile SYS_UINT32 *)(base + 0x30000 + addr_lo);
+    }
+#endif /* ECFG_CHIP_ZIP1 */
+
+    return(dst);
+}
+#endif
+
+/**
+*   Purpose:    Reads a clink bus register/location
+*               The register/location might be on the PCI bus
+*               or it might be accessed via MDIO
+*
+*               Takes the Address Translation lock
+*
+*   Imports:    vcp  - pointer to the driver control context
+*               addr - address of the register/location
+*                      this will be translated
+*               val  - pointer to place to put the data
+*
+*   Exports:    
+*
+*PUBLIC*******************************************************************************/
+void clnk_reg_read(void *vcp, SYS_UINT32 addr, SYS_UINT32 *val)
+{
+    dc_context_t *dccp = (dc_context_t *)vcp ;
+#if defined(PCI_DRVR_SUPPORT)
+    volatile SYS_UINT32 *src;
+#endif
+    HostOS_Lock(dccp->at_lock_link);
+//HostOS_PrintLog(L_INFO, "In clnk_reg_read: address=%x \n",addr);
+#if defined(PCI_DRVR_SUPPORT)
+    src = setup_atrans(dccp, addr);
+    clnk_bus_read( dccp, (SYS_UINTPTR)src, val);
+#elif defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT) || defined(APOLLO_DRVR_SUPPORT)
+    clnk_bus_read( dccp, (SYS_UINTPTR)addr, val);
+#endif
+//HostOS_PrintLog(L_INFO, "Done clnk_reg_read: val=%x \n",*val);
+
+    HostOS_Unlock(dccp->at_lock_link);
+}
+
+/**
+*   Purpose:    Writes a clink bus register/location
+*               The register/location might be on the PCI bus
+*               or it might be accessed via MDIO
+*
+*               Takes the Address Translation lock
+*
+*   Imports:    vcp  - pointer to the driver control context
+*               addr - address of the register/location
+*                      this will be translated
+*               val  - the data to write
+*
+*   Exports:    
+*
+*PUBLIC*******************************************************************************/
+void clnk_reg_write(void *vcp, SYS_UINT32 addr, SYS_UINT32 val)
+{
+    dc_context_t *dccp = (dc_context_t *)vcp ;
+#if defined(PCI_DRVR_SUPPORT)
+    volatile SYS_UINT32 *dst;
+#endif
+
+    HostOS_Lock(dccp->at_lock_link);
+#if defined(PCI_DRVR_SUPPORT)
+    dst = setup_atrans(dccp, addr);
+    clnk_bus_write( dccp, (SYS_UINTPTR)dst, val);
+#elif defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT)  || defined(APOLLO_DRVR_SUPPORT)
+    clnk_bus_write( dccp, (SYS_UINTPTR)addr, val);
+#endif
+    HostOS_Unlock(dccp->at_lock_link);
+}
+
+/**
+*
+*   Purpose:    Writes a clink bus register/location
+*                 WITHOUT LOCKING
+*               This is in support of a block write operation
+*               and the lock is outside the write loop.
+*
+*               The register/location might be on the PCI bus
+*               or it might be accessed via MDIO
+*
+*               Take the Address Translation lock before calling
+*
+*   Imports:    vcp  - pointer to the driver control context
+*               addr - address of the register/location
+*                      this will be translated
+*               val  - the data to write
+*
+*   Exports:    
+*
+*PUBLIC*******************************************************************************/
+void clnk_reg_write_nl(void *vcp, SYS_UINT32 addr, SYS_UINT32 val)
+{
+    dc_context_t *dccp = (dc_context_t *)vcp ;
+
+#if defined(PCI_DRVR_SUPPORT)
+    volatile SYS_UINT32 *dst;
+    dst = setup_atrans(dccp, addr);
+    clnk_bus_write( dccp, (SYS_UINTPTR)dst, val);
+#elif defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT) || defined(APOLLO_DRVR_SUPPORT)
+    clnk_bus_write( dccp, (SYS_UINTPTR)addr, val);
+#endif
+
+}
+
+/**
+*   Purpose:    Reads a clink bus register/location
+*                 WITHOUT LOCKING
+*               The register/location might be on the PCI bus
+*               or it might be accessed via MDIO
+*
+*               Take the Address Translation lock before calling
+*
+*   Imports:    vcp  - pointer to the driver control context
+*               addr - address of the register/location
+*                      this will be translated
+*               val  - pointer to place to put the data
+*
+*   Exports:    
+*
+*PUBLIC*******************************************************************************/
+void clnk_reg_read_nl(void *vcp, SYS_UINT32 addr, SYS_UINT32 *val)
+{
+    dc_context_t *dccp = (dc_context_t *)vcp ;
+#if defined(PCI_DRVR_SUPPORT)
+    volatile SYS_UINT32 *src;
+    src = setup_atrans(dccp, addr);
+    clnk_bus_read( dccp, (SYS_UINTPTR)src, val);
+#elif defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT) || defined(APOLLO_DRVR_SUPPORT)
+    clnk_bus_read( dccp, (SYS_UINTPTR)addr, val);
+#endif
+}
+
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Apollo/apollo_gpl_hdr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Apollo/apollo_gpl_hdr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Apollo/apollo_gpl_hdr.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Apollo/apollo_gpl_hdr.h	2012-09-14 14:51:36.943925000 +0530
@@ -0,0 +1,66 @@
+/*******************************************************************************
+*
+* GPL/Apollo/apollo_gpl_hdr.h
+*
+* Description: GPL headers
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __apollo_gpl_hdr_h__
+#define __apollo_gpl_hdr_h__
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "driverversion.h"
+#include "HostOS_Spec_apollo.h"
+#include "linux/errno.h"
+#include "inctypes_dvr.h"
+#include "hostos_linux.h"
+
+#include "common_dvr.h"
+#include "Clnk_ctl_dvr.h"
+#include "ClnkMbx_dvr.h"
+
+#include "data_context.h"
+#include "gpl_context.h"
+#include "drv_ctl_opts.h"
+#include "clnkiodefs.h"
+
+/*******************************************************************************
+*                            P R O T O T Y P E S                               *
+********************************************************************************/
+
+#include "com_abs_proto.h"
+
+#define dc_context_t void // Temporary
+#include "Apollo_proto.h"
+#include "Common_proto.h"
+#include "HostOS_proto.h"
+
+
+#endif // __apollo_gpl_hdr_h__
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Apollo/apollo_gpl_proto.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Apollo/apollo_gpl_proto.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Apollo/apollo_gpl_proto.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Apollo/apollo_gpl_proto.h	2012-09-14 14:51:36.947925000 +0530
@@ -0,0 +1,75 @@
+/*******************************************************************************
+*
+* GPL/Apollo/apollo_gpl_proto.h
+*
+* Description: Linux Ethernet Driver types
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+
+/* Do Not Edit! The following contents produced by script.  Thu Jan 22 16:27:49 HKT 2009  */
+
+
+/*** public prototypes from GPL/Apollo/en256x.c ***/
+int memory_init(void);
+void memory_exit(void);
+int memory_open(struct inode *inode, struct file *filp);
+int memory_release(struct inode *inode, struct file *filp);
+ssize_t memory_read(struct file *filp, char *buf, 
+                    size_t count, loff_t *f_pos);
+ssize_t memory_write(   struct file *filp, 
+                        const char *buf, 
+                        size_t count, 
+                        loff_t *f_pos);
+int ioctl_operation(struct inode  *fs_inode, 
+                    struct file   *filp, 
+                    unsigned int  cmd, 
+                    unsigned long argument);
+int ioctl_operation_work(   struct inode *fs_inode, 
+                            struct file *filp, 
+                            unsigned int cmd, 
+                            unsigned long argument);
+unsigned long int rand(int init);
+void setup_MDIOClockOut16Bit(void);
+void MDIOClockOut16Bits(unsigned int val);
+void MDIOClockOutPreamble(void);
+unsigned int MDIOClockIn16Bit(int data_bit);
+unsigned int ClinkReadMDIOData(int reg_addr);
+void ClinkWriteMDIOData(int reg_addr,unsigned val);
+void setup_SMIClockOut16Bit(void);
+unsigned int SMI_operation(int operation, int addr,unsigned int val);
+void ClinkWaitMDIOReady(void);
+unsigned long ClinkReadFrom(unsigned long addr);
+void ClinkWriteTo(unsigned long addr, unsigned long data);
+void Turbo_open(unsigned long addr);
+void Turbo_write(unsigned long data);
+unsigned int Turbo_read(void);
+void Turbo_close(void);
+void setup_gpio_signals(void);
+
+/*** public prototypes from GPL/Apollo/apollo_mdio.c ***/
+int clnk_write( void *vctx, SYS_UINT32 addr, SYS_UINT32 data);
+int clnk_read( void *vctx, SYS_UINT32 addr, SYS_UINT32 *data);
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Apollo/apollo_mdio.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Apollo/apollo_mdio.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Apollo/apollo_mdio.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Apollo/apollo_mdio.c	2012-09-14 14:51:36.950924000 +0530
@@ -0,0 +1,106 @@
+/*******************************************************************************
+*
+* GPL/Apollo/mdio.c
+*
+* Description: High level MDIO access
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "apollo_gpl_hdr.h"
+
+
+unsigned long ClinkReadFrom(unsigned long addr);
+void ClinkWriteTo(unsigned long addr, unsigned long data);
+void Turbo_open(unsigned long addr);
+void Turbo_close(void);
+void Turbo_write(unsigned long data);
+unsigned int Turbo_read(void);
+
+
+
+/*
+*PUBLIC*******************************************************************************/
+int clnk_write( void *vctx, SYS_UINT32 addr, SYS_UINT32 data)
+{
+    ClinkWriteTo( addr, data );
+
+    return(SYS_SUCCESS);
+}
+
+
+/*
+*PUBLIC*******************************************************************************/
+int clnk_read( void *vctx, SYS_UINT32 addr, SYS_UINT32 *data)
+{
+    SYS_UINT32      ret;
+    
+    ret = ClinkReadFrom( addr );
+    *data = ret;
+
+    return(SYS_SUCCESS);
+}
+
+/*
+*P UBLIC*******************************************************************************/
+int clnk_write_burst( void *vctx, SYS_UINT32 addr, SYS_UINT32 *data, unsigned int size, int inc )
+{
+    unsigned int    i;
+   
+    Turbo_open(addr);
+
+    for(i = 0; i < size; i += sizeof(*data))
+    {
+        Turbo_write(*data);
+        data++;
+    }
+
+    Turbo_close();
+
+    return(SYS_SUCCESS);
+}
+
+/*
+*P UBLIC*******************************************************************************/
+int clnk_read_burst( void *vctx, SYS_UINT32 addr, SYS_UINT32 *data, unsigned int size, int inc)
+{
+    unsigned int    i;
+
+    Turbo_open(addr);
+
+    for(i = 0; i < size; i += sizeof(*data))
+    {
+        *data = Turbo_read();
+        data++;
+    }
+
+    Turbo_close();
+
+    return(SYS_SUCCESS);
+}
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Apollo/data_context_apollo.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Apollo/data_context_apollo.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Apollo/data_context_apollo.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Apollo/data_context_apollo.h	2012-09-14 14:51:36.953923000 +0530
@@ -0,0 +1,60 @@
+/*******************************************************************************
+*
+* GPL/CandD/data_context_candd.h
+*
+* Description: Apollo Driver data definition
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __data_context_apollo_h__
+#define __data_context_apollo_h__
+
+#include "gmac_drv.h"
+
+//
+// driver kernel context - simulating the way a net driver works
+//
+// struct _driver_kernel_context_
+// {
+//     char *name ;
+//     void *priv ;    // pointer to data context
+// };
+
+
+// typedef struct _driver_kernel_context_ dk_context_t ;
+
+//
+// driver data context - simulating the way an ethernet driver works
+//
+// struct _driver_data_context_
+// {
+// 
+//     void *p_dg_ctx ;    // pointer to driver gpl context
+// };
+// typedef struct _driver_data_context_ dd_context_t ;
+
+
+#endif /* __data_context_apollo_h__ */
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Apollo/en256x.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Apollo/en256x.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Apollo/en256x.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Apollo/en256x.c	2012-09-14 15:01:07.268508000 +0530
@@ -0,0 +1,483 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ *
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:          en256x.c %
+ * %pid_version:       1.2      %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION:      Linux driver source file for MoCA 256x
+ *
+ * DOCUMENT REF:
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+ */
+
+/* Necessary includes for device drivers */
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)
+#include <generated/autoconf.h>
+#else 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
+#include <linux/autoconf.h>
+#else
+#include <linux/config.h>
+#endif
+#endif
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h> /* printk() */
+#include <linux/slab.h> /* kmalloc() */
+#include <linux/fs.h> /* everything... */
+#include <linux/errno.h> /* error codes */
+#include <linux/types.h> /* size_t */
+#include <linux/proc_fs.h>
+#include <linux/fcntl.h> /* O_ACCMODE */
+#include <asm/system.h> /* cli(), *_flags */
+#include <asm/uaccess.h> /* copy_from/to_user */
+#include <asm/io.h>
+#include <linux/ioport.h>
+#include <linux/sockios.h>
+
+#include <tmNxTypes.h>
+#include "apollo_gpl_hdr.h"
+#include "tmbslPhyEN256X.h"
+#include "tmhwLIPP6100Eth_Cfg.h"
+#include "linux/mii.h"
+#include "mach/gmac_eth_drv.h"
+#include "data_context_apollo.h"
+
+// definitions
+
+
+#define VERSION "Apollo Version 1.22"
+
+#define K_BUF_SIZE  512
+
+#define G_IO_START  0xc8004000
+
+
+
+#define reverse_endian(b)       ((b) >= 8 ? (b)+8 : (b)+24)
+#define reverse_endian_bit(b)   (1 << reverse_endian(b))
+
+//------------------------------------------------------------------------------
+// Define Ports used
+//------------------------------------------------------------------------------
+#define MDIO_PORT           0
+#define MDIO_CONFIG_PORT    4
+#define MDIO_INPUT_PORT     8
+
+//------------------------------------------------------------------------------
+// Define Bits in the GPIO ports
+//------------------------------------------------------------------------------
+#define MDIO_CLOCK_BIT  reverse_endian_bit(4)
+#define MDIO_DATA_BIT   reverse_endian_bit(5)
+
+#define SMI_CLOCK_BIT   reverse_endian_bit(6)
+#define SMI_DATA_BIT    reverse_endian_bit(7)
+
+#define YELLOW          reverse_endian_bit(0)
+#define GREEN           reverse_endian_bit(1)
+#define IXP_MII_DIS     reverse_endian_bit(2)
+#define SoC_RESET       reverse_endian_bit(3)
+#define SWITCH_RESET    reverse_endian_bit(8)
+#define SWITCH_INTR     reverse_endian_bit(9)
+#define BUTTON          reverse_endian_bit(10)
+#define SOC_XMII_DIS    reverse_endian_bit(11)
+#define DIPLEXER        reverse_endian_bit(12)
+#define CPU_RESET       reverse_endian_bit(13)
+
+
+#define __PHY_ADDRESS           0x01
+
+
+#define MDIO_START_BITS         (0x01 << (30-16))
+#define MDIO_OP_READ            (0x02 << (28-16))
+#define MDIO_OP_WRITE           (0x01 << (28-16))
+#define MDIO_READ_TURN_AROUND   (0x03 << (16-16))
+#define MDIO_WRITE_TURN_AROUND  (0x02 << (16-16))
+
+#define MDIO_READ_MASK          (MDIO_START_BITS | MDIO_OP_READ  | PHY_ADDRESS << (23-16))
+#define MDIO_WRITE_MASK         (MDIO_START_BITS | MDIO_OP_WRITE | PHY_ADDRESS << (23-16))  
+#define MDIO_REG_PLACEMENT      (18-16)
+
+#define ADDRESS_MODE            0x1b
+#define ADDRESS_HIGH            0x1c
+#define ADDRESS_LOW             0x1d
+#define DATA_HIGH               0x1e
+#define DATA_LOW                0x1f
+
+#define _BV(n)                  (1 << (n))
+
+#define CLINK_START_WRITE       _BV(0)
+#define CLINK_START_READ        _BV(1)
+#define CLINK_AUTO_INC          _BV(2)
+#define CLINK_BUSY              _BV(3)
+#define CLINK_ERROR             _BV(4)
+
+#define PHY_READ    (MDIO_START_BITS | MDIO_OP_READ  | MDIO_READ_TURN_AROUND)
+#define PHY_WRITE   (MDIO_START_BITS | MDIO_OP_WRITE | MDIO_WRITE_TURN_AROUND)
+
+//
+// structures and definitions
+//
+
+/* This structure is used in all SIOCxMIIxxx ioctl calls */
+struct mmi_ioctl_data {
+        uint16_t                phy_id;
+        uint16_t                reg_num;
+        uint16_t                val_in;
+        uint16_t                val_out;
+};
+
+struct ioctl_stuff
+{
+    char                        name[16];
+    union ioctl_data 
+    {
+        unsigned int            *ptr;
+        struct mmi_ioctl_data   mmi;
+        unsigned char           MAC[8];
+    } dat;
+};
+
+/* Global variables of the driver */
+
+//------------------------------------------------------------------------------
+// This is the location of the gpio registers 
+//------------------------------------------------------------------------------
+
+// prototypes
+int ioctl_operation_work( void *data_kernel_context, struct ifreq *ifr, unsigned int );
+void setup_MDIOClockOut16Bit(void);
+void MDIOClockOut16Bits(unsigned int val);
+void MDIOClockOutPreamble(void);
+unsigned int MDIOClockIn16Bit(int data_bit);
+unsigned int ClinkReadMDIOData(int reg_addr);
+void ClinkWriteMDIOData(int reg_addr,unsigned val);
+void setup_SMIClockOut16Bit(void);
+unsigned int SMI_operation(int operation, int addr,unsigned int val);
+void ClinkWaitMDIOReady(void);
+void Clink_update_unitnum_phyaddr( int unitNum, int phy_addr);
+unsigned long ClinkReadFrom(unsigned long addr);
+void ClinkWriteTo(unsigned long addr, unsigned long data);
+void Turbo_open(unsigned long addr);
+void Turbo_write(unsigned long data);
+unsigned int Turbo_read(void);
+void Turbo_close(void);
+extern tmErrorCode_t tmbslPhyEN256XRead (
+	tmUnitSelect_t		ethUnitId,
+	tmbslPhyEN256XReg_t	reg,
+	pUInt16			pVal
+	);
+
+
+extern tmErrorCode_t tmbslPhyEN256XWrite (
+    tmUnitSelect_t		ethUnitId,
+    tmbslPhyEN256XReg_t		reg,
+    UInt16			val
+	);
+static int en256x_unitnum, en256x_phy_addr;
+
+/*
+*
+*
+*
+*
+*
+*
+*PUBLIC***/
+int ioctl_operation_work( void *data_kernel_context, struct ifreq *ifr, unsigned cmd )
+{
+    unsigned int val1, val2;
+    struct mii_ioctl_data *data = if_mii(ifr);
+    int flag,status = 0;
+    void *arg = NULL;
+    dk_context_t *dkcp;
+    arg = ifr->ifr_data;
+
+    dkcp = (dk_context_t *)data_kernel_context ;
+
+    switch (cmd)
+    {
+        case SIOCETHTOOL:       // Ethernet tool
+            break;       
+        case SIOCGMIIPHY:       // Get PHY address
+            data->phy_id = en256x_phy_addr;   //pPlatData->phy_addr_val;
+            break;
+        case SIOCHDRCMD:        // Resets the SoC , Control the diplexer switch etc
+            flag = ifr->ifr_ifru.ifru_ivalue;
+#ifdef CONFIG_EN256X_GPIO_TOGGLE
+            val1 = readl(GPIO_PIN_MUX_REG_3); 
+            val2 = readl(GPIO_PIN_MUX_REG_4);
+            val1 |= 0x02000000;
+            val2 |= 0x08;
+            writel(val1, GPIO_PIN_MUX_REG_4);
+            writel(val2, GPIO_PIN_MUX_REG_5);
+            mdelay(10);
+            val1 = (val1 & 0xFFFFFFCF);
+            val2 = (val2 & 0xFFFFFFF7);
+            writel(val1, GPIO_PIN_MUX_REG_4);
+            writel(val2, GPIO_PIN_MUX_REG_5);
+#endif
+
+            if(flag)
+            {
+                writel(0, 0xE0680364); //We are writing to SGPIO directly too bad
+                printk(KERN_INFO "MoCA en256X SoC in-reset\n");
+            }
+            else
+            {
+                writel(3, 0xE0680364); //We are writing to SGPIO directly too too bad
+                printk(KERN_INFO "MoCA en256X SoC out of reset\n");
+            }
+            break;
+        case SIOCGMIIREG:       // PHY read request
+            data->val_out = ClinkReadMDIOData(data->reg_num);
+            break;
+        case SIOCSMIIREG:       // PHY write request
+            ClinkWriteMDIOData(data->reg_num,data->val_in);
+            break;
+        case SIOCCLINKDRV :     // Control plane commands for the driver
+            status = clnkioc_driver_cmd( dkcp, arg ) ;
+            break ; 
+        case SIOCGCLINKMEM :    // Reads registers/memory in c.LINK address space
+            status = clnkioc_mem_read( dkcp, arg ) ;
+            break ; 
+        case SIOCSCLINKMEM :    // Sets registers/memory in c.LINK address space
+            status = clnkioc_mem_write( dkcp, arg ) ;
+            break ; 
+/*
+        case SIOCGCLNKCMD :     // mbox cmmds: request with response
+            status = clnkioc_mbox_cmd_request( dkcp, arg, 1 ) ;
+            break ;
+        case SIOCSCLNKCMD :     // mbox cmmds: request with no response
+            status = clnkioc_mbox_cmd_request( dkcp, arg, 0 ) ;
+            break ;
+        case SIOCLNKDRV :       // mbox cmmds: retrieve unsol messages
+            status = clnkioc_mbox_unsolq_retrieve( dkcp, arg ) ;
+            break ;         
+*/
+	case SIOCMSCMD:
+	    status = clnkioc_moca_shell_cmd( dkcp, arg ) ;
+            break ;
+        default:
+            printk(KERN_ALERT "DIAG: IOCTL operation %x \n",cmd);
+            break ;
+    }
+    return(status);
+}
+
+/******************************************************
+
+        End of MODULE functions
+
+        Start of Utility functions
+
+*******************************************************/
+void Clink_update_unitnum_phyaddr( int unitNum, int phy_addr)
+{
+    en256x_unitnum = unitNum;
+    en256x_phy_addr = phy_addr;
+}
+
+/*
+*
+*
+*
+*
+*
+*
+*PUBLIC***/
+unsigned int ClinkReadMDIOData(int reg_addr)
+{
+    unsigned short data;
+    
+    tmbslPhyEN256XRead(en256x_unitnum, reg_addr, &data);
+
+    return(data);
+
+}
+
+/*
+*
+*
+*
+*
+*
+*
+*PUBLIC***/
+void ClinkWriteMDIOData(int reg_addr,unsigned val)
+{    
+    tmbslPhyEN256XWrite(en256x_unitnum, reg_addr, val);
+}
+
+
+/*
+*           wait for SoC bus to say idle
+*
+*
+*
+*
+*
+*PUBLIC***/
+void ClinkWaitMDIOReady(void)
+{
+    unsigned int rc;
+    for (;;) {          // If there is problem in SoC, Watchdog interrupt will reset me !!!
+        rc=ClinkReadMDIOData(ADDRESS_MODE);
+        if ((rc & 0xff) == 0)
+            return;
+        if (rc & CLINK_BUSY)
+        {
+            continue;
+        }
+        if (rc & CLINK_ERROR)
+        {
+            continue;
+        }
+        return;
+    }
+}
+
+
+/*
+*            read the soncis bus
+*
+*
+*
+*
+*
+*PUBLIC***/
+unsigned long ClinkReadFrom(unsigned long addr)
+{
+    unsigned long data;
+
+    ClinkWaitMDIOReady();
+    ClinkWriteMDIOData(ADDRESS_HIGH, addr >> 16);
+    ClinkWriteMDIOData(ADDRESS_LOW, addr & 0xffff);
+    ClinkWriteMDIOData(ADDRESS_MODE, CLINK_START_READ);
+    ClinkWaitMDIOReady();
+    data=ClinkReadMDIOData(DATA_HIGH);
+    data = data << 16;
+    data |= (ClinkReadMDIOData(DATA_LOW) & 0xffff);
+    return data;
+}
+
+
+/*
+*          read the soncis bus
+*
+*
+*
+*
+*
+*PUBLIC***/
+void ClinkWriteTo(unsigned long addr, unsigned long data)
+{
+    ClinkWaitMDIOReady();
+    ClinkWriteMDIOData(ADDRESS_HIGH, addr >> 16);
+    ClinkWriteMDIOData(ADDRESS_LOW, addr & 0xffff);
+    
+    ClinkWriteMDIOData(DATA_HIGH, data >> 16);
+    ClinkWriteMDIOData(DATA_LOW, data & 0xffff);
+    ClinkWriteMDIOData(ADDRESS_MODE, CLINK_START_WRITE);
+}
+
+/*
+*
+*
+*
+*
+*
+*
+*PUBLIC***/
+void Turbo_open(unsigned long addr)
+{
+    ClinkWaitMDIOReady();
+    ClinkWriteMDIOData(ADDRESS_HIGH, addr >> 16);
+    ClinkWriteMDIOData(ADDRESS_LOW, addr);
+    ClinkWriteMDIOData(ADDRESS_LOW, addr);
+}
+
+/*
+*
+*
+*
+*
+*
+*
+*PUBLIC***/
+void Turbo_write(unsigned long data)
+{
+    ClinkWriteMDIOData(DATA_HIGH, data >> 16);
+    ClinkWriteMDIOData(DATA_LOW, data);
+    ClinkWriteMDIOData(ADDRESS_MODE, CLINK_START_WRITE | CLINK_AUTO_INC);
+}
+
+/*
+*
+*
+*
+*
+*
+*
+*PUBLIC***/
+unsigned int Turbo_read(void)
+{
+    unsigned int data = 0;
+    unsigned int retVal = 0;
+
+    ClinkWriteMDIOData(ADDRESS_MODE, CLINK_START_READ | CLINK_AUTO_INC);
+
+    data = ClinkReadMDIOData(DATA_HIGH);
+    retVal = data << 16;
+    data = ClinkReadMDIOData(DATA_LOW);
+    retVal |= data & 0xFFFF;
+    
+    return retVal;
+}
+
+/*
+*
+*
+*
+*
+*
+*
+*PUBLIC***/
+void Turbo_close(void)
+{
+    ClinkWriteMDIOData(ADDRESS_MODE, 0);
+}
+
+/*****************************************************
+
+        End of utility functions
+
+******************************************************/
+
+
+
+
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/data_context.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/data_context.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/data_context.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/data_context.h	2012-09-14 14:51:36.959926000 +0530
@@ -0,0 +1,48 @@
+/*******************************************************************************
+*
+* GPL/Common/data_context.h
+*
+* Description: data context selector
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+#ifndef __data_context_h__
+#define __data_context_h__
+
+#if defined(PCI_DRVR_SUPPORT)
+#include "data_context_pci.h"
+#endif
+#if defined(E1000_DRVR_SUPPORT) 
+#include "data_context_e1000.h"
+#endif
+#if defined(CANDD_DRVR_SUPPORT) 
+#include "data_context_candd.h"
+#endif
+#if defined(APOLLO_DRVR_SUPPORT)
+#include "data_context_apollo.h"
+#endif
+
+#endif // __data_context_h__
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/gpl_context.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/gpl_context.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/gpl_context.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/gpl_context.h	2012-09-14 14:51:36.963930000 +0530
@@ -0,0 +1,66 @@
+/*******************************************************************************
+*
+* GPL/Common/gpl_context.h
+*
+* Description: PCI Driver GPL Context
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __gpl_context_h__
+#define __gpl_context_h__
+
+
+/*
+    This structure/variable is instantiated at probe time by allocation.
+    It is pointed to from the driver data context p_dg_ctx member. 
+*/
+
+struct _driver_gpl_context_ {
+    void                *p_dd_ctx ; // pointer to driver data    context
+    void                *p_dc_ctx ; // pointer to driver control context
+
+#ifdef CLNK_HOST_SEM
+    hostos_sema_t       at_lock; 
+#else
+    hostos_lock_t       at_lock;        // address translator spin lock - referenced in !GPL side
+#endif
+
+    hostos_sema_t       ioctl_sem;      // Mutex for ioctl threads, keeps them one at a time 
+
+#ifdef CLNK_HOST_SEM
+    hostos_sema_t       mbx_cmd_lock;   // mailbox cmd mutex semphore - referenced in !GPL side
+    hostos_sema_t       mbx_swun_lock;  // mailbox sw unsol mutex semphore - referenced in !GPL side
+    hostos_sema_t       ms_cmd_lock;    // moca shell command mutex semphore - referenced in !GPL side
+#else
+    hostos_lock_t       mbx_cmd_lock;   // mailbox cmd spin lock - referenced in !GPL side
+    hostos_lock_t       mbx_swun_lock;  // mailbox sw unsol spin lock - referenced in !GPL side
+    hostos_lock_t       ms_cmd_lock;    // moca shell command spin lock - referenced in !GPL side
+#endif
+
+};
+
+typedef struct _driver_gpl_context_ dg_context_t ;
+
+#endif  // __gpl_context_h__
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/gpl_ctx_abs.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/gpl_ctx_abs.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/gpl_ctx_abs.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/gpl_ctx_abs.c	2012-09-14 14:51:36.967924000 +0530
@@ -0,0 +1,310 @@
+/*******************************************************************************
+*
+* GPL/Common/gpl_ctx_abs.c
+*
+* Description: context abstraction
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+
+/*******************************************************************************
+*                                N O T E                                       *
+********************************************************************************/
+
+
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "gpl_hdr.h"
+
+
+/*
+    The parameter  CONTEXT_DEBUG   must be defined to enable context
+    linkage checking. With it defined you'll get error checking and
+    messages about null context linkage pointers.
+*/
+#define CONTEXT_DEBUG       0   // define 1 for context linkage checking
+
+
+
+
+
+
+/**
+*  Purpose:    Converts a driver kernel context pointer to
+*              a driver data context pointer.
+*
+*  Imports:    dkcp - pointer to a device kernel context
+*
+*  Exports:    pointer to the driver data context
+*
+*PUBLIC**************************/
+void *dk_to_dd( void *dkcp )
+{
+    dd_context_t *ddcp ;
+
+#if CONTEXT_DEBUG
+    if( dkcp ) {
+        ddcp = ((dk_context_t *)dkcp)->priv;
+    } else {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dk_to_dd\n" );
+        ddcp = 0 ;
+    }
+#else
+    ddcp = ((dk_context_t *)dkcp)->priv;
+#endif
+    return( ddcp ) ;
+}
+
+/**
+*  Purpose:    Converts a driver data context pointer to
+*              a driver gpl context pointer.
+*
+*  Imports:    ddcp - pointer to a device data context
+*
+*  Exports:    pointer to the driver gpl context
+*
+*PUBLIC**************************/
+void *dd_to_dg( void *ddcp )
+{
+    dg_context_t *dgcp ;
+
+#if CONTEXT_DEBUG
+    if( ddcp ) {
+        dgcp = ((dd_context_t *)ddcp)->p_dg_ctx;
+    } else {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dd_to_dg\n" );
+        dgcp = 0 ;
+    }
+#else
+    dgcp = ((dd_context_t *)ddcp)->p_dg_ctx ;
+#endif
+
+    return( dgcp ) ;
+}
+
+/**
+*  Purpose:    Converts a driver gpl context pointer to
+*              a driver control context pointer.
+*
+*  Imports:    dgcp - pointer to a device gpl context
+*
+*  Exports:    pointer to the driver control context
+*
+*PUBLIC**************************/
+void *dg_to_dc( void *dgcp )
+{
+    void *dccp ;
+
+#if CONTEXT_DEBUG
+    if( dgcp ) {
+        dccp = ((dg_context_t *)dgcp)->p_dc_ctx;
+    } else {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dg_to_dc\n" );
+        dccp = 0 ;
+    }
+#else
+    dccp = ((dg_context_t *)dgcp)->p_dc_ctx ;
+#endif
+
+    return( dccp ) ;
+}
+
+/**
+*  Purpose:    Converts a driver gpl context pointer to
+*              a driver data context pointer.
+*
+*  Imports:    dgcp - pointer to a device gpl context
+*
+*  Exports:    pointer to the driver data context
+*
+*PUBLIC**************************/
+void *dg_to_dd( void *dgcp )
+{
+    dd_context_t *ddcp ;
+
+#if CONTEXT_DEBUG
+    if( dgcp ) {
+        ddcp = ((dg_context_t *)dgcp)->p_dd_ctx;
+    } else {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dg_to_dd\n" );
+        ddcp = 0 ;
+    }
+#else
+    ddcp = ((dg_context_t *)dgcp)->p_dd_ctx ;
+#endif
+
+    return( ddcp ) ;
+}
+
+
+
+////////////////////////////////////////////////////////////
+// === combo functions
+////////////////////////////////////////////////////////////
+
+/**
+ *  Purpose:    Converts a driver kernel context pointer to
+ *              a driver control context pointer.
+ *
+ *  Imports:    dkcp - pointer to a device kernel context
+ *
+ *  Exports:    pointer to the driver control context
+ *
+*PUBLIC**************************/
+void *dk_to_dc( void *dkcp )
+{
+    void *ddcp ;
+    void *dgcp ;
+    void *dccp ;
+
+#if CONTEXT_DEBUG
+    dccp = 0 ;
+    if( dkcp ) {
+        ddcp = dk_to_dd( dkcp ) ;
+        if( ddcp ) {
+            dgcp = dd_to_dg( ddcp ) ;
+            if( dgcp ) {
+                dccp = dg_to_dc( dgcp ) ;
+            }
+        }
+    }
+    if( !dccp ) {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dk_to_dc\n" );
+    }
+#else
+    ddcp = dk_to_dd( dkcp ) ;
+    dgcp = dd_to_dg( ddcp ) ;
+    dccp = dg_to_dc( dgcp ) ;
+#endif
+
+    return( dccp ) ;
+}
+
+/**
+ *  Purpose:    Converts a driver data context pointer to
+ *              a driver control context pointer.
+ *
+ *  Imports:    dkcp - pointer to a device kernel context
+ *
+ *  Exports:    pointer to the driver control context
+ *
+*PUBLIC**************************/
+void *dd_to_dc( void *ddcp )
+{
+    void *dgcp ;
+    void *dccp ;
+
+#if CONTEXT_DEBUG
+    dccp = 0 ;
+    if( ddcp ) {
+        dgcp = dd_to_dg( ddcp ) ;
+        if( dgcp ) {
+            dccp = dg_to_dc( dgcp ) ;
+        }
+    }
+    if( !dccp ) {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dd_to_dc\n" );
+    }
+#else
+    dgcp = dd_to_dg( ddcp ) ;
+    dccp = dg_to_dc( dgcp ) ;
+#endif
+
+    return( dccp ) ;
+}
+
+/**
+ *  Purpose:    Converts a driver kernel context pointer to
+ *              a driver gpl context pointer.
+ *
+ *  Imports:    dkcp - pointer to a device kernel context
+ *
+ *  Exports:    pointer to the driver gpl context
+ *
+*PUBLIC**************************/
+void *dk_to_dg( void *dkcp )
+{
+    void *ddcp ;
+    void *dgcp ;
+
+#if CONTEXT_DEBUG
+    dgcp = 0 ;
+    if( dkcp ) {
+        ddcp = dk_to_dd( dkcp ) ;
+        if( ddcp ) {
+            dgcp = dd_to_dg( ddcp ) ;
+        }
+    }
+    if( !dgcp ) {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dk_to_dg\n" );
+    }
+#else
+    ddcp = dk_to_dd( dkcp ) ;
+    dgcp = dd_to_dg( ddcp ) ;
+#endif
+
+    return( dgcp ) ;
+}
+
+/**
+ *  Purpose:    Converts a driver control context pointer to
+ *              a driver data context pointer.
+ *
+ *  Imports:    dccp - pointer to a device control context
+ *
+ *  Exports:    pointer to the driver data context
+ *
+*PUBLIC**************************/
+void *dc_to_dd( void *dccp )
+{
+    void *dgcp ;
+    void *ddcp ;
+
+#if CONTEXT_DEBUG
+    ddcp = 0 ;
+    if( dccp ) {
+        dgcp = dc_to_dg( dccp ) ;
+        if( dgcp ) {
+            ddcp = dg_to_dd( dgcp ) ;
+        }
+    }
+    if( !ddcp ) {
+        HostOS_PrintLog(L_INFO, "Error - context linkage dc_to_dd\n" );
+    }
+#else
+    dgcp = dc_to_dg( dccp ) ;
+    ddcp = dg_to_dd( dgcp ) ;
+#endif
+
+    return( ddcp ) ;
+}
+
+
+
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/gpl_ctx_setup.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/gpl_ctx_setup.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/gpl_ctx_setup.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/gpl_ctx_setup.c	2012-09-14 14:51:36.970926000 +0530
@@ -0,0 +1,161 @@
+/*******************************************************************************
+*
+* GPL/Common/gpl_ctx_setup.c
+*
+* Description: context setup support
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "gpl_hdr.h"
+
+
+
+/*******************************************************************************
+*            S t a t i c   M e t h o d   P r o t o t y p e s                   *
+********************************************************************************/
+
+/*******************************************************************************
+*           
+* Purpose:  Allocates and clears a DG
+*    
+* Inputs:
+*
+* Outputs:  the context
+*
+*PUBLIC***************************************************************************/
+void *ctx_alloc_dg_context( void )
+{
+    dg_context_t *dgcp ;
+
+    dgcp = (dg_context_t *)HostOS_Alloc(sizeof(dg_context_t));
+    if( dgcp )
+    {
+        HostOS_Memset(dgcp, 0, sizeof(dg_context_t));
+    }
+
+    return(dgcp);
+}
+
+/*******************************************************************************
+*           
+* Purpose:  Frees a DG
+*    
+* Inputs:   dgcp - the DG context to free
+*
+* Outputs:  
+*
+*PUBLIC***************************************************************************/
+void ctx_free_dg_context( void *dgcp )
+{
+
+    HostOS_Free( dgcp, sizeof(dg_context_t) ) ;
+
+}
+
+/*******************************************************************************
+*           
+* Purpose:  links a DG somewhere
+*    
+* Inputs:   vdgcp - void pointer to DG context 
+*           ddcp  - void pointer to DD context
+*           dccp  - void pointer to DC context
+*
+* Outputs:  
+*
+*PUBLIC***************************************************************************/
+void ctx_link_dg_context( void *vdgcp, void *ddcp, void *dccp )
+{
+    dg_context_t *dgcp = vdgcp ;
+
+    dgcp->p_dd_ctx = (void *)ddcp ;  // link dg to dd
+    dgcp->p_dc_ctx = (void *)dccp;   // link dg to dc
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Initializes the OS context.
+*
+* Inputs:
+*       vdgcp        - void Pointer to the OS context.
+*
+* Outputs:
+*       0 = SYS_SUCCESS
+*
+*PUBLIC***************************************************************************/
+void Clnk_init_os_context( void *vdgcp )
+{
+    dg_context_t *dgcp = vdgcp ;
+
+#ifdef CLNK_HOST_SEM
+    HostOS_mutex_init(   &dgcp->at_lock);       // referenced from !GPL side
+#else
+    HostOS_lock_init(   &dgcp->at_lock);        // referenced from !GPL side
+#endif
+
+    HostOS_mutex_init(  &dgcp->ioctl_sem);
+
+#ifdef CLNK_HOST_SEM
+    HostOS_mutex_init(   &dgcp->mbx_cmd_lock);   // referenced from !GPL side
+    HostOS_mutex_init(   &dgcp->mbx_swun_lock);  // referenced from !GPL side
+    HostOS_mutex_init(   &dgcp->ms_cmd_lock);    // referenced from !GPL side
+#else
+    HostOS_lock_init(   &dgcp->mbx_cmd_lock);   // referenced from !GPL side
+    HostOS_lock_init(   &dgcp->mbx_swun_lock);  // referenced from !GPL side
+    HostOS_lock_init(   &dgcp->ms_cmd_lock);    // referenced from !GPL side
+#endif
+}
+
+/*******************************************************************************
+*
+* Description:
+*       Initializes the control context.
+*
+* Inputs:
+*       dccp        - Pointer to the control context.
+*       dkcp        - Pointer to the kernel context.
+*       dev_base    - Device base address
+*
+* Outputs:
+*       0 = SYS_SUCCESS
+*
+*PUBLIC***************************************************************************/
+void ctx_linkage_lister( void *dkcp, unsigned int **vp, int len )
+{
+    dg_context_t *dgcp = dk_to_dg( dkcp ) ;
+
+    *vp++ = (unsigned int *)&dgcp->at_lock;
+    *vp++ = (unsigned int *)&dgcp->ioctl_sem;
+    *vp++ = (unsigned int *)&dgcp->mbx_cmd_lock;
+    *vp++ = (unsigned int *)&dgcp->mbx_swun_lock;
+    *vp++ = (unsigned int *)&dgcp->ms_cmd_lock;
+}
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/gpl_hdr.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/gpl_hdr.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/gpl_hdr.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/gpl_hdr.h	2012-09-14 14:51:36.973931000 +0530
@@ -0,0 +1,76 @@
+/*******************************************************************************
+*
+* GPL/Common/gpl_hdr.h
+*
+* Description: GPL headers
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef __gpl_hdr_h__
+#define __gpl_hdr_h__
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "linux/errno.h"
+#include "inctypes_dvr.h"
+#include "hostos_linux.h"
+
+#include "common_dvr.h"
+
+#if defined(PCI_DRVR_SUPPORT) 
+#include "HostOS_Spec_pci.h"
+#include "eth_dvr.h"
+#endif
+
+#if defined(CANDD_DRVR_SUPPORT) 
+#include "HostOS_Spec_candd.h"
+#endif
+#if defined(APOLLO_DRVR_SUPPORT)
+#include "HostOS_Spec_apollo.h"
+#endif
+
+#if defined(E1000_DRVR_SUPPORT) 
+#include "HostOS_Spec_e1000.h"
+#include "e1000.h"
+#endif
+
+#include "data_context.h"
+#include "gpl_context.h"
+
+/*******************************************************************************
+*                            P R O T O T Y P E S                               *
+********************************************************************************/
+
+#if defined(PCI_DRVR_SUPPORT) 
+#include "pci_gpl_proto.h"
+#endif
+#include "com_abs_proto.h"
+
+#include "HostOS_proto.h"
+
+
+#endif // __gpl_hdr_h__
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/hostos_linux.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/hostos_linux.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/hostos_linux.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/hostos_linux.c	2012-09-14 14:51:36.977927000 +0530
@@ -0,0 +1,1433 @@
+/*******************************************************************************
+*
+* GPL/Common/hostos_linux.c
+*
+* Description: Host OS support for Linux
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+/*******************************************************************************
+*                            # I n c l u d e s                                 *
+********************************************************************************/
+
+#include "gpl_hdr.h"
+
+
+
+#define LOCK_MAGIC      0x4c4f434b       // spells "LOCK"
+
+#define KMALLOC_MAX     65536
+
+extern unsigned long volatile jiffies;
+
+
+/**
+*   Purpose:    Sets size bytes of memory to a given byte value.
+*
+*   Imports:    pMem - pointer to block of memory to set
+*               val  - value to set each byte to
+*               size - number of bytes to set
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_Memset(void *pMem, int val, int size)
+{
+    memset(pMem, val, size);
+}
+
+/**
+*   Purpose:    Copies size bytes of memory from pFrom to pTo.
+*               The memory areas may not overlap.
+*
+*   Imports:    pTo   - pointer to destination memory area
+*               pFrom - pointer to source memory area
+*               size  - number of bytes to copy
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_Memcpy(void *pTo, void *pFrom, int size)
+{
+    memcpy(pTo, pFrom, size);
+}
+
+/**
+*   Purpose:    Scans input buffer and according to format specified.
+*
+*   Imports:    buf   - input buffer
+*               fmt   - input format
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_Sscanf(const char *buf, const char *fmt, ...)
+{
+    va_list args;
+
+    va_start(args, fmt);
+    vsscanf(buf, fmt, args);
+    va_end(args);
+}
+
+/**
+*   Purpose:    Allocates DMA-addressable memory.
+*
+*   Imports:    size - size to allocate
+*
+*   Exports:    pointer to allocated block
+*
+*PUBLIC**************************/
+void* HostOS_Alloc(int size)
+{
+    void *pMem;
+
+    if (size < KMALLOC_MAX)
+        pMem = kmalloc(size, GFP_KERNEL /* | __GFP_DMA */);
+    else
+        pMem = (void *)__get_free_pages(GFP_KERNEL, get_order(size));
+    // printk("AllocMem %d %p\n", size, pMem);
+
+    /** Assure that system constants defined in Entropic space have harmonious
+     *  definitions compared with Unix constants.  This is not the most 
+     *  pure place to put this but it does not have any runtime cost since
+     *  the compiler optimizes it away. */
+    INCTYPES_COMPILE_TIME_ASSERT( EIO       == SYS_INPUT_OUTPUT_ERROR     );
+    INCTYPES_COMPILE_TIME_ASSERT( ENOMEM    == SYS_OUT_OF_MEMORY_ERROR    );
+    INCTYPES_COMPILE_TIME_ASSERT( EACCES    == SYS_PERMISSION_ERROR       );
+    INCTYPES_COMPILE_TIME_ASSERT( EFAULT    == SYS_INVALID_ADDRESS_ERROR  );
+    INCTYPES_COMPILE_TIME_ASSERT( EINVAL    == SYS_INVALID_ARGUMENT_ERROR );
+    INCTYPES_COMPILE_TIME_ASSERT( ENOSPC    == SYS_OUT_OF_SPACE_ERROR     );
+    INCTYPES_COMPILE_TIME_ASSERT( ENOTEMPTY == SYS_DIR_NOT_EMPTY_ERROR    );
+    INCTYPES_COMPILE_TIME_ASSERT( ENOMSG    == SYS_BAD_MSG_TYPE_ERROR     );
+    INCTYPES_COMPILE_TIME_ASSERT( ETIMEDOUT == SYS_TIMEOUT_ERROR          );
+
+    return (pMem);
+}
+
+/**
+*   Purpose:    Free DMA-addressable memory.
+*
+*   Imports:    pMem - allocation pointer from get free pages
+*               size - Requested block size
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_Free(void* pMem, int size)
+{
+    if (size < KMALLOC_MAX)
+        kfree(pMem);
+    else
+        free_pages((unsigned long)pMem, get_order(size));
+}
+
+/**
+*   Purpose:    Delays for about timeInUsec microseconds.
+*               The operation of this function is architecture dependent.
+*               It is probably a tight loop.
+*
+*   Imports:    timeInUsec - delay in microseconds
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_Sleep(int timeInUsec)
+{
+    if( timeInUsec < 1000 ) {
+        udelay(timeInUsec);
+    } else {
+        //HostOS_PrintLog(L_NOTICE, "mdelay delay=%d. jif=%d.\n", timeInUsec/1000, jiffies );
+        mdelay(timeInUsec/1000);
+        //HostOS_PrintLog(L_NOTICE, "mdelay jif=%d.\n", jiffies );
+    }
+}
+
+/**
+*   Purpose:    Inits a spinlock.
+*               Sets the magic code for later testing.
+*
+*   Imports:    vlk - pointer to an Entropic lock structure
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_lock_init( void *vlk)
+{
+    hostos_lock_t *lk = (hostos_lock_t *)vlk ;
+
+    if( !lk ) {
+        HostOS_PrintLog(L_ERR, "Error: invalid lock pointer\n");
+    } else {
+        spin_lock_init( &lk->lock_spinlock );
+        lk->lock_magic     = LOCK_MAGIC;
+    }
+}
+
+/**
+*   Purpose:    Waits for the lock.
+*               The lock must be initialized.
+*
+*               See the macro:  HostOS_Lock
+*
+*   Imports:    vlk - pointer to an initialized Entropic lock structure
+*                     or pointer to the mutex structure
+*
+*   Exports:    none - when this returns you have the lock.
+*                      Please do an unlock later.
+*
+*PUBLIC**************************/
+void HostOS_Lock(void *vlk)
+{
+#ifndef CLNK_HOST_SEM    
+    hostos_lock_t *lk = (hostos_lock_t *)vlk ;
+
+    BUG_ON((! lk) || (lk->lock_magic != LOCK_MAGIC));
+
+    if( in_irq() ) {
+        spin_lock(&lk->lock_spinlock);
+    } else {
+        spin_lock_irqsave(&lk->lock_spinlock, lk->lock_irq_flags);
+    }
+#else
+    down((struct semaphore *)vlk); 
+#endif
+}
+
+/**
+*   Purpose:    Saves current interrupt context and waits for the lock.
+*               The lock must be initialized.
+*
+*   Imports:    vlk - pointer to an initialized Entropic lock structure
+*
+*   Exports:    none - when this returns you have the lock.
+*                      Please do an unlock later.
+*
+*PUBLIC**************************/
+void HostOS_Lock_Irqsave(void *vlk)
+{
+    hostos_lock_t *lk = (hostos_lock_t *)vlk ;
+
+    BUG_ON((! lk) || (lk->lock_magic != LOCK_MAGIC));
+
+    spin_lock_irqsave(&lk->lock_spinlock, lk->lock_irq_flags);
+}
+
+/**
+*   Purpose:    Trys to get the lock.
+*               The lock must be initialized.
+*
+*   Imports:    vlk - pointer to an initialized Entropic lock structure
+*
+*   Exports:    0 - the lock was NOT acquired. Please try again.
+*               1 - the lock is yours. Please ulock it later.
+*
+*PUBLIC**************************/
+int HostOS_Lock_Try(void *vlk)
+{
+    hostos_lock_t *lk = (hostos_lock_t *)vlk ;
+    int locked ;
+
+    BUG_ON((! lk) || (lk->lock_magic != LOCK_MAGIC));
+
+    locked = spin_trylock(&lk->lock_spinlock) ;
+
+    return( locked );
+}
+
+/**
+*   Purpose:    Unlocks a lock.
+*               The lock must be initialized.
+*
+*               See the macro:  HostOS_Unlock
+*
+*   Imports:    vlk - pointer to an initialized Entropic lock structure
+*
+*   Exports:    none - when this returns you have released the lock.
+*
+*PUBLIC**************************/
+void HostOS_Unlock(void *vlk)
+{
+#ifndef CLNK_HOST_SEM 
+    hostos_lock_t *lk = (hostos_lock_t *)vlk ;
+
+    BUG_ON((! lk) || (lk->lock_magic != LOCK_MAGIC));
+
+    if( in_irq() ) {
+        spin_unlock(&lk->lock_spinlock);
+    } else {
+        spin_unlock_irqrestore(&lk->lock_spinlock, lk->lock_irq_flags);
+    }
+#else
+    up((struct semaphore *)vlk); 
+#endif
+}
+
+/**
+*   Purpose:    Unlocks a lock and restores interrupt context.
+*               The lock must be initialized.
+*
+*
+*   Imports:    vlk - pointer to an initialized Entropic lock structure
+*
+*   Exports:    none - when this returns you have released the lock.
+*
+*PUBLIC**************************/
+void HostOS_Unlock_Irqrestore(void *vlk)
+{
+    hostos_lock_t *lk = (hostos_lock_t *)vlk ;
+
+    BUG_ON((! lk) || (lk->lock_magic != LOCK_MAGIC));
+
+   spin_unlock_irqrestore(&lk->lock_spinlock, lk->lock_irq_flags);
+}
+
+/**
+*   Purpose:    Terminates a lock.
+*
+*   Imports:    vlk - pointer to an initialized Entropic lock structure
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_TermLock(void *vlk)
+{
+}
+
+
+// Host Print ForMaT string
+#define HPFMT "%s: %s"
+
+/**
+*   Purpose:    Variable argument OS print.
+*
+*   Imports:    lev - severity level. See the L_* enum.
+*                     See HOST_OS_PRINTLOG_THRESHOLD
+*               fmt - printf format string
+*               ... - printf format arguments
+*
+*   Exports:    none
+*
+*  For reference:  Linux has these
+*
+*  #define KERN_EMERG      "<0>"   / * system is unusable                   * /
+*  #define KERN_ALERT      "<1>"   / * action must be taken immediately     * /
+*  #define KERN_CRIT       "<2>"   / * critical conditions                  * /
+*  #define KERN_ERR        "<3>"   / * error conditions                     * /
+*  #define KERN_WARNING    "<4>"   / * warning conditions                   * /
+*  #define KERN_NOTICE     "<5>"   / * normal but significant condition     * /
+*  #define KERN_INFO       "<6>"   / * informational                        * /
+*  #define KERN_DEBUG      "<7>"   / * debug-level messages                 * /
+*
+*PUBLIC**************************/
+void HostOS_PrintLog(SYS_INT32 lev, const char *fmt, ...)
+{
+    va_list args;
+    int  printed_len;
+    static char printk_buf[1024]; /* Making it static as this is
+                                   * too much data to allocate on the stack. */
+
+    if (lev <= HOST_OS_PRINTLOG_THRESHOLD)
+    {   
+        /* Emit the output into the temporary buffer */
+        va_start(args, fmt);
+        printed_len = vsnprintf(printk_buf, sizeof(printk_buf), fmt, args);
+        va_end(args);
+
+        switch ( lev )
+        {
+            case L_EMERG   :
+                printk(KERN_EMERG   HPFMT, DRV_NAME, printk_buf);
+                break ;
+            case L_ALERT   :
+                printk(KERN_ALERT   HPFMT, DRV_NAME, printk_buf);
+                break ;
+            case L_CRIT    :
+                printk(KERN_CRIT    HPFMT, DRV_NAME, printk_buf);
+                break ;
+            case L_ERR     :
+                printk(KERN_ERR     HPFMT, DRV_NAME, printk_buf);
+                break ;
+            case L_WARNING :
+                printk(KERN_WARNING HPFMT, DRV_NAME, printk_buf);
+                break ;
+            case L_NOTICE  :
+                printk(KERN_NOTICE  HPFMT, DRV_NAME, printk_buf);
+                break ;
+            case L_INFO    :
+                printk(KERN_INFO    HPFMT, DRV_NAME, printk_buf);
+                break ;
+            case L_DEBUG   :
+                printk(KERN_DEBUG   HPFMT, DRV_NAME, printk_buf);
+                break ;
+        }
+    }
+}
+
+/**
+*   Purpose:    register/memory read access from kernel space.
+*
+*   Imports:    addr - address to read from
+*
+*   Exports:    32 bit value from given address
+*
+*PUBLIC**************************/
+SYS_UINT32 HostOS_Read_Word( SYS_UINT32 *addr )
+{
+    SYS_UINT32 rv ;
+
+#if defined(CONFIG_ARCH_ENTROPIC_ECB) && (defined(CONFIG_ARCH_IXP425) || defined(CONFIG_ARCH_IXP4XX))
+    rv = *(volatile SYS_UINT32 *)addr ;
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+    rv = readl( (const volatile void *)addr );
+#else
+    rv = readl( addr ) ;
+#endif
+#endif
+    return( rv ) ;
+}
+
+/**
+*   Purpose:    register/memory write access from kernel space.
+*
+*   Imports:    val  - 32 bit value to write
+*               addr - address to write to
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_Write_Word( SYS_UINT32 val, SYS_UINT32 *addr )
+{
+#if defined(CONFIG_ARCH_ENTROPIC_ECB) && (defined(CONFIG_ARCH_IXP425) || defined(CONFIG_ARCH_IXP4XX))
+    *(volatile SYS_UINT32 *)addr = val ;
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+    writel( val, (volatile void *)addr );
+#else
+    writel( val, addr );
+#endif
+#endif
+}
+
+
+/**
+*   Purpose:    Initialize a timer and register it.
+*
+*   Imports:    vtmr - pointer to the timer to initialize
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_timer_init( void *vtmr )
+{
+    struct hostos_timer *tmr = (struct hostos_timer *)vtmr ;
+
+    init_timer( &tmr->ostimer ) ;
+}
+
+/**
+*   Purpose:    Deactivate a registered timer.
+*
+*       http://lxr.linux.no/#linux+v2.6.24/kernel/timer.c#L509
+*
+*   Imports:    vtmr - pointer to the timer to deactivate
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+int HostOS_timer_del( void *vtmr )
+{
+    struct hostos_timer *tmr = (struct hostos_timer *)vtmr ;
+
+    return( del_timer( &tmr->ostimer ) ) ;
+}
+
+/**
+*   Purpose:    Deactivate a registered timer.
+*               And ensure the timer is not running on any CPU
+*               Can sleep
+*
+*   Imports:    vtmr - pointer to the timer to deactivate
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+int HostOS_timer_del_sync( void *vtmr )
+{
+    struct hostos_timer *tmr = (struct hostos_timer *)vtmr ;
+
+    return( del_timer_sync( &tmr->ostimer ) ) ;
+}
+
+/**
+*   Purpose:    Modifies a timer.
+*
+*       http://lxr.linux.no/#linux+v2.6.24/kernel/timer.c#L480
+*
+*   Imports:    vtmr    - pointer to the timer to deactivate
+*               timeout - timeout value from HostOS_timer_expire_seconds
+*                         or HostOS_timer_expire_ticks
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+int HostOS_timer_mod( void *vtmr, SYS_ULONG timeout )
+{
+    struct hostos_timer *tmr = (struct hostos_timer *)vtmr ;
+
+    return( mod_timer( &tmr->ostimer, timeout ) ) ;
+}
+
+/**
+*   Purpose:    Add a timer.
+*               Call this after HostOS_timer_setup
+*
+*       http://lxr.linux.no/#linux+v2.6.24/kernel/timer.c#L509
+*
+*   Imports:    vtmr - pointer to the timer to deactivate
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+void HostOS_timer_add( void *vtmr )
+{
+    struct hostos_timer *tmr = (struct hostos_timer *)vtmr ;
+
+    add_timer( &tmr->ostimer ) ;
+}
+
+/**
+*   Purpose:    Sets up a timer with function and user data.
+*
+*               See HostOS_timer_set_timeout
+*
+*   Imports:    vtmr    - pointer to the timer to deactivate
+*               func    - callback function to call at timer expiration
+*               data    - data to pass to callback
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_timer_setup( void *vtmr, timer_function_t func, SYS_UINTPTR data )
+{
+    struct hostos_timer *tmr = (struct hostos_timer *)vtmr ;
+
+    tmr->ostimer.function = func ;
+    tmr->ostimer.data     = data ;
+}
+
+/**
+*   Purpose:    Sets a timer's time out.
+*
+*               See HostOS_timer_setup
+*
+*   Imports:    vtmr    - pointer to the timer to deactivate
+*               timeout - timeout value from HostOS_timer_expire_seconds
+*                         or HostOS_timer_expire_ticks
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_timer_set_timeout( void *vtmr, SYS_ULONG timeout )
+{
+    struct hostos_timer *tmr = (struct hostos_timer *)vtmr ;
+
+    tmr->ostimer.expires  = timeout ;
+}
+
+/**
+*   Purpose:    Calculate a future expiration point.
+*              In seconds.
+*
+*   Imports:    future - number of seconds into the future
+*
+*   Exports:    A number for use in the timer expiration member
+*
+*PUBLIC**************************/
+SYS_ULONG HostOS_timer_expire_seconds( SYS_UINT32 future )
+{
+
+    return( jiffies + (future * HZ) ) ;
+}
+
+/**
+*   Purpose:    Calculate a future expiration point.
+*              In jiffies.
+*
+*   Imports:    future - number of ticks into the future
+*
+*   Exports:    A number for use in the timer expiration member
+*
+*PUBLIC**************************/
+SYS_ULONG HostOS_timer_expire_ticks( SYS_UINT32 future )
+{
+
+    return( jiffies + future ) ;
+}
+
+
+/**************************************************************
+
+    wait queue timer - support
+
+    This structure contains everything necessary to
+    use timers and wait queues from the !GPL side.
+
+    You allocate one of these wqt_t things and then
+    pass its pointer back on the various calls.
+
+***************************************************************/
+
+typedef struct hostos_w_q_t
+{
+    int                 wqt_allocated ; // 0 = no, 1 = yes
+    struct timer_list   wqt_timer;
+    wait_queue_head_t   wqt_wq;
+}
+wqt_t ;
+
+
+/**
+*   Purpose:    Allocates a wqt entry from the heap.
+*
+*   Imports:
+*
+*   Exports:    !0 = void pointer to opaque data (really a wqt_t)
+*               0 = allocation failure
+*
+*PUBLIC**************************/
+void *HostOS_wqt_alloc( void )
+{
+    wqt_t       *wqt ;
+
+    wqt = kmalloc( sizeof( wqt_t ), GFP_KERNEL ) ;
+
+    return( (void *)wqt ) ;
+}
+
+/**
+*   Purpose:    De-allocates a wqt entry from the heap.
+*
+*   Imports:    vwqt - pointer to the wqt_t to be freed
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_free( void *vwqt )
+{
+
+    kfree( vwqt ) ;
+}
+
+/**
+*   Purpose:    Initialize a timer and register it.
+*
+*   Imports:    vwqt - pointer to the wqt_t with timer to initialize
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_timer_init( void *vwqt )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    wqt->wqt_allocated = 1 ;  // mark the timer inited
+    init_timer( &wqt->wqt_timer ) ;
+}
+
+/**
+*   Purpose:    Deactivate a wqt timer.
+*
+*      http://lxr.linux.no/#linux+v2.6.24/kernel/timer.c#L509
+*
+*   Imports:    vwqt - pointer to the wqt_t with timer to deactivate
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_wqt_timer_del( void *vwqt )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    if( wqt->wqt_allocated ) {
+        del_timer( &wqt->wqt_timer ) ;
+    }
+}
+
+/**
+*   Purpose:    Deactivate a registered timer
+*               And ensure the timer is not running on any CPU.
+*               Can sleep.
+*
+*   Imports:    vwqt - pointer to the wqt_t with timer to deactivate
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+int HostOS_wqt_timer_del_sync( void *vwqt )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    return( del_timer_sync( &wqt->wqt_timer ) ) ;
+}
+
+/**
+*   Purpose:    Modifies a timer.
+*
+*      http://lxr.linux.no/#linux+v2.6.24/kernel/timer.c#L480
+*
+*   Imports:    vwqt    - pointer to the wqt_t with timer to modify
+*               timeout - timeout value from HostOS_timer_expire_seconds
+*                        or HostOS_timer_expire_ticks
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+int HostOS_wqt_timer_mod( void *vwqt, SYS_ULONG timeout )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    return( mod_timer( &wqt->wqt_timer, timeout ) ) ;
+}
+
+/**
+*   Purpose:    Add a timer
+*               Call this after HostOS_timer_setup.
+*
+*      http://lxr.linux.no/#linux+v2.6.24/kernel/timer.c#L509
+*
+*   Imports:    vwqt    - pointer to the wqt_t with timer to add
+*
+*   Exports:    1 = the timer was active (not expired)
+*               0 = the timer was not active
+*
+*PUBLIC**************************/
+void HostOS_wqt_timer_add( void *vwqt )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    add_timer( &wqt->wqt_timer ) ;
+}
+
+/**
+*   Purpose:    Sets up a timer with function and user data.
+*
+*               See HostOS_timer_set_timeout
+*
+*   Imports:    vwqt    - pointer to the wqt_t with timer to  init
+*               func    - callback function to call at timer expiration
+*               data    - data to pass to callback
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_timer_setup( void *vwqt, timer_function_t func, SYS_UINTPTR data )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    wqt->wqt_timer.function = func ;
+    wqt->wqt_timer.data     = data ;
+}
+
+/**
+*   Purpose:    Sets a timer's time out.
+*
+*               See HostOS_timer_setup
+*
+*   Imports:    vwqt    - pointer to the wqt_t with timer to set
+*               timeout - timeout value from HostOS_timer_expire_seconds
+*                         or HostOS_timer_expire_ticks
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_timer_set_timeout( void *vwqt, SYS_ULONG timeout )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    wqt->wqt_timer.expires  = timeout ;
+}
+
+/**
+*   Purpose:    Inits a wait queue head in a wqt_t.
+*
+*   Imports:    vwqt    - pointer to the wqt_t with wait q to init
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_waitq_init( void *vwqt )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    init_waitqueue_head( &wqt->wqt_wq );
+}
+
+/**
+*   Purpose:    Wakes up a wait q in a wqt_t.
+*
+*   Imports:    vwqt    - pointer to the wqt_t with wait q to wake
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_waitq_wakeup_intr( void *vwqt )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    if( wqt )
+    {
+        wake_up_interruptible( &wqt->wqt_wq );
+    }
+}
+
+/**
+*   Purpose:    Waits for a wait q event in a wqt_t.
+*
+*   Imports:    vwqt    - pointer to the wqt_t with wait q to wait on
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_wqt_waitq_wait_event_intr( void *vwqt, HostOS_wqt_condition func, void *vp )
+{
+    wqt_t       *wqt = (wqt_t *)vwqt ;
+
+    wait_event_interruptible( wqt->wqt_wq, /* pass by value */
+                              func(vp) );
+
+}
+
+#if defined(PCI_DRVR_SUPPORT)
+/**
+*   Purpose:    PCI device register access.
+*               These functions read or write the PCI bus device.
+*
+*               Linux uses nested macros to define these.
+*               See: lxr.linux.no/#linux+v2.6.24/drivers/pci/access.c
+*
+*   Imports:    ddev           - context structure with device pointer
+*               reg            - PCI device bus address/register address
+*               pVal or val    - where to put or get the data
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_ReadPciConfig_Word(void* ddev, SYS_UINT32 reg, SYS_UINT16* pVal)
+{
+    struct pci_dev *pdev = ((dd_context_t *)ddev)->pdev;
+
+    pci_read_config_word(pdev, reg, pVal);
+}
+
+/**
+*   Purpose:    PCI device register access.
+*              These functions read or write the PCI bus device.
+*
+*              Linux uses nested macros to define these.
+*              See: lxr.linux.no/#linux+v2.6.24/drivers/pci/access.c
+*
+*   Imports:    ddev           - context structure with pci_dev pointer
+*               reg            - PCI device bus address/register address
+*               pVal or val    - where to put or get the data
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_ReadPciConfig(void* ddev, SYS_UINT32 reg, SYS_UINT32* pVal)
+{
+    struct pci_dev *pdev = ((dd_context_t *)ddev)->pdev;
+
+    pci_read_config_dword(pdev, reg, pVal);
+}
+
+/**
+*   Purpose:    PCI device register access.
+*               These functions read or write the PCI bus device.
+*
+*               Linux uses nested macros to define these.
+*               See: lxr.linux.no/#linux+v2.6.24/drivers/pci/access.c
+*
+*   Imports:    ddev           - context structure with device pointer
+*               reg            - PCI device bus address/register address
+*               pVal or val    - where to put or get the data
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_WritePciConfig_Word(void *ddev, SYS_UINT32 reg, SYS_UINT16 val)
+{
+    struct pci_dev *pdev = ((dd_context_t *)ddev)->pdev;
+
+    pci_write_config_word(pdev, reg, val);
+}
+
+/**
+*   Purpose:    PCI device register access.
+*               These functions read or write the PCI bus device.
+*
+*               Linux uses nested macros to define these.
+*               See: lxr.linux.no/#linux+v2.6.24/drivers/pci/access.c
+*
+*   Imports:    ddev           - context structure with device pointer
+*               reg            - PCI device bus address/register address
+*               pVal or val    - where to put or get the data
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_WritePciConfig(void* ddev, SYS_UINT32 reg, SYS_UINT32 val)
+{
+    struct pci_dev *pdev = ((dd_context_t *)ddev)->pdev;
+
+    pci_write_config_dword(pdev, reg, val);
+}
+
+/**
+*   Purpose:    Allocate DMA-addressable memory.
+*
+*   Imports:    ddev    - pci_dev pointer
+*               size    - Requested block size
+*               ppMemPa - Pointer to place to return the Physical memory address
+*
+*   Exports:    Virtual memory address (and Phys address), or NULL on failure
+*
+*PUBLIC**************************/
+void *HostOS_AllocDmaMem(void *ddev, int size, void **ppMemPa)
+{
+    struct pci_dev *pdev = ((dd_context_t *)ddev)->pdev;
+    dma_addr_t     dma_buf;
+    void           *pMemVa;
+
+    pMemVa   = pci_alloc_consistent(pdev, size, &dma_buf);
+    *ppMemPa = (void *)dma_buf;
+
+    // printk("AllocDmaMem %d %x %x\n", size, pMemVa, dma_buf);
+
+    return (pMemVa);
+}
+
+/**
+*   Purpose:    Free DMA-addressable memory.
+*
+*   Imports:    ddev   - pci_dev pointer
+*               size   - Requested block size
+*               pMemVa - Virtual memory address returned by HostOS_AllocDmaMem()
+*               pMemPa - Physical memory address returned by    ditto
+*
+*   Exports:    Virtual memory address (and Phys address), or NULL on failure
+*
+*PUBLIC**************************/
+void HostOS_FreeDmaMem(void *ddev, int size, void *pMemVa, void *pMemPa)
+{
+    struct pci_dev *pdev = ((dd_context_t *)ddev)->pdev;
+
+    pci_free_consistent(pdev, (size_t) size, pMemVa, (dma_addr_t)pMemPa);
+}
+#endif
+
+/**
+*   Purpose:    Initialize a tasklet.
+*
+*               Prototype:
+*               void tasklet_init(struct tasklet_struct *t,
+*                                 void (*func)(unsigned long),
+*                                 unsigned long data)
+*
+*   Imports:    vtl  - pointer to the tasklet structure
+*               func - tasklet function
+*               data - tasklet context data
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_task_init( void *vtl, void *func, unsigned long data )
+{
+
+    tasklet_init((struct tasklet_struct *)vtl, func, data ) ; // abstraction
+}
+
+/**
+*   Purpose:    Schedule a tasklet.
+*               Tasklet must already be initialized.
+*
+*   Imports:    vtl - pointer to the tasklet structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_task_schedule( void *vtl )
+{
+
+    tasklet_schedule( (struct tasklet_struct *)vtl ) ; // abstraction
+}
+
+/**
+*   Purpose:    Enable a tasklet.
+*
+*   Imports:    vtl - pointer to the tasklet structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_task_enable( void *vtl )
+{
+
+    tasklet_enable( (struct tasklet_struct *)vtl ) ;  // abstraction
+}
+
+/**
+*   Purpose:    Disable a tasklet.
+*
+*   Imports:    vtl - pointer to the tasklet structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_task_disable( void *vtl )
+{
+
+    tasklet_disable( (struct tasklet_struct *)vtl ) ;  // abstraction
+}
+
+/**
+*   Purpose:    Kill a tasklet.
+*
+*   Imports:    vtl - pointer to the tasklet structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_task_kill( void *vtl )
+{
+
+    tasklet_kill( (struct tasklet_struct *)vtl ) ; // abstraction
+}
+
+/**
+*   Purpose:    Initialize a mutex.
+*
+*   Imports:    vmt - pointer to the mutex structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_mutex_init( void *vmt )
+{
+
+    init_MUTEX( (struct semaphore *)vmt ) ;  // abstraction
+}
+
+/**
+*   Purpose:    Release (up) a mutex.
+*
+*               Do NOT call this from an ISR!
+*
+*               Do NOT call this if you are not the current
+*               holder of the mutex.
+*
+*   Imports:    vmt - pointer to the mutex structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_mutex_release( void *vmt )
+{
+
+    up( (struct semaphore *)vmt ) ; // abstraction
+}
+
+/**
+*   Purpose:    Acquire (down) a mutex.
+*
+*               Might sleep.
+*               When this returns you have the mutex.
+*
+*               This is NOT the preferred method. See
+*               HostOS_mutex_acquire_intr().
+*
+*               Do NOT call this from an ISR!
+*
+*   Imports:    vmt - pointer to the mutex structure
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_mutex_acquire( void *vmt )
+{
+
+    down( (struct semaphore *)vmt ) ; // abstraction
+}
+
+/**
+*   Purpose:    Acquire (down) a mutex. Interruptible
+*
+*               Might sleep.
+*               When this returns 0 you have the mutex.
+*               When this returns -EINTR you have been interrupted
+*               and must bail out. You do NOT have the mutex. The
+*               purpose here is to allow the caller, probably a
+*               user space app, to be interrupted and die quickly
+*               and quietly; rather than becoming a zombie because
+*               the driver won't let go.
+*
+*               This is the preferred method.
+*
+*               Do NOT call this from an ISR!
+*
+*   Imports:    vmt - pointer to the mutex structure
+*
+*   Exports:    0      - you got the mutex
+*               -EINTR - you've been interrupted, no mutex
+*
+*PUBLIC**************************/
+int HostOS_mutex_acquire_intr( void *vmt )
+{
+    int rc ;
+
+    rc = down_interruptible( (struct semaphore *)vmt ) ; // abstraction
+    return( rc ) ;
+}
+
+/**
+*   Purpose:    Copies a block from user space to kernel space.
+*
+*   Imports:    to     - pointer to a kernel space buffer to receive the data
+*               from   - pointer to a user space buffer to source the data
+*               nbytes - number of bytes to copy
+*
+*   Exports:    number of bytes NOT copied
+*
+*PUBLIC**************************/
+unsigned long HostOS_copy_from_user( void *to, const void *from, unsigned long nbytes )
+{
+    unsigned long n ;
+
+    n = copy_from_user( to, from, nbytes );
+    return( n ) ;
+}
+
+/**
+*   Purpose:    Copies a block from kernel space to user space.
+*
+*   Imports:    to     - pointer to a user space buffer to receive the data
+*               from   - pointer to a kernel space buffer to source the data
+*               nbytes - number of bytes to copy
+*
+*   Exports:    number of bytes NOT copied
+*
+*PUBLIC**************************/
+unsigned long HostOS_copy_to_user( void *to, const void *from, unsigned long nbytes )
+{
+    unsigned long n ;
+
+    n = copy_to_user( to, from, nbytes );
+    return( n ) ;
+}
+
+#if defined(PCI_DRVR_SUPPORT)
+/**
+*   Purpose:    Check if the carrier is ok.
+*
+*   Imports:    kdev - context structure with device pointer
+*
+*   Exports:    1 if carrier is ok, 0 if not
+*
+*PUBLIC**************************/
+unsigned long HostOS_netif_carrier_ok( void *kdev )
+{
+
+    return( netif_carrier_ok((struct net_device *)kdev) ) ;
+}
+
+/**
+*   Purpose:    Sets net carrier on.
+*
+*   Imports:    kdev - context structure with device pointer
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_netif_carrier_on( void *kdev )
+{
+
+    netif_carrier_on((struct net_device *)kdev);
+    netif_wake_queue((struct net_device *)kdev);
+}
+
+/**
+*   Purpose:    Sets net carrier off.
+*
+*   Imports:    kdev - context structure with device pointer
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_netif_carrier_off( void *kdev )
+{
+
+    netif_carrier_off((struct net_device *)kdev);
+}
+
+/**
+*   Purpose:    Sets the MAC address in the OS.
+*
+*   Imports:    mac_hi - Bytes 0-3 of MAC address
+*               mac_lo - Bytes 4-5 of MAC address
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_set_mac_address( void *kdev, SYS_UINT32 mac_hi, SYS_UINT32 mac_lo )
+{
+    struct net_device *dev = (struct net_device *)kdev;
+
+    dev->dev_addr[0] = (SYS_UCHAR) ((mac_hi >> 24) & 0xff);
+    dev->dev_addr[1] = (SYS_UCHAR) ((mac_hi >> 16) & 0xff);
+    dev->dev_addr[2] = (SYS_UCHAR) ((mac_hi >>  8) & 0xff);
+    dev->dev_addr[3] = (SYS_UCHAR) ((mac_hi      ) & 0xff);
+    dev->dev_addr[4] = (SYS_UCHAR) ((mac_lo >> 24) & 0xff);
+    dev->dev_addr[5] = (SYS_UCHAR) ((mac_lo >> 16) & 0xff);
+}
+
+/**
+*   Purpose:    Brings up the Ethernet interface.
+*
+*   Imports:    kdev - context structure with device pointer
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_open( void *kdev )
+{
+    struct net_device *dev = (struct net_device *)kdev;
+
+    if ((dev->flags & IFF_UP) == IFF_UP)
+    {
+        clnketh_open(dev);
+    }
+}
+
+/**
+*   Purpose:    Shuts down the Ethernet interface.
+*
+*   Imports:    kdev - context structure with device pointer
+*
+*   Exports:
+*
+*PUBLIC**************************/
+void HostOS_close( void *kdev )
+{
+    struct net_device *dev = (struct net_device *)kdev;
+
+    if ((dev->flags & IFF_UP) == IFF_UP)
+    {
+        clnketh_close(dev);
+    }
+}
+#endif
+
+#if defined(E1000_DRVR_SUPPORT) || defined(CANDD_DRVR_SUPPORT) || defined(APOLLO_DRVR_SUPPORT)
+
+/* declaring mutexes for kernel thread start/stop */
+DECLARE_MUTEX (HostOS_thread_mutex);
+
+hostos_kthread_t hostosThread;
+
+/**
+*   Purpose:    Check pending signal of task.
+*
+*   Imports:    vtask - pointer to the task
+*
+*   Exports:    0 - no pending signal
+*               1 - has pendign signal
+*
+*PUBLIC**************************/
+int HostOS_signal_pending(void *vtask)
+{
+    struct task_struct *p;
+    
+    if(vtask== SYS_NULL)
+        p = current;
+    else
+        p = (struct task_struct *)vtask;
+
+    return signal_pending(p);
+}
+
+/**
+*   Purpose:    Convert  jiffies to milliseconds.
+*
+*   Imports:    j- jiffies
+*
+*   Exports:    none
+*
+***************************/
+static inline unsigned int HostOS_jiffies_to_msecs(const unsigned long j)
+{
+#if HZ <= 1000 && !(1000 % HZ)
+    return (1000 / HZ) * j;
+#elif HZ > 1000 && !(HZ % 1000)
+    return (j + (HZ / 1000) - 1)/(HZ / 1000);
+#else
+    return (j * 1000) / HZ;
+#endif
+}
+
+/**
+*   Purpose:    Convert milliseconds to jiffies.
+*
+*   Imports:    m - milliseconds
+*
+*   Exports:    none
+*
+***************************/
+static inline unsigned long HostOS_msecs_to_jiffies(const unsigned int m)
+{
+    if (m > HostOS_jiffies_to_msecs(MAX_JIFFY_OFFSET))
+        return MAX_JIFFY_OFFSET;
+#if HZ <= 1000 && !(1000 % HZ)
+    return (m + (1000 / HZ) - 1) / (1000 / HZ);
+#elif HZ > 1000 && !(HZ % 1000)
+    return m * (HZ / 1000);
+#else
+    return (m * HZ + 999) / 1000;
+#endif
+}
+
+/**
+*   Purpose:    Sleep waiting for waitqueue interruptions.
+*
+*   Imports:    msecs - Time in milliseconds to sleep for
+*
+*   Exports:    none
+*
+*PUBLIC**************************/
+void HostOS_msleep_interruptible(unsigned int msecs)
+{
+    unsigned long timeout = HostOS_msecs_to_jiffies(msecs) + 1;
+
+    while (timeout && !signal_pending(current)) {
+        __set_current_state(TASK_INTERRUPTIBLE);
+        timeout = schedule_timeout(timeout);
+    }
+}
+
+/**
+*   Purpose:    Kernel thread internal function.
+*
+*   Imports:    pdata - pointer to thread struct
+*
+*   Exports:    none
+*
+***************************/
+static void HostOS_thread_inter_func(void *pdata)
+{
+    hostos_kthread_t *pThread = (hostos_kthread_t *)pdata;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    daemonize(hostosThread.name, 0);
+    allow_signal(SIGKILL);
+    allow_signal(SIGTERM);    
+#else
+    daemonize();
+#endif
+
+    /* kernel thread main function */
+    pThread->func(pThread->arg);
+
+    return ;
+}
+
+/**
+*   Purpose:    Create new kernel thread.
+*
+*   Imports:    pThreadID - pointer to new kernel threadID
+*               pName     - pointer to thread name string
+*               func      - pointer to thread internal function
+*               arg       - argument to pass to thread function
+*
+*   Exports:    0  - OK
+*               -1 - FAILED
+*
+*PUBLIC**************************/
+int HostOS_thread_start(unsigned int *pThreadID, char *pName, void (*func)(void *), void *arg)
+{
+    down(&HostOS_thread_mutex);
+
+    strncpy(hostosThread.name, pName,16);
+    hostosThread.func = func;
+    hostosThread.arg = arg;
+
+    /* Create kernel thread */
+    hostosThread.threadID = kernel_thread((int (*)(void *))HostOS_thread_inter_func, &hostosThread, 0);
+    *pThreadID = hostosThread.threadID;
+
+    if(hostosThread.threadID < 0)
+    {
+        up (&HostOS_thread_mutex);
+        return -1;
+    }
+    
+    up(&HostOS_thread_mutex);
+    return 0;
+}
+
+/**
+*   Purpose:    Stop a kernel thread.
+*
+*   Imports:    threadID - kernel threadID that to be stopped
+*
+*   Exports:    0   - OK
+*               -1  - FAILED
+*
+*PUBLIC**************************/
+int HostOS_thread_stop(unsigned long threadID)
+{
+    int ret = 0;
+
+    down(&HostOS_thread_mutex);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)    
+    if((ret = kill_pid(find_vpid(threadID), SIGKILL, 1)))
+#else
+    if((ret = kill_proc(threadID, SIGKILL, 1)))
+#endif
+    {
+        up(&HostOS_thread_mutex);
+        return -1;
+    }
+
+    up(&HostOS_thread_mutex);
+    return 0;
+}
+
+#endif
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/hostos_linux.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/hostos_linux.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/hostos_linux.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common/hostos_linux.h	2012-09-14 14:51:36.981923000 +0530
@@ -0,0 +1,123 @@
+/*******************************************************************************
+*
+* GPL/Common/hostos_linux.h
+*
+* Description: OS includes and abstracted types
+*
+*******************************************************************************/
+
+/*******************************************************************************
+*                        Entropic Communications, Inc.
+*                         Copyright (c) 2001-2008
+*                          All rights reserved.
+*******************************************************************************/
+
+/*******************************************************************************
+* This file is licensed under GNU General Public license.                      *
+*                                                                              *
+* This file is free software: you can redistribute and/or modify it under the  *
+* terms of the GNU General Public License, Version 2, as published by the Free *
+* Software Foundation.                                                         *
+*                                                                              *
+* This program is distributed in the hope that it will be useful, but AS-IS and*
+* WITHOUT ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,*
+* FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT. Redistribution, *
+* except as permitted by the GNU General Public License is prohibited.         *
+*                                                                              *
+* You should have received a copy of the GNU General Public License, Version 2 *
+* along with this file; if not, see <http://www.gnu.org/licenses/>.            *
+*******************************************************************************/
+
+#ifndef _hostos_linux_h_
+#define _hostos_linux_h_
+
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)
+#include <generated/autoconf.h>
+#else 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
+#include <linux/autoconf.h>
+#else
+#include <linux/config.h>
+#endif
+#endif
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/spinlock.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/unaligned.h>
+#include <asm/uaccess.h>
+#include <linux/proc_fs.h>
+#include <linux/ctype.h>
+#include <linux/list.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+
+
+/**
+ *  spinlock structure with added bells and whistles
+ */
+
+// for locking purposes
+typedef struct hostos_lock
+{
+    int             lock_magic;        // used to verify the structure is initialized
+    unsigned long   lock_irq_flags;    // irq flags for restoring later
+    spinlock_t      lock_spinlock;
+}
+hostos_lock_t ;
+
+// timer operations
+// for linux this contains a struct timer_list
+typedef struct hostos_timer
+{
+    struct timer_list ostimer ;
+}
+hostos_timer_t ;
+
+// tasklet operations
+// for linux this contains a struct tasklet_struct
+typedef struct hostos_task
+{
+    struct tasklet_struct ostask ;
+}
+hostos_task_t ;
+
+// semaphore operations
+// for linux this contains a struct semaphore
+typedef struct hostos_sema
+{
+    struct semaphore ossema ;
+}
+hostos_sema_t ;
+
+typedef struct _hostos_waitq
+{
+    wait_queue_head_t   wq;
+}
+hostos_waitq_t ;
+
+// thread operations 
+// for linux this contains kernel thread related information
+typedef struct hostos_kthread
+{
+    char name[20];          /* thread name */
+    int  threadID;    
+    void (*func) (void *);  /* thread internal function */    
+    void *arg;              /* argument to pass to kernel thread */
+} 
+hostos_kthread_t;
+
+#endif /* _hostos_linux_h_ */
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/COPYING linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/COPYING
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/COPYING	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/COPYING	2012-09-14 14:51:36.984924000 +0530
@@ -0,0 +1,173 @@
+The GNU General Public License (GPL)
+Version 2, June 1991
+Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+Everyone is permitted to copy and distribute verbatim copies
+of this license document, but changing it is not allowed.
+
+Preamble
+
+The licenses for most software are designed to take away your freedom to share and change it. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change free software--to make sure the software is free for all its users. This General Public License applies to most of the Free Software Foundation's software and to any other program whose authors commit to using it. (Some other Free Software Foundation software is covered by the GNU Library General Public License instead.) You can apply it to your programs, too.
+
+When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for this service if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs; and that you know you can do these things.
+
+To protect your rights, we need to make restrictions that forbid anyone to deny you these rights or to ask you to surrender the rights. These restrictions translate to certain responsibilities for you if you distribute copies of the software, or if you modify it.
+
+For example, if you distribute copies of such a program, whether gratis or for a fee, you must give the recipients all the rights that you have. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights.
+
+We protect your rights with two steps: (1) copyright the software, and (2) offer you this license which gives you legal permission to copy, distribute and/or modify the software.
+
+Also, for each author's protection and ours, we want to make certain that everyone understands that there is no warranty for this free software. If the software is modified by someone else and passed on, we want its recipients to know that what they have is not the original, so that any problems introduced by others will not reflect on the original authors' reputations.
+
+Finally, any free program is threatened constantly by software patents. We wish to avoid the danger that redistributors of a free program will individually obtain patent licenses, in effect making the program proprietary. To prevent this, we have made it clear that any patent must be licensed for everyone's free use or not licensed at all.
+
+The precise terms and conditions for copying, distribution and modification follow.
+
+TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+0. This License applies to any program or other work which contains a notice placed by the copyright holder saying it may be distributed under the terms of this General Public License. The "Program", below, refers to any such program or work, and a "work based on the Program" means either the Program or any derivative work under copyright law: that is to say, a work containing the Program or a portion of it, either verbatim or with modifications and/or translated into another language. (Hereinafter, translation is included without limitation in the term "modification".) Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not covered by this License; they are outside its scope. The act of running the Program is not restricted, and the output from the Program is covered only if its contents constitute a work based on the Program (independent of having been made by running the Program). Whether that is true depends on what the Program does.
+
+1. You may copy and distribute verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice and disclaimer of warranty; keep intact all the notices that refer to this License and to the absence of any warranty; and give any other recipients of the Program a copy of this License along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and you may at your option offer warranty protection in exchange for a fee.
+
+2. You may modify your copy or copies of the Program or any portion of it, thus forming a work based on the Program, and copy and distribute such modifications or work under the terms of Section 1 above, provided that you also meet all of these conditions:
+
+
+   a) You must cause the modified files to carry prominent notices
+      stating that you changed the files and the date of any change.
+
+
+   b) You must cause any work that you distribute or publish, that in
+      whole or in part contains or is derived from the Program or any part
+      thereof, to be licensed as a whole at no charge to all third parties
+      under the terms of this License.
+
+
+   c) If the modified program normally reads commands interactively when
+      run, you must cause it, when started running for such interactive use
+      in the most ordinary way, to print or display an announcement including
+      an appropriate copyright notice and a notice that there is no warranty
+      (or else, saying that you provide a warranty) and that users may
+      redistribute the program under these conditions, and telling the user
+      how to view a copy of this License. (Exception: if the Program itself
+      is interactive but does not normally print such an announcement, your
+      work based on the Program is not required to print an announcement.)
+
+
+These requirements apply to the modified work as a whole. If identifiable sections of that work are not derived from the Program, and can be reasonably considered independent and separate works in themselves, then this License, and its terms, do not apply to those sections when you distribute them as separate works. But when you distribute the same sections as part of a whole which is a work based on the Program, the distribution of the whole must be on the terms of this License, whose permissions for other licensees extend to the entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest your rights to work written entirely by you; rather, the intent is to exercise the right to control the distribution of derivative or collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program with the Program (or with a work based on the Program) on a volume of a storage or distribution medium does not bring the other work under the scope of this License.
+
+3. You may copy and distribute the Program (or a work based on it, under Section 2) in object code or executable form under the terms of Sections 1 and 2 above provided that you also do one of the following:
+
+
+   a) Accompany it with the complete corresponding machine-readable source
+      code, which must be distributed under the terms of Sections 1 and
+      2 above on a medium customarily used for software interchange; or,
+
+
+   b) Accompany it with a written offer, valid for at least three
+      years, to give any third party, for a charge no more than your
+      cost of physically performing source distribution, a complete
+      machine-readable copy of the corresponding source code, to be
+      distributed under the terms of Sections 1 and 2 above on a medium
+      customarily used for software interchange; or,
+
+
+   c) Accompany it with the information you received as to the offer to
+      distribute corresponding source code. (This alternative is allowed
+      only for noncommercial distribution and only if you received the
+      program in object code or executable form with such an offer,
+      in accord with Subsection b above.)
+
+
+The source code for a work means the preferred form of the work for making modifications to it. For an executable work, complete source code means all the source code for all modules it contains, plus any associated interface definition files, plus the scripts used to control compilation and installation of the executable. However, as a special exception, the source code distributed need not include anything that is normally distributed (in either source or binary form) with the major components (compiler, kernel, and so on) of the operating system on which the executable runs, unless that component itself accompanies the executable.
+
+If distribution of executable or object code is made by offering access to copy from a designated place, then offering equivalent access to copy the source code from the same place counts as distribution of the source code, even though third parties are not compelled to copy the source along with the object code.
+
+4. You may not copy, modify, sublicense, or distribute the Program except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense or distribute the Program is void, and will automatically terminate your rights under this License. However, parties who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in full compliance.
+
+5. You are not required to accept this License, since you have not signed it. However, nothing else grants you permission to modify or distribute the Program or its derivative works. These actions are prohibited by law if you do not accept this License. Therefore, by modifying or distributing the Program (or any work based on the Program), you indicate your acceptance of this License to do so, and all its terms and conditions for copying, distributing or modifying the Program or works based on it.
+
+6. Each time you redistribute the Program (or any work based on the Program), the recipient automatically receives a license from the original licensor to copy, distribute or modify the Program subject to these terms and conditions. You may not impose any further restrictions on the recipients' exercise of the rights granted herein. You are not responsible for enforcing compliance by third parties to this License.
+
+7. If, as a consequence of a court judgment or allegation of patent infringement or for any other reason (not limited to patent issues), conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot distribute so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not distribute the Program at all. For example, if a patent license would not permit royalty-free redistribution of the Program by all those who receive copies directly or indirectly through you, then the only way you could satisfy both it and this License would be to refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under any particular circumstance, the balance of the section is intended to apply and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any patents or other property right claims or to contest validity of any such claims; this section has the sole purpose of protecting the integrity of the free software distribution system, which is implemented by public license practices. Many people have made generous contributions to the wide range of software distributed through that system in reliance on consistent application of that system; it is up to the author/donor to decide if he or she is willing to distribute software through any other system and a licensee cannot impose that choice.
+
+This section is intended to make thoroughly clear what is believed to be a consequence of the rest of this License.
+
+8. If the distribution and/or use of the Program is restricted in certain countries either by patents or by copyrighted interfaces, the original copyright holder who places the Program under this License may add an explicit geographical distribution limitation excluding those countries, so that distribution is permitted only in or among countries not thus excluded. In such case, this License incorporates the limitation as if written in the body of this License.
+
+9. The Free Software Foundation may publish revised and/or new versions of the General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number. If the Program specifies a version number of this License which applies to it and "any later version", you have the option of following the terms and conditions either of that version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of this License, you may choose any version ever published by the Free Software Foundation.
+
+10. If you wish to incorporate parts of the Program into other free programs whose distribution conditions are different, write to the author to ask for permission. For software which is copyrighted by the Free Software Foundation, write to the Free Software Foundation; we sometimes make exceptions for this. Our decision will be guided by the two goals of preserving the free status of all derivatives of our free software and of promoting the sharing and reuse of software generally.
+
+NO WARRANTY
+
+11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+
+END OF TERMS AND CONDITIONS
+
+How to Apply These Terms to Your New Programs
+
+If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms.
+
+To do so, attach the following notices to the program. It is safest to attach them to the start of each source file to most effectively convey the exclusion of warranty; and each file should have at least the "copyright" line and a pointer to where the full notice is found.
+
+
+   one line to give the program's name and a brief idea of what it does.
+   Copyright (C) 
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this when it starts in an interactive mode:
+
+
+   Gnomovision version 69, Copyright (C) year name of author Gnomovision
+   comes with ABSOLUTELY NO WARRANTY; for details type `show w'. This is
+   free software, and you are welcome to redistribute it under certain
+   conditions; type `show c' for details.
+
+
+The hypothetical commands `show w' and `show c' should show the appropriate parts of the General Public License. Of course, the commands you use may be called something other than `show w' and `show c'; they could even be mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your school, if any, to sign a "copyright disclaimer" for the program, if necessary. Here is a sample; alter the names:
+
+
+   Yoyodyne, Inc., hereby disclaims all copyright interest 
+   in the program `Gnomovision' (which makes passes at compilers)
+   written by James Hacker.
+
+   signature of Ty Coon, 1 April 1989
+   Ty Coon, President of Vice
+
+
+This General Public License does not permit incorporating your program into proprietary programs. If your program is a subroutine library, you may consider it more useful to permit linking proprietary applications with the library. If this is what you want to do, use the GNU Library General Public License instead of this License.
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/inc/tmbslPhyEN256X.h linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/inc/tmbslPhyEN256X.h
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/inc/tmbslPhyEN256X.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/inc/tmbslPhyEN256X.h	2012-09-14 14:51:36.998926000 +0530
@@ -0,0 +1,697 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhyEN256X.h %
+ * %pid_version:              1.0 %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: Macros and function prototypes for EN256X PHY
+ *
+ * DOCUMENT REF: Datasheet Realtek Semiconductor EN256x-GR
+ *               Integrated 10/100/1000 Gigabit Ethernet Transceiver
+ *               Rev. 1.0, April 3, 2008
+ *
+ * NOTES:        None
+ *
+ *-----------------------------------------------------------------------------
+ *
+*/
+
+#ifndef tmbslPhyEN256X_H_
+#define tmbslPhyEN256X_H_
+
+#if        defined(__cplusplus)
+extern "C"
+{
+#endif  // defined(__cplusplus)
+
+
+#include "tmNxTypes.h"
+#include "tmbslPhy.h"
+
+/* Macros */
+
+/* MAC Macros */
+#define TMHW_LIPP6100ETH_ADR_REG_OFFSET  (0x010)
+#define TMHW_LIPP6100ETH_DATA_REG_OFFSET (0x014)
+
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_CLR (0xFFFFF83F)
+#define TMHW_LIPP6100ETH_ADR_PHY_REG_POS (6)
+#define TMHW_LIPP6100ETH_ADR_PHY_WR_VAL  (0x2)
+#define TMHW_LIPP6100ETH_ADR_PHY_RD_CLR  (0xFFFFFFFD)
+#define TMHW_LIPP6100ETH_ADR_PHY_EN_VAL  (0x1)
+
+/*PHY Macros */
+/*************** Basic Mode control register ************/
+#define TMBSL_PHYEN256X_BMCR_RST_VAL (0x8000)
+
+/* Enable loopback */
+#define TMBSL_PHYEN256X_BMCR_LPBK_VAL (0x4000)
+#define TMBSL_PHYEN256X_BMCR_LPBK_CLR (0xBFFF)
+
+/* Set Speed to 1Gbps */
+#define TMBSL_PHYEN256X_BMCR_SPEED_1G (0x40)
+
+/* Set Speed to 100Mbps */
+#define TMBSL_PHYEN256X_BMCR_SPEED_100 (0x2000)
+
+/* Set Speed */
+#define TMBSL_PHYEN256X_BMCR_SPEED_10 (0)
+
+/* Speed mask */
+#define TMBSL_PHYEN256X_BMCR_SPEED_MSK (0x2040)
+
+/* Enable autonegotiation */
+#define TMBSL_PHYEN256X_BMCR_AN_EN (0x1000)
+#define TMBSL_PHYEN256X_BMCR_AN_CLR (0xFFFFEFFF)
+
+/* Set power down mode */
+#define TMBSL_PHYEN256X_BMCR_PWRDN_EN (0x800)
+
+/* Disable  power down mode */
+#define TMBSL_PHYEN256X_BMCR_PWRDN_CLR (0xF7FF)
+
+/* Isolate PHY enable */
+#define TMBSL_PHYEN256X_BMCR_ISO_PHY (0x400)
+
+/* Auto negotiation restart */
+#define TMBSL_PHYEN256X_BMCR_AN_RESTART (0x200)
+
+/* Collision Test enable */
+#define TMBSL_PHYEN256X_BMCR_COLTEST (0x80)
+
+/* Full duplex enable */
+#define TMBSL_PHYEN256X_BMCR_FD_EN (0x100)
+
+/****** Basic Mode status Register bits ******/
+
+/* Autonegotiation complete value */
+#define TMBSL_PHYEN256X_BMSR_T4100BASE (0x8000)
+
+#define TMBSL_PHYEN256X_BMSR_X100BASEFD (0x4000)
+
+#define TMBSL_PHYEN256X_BMSR_X100BASEHD (0x2000)
+
+#define TMBSL_PHYEN256X_BMSR_10MBPSFD (0x1000)
+
+#define TMBSL_PHYEN256X_BMSR_10MBPSHD (0x800)
+
+#define TMBSL_PHYEN256X_BMSR_T2100BASEFD (0x400)
+
+#define TMBSL_PHYEN256X_BMSR_T2100BASEHD (0x200)
+
+/* Preamble suppression capability */
+#define TMBSL_PHYEN256X_BMSR_PREAMBLE_SUP (0x40)
+
+#define TMBSL_PHYEN256X_BMSR_AN_VAL (0x20)
+
+/* Remote fault value */
+#define TMBSL_PHYEN256X_BMSR_RF_VAL (0x10)
+
+/* PHY is able to perform auto negotiation */
+#define TMBSL_PHYEN256X_BMSR_AN_ABLE (0x8)
+
+#define TMBSL_PHYEN256X_BMSR_LINK_STAT (0x4)
+
+/* Jabber detected */
+#define TMBSL_PHYEN256X_BMSR_JAB_VAL (0x2)
+
+/****** Auto Negotiation Advertisement Register bits ******/
+
+/* Advertise Next page desired */
+#define TMBSL_PHYEN256X_ANAR_NP (0x8000)
+
+/* Advertise remote fault */
+#define TMBSL_PHYEN256X_ANAR_ADV_RF (0x2000)
+
+/* Advertise asymmetric pause */
+#define TMBSL_PHYEN256X_ANAR_AP (0x800)
+
+/* Advertise pause frame support */
+#define TMBSL_PHYEN256X_ANAR_PAUSE (0x400)
+
+/* Advertise 100Base-TX full duplex support */
+#define TMBSL_PHYEN256X_ANAR_100B_TX_FD (0x100)
+
+/* Advertise 100Base-TX half duplex support */
+#define TMBSL_PHYEN256X_ANAR_100B_TX_HD (0x80)
+
+/* Advertise 10Base-TX full duplex support */
+#define TMBSL_PHYEN256X_ANAR_10B_TX_FD (0x40)
+
+/* Advertise 10Base-TX half duplex support */
+#define TMBSL_PHYEN256X_ANAR_10B_TX_HD (0x20)
+
+
+/****** 1KTCR : 1000 Base-T Master-Slave Control Register ******/
+
+/* Maser/Slave config enable */
+#define TMBSL_PHYEN256X_1KTCR_MS_CONFIG (0x1000)
+
+/* Set PHY as master */
+#define TMBSL_PHYEN256X_1KTCR_MASTER_EN (0x800)
+
+/* Advertise device as Multiport */
+#define TMBSL_PHYEN256X_1KTCR_MULTIPORT_EN (0x400)
+
+/* 1000 Base-T Full duplex capable */
+#define TMBSL_PHYEN256X_1KTCR_1000BT_FD (0x200)
+
+/* 1000 Base-T Half duplex capable */
+#define TMBSL_PHYEN256X_1KTCR_1000BT_HD (0x100)
+
+/********1KSTSR 1000 BASE-T Master-Slave Status Register *****/
+#define TMBSL_PHYEN256X_1KSTSR_MAN_FAULT (0x8000)
+#define TMBSL_PHYEN256X_1KSTSR_MASTER (0x4000)
+#define TMBSL_PHYEN256X_1KSTSR_LOCAL_RX_STAT (0x2000)
+#define TMBSL_PHYEN256X_1KSTSR_REMOTE_RX_STAT (0x1000)
+#define TMBSL_PHYEN256X_1KSTSR_PART_FD_CAP (0x800)
+#define TMBSL_PHYEN256X_1KSTSR_PART_HD_CAP (0x400)
+
+/********** EXTENDED STATUS REGISTER ******************/
+#define TMBSL_PHYEN256X_1KSCR_1000BASEX_FD (0x8000)
+#define TMBSL_PHYEN256X_1KSCR_1000BASEX_HD (0x4000)
+#define TMBSL_PHYEN256X_1KSCR_1000BASET_FD (0x2000)
+#define TMBSL_PHYEN256X_1KSCR_1000BASET_HD (0x1000)
+
+/**************** VENDOR SPECIFIC REGISTERS **************/
+/****** PHY Specific Control register ******/
+#define TMBSL_PHYEN256X_PHYCR_CRS          (0x800)
+#define TMBSL_PHYEN256X_PHYCR_FORCE_LNK    (0x400)
+#define TMBSL_PHYEN256X_PHYCR_DIS_CLK125   (0x10)
+#define TMBSL_PHYEN256X_PHYCR_DIS_JABBER   (0x1)
+
+/* Bit 6:5 MDI Crossover Mode
+ *   00: Manual MDI Crossover configuration
+ *   01: Manual MDI configuration
+ *   10: Default value
+ * Note: Before setting register, address 0xE bit 10 needs to be set to 1.
+ *       After setting register, a PHY reset is required.
+ */
+#define TMBSL_PHYEN256X_PHYCR_MDI_XOVR_MODE_MSK (0x60)
+#define TMBSL_PHYEN256X_PHYCR_MAN_MDI_XOVR      (0x0)
+#define TMBSL_PHYEN256X_PHYCR_MAN_MDI           (0x1)
+#define TMBSL_PHYEN256X_PHYCR_MDI               (0x2)
+
+/****** PHY Specific Status Register ******/
+/* Bit 15:14 Speed
+ *   00: 10 Mbps
+ *   01: 100 Mbps
+ *   10: 1000 Mbps
+ *   11: Reserved
+ */
+#define TMBSL_PHYEN256X_PHYSTAT_SPEED_MSK       (0xC000)
+#define TMBSL_PHYEN256X_PHYSTAT_SPEED_10        (0x0)
+#define TMBSL_PHYEN256X_PHYSTAT_SPEED_100       (0x1)
+#define TMBSL_PHYEN256X_PHYSTAT_SPEED_1000      (0x2)
+
+#define TMBSL_PHYEN256X_PHYSTAT_DUPLEX          (0x2000)
+#define TMBSL_PHYEN256X_PHYSTAT_PAGE_RX         (0x1000)
+#define TMBSL_PHYEN256X_PHYSTAT_SPD_DUP_RES     (0x800)
+#define TMBSL_PHYEN256X_PHYSTAT_LINK_RT         (0x400)
+#define TMBSL_PHYEN256X_PHYSTAT_MDI_XOVR_STAT   (0x40)
+#define TMBSL_PHYEN256X_PHYSTAT_JABBER_RT       (0x1)
+
+/****** Interrupt Enable Register ******/
+#define TMBSL_PHYEN256X_IER_AN_ERR              (0x8000)
+#define TMBSL_PHYEN256X_IER_SPEED_CHG           (0x4000)
+#define TMBSL_PHYEN256X_IER_DUPLEX_CHG          (0x2000)
+#define TMBSL_PHYEN256X_IER_PG_RX               (0x1000)
+#define TMBSL_PHYEN256X_IER_AN_COMP             (0x800)
+#define TMBSL_PHYEN256X_IER_LNK_STAT_CHG        (0x400)
+#define TMBSL_PHYEN256X_IER_SYMBOL_ERR          (0x200)
+#define TMBSL_PHYEN256X_IER_FALSE_CARRIER       (0x100)
+#define TMBSL_PHYEN256X_IER_MDI_XOVR_CHG        (0x40)
+#define TMBSL_PHYEN256X_IER_POLARITY_CHG        (0x2)
+#define TMBSL_PHYEN256X_IER_JABBER              (0x1)
+
+/****** Interrupt Status Register ******/
+#define TMBSL_PHYEN256X_ISR_AN_ERR              (0x8000)
+#define TMBSL_PHYEN256X_ISR_SPEED_CHG           (0x4000)
+#define TMBSL_PHYEN256X_ISR_DUPLEX_CHG          (0x2000)
+#define TMBSL_PHYEN256X_ISR_PG_RX               (0x1000)
+#define TMBSL_PHYEN256X_ISR_AN_COMP             (0x800)
+#define TMBSL_PHYEN256X_ISR_LNK_STAT_CHG        (0x400)
+#define TMBSL_PHYEN256X_ISR_SYMBOL_ERR          (0x200)
+#define TMBSL_PHYEN256X_ISR_FALSE_CARRIER       (0x100)
+#define TMBSL_PHYEN256X_ISR_MDI_XOVR_CHG        (0x40)
+#define TMBSL_PHYEN256X_ISR_POLARITY_CHG        (0x2)
+#define TMBSL_PHYEN256X_ISR_JABBER              (0x1)
+
+/****** LED Control Register ******/
+#define TMBSL_PHYEN256X_LEDCR_DISABLE_LED        (0x8000)
+#define TMBSL_PHYEN256X_LEDCR_LINK_CTL           (0x8)
+#define TMBSL_PHYEN256X_LEDCR_RX_CTL             (0x2)
+#define TMBSL_PHYEN256X_LEDCR_TX_CTL             (0x1)
+
+//Structure Declarations
+//-----------------------------------------------------------------------------
+//	Typedefinition
+//-----------------------------------------------------------------------------
+typedef enum
+{
+    /* Basic mode control */
+    tmbslPhyEN256XBmcr			= 0x0,
+    /* Basic mode status */
+    tmbslPhyEN256XBmsr			= 0x1,
+
+    /* 0x2-1E are reserved */
+
+    /*Extended status register */
+    tmbslPhyEN256X1kscr		= 0xF,
+
+    /**** Vendor Specific Registers *****/
+    /* 0x10-19 are reserved */
+
+} tmbslPhyEN256XReg_t;
+
+typedef struct  _tmbslPhyEN256XContext_t
+{
+    UInt32	pRegs;         // Array ETHERNET Module regs
+} tmbslPhyEN256XContext_t, *ptmbslPhyEN256XContext_t;
+
+//-----------------------------------------------------------------------------
+// Exported functions:
+//-----------------------------------------------------------------------------
+//
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version
+//		information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY
+//		or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN256XBNGetSWVersion (
+    ptmSWVersion_t	pPhyVersion
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//		unit. The function is callable at any time to return the unit's
+//		capabilities (PHY unit initialization is not necessary).
+//		Capabilities may be different among multiple PHY units.For completeness,
+//		a PHY BSL user should call this function for each PHY unit to
+//		determine its individual capabilities.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY
+//		or in PowerOff state.
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN256XBNGetCapabilities (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyCapabilities_t	pPhyCaps
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyInit:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//		before any access to the device is made.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       This function initializes the PHY device with the following
+//		default initial configuration.
+//		1. Enable the auto negotiation. In auto-negotiation mode the
+//		highest possible performance mode is selected automatically
+//		which the Link Partner also supports. (In auto negotiation mode
+//		speed and duplex mode will be selected by means of auto negotiation.
+//		Writing to speed and duplex mode does not have meaning in auto
+//		negotiation mode.)
+//		2. The device abilities are programmed to Auto negotiation advertise
+//		register. None of the device abilities are masked. If the PHY
+//		device does not support Auto-negotiation mode, then this function
+//		will set the PHY to basic capabilities of the device.The function
+//		tmbslPhyGetBasicModeControl can be called after tmbsPhyInit to
+//		know what are the default configurations the tmbslPhyInit function
+//		has set to
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN256XBNInit(
+    tmUnitSelect_t	phyUnitId
+    );
+
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyDeinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//		deinitilized device will no more be available to access
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+tmErrorCode_t
+tmbslPhyEN256XBNDeinit(
+    tmUnitSelect_t	phyUnitId
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified
+//		power state
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN256XBNSetPowerState(
+    tmUnitSelect_t	phyUnitId ,
+    tmPowerState_t	phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN256XBNGetPowerState(
+    tmUnitSelect_t	phyUnitId,
+    ptmPowerState_t	phyPowerState
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:       PHY device is initialized using the function tmbslPhyInit.
+//		tmbslPhyInit Enable the Auto negotiation mode and will configure
+//		the PHY device for the maximum performance mode available. After
+//		the device is initialized this function can be called to know the
+//		present settings of the PHY device. If application wants to change
+//		the settings it can call tmbslPhySetBasicModeControl to change
+//		the configuration after knowing the capabilities of the PHY device
+//		and Link Partner. #define for the Basic Mode Control
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN256XBNGetBasicModeControl (
+    tmUnitSelect_t			phyUnitId,
+    ptmbslPhyBasicModeControl_t      	pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+
+tmErrorCode_t
+tmbslPhyEN256XBNSetBasicModeControl (
+    tmUnitSelect_t			phyUnitId,
+    ptmbslPhyBasicModeControl_t      	pPhyBasicModeControl
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device
+//		such as the speed, duplex mode
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN256XBNGetBasicModeStatus (
+    tmUnitSelect_t			phyUnitId,
+    ptmbslPhyBasicModeStatus_t    	pPhyBasicModeStatus
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyAutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device
+//		with Link Partner. Best possible performance configuration is
+//		selected automatically during this process
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN256XBNAutoNegotiate (
+    tmUnitSelect_t			phyUnitId,
+    ptmbslPhyAutoNegotitationMask_t    	pAutoNegotiationMask
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetIdentifier:
+//
+// DESCRIPTION: This function gets the PHY device Identifier
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN256XBNGetIdentifier (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyIdentifier_t     	pPhyIdentifier
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkPartnerCapabilities:
+//
+// DESCRIPTION: This function will get the Link Partner Capabilities.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN256XBNGetLinkPartnerCapabilities (
+    tmUnitSelect_t                         phyUnitId,
+    ptmbslPhyLinkPartnerCapabilities_t     pPhyLinkPartnerCapabilities
+    );
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCounters:
+//
+// DESCRIPTION: This function will get the present counter values of the PHY counters
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN256XBNGetCounters (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyCounters_t		pPhyCounters
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsConfig:
+//
+// DESCRIPTION: This function will configure the Physical layer configurations.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN256XBNPcsConfig (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyPcsConfig_t    	pPhyPcsConfig
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsGetConfig:
+//
+// DESCRIPTION: This function will get the present PCS configuration
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN256XBNPcsGetConfig (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyPcsConfig_t    	pPhyPcsConfig
+    );
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyBist:
+//
+// DESCRIPTION: This function will do the Built In Self Test and the result
+//		will be indicated in the pBistState
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN256XBNBist (
+    tmUnitSelect_t		phyUnitId,
+    tmbslPhyPseudoRandomSeq_t  	phyPsedoRandomSeq ,
+    pUInt8			pBistState
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyConfigBypass:
+//
+// DESCRIPTION: This function will bypass the functional blocks within 100Base-Tx transmitter
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN256XPhyConfigBypass (
+    tmUnitSelect_t	phyUnitId,
+    ptmbslPhyBypass_t  	pPhyBypass
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyConfigBypass:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback mode.
+//
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN256XBNLoopBack (
+    tmUnitSelect_t		phyUnitId,
+    tmbslPhyEnableDisable_t	loopbackMode
+	);
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhySoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN256XBNSoftReset (
+    tmUnitSelect_t	phyUnitId
+	);
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//		TM_BSLPHY_ERR_BAD_UNIT_NUM
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN256XBNGetLinkStatus (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyEnableDisable_t	pLinkStatus
+	);
+
+#if        defined(__cplusplus)
+}
+#endif  // defined(__cplusplus)
+
+#endif
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/makefile linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/makefile
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/makefile	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/makefile	2012-09-14 14:51:37.001926000 +0530
@@ -0,0 +1,49 @@
+DIR_LOCAL = comps/tmbslPhyEN256X
+
+#***********************************************************************
+# Do not change the following include
+#***********************************************************************
+include $(_TMROOT)/sde/environment.mk
+
+#-----------------------------------------------------------------------
+# Source environment variables
+#-----------------------------------------------------------------------
+CXX_SOURCES =
+
+C_SOURCES = src/tmbslPhyEN256X.c 
+ 
+#-----------------------------------------------------------------------
+# Which modules does this target requires (includes & libs)
+#-----------------------------------------------------------------------
+REQUIRES = tmbslPhy
+
+LIBS = 
+
+#-----------------------------------------------------------------------
+# Directory where the 3rdparty includes are stored
+#-----------------------------------------------------------------------
+DIR_INCLUDE = 
+
+#-----------------------------------------------------------------------
+# local CFLAGS
+#-----------------------------------------------------------------------
+LOCAL_CFLAGS =
+
+#-----------------------------------------------------------------------
+# local CPPFLAGS
+#-----------------------------------------------------------------------
+LOCAL_CXXFLAGS = 
+
+EXPORTS = 
+
+#***********************************************************************
+# Do not change this
+#***********************************************************************
+all: configuration lib
+
+#***********************************************************************
+# Do not change the following include
+#***********************************************************************
+ifneq ($(DIR_CONFIG),_)
+include $(DIR_SDE)/$(DIR_CONFIG)/makelib.mk
+endif
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/src/tmbslPhyEN256X.c linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/src/tmbslPhyEN256X.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/src/tmbslPhyEN256X.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/src/tmbslPhyEN256X.c	2012-09-14 14:51:37.004929000 +0530
@@ -0,0 +1,886 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Copyright (c) 2006-2007, LIPP Alliance
+ * All Rights Reserved.
+ *
+ *---------------------------------------------------------------------------
+ * %filename:     tmbslPhyEN256XBN.h %
+ * %pid_version:              1.0 %
+ *---------------------------------------------------------------------------
+ * DESCRIPTION: Macros and function prototypes for EN256XBN PHY
+ *
+ * DOCUMENT REF: Datasheet Realtek Semiconductor EN256XBN-GR
+ *               Integrated 10/100/1000 Gigabit Ethernet Transceiver
+ *               Rev. 1.0, April 3, 2008
+ *
+ * NOTES:        None
+ *-----------------------------------------------------------------------------
+ *
+*/
+#include <asm/io.h>
+#include <tmNxTypes.h>
+#include <tmNxCompId.h>
+
+/*  Project include files */
+
+#include "tmbslPhy.h"
+#include "tmbslPhyEN256X.h"
+#include "tmhwLIPP6100Eth_Cfg.h"
+#include "linux/spinlock.h"
+
+/* Defines */
+
+#define PHY_TIMEOUT				(100000)
+
+#define ANAR_DEFAULT_VAL			(0xADE1)
+#define KTCR1_DEFAULT_VAL			(0x300)
+
+/* Global Data */
+ /* Initialize with base address of GMAC. This will be used to access MAC Address & MAC data register */
+
+static tmbslPhyEN256XContext_t gEthContext;
+
+extern spinlock_t moca_spinlock;
+
+/* Static functions definition */
+
+tmErrorCode_t
+tmbslPhyEN256XRead (
+	tmUnitSelect_t		ethUnitId,
+	tmbslPhyEN256XReg_t	reg,
+	pUInt16			pVal
+	);
+
+
+tmErrorCode_t
+tmbslPhyEN256XWrite (
+    tmUnitSelect_t		ethUnitId,
+    tmbslPhyEN256XReg_t	reg,
+    UInt16			val
+	);
+
+/* Exported functions */
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN256XBNGetSWVersion:
+//
+// DESCRIPTION: This function returns the PHY device interface software version
+//		information
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY
+//		or in PowerOff state.
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN256XBNGetSWVersion (
+	ptmSWVersion_t	pPhyVersion
+	)
+{
+	pPhyVersion->compatibilityNr = TMBSL_PHY_COMPATIBILITY_NR;
+	pPhyVersion->majorVersionNr = TMBSL_PHY_MAJOR_VERSION_NR;
+	pPhyVersion->minorVersionNr = TMBSL_PHY_MINOR_VERSION_NR;
+
+	return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN256XBNGetCapabilities:
+//
+// DESCRIPTION: This function returns the PHY capabilities for the specified PHY
+//		unit. The function is callable at any time to return the unit's
+//		capabilities (PHY unit initialization is not necessary).
+//		Capabilities may be different among multiple PHY units.For completeness,
+//		a PHY BSL user should call this function for each PHY unit to
+//		determine its individual capabilities.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This API can be called anytime i.e. before initializing the PHY.
+//
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyEN256XBNGetCapabilities (
+    tmUnitSelect_t		ethUnitId,
+    ptmbslPhyCapabilities_t  	pPhyCaps
+    )
+
+{
+    UInt16 bmsr,extStat;
+
+    /*  Read the PHY capabilites from the BMSR register */
+    tmbslPhyEN256XRead(ethUnitId, tmbslPhyEN256XBmsr, &bmsr);
+
+    /*  Read the extended status register */
+    tmbslPhyEN256XRead(ethUnitId, tmbslPhyEN256X1kscr, &extStat);
+
+    pPhyCaps->T4Support100Base = False;
+
+    pPhyCaps->Tx_FullDuplexSupport100Base = True;
+
+    pPhyCaps->Tx_HalfDuplexSupport100Base = False;
+
+    pPhyCaps->Tx_FullDuplexSupport10Base = False;
+
+    pPhyCaps->Tx_HalfDuplexSupport10Base = False;
+
+    pPhyCaps->preAmbleSuppresionCapability =
+        (((bmsr &TMBSL_PHYEN256X_BMSR_PREAMBLE_SUP) > 0) ? True : False);
+
+    pPhyCaps->autoNegotiationAbility = False;
+
+
+    pPhyCaps->X1000BaseFDSupport =
+                (((extStat &TMBSL_PHYEN256X_1KSCR_1000BASEX_FD) > 0) ? True : False);
+
+    pPhyCaps->X1000BaseHDSupport =
+                (((extStat &TMBSL_PHYEN256X_1KSCR_1000BASEX_HD) > 0) ? True : False);
+
+    pPhyCaps->T1000BaseFDSupport =
+                (((extStat &TMBSL_PHYEN256X_1KSCR_1000BASET_FD) > 0) ? True : False);
+
+    pPhyCaps->T1000BaseHDSupport =
+                (((extStat &TMBSL_PHYEN256X_1KSCR_1000BASET_HD) > 0) ? True : False);
+
+    pPhyCaps->ledStatusSupport = True ;
+
+    /* Other capabilites set to False */
+    pPhyCaps->nextPageIndication = False;
+
+    pPhyCaps->force100MbpsTxOff = False;
+
+    pPhyCaps->bypassSymbolAlignment =False;
+
+    pPhyCaps->badSSDDetectionConfig = False;
+
+    return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN256XBNInit:
+//
+// DESCRIPTION: This function initializes the PHY device. It should be called
+//		before any access to the device is made.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       This function initializes the PHY device with the following
+//		default initial configuration.No Autonegotiation is done in the
+//		initialization function
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyEN256XBNInit(
+    tmUnitSelect_t	ethUnitId
+    )
+{
+//    tmErrorCode_t	ethStatus = TM_OK;
+//    UInt16		regval = 0;
+    unsigned int regVal;
+
+    gEthContext.pRegs = gtmhwLIPP6100Eth_Base[ethUnitId].baseAddress;
+#if 0
+
+    /* Read the defaults in the BMCR */
+    ethStatus = tmbslPhyEN256XRead(ethUnitId,tmbslPhyEN256XBmcr,&regval);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    regval |= 0x2100;
+
+    /* Set the PHY for the 100Mbps and Full Duplex */
+    ethStatus = tmbslPhyEN256XWrite(ethUnitId,tmbslPhyEN256XBmcr,regval);
+
+    if(ethStatus != TM_OK)
+    {
+        return (ethStatus);
+    }
+#endif
+    regVal = readl(0xE06BB304U);
+    regVal = (regVal & 0x0FF);
+    writel(regVal, 0xE06BB304U);
+    return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN256XBNDeinit:
+//
+// DESCRIPTION: This function de-initializes the PHY device. Once the device is
+//		deinitilized device will no more be available to access
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN256XBNDeinit(
+    tmUnitSelect_t	ethUnitId
+    )
+
+{
+    tmErrorCode_t	ethStatus = TM_OK;
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+    else
+    {
+        return TM_OK;
+    }
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN256XBNSetPowerState:
+//
+// DESCRIPTION: This function will set the Power State of the PHY device to specified
+//		power state
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN256XBNSetPowerState(
+    tmUnitSelect_t	ethUnitId ,
+    tmPowerState_t	phyPowerState
+    )
+
+{
+    return TMBSL_ERR_PHY_NOT_SUPPORTED;    
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN256XBNGetPowerState:
+//
+// DESCRIPTION: This function will get the preset power state of the PHY device
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN256XBNGetPowerState(
+    tmUnitSelect_t	ethUnitId ,
+    ptmPowerState_t	phyPowerState
+    )
+
+{
+    return TMBSL_ERR_PHY_NOT_SUPPORTED;
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN256XBNGetBasicModeControl:
+//
+// DESCRIPTION: This function will get the basic configuration of the PHY device.
+//
+// RETURN:      TM_OK
+//
+// NOTES:       See #define for the Basic Mode Control
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN256XBNGetBasicModeControl (
+    tmUnitSelect_t			ethUnitId,
+    ptmbslPhyBasicModeControl_t		pPhyBasicModeControl
+    )
+{
+    tmErrorCode_t	ethStatus = TM_OK;
+    UInt16		bmcr;
+
+    /* Read the present settings of the BMCR register */
+    ethStatus = tmbslPhyEN256XRead(ethUnitId,tmbslPhyEN256XBmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus;
+    }
+
+    pPhyBasicModeControl->enableCollisionTest = False;
+
+    pPhyBasicModeControl->duplexMode =
+                (((bmcr & TMBSL_PHYEN256X_BMCR_FD_EN ) > 0) ? tmbslPhyFullDuplex : tmbslPhyHalfDuplex);
+
+    switch(bmcr & TMBSL_PHYEN256X_BMCR_SPEED_MSK)
+    {
+        case TMBSL_PHYEN256X_BMCR_SPEED_1G:
+            pPhyBasicModeControl->speed = tmbslPhySpeed1Gbps;
+            break;
+
+        case TMBSL_PHYEN256X_BMCR_SPEED_100:
+            pPhyBasicModeControl->speed = tmbslPhySpeed100Mbps;
+            break;
+
+        case TMBSL_PHYEN256X_BMCR_SPEED_10:
+            pPhyBasicModeControl->speed = tmbslPhySpeed10Mbps;
+            break;
+
+        default:
+            pPhyBasicModeControl->speed = tmbslPhySpeed100Mbps;
+            break;
+    }
+
+    return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN256XBNSetBasicModeControl:
+//
+// DESCRIPTION: This function will configure the PHY device for the Basic Mode.
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN256XBNSetBasicModeControl (
+    tmUnitSelect_t			ethUnitId,
+    ptmbslPhyBasicModeControl_t		pPhyBasicModeControl
+    )
+{
+    tmErrorCode_t	ethStatus = TM_OK;
+#if 0    
+    UInt16		bmcr = 0;
+
+    /* Only Full Duplex is supported */
+    bmcr = TMBSL_PHYEN256X_BMCR_FD_EN;
+
+    switch(pPhyBasicModeControl->speed)
+    {
+        case tmbslPhySpeed1Gbps :
+            bmcr |= TMBSL_PHYEN256X_BMCR_SPEED_1G;
+            break;
+
+        case tmbslPhySpeed100Mbps :
+            bmcr |= TMBSL_PHYEN256X_BMCR_SPEED_100;
+            break;
+
+        case tmbslPhySpeed10Mbps :
+            bmcr |= TMBSL_PHYEN256X_BMCR_SPEED_10;
+            break;
+
+        default:
+            bmcr |= TMBSL_PHYEN256X_BMCR_SPEED_100;
+            break;
+
+    }
+
+    /* Write the result to the BMC register */
+    ethStatus = tmbslPhyEN256XWrite(ethUnitId,tmbslPhyEN256XBmcr,bmcr);
+#endif
+    return ethStatus;
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN256XBNGetBasicModeStatus:
+//
+// DESCRIPTION: This function will get the Basic Mode Status of the PHY device
+//		such as the speed, duplex mode and other statuses
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN256XBNGetBasicModeStatus (
+    tmUnitSelect_t		ethUnitId,
+    ptmbslPhyBasicModeStatus_t	pPhyBasicModeStatus
+    )
+
+{
+    tmErrorCode_t	ethStatus = TM_OK;
+    UInt16		bmsr,bmcr;
+
+    /* Read the PHY status from the BMSR register */
+    ethStatus = tmbslPhyEN256XRead(ethUnitId, tmbslPhyEN256XBmsr, &bmsr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    /* Read the PHY control register from the BMCR register */
+    ethStatus = tmbslPhyEN256XRead(ethUnitId, tmbslPhyEN256XBmcr, &bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    pPhyBasicModeStatus->jabberDetect = False;
+
+    pPhyBasicModeStatus->remoteFaultDetected = False;
+
+    pPhyBasicModeStatus->autoNegotiationComplete = False;
+
+    pPhyBasicModeStatus->loopBackEnabled = (((bmcr & TMBSL_PHYEN256X_BMCR_LPBK_VAL) > 0) ? True : False);
+
+    /* Not an auto negotiation. So read the values from BMCR */
+    pPhyBasicModeStatus->duplexMode = tmbslPhyFullDuplex;
+
+    switch(bmcr & TMBSL_PHYEN256X_BMCR_SPEED_MSK)
+    {
+        case TMBSL_PHYEN256X_BMCR_SPEED_1G:
+            pPhyBasicModeStatus->speed = tmbslPhySpeed1Gbps;
+            break;
+
+        case TMBSL_PHYEN256X_BMCR_SPEED_100:
+            pPhyBasicModeStatus->speed = tmbslPhySpeed100Mbps;
+            break;
+
+        case TMBSL_PHYEN256X_BMCR_SPEED_10:
+            pPhyBasicModeStatus->speed = tmbslPhySpeed10Mbps;
+            break;
+
+        default:
+            pPhyBasicModeStatus->speed = tmbslPhySpeed100Mbps;
+            break;
+    }
+
+    return TM_OK;
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN256XBNAutoNegotiate:
+//
+// DESCRIPTION: This function will enable the Auto negotiation of the PHY device
+//		with Link Partner. Best possible performance configuration is
+//		selected automatically during this process
+//
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN256XBNAutoNegotiate (
+    tmUnitSelect_t			ethUnitId,
+    ptmbslPhyAutoNegotitationMask_t	pAutoNegotiationMask
+    )
+{
+    return TMBSL_ERR_PHY_NOT_SUPPORTED;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN256XBNLoopBack:
+//
+// DESCRIPTION: Function will enable or disable the PHY device in the Loopback
+//		mode.
+//
+// RETURN:      TM_OK
+// NOTES:
+//-----------------------------------------------------------------------------
+
+
+tmErrorCode_t
+tmbslPhyEN256XBNLoopBack (
+    tmUnitSelect_t		ethUnitId,
+    tmbslPhyEnableDisable_t	loopbackMode
+    )
+{
+    tmErrorCode_t	ethStatus = TM_OK;
+    UInt16		bmcr;
+
+    /* Read the existing settings of the BMCR register */
+    ethStatus = tmbslPhyEN256XRead(ethUnitId,tmbslPhyEN256XBmcr,&bmcr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    if(tmbslPhyEnable == loopbackMode)
+    {
+        bmcr |= TMBSL_PHYEN256X_BMCR_LPBK_VAL;
+    }
+    else if(tmbslPhyDisable == loopbackMode)
+    {
+        bmcr &= TMBSL_PHYEN256X_BMCR_LPBK_CLR;
+    }
+    else
+    {
+        ethStatus = TMBSL_ERR_PHY_NOT_SUPPORTED;
+    }
+
+    /* Write the Loopback setting to the BMCR register */
+    ethStatus = tmbslPhyEN256XWrite(ethUnitId,tmbslPhyEN256XBmcr,bmcr);
+
+    return ethStatus;
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN256XBNSoftReset:
+//
+// DESCRIPTION: Function will do the soft reset of the PHY device
+
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN256XBNSoftReset (
+    tmUnitSelect_t	ethUnitId
+	)
+
+{
+    return TMBSL_ERR_PHY_NOT_SUPPORTED;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN256XBNGetLinkStatus:
+//
+// DESCRIPTION: Function will get the link status
+
+// RETURN:      TM_OK
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN256XBNGetLinkStatus (
+    tmUnitSelect_t		ethUnitId,
+    ptmbslPhyEnableDisable_t	pLinkStatus
+    )
+{
+    tmErrorCode_t	ethStatus = TM_OK;
+    UInt16		bmsr;
+
+    /* Read the BMSR register */
+    ethStatus = tmbslPhyEN256XRead(ethUnitId,tmbslPhyEN256XBmsr,&bmsr);
+
+    if(ethStatus != TM_OK)
+    {
+        return ethStatus ;
+    }
+
+    *pLinkStatus =
+    (((bmsr & TMBSL_PHYEN256X_BMSR_LINK_STAT) > 0) ? tmbslPhyEnable : tmbslPhyDisable);
+
+    return(TM_OK);
+}
+
+//-----------------------------------------------------------------------------
+//	Local static functions
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN256XRead:
+//
+// DESCRIPTION: Function will read from the Specified PHY register
+
+// RETURN:
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN256XRead (
+    tmUnitSelect_t		ethUnitId,
+    tmbslPhyEN256XReg_t	reg,
+    pUInt16			pVal
+	)
+
+{
+    UInt32		timeout = 0;
+    UInt32 		pEthRegs;
+    volatile UInt32	*pAdrReg;
+    volatile UInt32	*pDataReg;
+    UInt32		regValue;
+
+    /* get Ethernet Module Reg Pointer  */
+    pEthRegs = gtmhwLIPP6100Eth_Base[ethUnitId].baseAddress; //gEthContext.pRegs; i cannot do this
+
+    /* Get the Address register */
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* lock the spinlock */
+    spin_lock( &moca_spinlock ) ;
+
+    /* Program the Register address in the MII */
+    regValue = *pAdrReg;
+
+    /* Clear the earlier register value in Address register and write the new value */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Clear the bit GMII write for read operation */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_RD_CLR;
+
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_EN_VAL;
+
+    *pAdrReg = regValue;
+
+    /* Wait till the read operation is complete */
+
+    do
+    {
+        timeout++;
+
+    }while ( ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) &&
+                   (timeout < PHY_TIMEOUT) );
+
+    if( (timeout == PHY_TIMEOUT) &&
+        ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+    {
+        /* Unlock the spinlock */
+        spin_unlock( &moca_spinlock ) ;
+        return(TMBSL_ERR_PHY_READ_FAILED);
+    }
+
+    /* Read the data from the data register */
+    *pVal = (UInt16) *pDataReg;
+    
+    /* Unlock the spinlock */
+    spin_unlock( &moca_spinlock ) ;
+
+    return TM_OK;
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN256XWrite:
+//
+// DESCRIPTION: Function will Write to the Specified PHY register
+
+// RETURN:
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+//
+
+tmErrorCode_t
+tmbslPhyEN256XWrite (
+    tmUnitSelect_t		ethUnitId,
+    tmbslPhyEN256XReg_t	reg,
+    UInt16			val
+	)
+
+{
+    UInt32		pEthRegs;
+    volatile UInt32	*pAdrReg;
+    volatile UInt32	*pDataReg;
+    UInt32		regValue;
+    UInt32		timeout = 0;
+
+    /* Get the Ethernet Module Reg pointer */
+    pEthRegs = gtmhwLIPP6100Eth_Base[ethUnitId].baseAddress; //gEthContext.pRegs;
+
+    /* Get the Address register */
+    pAdrReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_ADR_REG_OFFSET) ;
+    pDataReg = (UInt32*)(pEthRegs+TMHW_LIPP6100ETH_DATA_REG_OFFSET) ;
+
+    /* lock the spinlock */
+    spin_lock( &moca_spinlock ) ;
+
+    /* Write the data into data register  */
+    *pDataReg = 0;
+    *pDataReg = val;
+
+    /* Program the Register address */
+    regValue = *pAdrReg;
+
+    /* Clear the earlier register value in Address register */
+    regValue &= TMHW_LIPP6100ETH_ADR_PHY_REG_CLR;
+    regValue |= reg << TMHW_LIPP6100ETH_ADR_PHY_REG_POS;
+
+    /* Set Write operation bit and enable write */
+    regValue |= TMHW_LIPP6100ETH_ADR_PHY_WR_VAL |
+               TMHW_LIPP6100ETH_ADR_PHY_EN_VAL ;
+
+    /* Write the value back to Address register */
+    *pAdrReg = regValue;
+
+    /* wait till the write operation is complete */
+
+    do
+    {
+        timeout++;
+    }
+    while (((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) &&
+            (timeout < PHY_TIMEOUT));
+
+    if ((timeout == PHY_TIMEOUT) &&
+        ((*pAdrReg & TMHW_LIPP6100ETH_ADR_PHY_EN_VAL) == tmbslPhyEnable) )
+    {        
+        /* Unlock the spinlock */
+        spin_unlock( &moca_spinlock ) ;
+        return(TMBSL_ERR_PHY_WRITE_FAILED);
+    }
+
+    /* Unlock the spinlock */
+    spin_unlock( &moca_spinlock ) ;
+
+    return TM_OK;
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN256XBNGetIdentifier:
+//
+// DESCRIPTION: This function will get the Phy Identifiers
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN256XBNGetIdentifier(
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyIdentifier_t     	pPhyIdentifier
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyEN256XBNGetLinkPartnerCapabilities:
+//
+// DESCRIPTION: This function will get the Link Partner Capabilities.
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN256XBNGetLinkPartnerCapabilities (
+    tmUnitSelect_t			ethUnitId,
+    ptmbslPhyLinkPartnerCapabilities_t	pPhyLinkPartnerCapabilities
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyGetCounters:
+//
+// DESCRIPTION: This function will get the Phy counters
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN256XBNGetCounters(
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyCounters_t     	pPhyCounters
+    )
+{
+    return(TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsSetConfig:
+//
+// DESCRIPTION: This function will set the pcs configuration
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN256XPcsSetConfig(
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyPcsConfig_t	pPhyPcsConfig
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyPcsGetConfig:
+//
+// DESCRIPTION:
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslPhyEN256XPcsGetConfig (
+    tmUnitSelect_t		phyUnitId,
+    ptmbslPhyPcsConfig_t    	pPhyPcsConfig
+    )
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyBist:
+//
+// DESCRIPTION:
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+ tmErrorCode_t
+tmbslEN256XPhyBist(
+    tmUnitSelect_t		phyUnitId,
+    tmbslPhyPseudoRandomSeq_t	phyPsedoRandomSeq ,
+    pUInt8                     	pBistState
+)
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
+
+//-----------------------------------------------------------------------------
+// FUNCTION:    tmbslPhyConfigBypass:
+//
+// DESCRIPTION:
+//
+// RETURN:      TMBSL_ERR_PHY_NOT_SUPPORTED
+//
+// NOTES:
+//-----------------------------------------------------------------------------
+
+tmErrorCode_t
+tmbslEN256XPhyConfigBypass(
+    tmUnitSelect_t	phyUnitId,
+    ptmbslPhyBypass_t	pPhyBypass
+)
+{
+    return (TMBSL_ERR_PHY_NOT_SUPPORTED);
+}
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/Kconfig linux-2.6.34/drivers/net/LIPP_6300ETH/Kconfig
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/Kconfig	2012-09-14 14:44:58.436458000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/Kconfig	2012-09-14 14:54:45.048943000 +0530
@@ -33,10 +33,15 @@ config ENABLE_MOCA
 
 choice
 	prompt "Choose Entropic PHY version"
-        default EN2512_PHY
+        default EN256X_PHY
 	depends on ENABLE_MOCA
 	help
-		This option allows to select between EN2512 or EN2510 MoCA PHY driver
+		This option allows to select between EN256x or EN2512 or EN2510 MoCA PHY driver
+
+config EN256X_PHY
+	bool "Entropic MoCA EN256X PHY"
+	help
+		Select HiRF EN256X Entropic MoCA PHY driver
 
 config EN2512_PHY
 	bool "Entropic MoCA EN2512 PHY"
@@ -49,3 +54,9 @@ config EN2510_PHY
 		Select HiRF EN2510 Entropic MoCA PHY driver
 
 endchoice
+
+config EN256X_GPIO_TOGGLE
+	bool "Enable PIO 131/121 toggle" 
+	default y
+	depends on EN256X_PHY
+
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/Makefile linux-2.6.34/drivers/net/LIPP_6300ETH/Makefile
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/Makefile	2012-09-14 14:44:58.437462000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/Makefile	2012-09-14 14:51:37.008923000 +0530
@@ -50,6 +50,22 @@ PHY_OBJS-$(CONFIG_EN2512_PHY) += comps/t
 				 comps/tmbslPhyEN2512/en2512/GPL/Apollo/en2512.o \
 				 comps/tmbslPhyEN2512/en2512/GPL/Apollo/apollo_mdio.o
 
+PHY_OBJS-$(CONFIG_EN256X_PHY) += comps/tmbslPhyEN256X/src/tmbslPhyEN256X.o \
+				 comps/tmbslPhyEN256X/en256x/Apollo/Src/Clnk_ctl_apollo.o \
+				 comps/tmbslPhyEN256X/en256x/Apollo/Src/ClnkBus_iface_apollo.o \
+				 comps/tmbslPhyEN256X/en256x/Common/Src/ClnkIo.o \
+				 comps/tmbslPhyEN256X/en256x/Common/Src/ClnkIo_common.o \
+				 comps/tmbslPhyEN256X/en256x/Common/Src/ClnkMbx_call.o \
+				 comps/tmbslPhyEN256X/en256x/Common/Src/ClnkMbx_dvr.o \
+				 comps/tmbslPhyEN256X/en256x/Common/Src/ctx_abs.o \
+				 comps/tmbslPhyEN256X/en256x/Common/Src/ctx_setup.o \
+				 comps/tmbslPhyEN256X/en256x/Common/Src/util_dvr.o \
+				 comps/tmbslPhyEN256X/en256x/GPL/Common/hostos_linux.o \
+				 comps/tmbslPhyEN256X/en256x/GPL/Common/gpl_ctx_abs.o \
+				 comps/tmbslPhyEN256X/en256x/GPL/Common/gpl_ctx_setup.o \
+				 comps/tmbslPhyEN256X/en256x/GPL/Apollo/en256x.o \
+				 comps/tmbslPhyEN256X/en256x/GPL/Apollo/apollo_mdio.o
+
 LIPP_6300ETH-objs = src/gmac_drv.o src/remap.o src/tmbslPhyAccess.o \
 		    comps/tmhwLIPP6100Eth/src/tmhwLIPP6100Eth.o \
 		    comps/tmhwLIPP6100Eth/cfg/tmhwLIPP6100Eth_Cfg.o $(PHY_OBJS-y)
@@ -89,6 +105,13 @@ EXTRA_PHY_FLAGS-$(CONFIG_EN2512_PHY) += 
 					-Idrivers/net/LIPP_6300ETH/comps/tmbslPhyEN2512/en2512/GPL/Apollo \
 					-DAPOLLO_DRVR_SUPPORT
 
+EXTRA_PHY_FLAGS-$(CONFIG_EN256X_PHY) += -Idrivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/inc \
+					-Idrivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Apollo/Inc \
+					-Idrivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/Common/Inc \
+					-Idrivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Common \
+					-Idrivers/net/LIPP_6300ETH/comps/tmbslPhyEN256X/en256x/GPL/Apollo \
+					-DAPOLLO_DRVR_SUPPORT
+
 EXTRA_PHY_FLAGS-y += -Idrivers/net/LIPP_6300ETH/comps/tmbslPhyMYSTI110E/inc \
 		     -Idrivers/net/LIPP_6300ETH/comps/tmbslPhyRTL8211BN/inc \
 		     -Idrivers/net/LIPP_6300ETH/comps/tmbslPhyIntel972/inc
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/gmac_drv.c linux-2.6.34/drivers/net/LIPP_6300ETH/src/gmac_drv.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/gmac_drv.c	2012-09-14 14:44:58.442462000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/src/gmac_drv.c	2012-09-14 14:51:37.012929000 +0530
@@ -2891,9 +2891,15 @@ static __s32 lipp_6300Eth_do_ioctl(struc
         case SIOCCLINKDRV :     // Control plane commands for the driver
         case SIOCGCLINKMEM :    // Reads registers/memory in c.LINK address space
         case SIOCSCLINKMEM :    // Sets registers/memory in c.LINK address space
+#ifndef CONFIG_EN256X_PHY
         case SIOCGCLNKCMD :     // mbox cmmds: request with response
         case SIOCSCLNKCMD :     // mbox cmmds: request with no response
         case SIOCLNKDRV :       // mbox cmmds: retrieve unsol messages
+#else
+        case SIOCETHTOOL:
+        case SIOCGIFHWADDR:
+        case SIOCMSCMD: 
+#endif
             retVal = ioctl_operation_work( moca_data_kernel_content, ifr, cmd ) ;
             break ;
 #endif
diff -Naupr linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tmbslPhyAccess.c linux-2.6.34/drivers/net/LIPP_6300ETH/src/tmbslPhyAccess.c
--- linux-2.6.34.orig/drivers/net/LIPP_6300ETH/src/tmbslPhyAccess.c	2012-09-14 14:44:58.447463000 +0530
+++ linux-2.6.34/drivers/net/LIPP_6300ETH/src/tmbslPhyAccess.c	2012-09-14 14:51:37.054923000 +0530
@@ -275,6 +275,10 @@
 #include "tmbslPhyEN2512.h"
 #endif
 
+#ifdef CONFIG_EN256X_PHY
+#include "tmbslPhyEN256X.h"
+#endif
+
 tmbslPhyConfig_t gtmbslRTL8211BNPhyInterface =
 {
        "RTL-8211BN",
@@ -359,6 +363,35 @@ tmbslPhyConfig_t gtmbslMYSTIPhyInterface
         tmbslPhyMYSTI110EGetLinkStatus
 };
 #ifdef CONFIG_ENABLE_MOCA
+#ifdef CONFIG_EN256X_PHY
+tmbslPhyConfig_t gtmbslMoCAPhyInterface =
+{
+       "EN256X",
+        0x02434664,
+        LAN_CLK_SEL,
+        LAN_CLK_SPEED_SEL,
+        tmbslPhyEN256XBNGetSWVersion,
+        tmbslPhyEN256XBNGetCapabilities,
+        tmbslPhyEN256XBNInit,
+        tmbslPhyEN256XBNDeinit,
+        tmbslPhyEN256XBNSetPowerState,
+        tmbslPhyEN256XBNGetPowerState,
+        tmbslPhyEN256XBNGetBasicModeControl,
+        tmbslPhyEN256XBNSetBasicModeControl,
+        tmbslPhyEN256XBNGetBasicModeStatus,
+        tmbslPhyEN256XBNAutoNegotiate,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        Null,
+        tmbslPhyEN256XBNLoopBack,
+        tmbslPhyEN256XBNSoftReset,
+        tmbslPhyEN256XBNGetLinkStatus
+};
+#else
 #ifdef CONFIG_EN2510_PHY
 tmbslPhyConfig_t gtmbslMoCAPhyInterface =
 {
@@ -418,6 +451,7 @@ tmbslPhyConfig_t gtmbslMoCAPhyInterface 
 };
 #endif
 #endif
+#endif
 
 tmbslPhyConfig_t gtmbslLXT972APhyInterface =
 {
@@ -453,8 +487,12 @@ phyID_interface_tbl phy_tbl[]={
 {0x001cc912, &gtmbslRTL8211BNPhyInterface},
 {0x001cc915, &gtmbslRTL8211EGPhyInterface},
 #ifdef CONFIG_ENABLE_MOCA
+#ifdef CONFIG_EN256X_PHY
+{0x02434664, &gtmbslMoCAPhyInterface},
+#else
 {0x0,        &gtmbslMoCAPhyInterface},
 #endif
+#endif
 {0x00008201, &gtmbslLXT972APhyInterface},
 {0x001378e2, &gtmbslLXT972APhyInterface}
 };
diff -Naupr linux-2.6.34.orig/include/net/LIPP_6300ETH/gmac_ioctl.h linux-2.6.34/include/net/LIPP_6300ETH/gmac_ioctl.h
--- linux-2.6.34.orig/include/net/LIPP_6300ETH/gmac_ioctl.h	2012-09-14 14:45:20.537026000 +0530
+++ linux-2.6.34/include/net/LIPP_6300ETH/gmac_ioctl.h	2012-09-14 14:51:37.057925000 +0530
@@ -24,6 +24,7 @@
 #define SIOCSCLNKCMD    (SIOCDEVPRIVATE+11) // pass thru c.LINK command that expects no response
 #define SIOCLNKDRV      (SIOCDEVPRIVATE+12) // a. Initialize Mailbox Queue Handler b. Get Unsolicited Message
 #define SIOCHDRCMD      (SIOCDEVPRIVATE+13)  // Resets the SoC , Control the diplexer switch etc.
+#define SIOCMSCMD       (SIOCDEVPRIVATE+15)  // MoCA Shell command
 
 #define ETH_POWER_DOWN (SIOCDEVPRIVATE+5)
 
