diff -Naurp linux-2.6.34.org/drivers/mtd/nand/nand_base.c linux-2.6.34/drivers/mtd/nand/nand_base.c
--- linux-2.6.34.org/drivers/mtd/nand/nand_base.c	2011-04-14 23:17:31.000000000 -0500
+++ linux-2.6.34/drivers/mtd/nand/nand_base.c	2011-04-14 17:12:01.000000000 -0500
@@ -108,6 +108,35 @@ static int nand_do_write_oob(struct mtd_
  */
 DEFINE_LED_TRIGGER(nand_led_trigger);
 
+static int check_offs_len(struct mtd_info *mtd,
+					loff_t ofs, uint64_t len)
+{
+	struct nand_chip *chip = mtd->priv;
+	int ret = 0;
+
+	/* Start address must align on block boundary */
+	if (ofs & ((1 << chip->phys_erase_shift) - 1)) {
+		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Unaligned address\n", __func__);
+		ret = -EINVAL;
+	}
+
+	/* Length must align on block boundary */
+	if (len & ((1 << chip->phys_erase_shift) - 1)) {
+		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Length not block aligned\n",
+					__func__);
+		ret = -EINVAL;
+	}
+
+	/* Do not allow past end of device */
+	if (ofs + len > mtd->size) {
+		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Past end of device\n",
+					__func__);
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
 /**
  * nand_release_device - [GENERIC] release chip
  * @mtd:	MTD device structure
@@ -318,6 +347,9 @@ static int nand_block_bad(struct mtd_inf
 	struct nand_chip *chip = mtd->priv;
 	u16 bad;
 
+	if (chip->options & NAND_BBT_SCANLASTPAGE)
+		ofs += mtd->erasesize - mtd->writesize;
+
 	page = (int)(ofs >> chip->page_shift) & chip->pagemask;
 
 	if (getchip) {
@@ -335,14 +367,18 @@ static int nand_block_bad(struct mtd_inf
 		bad = cpu_to_le16(chip->read_word(mtd));
 		if (chip->badblockpos & 0x1)
 			bad >>= 8;
-		if ((bad & 0xFF) != 0xff)
-			res = 1;
+		else
+			bad &= 0xFF;
 	} else {
 		chip->cmdfunc(mtd, NAND_CMD_READOOB, chip->badblockpos, page);
-		if (chip->read_byte(mtd) != 0xff)
-			res = 1;
+		bad = chip->read_byte(mtd);
 	}
 
+	if (likely(chip->badblockbits == 8))
+		res = bad != 0xFF;
+	else
+		res = hweight8(bad) < chip->badblockbits;
+
 	if (getchip)
 		nand_release_device(mtd);
 
@@ -361,7 +397,10 @@ static int nand_default_block_markbad(st
 {
 	struct nand_chip *chip = mtd->priv;
 	uint8_t buf[2] = { 0, 0 };
-	int block, ret;
+	int block, ret, i = 0;
+
+	if (chip->options & NAND_BBT_SCANLASTPAGE)
+		ofs += mtd->erasesize - mtd->writesize;
 
 	/* Get block number */
 	block = (int)(ofs >> chip->bbt_erase_shift);
@@ -372,17 +411,31 @@ static int nand_default_block_markbad(st
 	if (chip->options & NAND_USE_FLASH_BBT)
 		ret = nand_update_bbt(mtd, ofs);
 	else {
-		/* We write two bytes, so we dont have to mess with 16 bit
-		 * access
-		 */
 		nand_get_device(chip, mtd, FL_WRITING);
-		ofs += mtd->oobsize;
-		chip->ops.len = chip->ops.ooblen = 2;
-		chip->ops.datbuf = NULL;
-		chip->ops.oobbuf = buf;
-		chip->ops.ooboffs = chip->badblockpos & ~0x01;
 
-		ret = nand_do_write_oob(mtd, ofs, &chip->ops);
+		/* Write to first two pages and to byte 1 and 6 if necessary.
+		 * If we write to more than one location, the first error
+		 * encountered quits the procedure. We write two bytes per
+		 * location, so we dont have to mess with 16 bit access.
+		 */
+		do {
+			chip->ops.len = chip->ops.ooblen = 2;
+			chip->ops.datbuf = NULL;
+			chip->ops.oobbuf = buf;
+			chip->ops.ooboffs = chip->badblockpos & ~0x01;
+
+			ret = nand_do_write_oob(mtd, ofs, &chip->ops);
+
+			if (!ret && (chip->options & NAND_BBT_SCANBYTE1AND6)) {
+				chip->ops.ooboffs = NAND_SMALL_BADBLOCK_POS
+					& ~0x01;
+				ret = nand_do_write_oob(mtd, ofs, &chip->ops);
+			}
+			i++;
+			ofs += mtd->writesize;
+		} while (!ret && (chip->options & NAND_BBT_SCAN2NDPAGE) &&
+				i < 2);
+
 		nand_release_device(mtd);
 	}
 	if (!ret)
@@ -401,6 +454,11 @@ static int nand_default_block_markbad(st
 static int nand_check_wp(struct mtd_info *mtd)
 {
 	struct nand_chip *chip = mtd->priv;
+
+	/* broken xD cards report WP despite being writable */
+	if (chip->options & NAND_BROKEN_XD)
+		return 0;
+
 	/* Check the WP bit */
 	chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
 	return (chip->read_byte(mtd) & NAND_STATUS_WP) ? 0 : 1;
@@ -555,7 +613,8 @@ static void nand_command(struct mtd_info
 			       NAND_CTRL_CLE | NAND_CTRL_CHANGE);
 		chip->cmd_ctrl(mtd,
 			       NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
-		while (!(chip->read_byte(mtd) & NAND_STATUS_READY)) ;
+		while (!(chip->read_byte(mtd) & NAND_STATUS_READY))
+				;
 		return;
 
 		/* This applies to read commands */
@@ -661,7 +720,8 @@ static void nand_command_lp(struct mtd_i
 			       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
 		chip->cmd_ctrl(mtd, NAND_CMD_NONE,
 			       NAND_NCE | NAND_CTRL_CHANGE);
-		while (!(chip->read_byte(mtd) & NAND_STATUS_READY)) ;
+		while (!(chip->read_byte(mtd) & NAND_STATUS_READY))
+				;
 		return;
 
 	case NAND_CMD_RNDOUT:
@@ -727,7 +787,7 @@ nand_get_device(struct nand_chip *chip, 
 	spinlock_t *lock = &chip->controller->lock;
 	wait_queue_head_t *wq = &chip->controller->wq;
 	DECLARE_WAITQUEUE(wait, current);
- retry:
+retry:
 	spin_lock(lock);
 
 	/* Hardware controller shared among independent devices */
@@ -744,9 +804,6 @@ nand_get_device(struct nand_chip *chip, 
 			chip->state = FL_PM_SUSPENDED;
 			spin_unlock(lock);
 			return 0;
-		} else {
-			spin_unlock(lock);
-			return -EAGAIN;
 		}
 	}
 	set_current_state(TASK_UNINTERRUPTIBLE);
@@ -765,7 +822,7 @@ nand_get_device(struct nand_chip *chip, 
  *
  * Wait for command done. This is a helper function for nand_wait used when
  * we are in interrupt context. May happen when in panic and trying to write
- * an oops trough mtdoops.
+ * an oops through mtdoops.
  */
 static void panic_nand_wait(struct mtd_info *mtd, struct nand_chip *chip,
 			    unsigned long timeo)
@@ -780,7 +837,7 @@ static void panic_nand_wait(struct mtd_i
 				break;
 		}
 		mdelay(1);
-        }
+	}
 }
 
 /**
@@ -835,6 +892,170 @@ static int nand_wait(struct mtd_info *mt
 }
 
 /**
+ * __nand_unlock - [REPLACEABLE] unlocks specified locked blocks
+ *
+ * @mtd: mtd info
+ * @ofs: offset to start unlock from
+ * @len: length to unlock
+ * @invert:   when = 0, unlock the range of blocks within the lower and
+ *                      upper boundary address
+ *            when = 1, unlock the range of blocks outside the boundaries
+ *                      of the lower and upper boundary address
+ *
+ * return - unlock status
+ */
+static int __nand_unlock(struct mtd_info *mtd, loff_t ofs,
+					uint64_t len, int invert)
+{
+	int ret = 0;
+	int status, page;
+	struct nand_chip *chip = mtd->priv;
+
+	/* Submit address of first page to unlock */
+	page = ofs >> chip->page_shift;
+	chip->cmdfunc(mtd, NAND_CMD_UNLOCK1, -1, page & chip->pagemask);
+
+	/* Submit address of last page to unlock */
+	page = (ofs + len) >> chip->page_shift;
+	chip->cmdfunc(mtd, NAND_CMD_UNLOCK2, -1,
+				(page | invert) & chip->pagemask);
+
+	/* Call wait ready function */
+	status = chip->waitfunc(mtd, chip);
+	udelay(1000);
+	/* See if device thinks it succeeded */
+	if (status & 0x01) {
+		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Error status = 0x%08x\n",
+					__func__, status);
+		ret = -EIO;
+	}
+
+	return ret;
+}
+
+/**
+ * nand_unlock - [REPLACEABLE] unlocks specified locked blocks
+ *
+ * @mtd: mtd info
+ * @ofs: offset to start unlock from
+ * @len: length to unlock
+ *
+ * return - unlock status
+ */
+int nand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
+{
+	int ret = 0;
+	int chipnr;
+	struct nand_chip *chip = mtd->priv;
+
+	MTDDEBUG(MTD_DEBUG_LEVEL3, "%s: start = 0x%012llx, len = %llu\n",
+			__func__, (unsigned long long)ofs, len);
+
+	if (check_offs_len(mtd, ofs, len))
+		ret = -EINVAL;
+
+	/* Align to last block address if size addresses end of the device */
+	if (ofs + len == mtd->size)
+		len -= mtd->erasesize;
+
+	nand_get_device(chip, mtd, FL_UNLOCKING);
+
+	/* Shift to get chip number */
+	chipnr = ofs >> chip->chip_shift;
+
+	chip->select_chip(mtd, chipnr);
+
+	/* Check, if it is write protected */
+	if (nand_check_wp(mtd)) {
+		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Device is write protected!!!\n",
+					__func__);
+		ret = -EIO;
+		goto out;
+	}
+
+	ret = __nand_unlock(mtd, ofs, len, 0);
+
+out:
+	/* de-select the NAND device */
+	chip->select_chip(mtd, -1);
+
+	nand_release_device(mtd);
+
+	return ret;
+}
+EXPORT_SYMBOL(nand_unlock);
+
+/**
+ * nand_lock - [REPLACEABLE] locks all blocks present in the device
+ *
+ * @mtd: mtd info
+ * @ofs: offset to start unlock from
+ * @len: length to unlock
+ *
+ * return - lock status
+ *
+ * This feature is not supported in many NAND parts. 'Micron' NAND parts
+ * do have this feature, but it allows only to lock all blocks, not for
+ * specified range for block.
+ *
+ * Implementing 'lock' feature by making use of 'unlock', for now.
+ */
+int nand_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
+{
+	int ret = 0;
+	int chipnr, status, page;
+	struct nand_chip *chip = mtd->priv;
+
+	MTDDEBUG(MTD_DEBUG_LEVEL3, "%s: start = 0x%012llx, len = %llu\n",
+			__func__, (unsigned long long)ofs, len);
+
+	if (check_offs_len(mtd, ofs, len))
+		ret = -EINVAL;
+
+	nand_get_device(chip, mtd, FL_LOCKING);
+
+	/* Shift to get chip number */
+	chipnr = ofs >> chip->chip_shift;
+
+	chip->select_chip(mtd, chipnr);
+
+	/* Check, if it is write protected */
+	if (nand_check_wp(mtd)) {
+		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Device is write protected!!!\n",
+					__func__);
+		status = MTD_ERASE_FAILED;
+		ret = -EIO;
+		goto out;
+	}
+
+	/* Submit address of first page to lock */
+	page = ofs >> chip->page_shift;
+	chip->cmdfunc(mtd, NAND_CMD_LOCK, -1, page & chip->pagemask);
+
+	/* Call wait ready function */
+	status = chip->waitfunc(mtd, chip);
+	udelay(1000);
+	/* See if device thinks it succeeded */
+	if (status & 0x01) {
+		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Error status = 0x%08x\n",
+					__func__, status);
+		ret = -EIO;
+		goto out;
+	}
+
+	ret = __nand_unlock(mtd, ofs, len, 0x1);
+
+out:
+	/* de-select the NAND device */
+	chip->select_chip(mtd, -1);
+
+	nand_release_device(mtd);
+
+	return ret;
+}
+EXPORT_SYMBOL(nand_lock);
+
+/**
  * nand_read_page_raw - [Intern] read raw page data without ecc
  * @mtd:	mtd info structure
  * @chip:	nand chip info structure
@@ -860,8 +1081,9 @@ static int nand_read_page_raw(struct mtd
  *
  * We need a special oob layout and handling even when OOB isn't used.
  */
-static int nand_read_page_raw_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
-			      uint8_t *buf, int page)
+static int nand_read_page_raw_syndrome(struct mtd_info *mtd,
+					struct nand_chip *chip,
+					uint8_t *buf, int page)
 {
 	int eccsize = chip->ecc.size;
 	int eccbytes = chip->ecc.bytes;
@@ -942,7 +1164,8 @@ static int nand_read_page_swecc(struct m
  * @readlen:	data length
  * @bufpoi:	buffer to store read data
  */
-static int nand_read_subpage(struct mtd_info *mtd, struct nand_chip *chip, uint32_t data_offs, uint32_t readlen, uint8_t *bufpoi)
+static int nand_read_subpage(struct mtd_info *mtd, struct nand_chip *chip,
+			uint32_t data_offs, uint32_t readlen, uint8_t *bufpoi)
 {
 	int start_step, end_step, num_steps;
 	uint32_t *eccpos = chip->ecc.layout->eccpos;
@@ -950,6 +1173,7 @@ static int nand_read_subpage(struct mtd_
 	int data_col_addr, i, gaps = 0;
 	int datafrag_len, eccfrag_len, aligned_len, aligned_pos;
 	int busw = (chip->options & NAND_BUSWIDTH_16) ? 2 : 1;
+	int index = 0;
 
 	/* Column address wihin the page aligned to ECC size (256bytes). */
 	start_step = data_offs / chip->ecc.size;
@@ -988,26 +1212,30 @@ static int nand_read_subpage(struct mtd_
 	} else {
 		/* send the command to read the particular ecc bytes */
 		/* take care about buswidth alignment in read_buf */
-		aligned_pos = eccpos[start_step * chip->ecc.bytes] & ~(busw - 1);
+		index = start_step * chip->ecc.bytes;
+
+		aligned_pos = eccpos[index] & ~(busw - 1);
 		aligned_len = eccfrag_len;
-		if (eccpos[start_step * chip->ecc.bytes] & (busw - 1))
+		if (eccpos[index] & (busw - 1))
 			aligned_len++;
-		if (eccpos[(start_step + num_steps) * chip->ecc.bytes] & (busw - 1))
+		if (eccpos[index + (num_steps * chip->ecc.bytes)] & (busw - 1))
 			aligned_len++;
 
-		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, mtd->writesize + aligned_pos, -1);
+		chip->cmdfunc(mtd, NAND_CMD_RNDOUT,
+					mtd->writesize + aligned_pos, -1);
 		chip->read_buf(mtd, &chip->oob_poi[aligned_pos], aligned_len);
 	}
 
 	for (i = 0; i < eccfrag_len; i++)
-		chip->buffers->ecccode[i] = chip->oob_poi[eccpos[i + start_step * chip->ecc.bytes]];
+		chip->buffers->ecccode[i] = chip->oob_poi[eccpos[i + index]];
 
 	p = bufpoi + data_col_addr;
 	for (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size) {
 		int stat;
 
-		stat = chip->ecc.correct(mtd, p, &chip->buffers->ecccode[i], &chip->buffers->ecccalc[i]);
-		if (stat == -1)
+		stat = chip->ecc.correct(mtd, p,
+			&chip->buffers->ecccode[i], &chip->buffers->ecccalc[i]);
+		if (stat < 0)
 			mtd->ecc_stats.failed++;
 		else
 			mtd->ecc_stats.corrected += stat;
@@ -1174,7 +1402,7 @@ static int nand_read_page_syndrome(struc
 static uint8_t *nand_transfer_oob(struct nand_chip *chip, uint8_t *oob,
 				  struct mtd_oob_ops *ops, size_t len)
 {
-	switch(ops->mode) {
+	switch (ops->mode) {
 
 	case MTD_OOB_PLACE:
 	case MTD_OOB_RAW:
@@ -1186,7 +1414,7 @@ static uint8_t *nand_transfer_oob(struct
 		uint32_t boffs = 0, roffs = ops->ooboffs;
 		size_t bytes = 0;
 
-		for(; free->length && len; free++, len -= bytes) {
+		for (; free->length && len; free++, len -= bytes) {
 			/* Read request not from offset 0 ? */
 			if (unlikely(roffs)) {
 				if (roffs >= free->length) {
@@ -1232,6 +1460,9 @@ static int nand_do_read_ops(struct mtd_i
 	int ret = 0;
 	uint32_t readlen = ops->len;
 	uint32_t oobreadlen = ops->ooblen;
+	uint32_t max_oobsize = ops->mode == MTD_OOB_AUTO ?
+		mtd->oobavail : mtd->oobsize;
+
 	uint8_t *bufpoi, *oob, *buf;
 
 	stats = mtd->ecc_stats;
@@ -1247,7 +1478,7 @@ static int nand_do_read_ops(struct mtd_i
 	buf = ops->datbuf;
 	oob = ops->oobbuf;
 
-	while(1) {
+	while (1) {
 		bytes = min(mtd->writesize - col, readlen);
 		aligned = (bytes == mtd->writesize);
 
@@ -1265,7 +1496,8 @@ static int nand_do_read_ops(struct mtd_i
 				ret = chip->ecc.read_page_raw(mtd, chip,
 							      bufpoi, page);
 			else if (!aligned && NAND_SUBPAGE_READ(chip) && !oob)
-				ret = chip->ecc.read_subpage(mtd, chip, col, bytes, bufpoi);
+				ret = chip->ecc.read_subpage(mtd, chip,
+							col, bytes, bufpoi);
 			else
 				ret = chip->ecc.read_page(mtd, chip, bufpoi,
 							  page);
@@ -1274,7 +1506,8 @@ static int nand_do_read_ops(struct mtd_i
 
 			/* Transfer not aligned data */
 			if (!aligned) {
-				if (!NAND_SUBPAGE_READ(chip) && !oob)
+				if (!NAND_SUBPAGE_READ(chip) && !oob &&
+				    !(mtd->ecc_stats.failed - stats.failed))
 					chip->pagebuf = realpage;
 				memcpy(buf, chip->buffers->databuf + col, bytes);
 			}
@@ -1282,18 +1515,14 @@ static int nand_do_read_ops(struct mtd_i
 			buf += bytes;
 
 			if (unlikely(oob)) {
-				/* Raw mode does data:oob:data:oob */
-				if (ops->mode != MTD_OOB_RAW) {
-					int toread = min(oobreadlen,
-						chip->ecc.layout->oobavail);
-					if (toread) {
-						oob = nand_transfer_oob(chip,
-							oob, ops, toread);
-						oobreadlen -= toread;
-					}
-				} else
-					buf = nand_transfer_oob(chip,
-						buf, ops, mtd->oobsize);
+
+				int toread = min(oobreadlen, max_oobsize);
+
+				if (toread) {
+					oob = nand_transfer_oob(chip,
+						oob, ops, toread);
+					oobreadlen -= toread;
+				}
 			}
 
 			if (!(chip->options & NAND_NO_READRDY)) {
@@ -1353,7 +1582,7 @@ static int nand_do_read_ops(struct mtd_i
 }
 
 /**
- * nand_read - [MTD Interface] MTD compability function for nand_do_read_ecc
+ * nand_read - [MTD Interface] MTD compatibility function for nand_do_read_ecc
  * @mtd:	MTD device structure
  * @from:	offset to read from
  * @len:	number of bytes to read
@@ -1576,7 +1805,7 @@ static int nand_do_read_oob(struct mtd_i
 	realpage = (int)(from >> chip->page_shift);
 	page = realpage & chip->pagemask;
 
-	while(1) {
+	while (1) {
 		sndcmd = chip->ecc.read_oob(mtd, chip, page, sndcmd);
 
 		len = min(len, readlen);
@@ -1646,7 +1875,7 @@ static int nand_read_oob(struct mtd_info
 
 	nand_get_device(chip, mtd, FL_READING);
 
-	switch(ops->mode) {
+	switch (ops->mode) {
 	case MTD_OOB_PLACE:
 	case MTD_OOB_AUTO:
 	case MTD_OOB_RAW:
@@ -1661,7 +1890,7 @@ static int nand_read_oob(struct mtd_info
 	else
 		ret = nand_do_read_ops(mtd, from, ops);
 
- out:
+out:
 	nand_release_device(mtd);
 	return ret;
 }
@@ -1690,8 +1919,9 @@ static void nand_write_page_raw(struct m
  *
  * We need a special oob layout and handling even when ECC isn't checked.
  */
-static void nand_write_page_raw_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
-				const uint8_t *buf)
+static void nand_write_page_raw_syndrome(struct mtd_info *mtd,
+					struct nand_chip *chip,
+					const uint8_t *buf)
 {
 	int eccsize = chip->ecc.size;
 	int eccbytes = chip->ecc.bytes;
@@ -1878,14 +2108,13 @@ static int nand_write_page(struct mtd_in
  * nand_fill_oob - [Internal] Transfer client buffer to oob
  * @chip:	nand chip structure
  * @oob:	oob data buffer
+ * @len:	oob data write length
  * @ops:	oob ops structure
  */
-static uint8_t *nand_fill_oob(struct nand_chip *chip, uint8_t *oob,
-				  struct mtd_oob_ops *ops)
+static uint8_t *nand_fill_oob(struct nand_chip *chip, uint8_t *oob, size_t len,
+						struct mtd_oob_ops *ops)
 {
-	size_t len = ops->ooblen;
-
-	switch(ops->mode) {
+	switch (ops->mode) {
 
 	case MTD_OOB_PLACE:
 	case MTD_OOB_RAW:
@@ -1897,7 +2126,7 @@ static uint8_t *nand_fill_oob(struct nan
 		uint32_t boffs = 0, woffs = ops->ooboffs;
 		size_t bytes = 0;
 
-		for(; free->length && len; free++, len -= bytes) {
+		for (; free->length && len; free++, len -= bytes) {
 			/* Write request not from offset 0 ? */
 			if (unlikely(woffs)) {
 				if (woffs >= free->length) {
@@ -1923,7 +2152,7 @@ static uint8_t *nand_fill_oob(struct nan
 	return NULL;
 }
 
-#define NOTALIGNED(x)	(x & (chip->subpagesize - 1)) != 0
+#define NOTALIGNED(x)	((x & (chip->subpagesize - 1)) != 0)
 
 /**
  * nand_do_write_ops - [Internal] NAND write with ECC
@@ -1939,6 +2168,11 @@ static int nand_do_write_ops(struct mtd_
 	int chipnr, realpage, page, blockmask, column;
 	struct nand_chip *chip = mtd->priv;
 	uint32_t writelen = ops->len;
+
+	uint32_t oobwritelen = ops->ooblen;
+	uint32_t oobmaxlen = ops->mode == MTD_OOB_AUTO ?
+				mtd->oobavail : mtd->oobsize;
+
 	uint8_t *oob = ops->oobbuf;
 	uint8_t *buf = ops->datbuf;
 	int ret, subpage;
@@ -1980,7 +2214,11 @@ static int nand_do_write_ops(struct mtd_
 	if (likely(!oob))
 		memset(chip->oob_poi, 0xff, mtd->oobsize);
 
-	while(1) {
+	/* Don't allow multipage oob writes with offset */
+	if (oob && ops->ooboffs && (ops->ooboffs + ops->ooblen > oobmaxlen))
+		return -EINVAL;
+
+	while (1) {
 		int bytes = mtd->writesize;
 		int cached = writelen > bytes && page != blockmask;
 		uint8_t *wbuf = buf;
@@ -1995,8 +2233,11 @@ static int nand_do_write_ops(struct mtd_
 			wbuf = chip->buffers->databuf;
 		}
 
-		if (unlikely(oob))
-			oob = nand_fill_oob(chip, oob, ops);
+		if (unlikely(oob)) {
+			size_t len = min(oobwritelen, oobmaxlen);
+			oob = nand_fill_oob(chip, oob, len, ops);
+			oobwritelen -= len;
+		}
 
 		ret = chip->write_page(mtd, chip, wbuf, page, cached,
 				       (ops->mode == MTD_OOB_RAW));
@@ -2137,7 +2378,7 @@ static int nand_do_write_oob(struct mtd_
 		return -EINVAL;
 	}
 
-	/* Do not allow reads past end of device */
+	/* Do not allow write past end of device */
 	if (unlikely(to >= mtd->size ||
 		     ops->ooboffs + ops->ooblen >
 			((mtd->size >> chip->page_shift) -
@@ -2170,7 +2411,7 @@ static int nand_do_write_oob(struct mtd_
 		chip->pagebuf = -1;
 
 	memset(chip->oob_poi, 0xff, mtd->oobsize);
-	nand_fill_oob(chip, ops->oobbuf, ops);
+	nand_fill_oob(chip, ops->oobbuf, ops->ooblen, ops);
 	status = chip->ecc.write_oob(mtd, chip, page & chip->pagemask);
 	memset(chip->oob_poi, 0xff, mtd->oobsize);
 
@@ -2205,7 +2446,7 @@ static int nand_write_oob(struct mtd_inf
 
 	nand_get_device(chip, mtd, FL_WRITING);
 
-	switch(ops->mode) {
+	switch (ops->mode) {
 	case MTD_OOB_PLACE:
 	case MTD_OOB_AUTO:
 	case MTD_OOB_RAW:
@@ -2220,7 +2461,7 @@ static int nand_write_oob(struct mtd_inf
 	else
 		ret = nand_do_write_ops(mtd, to, ops);
 
- out:
+out:
 	nand_release_device(mtd);
 	return ret;
 }
@@ -2285,7 +2526,7 @@ int nand_erase_nand(struct mtd_info *mtd
 {
 	int page, status, pages_per_block, ret, chipnr;
 	struct nand_chip *chip = mtd->priv;
-	loff_t rewrite_bbt[NAND_MAX_CHIPS]={0};
+	loff_t rewrite_bbt[NAND_MAX_CHIPS] = {0};
 	unsigned int bbt_masked_page = 0xffffffff;
 	loff_t len;
 
@@ -2293,25 +2534,8 @@ int nand_erase_nand(struct mtd_info *mtd
 				__func__, (unsigned long long)instr->addr,
 				(unsigned long long)instr->len);
 
-	/* Start address must align on block boundary */
-	if (instr->addr & ((1 << chip->phys_erase_shift) - 1)) {
-		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Unaligned address\n", __func__);
-		return -EINVAL;
-	}
-
-	/* Length must align on block boundary */
-	if (instr->len & ((1 << chip->phys_erase_shift) - 1)) {
-		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Length not block aligned\n",
-					__func__);
-		return -EINVAL;
-	}
-
-	/* Do not allow erase past end of device */
-	if ((instr->len + instr->addr) > mtd->size) {
-		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Erase past end of device\n",
-					__func__);
+	if (check_offs_len(mtd, instr->addr, instr->len))
 		return -EINVAL;
-	}
 
 	instr->fail_addr = MTD_FAIL_ADDR_UNKNOWN;
 
@@ -2423,7 +2647,7 @@ int nand_erase_nand(struct mtd_info *mtd
 	}
 	instr->state = MTD_ERASE_DONE;
 
- erase_exit:
+erase_exit:
 
 	ret = instr->state == MTD_ERASE_DONE ? 0 : -EIO;
 
@@ -2497,7 +2721,8 @@ static int nand_block_markbad(struct mtd
 	struct nand_chip *chip = mtd->priv;
 	int ret;
 
-	if ((ret = nand_block_isbad(mtd, ofs))) {
+	ret = nand_block_isbad(mtd, ofs);
+	if (ret) {
 		/* If it was bad already, return success and do nothing. */
 		if (ret > 0)
 			return 0;
@@ -2533,65 +2758,6 @@ static void nand_resume(struct mtd_info 
 		       "in suspended state\n", __func__);
 }
 
-/*************************************************************************************************/
-#if 0
-/*
- * This function simply calls nand_read_ecc with oob buffer and oobsel = NULL
- * after mapping over any bad blocks when read only.
- *
- * @mtd:        MTD device structure
- * @from:       offset to read from
- * @len:        number of bytes to read
- * @retlen:     pointer to variable to store the number of read bytes
- * @buf:        the databuffer to put data
-*/
-static int nand_block_read (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
-{
-   int ret;
-
-#ifdef CONFIG_MTD_SKIP_BB_FOR_SQUASHFS
-   /* if partition writable (and not squashfs) just read with ECC */
-   if ((mtd->flags & MTD_SKIP_BB_FOR_SQUASHFS) != MTD_SKIP_BB_FOR_SQUASHFS)
-#endif
-      if ((mtd->flags & MTD_WRITEABLE) == MTD_WRITEABLE) {
-         ret = nand_read (mtd, from, len, retlen, buf);
-         return (ret == -EUCLEAN) ? 0 : ret;
-      }
-
-   /* skip bad blocks (for squashfs irrespectable of ro/rw */
-   from = map_over_bad_blocks(mtd, from);
-
-   /* exchausted memory; simulated read of 0xff */
-   if (from == (loff_t)-1) {
-      memset(buf, 0xff, len);
-      *retlen = len;
-      return 0;
-   }
-
-   /* the length must always be less than the erase size */
-   BUG_ON(len > mtd->erasesize);
-
-
-   /* do the read by just skipping over any bad blocks as they weren't there */
-   ret = nand_read (mtd, from, len, retlen, buf);
-   return (ret == -EUCLEAN) ? 0 : ret;
-}
-
-/*
- * This function simply calls nand_write_ecc with oob buffer and oobsel = NULL
- *
- * @mtd:        MTD device structure
- * @to:         offset to write to
- * @len:        number of bytes to write
- * @retlen:     pointer to variable to store the number of written bytes
- * @buf:        the data to write
-*/
-static int nand_block_write (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * buf)
-{
-   BUG_ON((mtd->flags & MTD_WRITEABLE) == MTD_WRITEABLE);  /* must be writable to work */
-   return (nand_write (mtd, to, len, retlen, buf));
-}
-#endif
 /*
  * Set default functions
  */
@@ -2637,15 +2803,119 @@ static void nand_set_defaults(struct nan
 }
 
 /*
+ * sanitize ONFI strings so we can safely print them
+ */
+static void sanitize_string(uint8_t *s, size_t len)
+{
+	ssize_t i;
+
+	/* null terminate */
+	s[len - 1] = 0;
+
+	/* remove non printable chars */
+	for (i = 0; i < len - 1; i++) {
+		if (s[i] < ' ' || s[i] > 127)
+			s[i] = '?';
+	}
+
+	/* remove trailing spaces */
+	strim(s);
+}
+
+static u16 onfi_crc16(u16 crc, u8 const *p, size_t len)
+{
+	int i;
+	while (len--) {
+		crc ^= *p++ << 8;
+		for (i = 0; i < 8; i++)
+			crc = (crc << 1) ^ ((crc & 0x8000) ? 0x8005 : 0);
+	}
+
+	return crc;
+}
+
+/*
+ * Check if the NAND chip is ONFI compliant, returns 1 if it is, 0 otherwise
+ */
+static int nand_flash_detect_onfi(struct mtd_info *mtd, struct nand_chip *chip,
+					int busw)
+{
+	struct nand_onfi_params *p = &chip->onfi_params;
+	int i;
+	int val;
+
+	/* try ONFI for unknow chip or LP */
+	chip->cmdfunc(mtd, NAND_CMD_READID, 0x20, -1);
+	if (chip->read_byte(mtd) != 'O' || chip->read_byte(mtd) != 'N' ||
+		chip->read_byte(mtd) != 'F' || chip->read_byte(mtd) != 'I')
+		return 0;
+
+	printk(KERN_INFO "ONFI flash detected\n");
+	chip->cmdfunc(mtd, NAND_CMD_PARAM, 0, -1);
+	for (i = 0; i < 3; i++) {
+		chip->read_buf(mtd, (uint8_t *)p, sizeof(*p));
+		if (onfi_crc16(ONFI_CRC_BASE, (uint8_t *)p, 254) ==
+				le16_to_cpu(p->crc)) {
+			printk(KERN_INFO "ONFI param page %d valid\n", i);
+			break;
+		}
+	}
+
+	if (i == 3)
+		return 0;
+
+	/* check version */
+	val = le16_to_cpu(p->revision);
+	if (val & (1 << 5))
+		chip->onfi_version = 23;
+	else if (val & (1 << 4))
+		chip->onfi_version = 22;
+	else if (val & (1 << 3))
+		chip->onfi_version = 21;
+	else if (val & (1 << 2))
+		chip->onfi_version = 20;
+	else if (val & (1 << 1))
+		chip->onfi_version = 10;
+	else
+		chip->onfi_version = 0;
+
+	if (!chip->onfi_version) {
+		printk(KERN_INFO "%s: unsupported ONFI version: %d\n",
+								__func__, val);
+		return 0;
+	}
+
+	sanitize_string(p->manufacturer, sizeof(p->manufacturer));
+	sanitize_string(p->model, sizeof(p->model));
+	if (!mtd->name)
+		mtd->name = p->model;
+	mtd->writesize = le32_to_cpu(p->byte_per_page);
+	mtd->erasesize = le32_to_cpu(p->pages_per_block) * mtd->writesize;
+	mtd->oobsize = le16_to_cpu(p->spare_bytes_per_page);
+	chip->chipsize = (uint64_t)le32_to_cpu(p->blocks_per_lun) * mtd->erasesize;
+	busw = 0;
+	if (le16_to_cpu(p->features) & 1)
+		busw = NAND_BUSWIDTH_16;
+
+	chip->options &= ~NAND_CHIPOPTIONS_MSK;
+	chip->options |= (NAND_NO_READRDY |
+			NAND_NO_AUTOINCR) & NAND_CHIPOPTIONS_MSK;
+
+	return 1;
+}
+
+/*
  * Get the flash and manufacturer id and lookup if the type is supported
  */
 static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 						  struct nand_chip *chip,
-						  int busw, int *maf_id)
+						  int busw,
+						  int *maf_id, int *dev_id,
+						  struct nand_flash_dev *type)
 {
-	struct nand_flash_dev *type = NULL;
-	int i, dev_id, maf_idx;
-	int tmp_id, tmp_manf;
+	int i, maf_idx;
+	u8 id_data[8];
+	int ret;
 
 	/* Select the device */
 	chip->select_chip(mtd, 0);
@@ -2661,7 +2931,7 @@ static struct nand_flash_dev *nand_get_f
 
 	/* Read manufacturer and device IDs */
 	*maf_id = chip->read_byte(mtd);
-	dev_id = chip->read_byte(mtd);
+	*dev_id = chip->read_byte(mtd);
 
 	/* Try again to make sure, as some systems the bus-hold or other
 	 * interface concerns can cause random data which looks like a
@@ -2671,27 +2941,39 @@ static struct nand_flash_dev *nand_get_f
 
 	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
 
-	/* Read manufacturer and device IDs */
-
-	tmp_manf = chip->read_byte(mtd);
-	tmp_id = chip->read_byte(mtd);
+	for (i = 0; i < 2; i++)
+		id_data[i] = chip->read_byte(mtd);
 
-	if (tmp_manf != *maf_id || tmp_id != dev_id) {
+	if (id_data[0] != *maf_id || id_data[1] != *dev_id) {
 		printk(KERN_INFO "%s: second ID read did not match "
 		       "%02x,%02x against %02x,%02x\n", __func__,
-		       *maf_id, dev_id, tmp_manf, tmp_id);
+		       *maf_id, *dev_id, id_data[0], id_data[1]);
 		return ERR_PTR(-ENODEV);
 	}
 
-	/* Lookup the flash id */
-	for (i = 0; nand_flash_ids[i].name != NULL; i++) {
-		if (dev_id == nand_flash_ids[i].id) {
-			type =  &nand_flash_ids[i];
+	if (!type)
+		type = nand_flash_ids;
+
+	for (; type->name != NULL; type++)
+		if (*dev_id == type->id)
 			break;
-		}
+
+	chip->onfi_version = 0;
+	if (!type->name || !type->pagesize) {
+		/* Check is chip is ONFI compliant */
+		ret = nand_flash_detect_onfi(mtd, chip, busw);
+		if (ret)
+			goto ident_done;
 	}
 
-	if (!type)
+	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
+
+	/* Read entire ID string */
+
+	for (i = 0; i < 8; i++)
+		id_data[i] = chip->read_byte(mtd);
+
+	if (!type->name)
 		return ERR_PTR(-ENODEV);
 
 	if (!mtd->name)
@@ -2699,25 +2981,65 @@ static struct nand_flash_dev *nand_get_f
 
 	chip->chipsize = (uint64_t)type->chipsize << 20;
 
-	/* Newer devices have all the information in additional id bytes */
-	if (!type->pagesize) {
+	if (!type->pagesize && chip->init_size) {
+		/* set the pagesize, oobsize, erasesize by the driver*/
+		busw = chip->init_size(mtd, chip, id_data);
+	} else if (!type->pagesize) {
 		int extid;
 		/* The 3rd id byte holds MLC / multichip data */
-		chip->cellinfo = chip->read_byte(mtd);
+		chip->cellinfo = id_data[2];
 		/* The 4th id byte is the important one */
-		extid = chip->read_byte(mtd);
-		/* Calc pagesize */
-		mtd->writesize = 1024 << (extid & 0x3);
-		extid >>= 2;
-		/* Calc oobsize */
-		mtd->oobsize = (8 << (extid & 0x01)) * (mtd->writesize >> 9);
-		extid >>= 2;
-		/* Calc blocksize. Blocksize is multiples of 64KiB */
-		mtd->erasesize = (64 * 1024) << (extid & 0x03);
-		extid >>= 2;
-		/* Get buswidth information */
-		busw = (extid & 0x01) ? NAND_BUSWIDTH_16 : 0;
+		extid = id_data[3];
 
+		/*
+		 * Field definitions are in the following datasheets:
+		 * Old style (4,5 byte ID): Samsung K9GAG08U0M (p.32)
+		 * New style   (6 byte ID): Samsung K9GBG08U0M (p.40)
+		 *
+		 * Check for wraparound + Samsung ID + nonzero 6th byte
+		 * to decide what to do.
+		 */
+		if (id_data[0] == id_data[6] && id_data[1] == id_data[7] &&
+				id_data[0] == NAND_MFR_SAMSUNG &&
+				(chip->cellinfo & NAND_CI_CELLTYPE_MSK) &&
+				id_data[5] != 0x00) {
+			/* Calc pagesize */
+			mtd->writesize = 2048 << (extid & 0x03);
+			extid >>= 2;
+			/* Calc oobsize */
+			switch (extid & 0x03) {
+			case 1:
+				mtd->oobsize = 128;
+				break;
+			case 2:
+				mtd->oobsize = 218;
+				break;
+			case 3:
+				mtd->oobsize = 400;
+				break;
+			default:
+				mtd->oobsize = 436;
+				break;
+			}
+			extid >>= 2;
+			/* Calc blocksize */
+			mtd->erasesize = (128 * 1024) <<
+				(((extid >> 1) & 0x04) | (extid & 0x03));
+			busw = 0;
+		} else {
+			/* Calc pagesize */
+			mtd->writesize = 1024 << (extid & 0x03);
+			extid >>= 2;
+			/* Calc oobsize */
+			mtd->oobsize = (8 << (extid & 0x01)) *
+				(mtd->writesize >> 9);
+			extid >>= 2;
+			/* Calc blocksize. Blocksize is multiples of 64KiB */
+			mtd->erasesize = (64 * 1024) << (extid & 0x03);
+			extid >>= 2;
+			/* Get buswidth information */
+			busw = (extid & 0x01) ? NAND_BUSWIDTH_16 : 0;
+		}
 	} else {
 		/*
 		 * Old devices have chip data hardcoded in the device id table
@@ -2726,7 +3048,35 @@ static struct nand_flash_dev *nand_get_f
 		mtd->writesize = type->pagesize;
 		mtd->oobsize = mtd->writesize / 32;
 		busw = type->options & NAND_BUSWIDTH_16;
+
+		/*
+		 * Check for Spansion/AMD ID + repeating 5th, 6th byte since
+		 * some Spansion chips have erasesize that conflicts with size
+		 * listed in nand_ids table
+		 * Data sheet (5 byte ID): Spansion S30ML-P ORNAND (p.39)
+		 */
+		if (*maf_id == NAND_MFR_AMD && id_data[4] != 0x00 &&
+				id_data[5] == 0x00 && id_data[6] == 0x00 &&
+				id_data[7] == 0x00 && mtd->writesize == 512) {
+			mtd->erasesize = 128 * 1024;
+			mtd->erasesize <<= ((id_data[3] & 0x03) << 1);
+		}
 	}
+	/* Get chip options, preserve non chip based options */
+	chip->options &= ~NAND_CHIPOPTIONS_MSK;
+	chip->options |= type->options & NAND_CHIPOPTIONS_MSK;
+
+	/* Check if chip is a not a samsung device. Do not clear the
+	 * options for chips which are not having an extended id.
+	 */
+	if (*maf_id != NAND_MFR_SAMSUNG && !type->pagesize)
+		chip->options &= ~NAND_SAMSUNG_LP_OPTIONS;
+ident_done:
+
+	/*
+	 * Set chip as a default. Board drivers can override it, if necessary
+	 */
+	chip->options |= NAND_NO_AUTOINCR;
 
 	/* Try to identify manufacturer */
 	for (maf_idx = 0; nand_manuf_ids[maf_idx].id != 0x0; maf_idx++) {
@@ -2741,7 +3091,7 @@ static struct nand_flash_dev *nand_get_f
 	if (busw != (chip->options & NAND_BUSWIDTH_16)) {
 		printk(KERN_INFO "NAND device: Manufacturer ID:"
 		       " 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id,
-		       dev_id, nand_manuf_ids[maf_idx].name, mtd->name);
+		       *dev_id, nand_manuf_ids[maf_idx].name, mtd->name);
 		printk(KERN_WARNING "NAND bus width %d instead %d bit\n",
 		       (chip->options & NAND_BUSWIDTH_16) ? 16 : 8,
 		       busw ? 16 : 8);
@@ -2757,29 +3107,46 @@ static struct nand_flash_dev *nand_get_f
 		ffs(mtd->erasesize) - 1;
 	if (chip->chipsize & 0xffffffff)
 		chip->chip_shift = ffs((unsigned)chip->chipsize) - 1;
-	else
-		chip->chip_shift = ffs((unsigned)(chip->chipsize >> 32)) + 32 - 1;
+	else {
+		chip->chip_shift = ffs((unsigned)(chip->chipsize >> 32));
+		chip->chip_shift += 32 - 1;
+	}
 
 	/* Set the bad block position */
-	chip->badblockpos = mtd->writesize > 512 ?
-		NAND_LARGE_BADBLOCK_POS : NAND_SMALL_BADBLOCK_POS;
-
-	/* Get chip options, preserve non chip based options */
-	chip->options &= ~NAND_CHIPOPTIONS_MSK;
-	chip->options |= type->options & NAND_CHIPOPTIONS_MSK;
+	if (mtd->writesize > 512 || (busw & NAND_BUSWIDTH_16))
+		chip->badblockpos = NAND_LARGE_BADBLOCK_POS;
+	else
+		chip->badblockpos = NAND_SMALL_BADBLOCK_POS;
 
 	/*
-	 * Set chip as a default. Board drivers can override it, if necessary
+	 * Bad block marker is stored in the last page of each block
+	 * on Samsung and Hynix MLC devices; stored in first two pages
+	 * of each block on Micron devices with 2KiB pages and on
+	 * SLC Samsung, Hynix, Toshiba and AMD/Spansion. All others scan
+	 * only the first page.
 	 */
-	chip->options |= NAND_NO_AUTOINCR;
+	if ((chip->cellinfo & NAND_CI_CELLTYPE_MSK) &&
+			(*maf_id == NAND_MFR_SAMSUNG ||
+			 *maf_id == NAND_MFR_HYNIX))
+		chip->options |= NAND_BBT_SCANLASTPAGE;
+	else if ((!(chip->cellinfo & NAND_CI_CELLTYPE_MSK) &&
+				(*maf_id == NAND_MFR_SAMSUNG ||
+				 *maf_id == NAND_MFR_HYNIX ||
+				 *maf_id == NAND_MFR_TOSHIBA ||
+				 *maf_id == NAND_MFR_AMD)) ||
+			(mtd->writesize == 2048 &&
+			 *maf_id == NAND_MFR_MICRON))
+		chip->options |= NAND_BBT_SCAN2NDPAGE;
 
-	/* Check if chip is a not a samsung device. Do not clear the
-	 * options for chips which are not having an extended id.
+	/*
+	 * Numonyx/ST 2K pages, x8 bus use BOTH byte 1 and 6
 	 */
-	if ((*maf_id != NAND_MFR_SAMSUNG) && (*maf_id != NAND_MFR_STMICRO) && 
-    	(*maf_id != NAND_MFR_HYNIX) && (*maf_id != NAND_MFR_TOSHIBA) && 
-    	(!type->pagesize))
-		chip->options &= ~NAND_SAMSUNG_LP_OPTIONS;
+	if (!(busw & NAND_BUSWIDTH_16) &&
+			*maf_id == NAND_MFR_STMICRO &&
+			mtd->writesize == 2048) {
+		chip->options |= NAND_BBT_SCANBYTE1AND6;
+		chip->badblockpos = 0;
+	}
 
 	/* Check for AND chips with 4 page planes */
 	if (chip->options & NAND_4PAGE_ARRAY)
@@ -2791,9 +3158,11 @@ static struct nand_flash_dev *nand_get_f
 	if (mtd->writesize > 512 && chip->cmdfunc == nand_command)
 		chip->cmdfunc = nand_command_lp;
 
+	/* TODO onfi flash name */
 	printk(KERN_INFO "NAND device: Manufacturer ID:"
-	       " 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id, dev_id,
-	       nand_manuf_ids[maf_idx].name, type->name);
+		" 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id, *dev_id,
+		nand_manuf_ids[maf_idx].name,
+		chip->onfi_version ? chip->onfi_params.model : type->name);
 
 	return type;
 }
@@ -2802,15 +3171,17 @@ static struct nand_flash_dev *nand_get_f
  * nand_scan_ident - [NAND Interface] Scan for the NAND device
  * @mtd:	     MTD device structure
  * @maxchips:	     Number of chips to scan for
+ * @table:	     Alternative NAND ID table
  *
  * This is the first phase of the normal nand_scan() function. It
  * reads the flash ID and sets up MTD fields accordingly.
  *
  * The mtd->owner field must be set to the module of the caller.
  */
-int nand_scan_ident(struct mtd_info *mtd, int maxchips)
+int nand_scan_ident(struct mtd_info *mtd, int maxchips,
+		    struct nand_flash_dev *table)
 {
-	int i, busw, nand_maf_id;
+	int i, busw, nand_maf_id, nand_dev_id;
 	struct nand_chip *chip = mtd->priv;
 	struct nand_flash_dev *type;
 
@@ -2820,7 +3191,8 @@ int nand_scan_ident(struct mtd_info *mtd
 	nand_set_defaults(chip, busw);
 
 	/* Read the flash type */
-	type = nand_get_flash_type(mtd, chip, busw, &nand_maf_id);
+	type = nand_get_flash_type(mtd, chip, busw,
+				&nand_maf_id, &nand_dev_id, table);
 
 	if (IS_ERR(type)) {
 		if (!(chip->options & NAND_SCAN_SILENT_NODEV))
@@ -2838,7 +3210,7 @@ int nand_scan_ident(struct mtd_info *mtd
 		chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
 		/* Read manufacturer and device IDs */
 		if (nand_maf_id != chip->read_byte(mtd) ||
-		    type->id != chip->read_byte(mtd))
+		    nand_dev_id != chip->read_byte(mtd))
 			break;
 	}
 	if (i > 1)
@@ -3014,7 +3386,7 @@ int nand_scan_tail(struct mtd_info *mtd)
 	 * mode
 	 */
 	chip->ecc.steps = mtd->writesize / chip->ecc.size;
-	if(chip->ecc.steps * chip->ecc.size != mtd->writesize) {
+	if (chip->ecc.steps * chip->ecc.size != mtd->writesize) {
 		printk(KERN_WARNING "Invalid ecc parameters\n");
 		BUG();
 	}
@@ -3026,7 +3398,7 @@ int nand_scan_tail(struct mtd_info *mtd)
 	 */
 	if (!(chip->options & NAND_NO_SUBPAGE_WRITE) &&
 	    !(chip->cellinfo & NAND_CI_CELLTYPE_MSK)) {
-		switch(chip->ecc.steps) {
+		switch (chip->ecc.steps) {
 		case 2:
 			mtd->subpage_sft = 1;
 			break;
@@ -3050,7 +3422,8 @@ int nand_scan_tail(struct mtd_info *mtd)
 
 	/* Fill in remaining MTD driver data */
 	mtd->type = MTD_NANDFLASH;
-	mtd->flags = MTD_CAP_NANDFLASH;
+	mtd->flags = (chip->options & NAND_ROM) ? MTD_CAP_ROM :
+						MTD_CAP_NANDFLASH;
 	mtd->erase = nand_erase;
 	mtd->point = NULL;
 	mtd->unpoint = NULL;
@@ -3066,11 +3439,7 @@ int nand_scan_tail(struct mtd_info *mtd)
 	mtd->resume = nand_resume;
 	mtd->block_isbad = nand_block_isbad;
 	mtd->block_markbad = nand_block_markbad;
-
-#if 0
-   mtd->block_read = nand_block_read;
-   mtd->block_write = nand_block_write;
-#endif
+	mtd->writebufsize = mtd->writesize;
 
 	/* propagate ecc.layout to mtd_info */
 	mtd->ecclayout = chip->ecc.layout;
@@ -3084,8 +3453,8 @@ int nand_scan_tail(struct mtd_info *mtd)
 }
 
 /* is_module_text_address() isn't exported, and it's mostly a pointless
-   test if this is a module _anyway_ -- they'd have to try _really_ hard
-   to call us from in-kernel code if the core NAND support is modular. */
+ * test if this is a module _anyway_ -- they'd have to try _really_ hard
+ * to call us from in-kernel code if the core NAND support is modular. */
 #ifdef MODULE
 #define caller_is_module() (1)
 #else
@@ -3116,7 +3485,7 @@ int nand_scan(struct mtd_info *mtd, int 
 		BUG();
 	}
 
-	ret = nand_scan_ident(mtd, maxchips);
+	ret = nand_scan_ident(mtd, maxchips, NULL);
 	if (!ret)
 		ret = nand_scan_tail(mtd);
 	return ret;
@@ -3141,6 +3510,11 @@ void nand_release(struct mtd_info *mtd)
 	kfree(chip->bbt);
 	if (!(chip->options & NAND_OWN_BUFFERS))
 		kfree(chip->buffers);
+
+	/* Free bad block descriptor memory */
+	if (chip->badblock_pattern && chip->badblock_pattern->options
+			& NAND_BBT_DYNAMICSTRUCT)
+		kfree(chip->badblock_pattern);
 }
 
 EXPORT_SYMBOL_GPL(nand_scan);
@@ -3163,5 +3537,6 @@ module_init(nand_base_init);
 module_exit(nand_base_exit);
 
 MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Steven J. Hill <sjhill@realitydiluted.com>, Thomas Gleixner <tglx@linutronix.de>");
+MODULE_AUTHOR("Steven J. Hill <sjhill@realitydiluted.com>");
+MODULE_AUTHOR("Thomas Gleixner <tglx@linutronix.de>");
 MODULE_DESCRIPTION("Generic NAND flash driver code");
diff -Naurp linux-2.6.34.org/drivers/mtd/nand/nand_bbt.c linux-2.6.34/drivers/mtd/nand/nand_bbt.c
--- linux-2.6.34.org/drivers/mtd/nand/nand_bbt.c	2011-04-06 19:08:21.000000000 -0500
+++ linux-2.6.34/drivers/mtd/nand/nand_bbt.c	2011-04-14 17:12:40.000000000 -0500
@@ -13,28 +13,37 @@
  * Description:
  *
  * When nand_scan_bbt is called, then it tries to find the bad block table
- * depending on the options in the bbt descriptor(s). If a bbt is found
- * then the contents are read and the memory based bbt is created. If a
- * mirrored bbt is selected then the mirror is searched too and the
- * versions are compared. If the mirror has a greater version number
- * than the mirror bbt is used to build the memory based bbt.
+ * depending on the options in the BBT descriptor(s). If no flash based BBT
+ * (NAND_USE_FLASH_BBT) is specified then the device is scanned for factory
+ * marked good / bad blocks. This information is used to create a memory BBT.
+ * Once a new bad block is discovered then the "factory" information is updated
+ * on the device.
+ * If a flash based BBT is specified then the function first tries to find the
+ * BBT on flash. If a BBT is found then the contents are read and the memory
+ * based BBT is created. If a mirrored BBT is selected then the mirror is
+ * searched too and the versions are compared. If the mirror has a greater
+ * version number than the mirror BBT is used to build the memory based BBT.
  * If the tables are not versioned, then we "or" the bad block information.
- * If one of the bbt's is out of date or does not exist it is (re)created.
- * If no bbt exists at all then the device is scanned for factory marked
+ * If one of the BBTs is out of date or does not exist it is (re)created.
+ * If no BBT exists at all then the device is scanned for factory marked
  * good / bad blocks and the bad block tables are created.
  *
- * For manufacturer created bbts like the one found on M-SYS DOC devices
- * the bbt is searched and read but never created
+ * For manufacturer created BBTs like the one found on M-SYS DOC devices
+ * the BBT is searched and read but never created
  *
- * The autogenerated bad block table is located in the last good blocks
+ * The auto generated bad block table is located in the last good blocks
  * of the device. The table is mirrored, so it can be updated eventually.
- * The table is marked in the oob area with an ident pattern and a version
- * number which indicates which of both tables is more up to date.
+ * The table is marked in the OOB area with an ident pattern and a version
+ * number which indicates which of both tables is more up to date. If the NAND
+ * controller needs the complete OOB area for the ECC information then the
+ * option NAND_USE_FLASH_BBT_NO_OOB should be used: it moves the ident pattern
+ * and the version byte into the data area and the OOB area will remain
+ * untouched.
  *
  * The table uses 2 bits per block
- * 11b: 	block is good
- * 00b: 	block is factory marked bad
- * 01b, 10b: 	block is marked bad due to wear
+ * 11b:		block is good
+ * 00b:		block is factory marked bad
+ * 01b, 10b:	block is marked bad due to wear
  *
  * The memory bad block table uses the following scheme:
  * 00b:		block is good
@@ -60,6 +69,16 @@
 #include <linux/delay.h>
 #include <linux/vmalloc.h>
 
+static int check_pattern_no_oob(uint8_t *buf, struct nand_bbt_descr *td)
+{
+	int ret;
+
+	ret = memcmp(buf, td->pattern, td->len);
+	if (!ret)
+		return ret;
+	return -1;
+}
+
 /**
  * check_pattern - [GENERIC] check if a pattern is in the buffer
  * @buf:	the buffer to search
@@ -78,6 +97,9 @@ static int check_pattern(uint8_t *buf, i
 	int i, end = 0;
 	uint8_t *p = buf;
 
+	if (td->options & NAND_BBT_NO_OOB)
+		return check_pattern_no_oob(buf, td);
+
 	end = paglen + td->offs;
 	if (td->options & NAND_BBT_SCANEMPTY) {
 		for (i = 0; i < end; i++) {
@@ -93,6 +115,28 @@ static int check_pattern(uint8_t *buf, i
 			return -1;
 	}
 
+	/* Check both positions 1 and 6 for pattern? */
+	if (td->options & NAND_BBT_SCANBYTE1AND6) {
+		if (td->options & NAND_BBT_SCANEMPTY) {
+			p += td->len;
+			end += NAND_SMALL_BADBLOCK_POS - td->offs;
+			/* Check region between positions 1 and 6 */
+			for (i = 0; i < NAND_SMALL_BADBLOCK_POS - td->offs - td->len;
+					i++) {
+				if (*p++ != 0xff)
+					return -1;
+			}
+		}
+		else {
+			p += NAND_SMALL_BADBLOCK_POS - td->offs;
+		}
+		/* Compare the pattern */
+		for (i = 0; i < td->len; i++) {
+			if (p[i] != td->pattern[i])
+				return -1;
+		}
+	}
+
 	if (td->options & NAND_BBT_SCANEMPTY) {
 		p += td->len;
 		end += td->len;
@@ -124,36 +168,74 @@ static int check_short_pattern(uint8_t *
 		if (p[td->offs + i] != td->pattern[i])
 			return -1;
 	}
+	/* Need to check location 1 AND 6? */
+	if (td->options & NAND_BBT_SCANBYTE1AND6) {
+		for (i = 0; i < td->len; i++) {
+			if (p[NAND_SMALL_BADBLOCK_POS + i] != td->pattern[i])
+				return -1;
+		}
+	}
 	return 0;
 }
 
 /**
+ * add_marker_len - compute the length of the marker in data area
+ * @td:		BBT descriptor used for computation
+ *
+ * The length will be 0 if the markeris located in OOB area.
+ */
+static u32 add_marker_len(struct nand_bbt_descr *td)
+{
+	u32 len;
+
+	if (!(td->options & NAND_BBT_NO_OOB))
+		return 0;
+
+	len = td->len;
+	if (td->options & NAND_BBT_VERSION)
+		len++;
+	return len;
+}
+
+/**
  * read_bbt - [GENERIC] Read the bad block table starting from page
  * @mtd:	MTD device structure
  * @buf:	temporary buffer
  * @page:	the starting page
  * @num:	the number of bbt descriptors to read
- * @bits:	number of bits per block
+ * @td:		the bbt describtion table
  * @offs:	offset in the memory table
- * @reserved_block_code:	Pattern to identify reserved blocks
  *
  * Read the bad block table starting from page.
  *
  */
 static int read_bbt(struct mtd_info *mtd, uint8_t *buf, int page, int num,
-		    int bits, int offs, int reserved_block_code)
+		struct nand_bbt_descr *td, int offs)
 {
 	int res, i, j, act = 0;
 	struct nand_chip *this = mtd->priv;
 	size_t retlen, len, totlen;
 	loff_t from;
+	int bits = td->options & NAND_BBT_NRBITS_MSK;
 	uint8_t msk = (uint8_t) ((1 << bits) - 1);
+	u32 marker_len;
+	int reserved_block_code = td->reserved_block_code;
 
 	totlen = (num * bits) >> 3;
+	marker_len = add_marker_len(td);
 	from = ((loff_t) page) << this->page_shift;
 
 	while (totlen) {
 		len = min(totlen, (size_t) (1 << this->bbt_erase_shift));
+		if (marker_len) {
+			/*
+			 * In case the BBT marker is not in the OOB area it
+			 * will be just in the first page.
+			 */
+			len -= marker_len;
+			from += marker_len;
+			marker_len = 0;
+		}
 		res = mtd->read(mtd, from, len, &retlen, buf);
 		if (res < 0) {
 			if (retlen != len) {
@@ -210,20 +292,21 @@ static int read_abs_bbt(struct mtd_info 
 {
 	struct nand_chip *this = mtd->priv;
 	int res = 0, i;
-	int bits;
 
-	bits = td->options & NAND_BBT_NRBITS_MSK;
 	if (td->options & NAND_BBT_PERCHIP) {
 		int offs = 0;
 		for (i = 0; i < this->numchips; i++) {
 			if (chip == -1 || chip == i)
-				res = read_bbt (mtd, buf, td->pages[i], this->chipsize >> this->bbt_erase_shift, bits, offs, td->reserved_block_code);
+				res = read_bbt(mtd, buf, td->pages[i],
+					this->chipsize >> this->bbt_erase_shift,
+					td, offs);
 			if (res)
 				return res;
 			offs += this->chipsize >> (this->bbt_erase_shift + 2);
 		}
 	} else {
-		res = read_bbt (mtd, buf, td->pages[0], mtd->size >> this->bbt_erase_shift, bits, 0, td->reserved_block_code);
+		res = read_bbt(mtd, buf, td->pages[0],
+				mtd->size >> this->bbt_erase_shift, td, 0);
 		if (res)
 			return res;
 	}
@@ -231,21 +314,64 @@ static int read_abs_bbt(struct mtd_info 
 }
 
 /*
+ * BBT marker is in the first page, no OOB.
+ */
+static int scan_read_raw_data(struct mtd_info *mtd, uint8_t *buf, loff_t offs,
+			 struct nand_bbt_descr *td)
+{
+	size_t retlen;
+	size_t len;
+
+	len = td->len;
+	if (td->options & NAND_BBT_VERSION)
+		len++;
+
+	return mtd->read(mtd, offs, len, &retlen, buf);
+}
+
+/*
  * Scan read raw data from flash
  */
-static int scan_read_raw(struct mtd_info *mtd, uint8_t *buf, loff_t offs,
+static int scan_read_raw_oob(struct mtd_info *mtd, uint8_t *buf, loff_t offs,
 			 size_t len)
 {
 	struct mtd_oob_ops ops;
+	int res;
 
 	ops.mode = MTD_OOB_RAW;
 	ops.ooboffs = 0;
 	ops.ooblen = mtd->oobsize;
-	ops.oobbuf = buf;
-	ops.datbuf = buf;
-	ops.len = len;
 
-	return mtd->read_oob(mtd, offs, &ops);
+
+	while (len > 0) {
+		if (len <= mtd->writesize) {
+			ops.oobbuf = buf + len;
+			ops.datbuf = buf;
+			ops.len = len;
+			return mtd->read_oob(mtd, offs, &ops);
+		} else {
+			ops.oobbuf = buf + mtd->writesize;
+			ops.datbuf = buf;
+			ops.len = mtd->writesize;
+			res = mtd->read_oob(mtd, offs, &ops);
+
+			if (res)
+				return res;
+		}
+
+		buf += mtd->oobsize + mtd->writesize;
+		len -= mtd->writesize;
+	}
+	return 0;
+}
+
+static int scan_read_raw(struct mtd_info *mtd, uint8_t *buf, loff_t offs,
+			 size_t len, struct nand_bbt_descr *td)
+{
+	if (td->options & NAND_BBT_NO_OOB)
+		return scan_read_raw_data(mtd, buf, offs, td);
+	else
+		return scan_read_raw_oob(mtd, buf, offs, len);
 }
 
 /*
@@ -266,6 +392,15 @@ static int scan_write_bbt(struct mtd_inf
 	return mtd->write_oob(mtd, offs, &ops);
 }
 
+static u32 bbt_get_ver_offs(struct mtd_info *mtd, struct nand_bbt_descr *td)
+{
+	u32 ver_offs = td->veroffs;
+
+	if (!(td->options & NAND_BBT_NO_OOB))
+		ver_offs += mtd->writesize;
+	return ver_offs;
+}
+
 /**
  * read_abs_bbts - [GENERIC] Read the bad block table(s) for all chips starting at a given page
  * @mtd:	MTD device structure
@@ -285,8 +420,8 @@ static int read_abs_bbts(struct mtd_info
 	/* Read the primary version, if available */
 	if (td->options & NAND_BBT_VERSION) {
 		scan_read_raw(mtd, buf, (loff_t)td->pages[0] << this->page_shift,
-			      mtd->writesize);
-		td->version[0] = buf[mtd->writesize + td->veroffs];
+			      mtd->writesize, td);
+		td->version[0] = buf[bbt_get_ver_offs(mtd, td)];
 		printk(KERN_DEBUG "Bad block table at page %d, version 0x%02X\n",
 		       td->pages[0], td->version[0]);
 	}
@@ -294,8 +429,8 @@ static int read_abs_bbts(struct mtd_info
 	/* Read the mirror version, if available */
 	if (md && (md->options & NAND_BBT_VERSION)) {
 		scan_read_raw(mtd, buf, (loff_t)md->pages[0] << this->page_shift,
-			      mtd->writesize);
-		md->version[0] = buf[mtd->writesize + md->veroffs];
+			      mtd->writesize, td);
+		md->version[0] = buf[bbt_get_ver_offs(mtd, md)];
 		printk(KERN_DEBUG "Bad block table at page %d, version 0x%02X\n",
 		       md->pages[0], md->version[0]);
 	}
@@ -311,7 +446,7 @@ static int scan_block_full(struct mtd_in
 {
 	int ret, j;
 
-	ret = scan_read_raw(mtd, buf, offs, readlen);
+	ret = scan_read_raw_oob(mtd, buf, offs, readlen);
 	if (ret)
 		return ret;
 
@@ -336,8 +471,6 @@ static int scan_block_fast(struct mtd_in
 	ops.ooboffs = 0;
 	ops.datbuf = NULL;
 	ops.mode = MTD_OOB_PLACE;
-	
-	mtd->flags |= MTD_USE_DEV_OOB_LAYOUT;
 
 	for (j = 0; j < len; j++) {
 		/*
@@ -354,9 +487,6 @@ static int scan_block_fast(struct mtd_in
 
 		offs += mtd->writesize;
 	}
-	
-	mtd->flags &= ~MTD_USE_DEV_OOB_LAYOUT;
-
 	return 0;
 }
 
@@ -384,12 +514,10 @@ static int create_bbt(struct mtd_info *m
 
 	if (bd->options & NAND_BBT_SCANALLPAGES)
 		len = 1 << (this->bbt_erase_shift - this->page_shift);
-	else {
-		if (bd->options & NAND_BBT_SCAN2NDPAGE)
-			len = 2;
-		else
-			len = 1;
-	}
+	else if (bd->options & NAND_BBT_SCAN2NDPAGE)
+		len = 2;
+	else
+		len = 1;
 
 	if (!(bd->options & NAND_BBT_SCANEMPTY)) {
 		/* We need only read few bytes from the OOB area */
@@ -419,9 +547,14 @@ static int create_bbt(struct mtd_info *m
 		from = (loff_t)startblock << (this->bbt_erase_shift - 1);
 	}
 
+	if (this->options & NAND_BBT_SCANLASTPAGE)
+		from += mtd->erasesize - (mtd->writesize * len);
+
 	for (i = startblock; i < numblocks;) {
 		int ret;
 
+		BUG_ON(bd->options & NAND_BBT_NO_OOB);
+
 		if (bd->options & NAND_BBT_SCANALLPAGES)
 			ret = scan_block_full(mtd, bd, from, buf, readlen,
 					      scanlen, len);
@@ -503,11 +636,12 @@ static int search_bbt(struct mtd_info *m
 			loff_t offs = (loff_t)actblock << this->bbt_erase_shift;
 
 			/* Read first page */
-			scan_read_raw(mtd, buf, offs, mtd->writesize);
+			scan_read_raw(mtd, buf, offs, mtd->writesize, td);
 			if (!check_pattern(buf, scanlen, mtd->writesize, td)) {
 				td->pages[i] = actblock << blocktopage;
 				if (td->options & NAND_BBT_VERSION) {
-					td->version[i] = buf[mtd->writesize + td->veroffs];
+					offs = bbt_get_ver_offs(mtd, td);
+					td->version[i] = buf[offs];
 				}
 				break;
 			}
@@ -691,12 +825,26 @@ static int write_bbt(struct mtd_info *mt
 			memset(&buf[offs], 0xff, (size_t) (numblocks >> sft));
 			ooboffs = len + (pageoffs * mtd->oobsize);
 
+		} else if (td->options & NAND_BBT_NO_OOB) {
+			ooboffs = 0;
+			offs = td->len;
+			/* the version byte */
+			if (td->options & NAND_BBT_VERSION)
+				offs++;
+			/* Calc length */
+			len = (size_t) (numblocks >> sft);
+			len += offs;
+			/* Make it page aligned ! */
+			len = ALIGN(len, mtd->writesize);
+			/* Preset the buffer with 0xff */
+			memset(buf, 0xff, len);
+			/* Pattern is located at the begin of first page */
+			memcpy(buf, td->pattern, td->len);
 		} else {
 			/* Calc length */
 			len = (size_t) (numblocks >> sft);
 			/* Make it page aligned ! */
-			len = (len + (mtd->writesize - 1)) &
-				~(mtd->writesize - 1);
+			len = ALIGN(len, mtd->writesize);
 			/* Preset the buffer with 0xff */
 			memset(buf, 0xff, len +
 			       (len >> this->page_shift)* mtd->oobsize);
@@ -730,7 +878,9 @@ static int write_bbt(struct mtd_info *mt
 		if (res < 0)
 			goto outerr;
 
-		res = scan_write_bbt(mtd, to, len, buf, &buf[len]);
+		res = scan_write_bbt(mtd, to, len, buf,
+				td->options & NAND_BBT_NO_OOB ? NULL :
+				&buf[len]);
 		if (res < 0)
 			goto outerr;
 
@@ -796,7 +946,7 @@ static int check_create(struct mtd_info 
 		rd2 = NULL;
 		/* Per chip or per device ? */
 		chipsel = (td->options & NAND_BBT_PERCHIP) ? i : -1;
-		/* Mirrored table avilable ? */
+		/* Mirrored table available ? */
 		if (md) {
 			if (td->pages[i] == -1 && md->pages[i] == -1) {
 				writeops = 0x03;
@@ -850,7 +1000,8 @@ static int check_create(struct mtd_info 
 			continue;
 
 		/* Create the table in memory by scanning the chip(s) */
-		create_bbt(mtd, buf, bd, chipsel);
+		if (!(this->options & NAND_CREATE_EMPTY_BBT))
+			create_bbt(mtd, buf, bd, chipsel);
 
 		td->version[i] = 1;
 		if (md)
@@ -941,6 +1092,54 @@ static void mark_bbt_region(struct mtd_i
 }
 
 /**
+ * verify_bbt_descr - verify the bad block description
+ * @mtd:	MTD device structure
+ * @bd:		the table to verify
+ *
+ * This functions performs a few sanity checks on the bad block description
+ * table.
+ */
+static void verify_bbt_descr(struct mtd_info *mtd, struct nand_bbt_descr *bd)
+{
+	struct nand_chip *this = mtd->priv;
+	u32 pattern_len;
+	u32 bits;
+	u32 table_size;
+
+	if (!bd)
+		return;
+
+	pattern_len = bd->len;
+	bits = bd->options & NAND_BBT_NRBITS_MSK;
+
+	BUG_ON((this->options & NAND_USE_FLASH_BBT_NO_OOB) &&
+			!(this->options & NAND_USE_FLASH_BBT));
+	BUG_ON(!bits);
+
+	if (bd->options & NAND_BBT_VERSION)
+		pattern_len++;
+
+	if (bd->options & NAND_BBT_NO_OOB) {
+		BUG_ON(!(this->options & NAND_USE_FLASH_BBT));
+		BUG_ON(!(this->options & NAND_USE_FLASH_BBT_NO_OOB));
+		BUG_ON(bd->offs);
+		if (bd->options & NAND_BBT_VERSION)
+			BUG_ON(bd->veroffs != bd->len);
+		BUG_ON(bd->options & NAND_BBT_SAVECONTENT);
+	}
+
+	if (bd->options & NAND_BBT_PERCHIP)
+		table_size = this->chipsize >> this->bbt_erase_shift;
+	else
+		table_size = mtd->size >> this->bbt_erase_shift;
+	table_size >>= 3;
+	table_size *= bits;
+	if (bd->options & NAND_BBT_NO_OOB)
+		table_size += pattern_len;
+	BUG_ON(table_size > (1 << this->bbt_erase_shift));
+}
+
+/**
  * nand_scan_bbt - [NAND Interface] scan, find, read and maybe create bad block table(s)
  * @mtd:	MTD device structure
  * @bd:		descriptor for the good/bad block search pattern
@@ -981,6 +1180,8 @@ int nand_scan_bbt(struct mtd_info *mtd, 
 		}
 		return res;
 	}
+	verify_bbt_descr(mtd, td);
+	verify_bbt_descr(mtd, md);
 
 	/* Allocate a temporary buffer for one eraseblock incl. oob */
 	len = (1 << this->bbt_erase_shift);
@@ -1076,30 +1277,16 @@ int nand_update_bbt(struct mtd_info *mtd
  * while scanning a device for factory marked good / bad blocks. */
 static uint8_t scan_ff_pattern[] = { 0xff, 0xff };
 
-static struct nand_bbt_descr smallpage_memorybased = {
-	.options = NAND_BBT_SCAN2NDPAGE,
-	.offs = 5,
-	.len = 1,
-	.pattern = scan_ff_pattern
-};
-
-static struct nand_bbt_descr largepage_memorybased = {
-	.options = 0,
-	.offs = 0,
-	.len = 2,
-	.pattern = scan_ff_pattern
-};
-
 static struct nand_bbt_descr smallpage_flashbased = {
 	.options = NAND_BBT_SCAN2NDPAGE,
-	.offs = 5,
+	.offs = NAND_SMALL_BADBLOCK_POS,
 	.len = 1,
 	.pattern = scan_ff_pattern
 };
 
 static struct nand_bbt_descr largepage_flashbased = {
 	.options = NAND_BBT_SCAN2NDPAGE,
-	.offs = 0,
+	.offs = NAND_LARGE_BADBLOCK_POS,
 	.len = 2,
 	.pattern = scan_ff_pattern
 };
@@ -1138,6 +1325,63 @@ static struct nand_bbt_descr bbt_mirror_
 	.pattern = mirror_pattern
 };
 
+static struct nand_bbt_descr bbt_main_no_bbt_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP
+		| NAND_BBT_NO_OOB,
+	.len = 4,
+	.veroffs = 4,
+	.maxblocks = 4,
+	.pattern = bbt_pattern
+};
+
+static struct nand_bbt_descr bbt_mirror_no_bbt_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP
+		| NAND_BBT_NO_OOB,
+	.len = 4,
+	.veroffs = 4,
+	.maxblocks = 4,
+	.pattern = mirror_pattern
+};
+
+#define BBT_SCAN_OPTIONS (NAND_BBT_SCANLASTPAGE | NAND_BBT_SCAN2NDPAGE | \
+		NAND_BBT_SCANBYTE1AND6)
+/**
+ * nand_create_default_bbt_descr - [Internal] Creates a BBT descriptor structure
+ * @this:	NAND chip to create descriptor for
+ *
+ * This function allocates and initializes a nand_bbt_descr for BBM detection
+ * based on the properties of "this". The new descriptor is stored in
+ * this->badblock_pattern. Thus, this->badblock_pattern should be NULL when
+ * passed to this function.
+ *
+ * TODO: Handle other flags, replace other static structs
+ *        (e.g. handle NAND_BBT_FLASH for flash-based BBT,
+ *             replace smallpage_flashbased)
+ *
+ */
+static int nand_create_default_bbt_descr(struct nand_chip *this)
+{
+	struct nand_bbt_descr *bd;
+	if (this->badblock_pattern) {
+		printk(KERN_WARNING "BBT descr already allocated; not replacing.\n");
+		return -EINVAL;
+	}
+	bd = kzalloc(sizeof(*bd), GFP_KERNEL);
+	if (!bd) {
+		printk(KERN_ERR "nand_create_default_bbt_descr: Out of memory\n");
+		return -ENOMEM;
+	}
+	bd->options = this->options & BBT_SCAN_OPTIONS;
+	bd->offs = this->badblockpos;
+	bd->len = (this->options & NAND_BUSWIDTH_16) ? 2 : 1;
+	bd->pattern = scan_ff_pattern;
+	bd->options |= NAND_BBT_DYNAMICSTRUCT;
+	this->badblock_pattern = bd;
+	return 0;
+}
+
 /**
  * nand_default_bbt - [NAND Interface] Select a default bad block table for the device
  * @mtd:	MTD device structure
@@ -1171,8 +1415,13 @@ int nand_default_bbt(struct mtd_info *mt
 	if (this->options & NAND_USE_FLASH_BBT) {
 		/* Use the default pattern descriptors */
 		if (!this->bbt_td) {
-			this->bbt_td = &bbt_main_descr;
-			this->bbt_md = &bbt_mirror_descr;
+			if (this->options & NAND_USE_FLASH_BBT_NO_OOB) {
+				this->bbt_td = &bbt_main_no_bbt_descr;
+				this->bbt_md = &bbt_mirror_no_bbt_descr;
+			} else {
+				this->bbt_td = &bbt_main_descr;
+				this->bbt_md = &bbt_mirror_descr;
+			}
 		}
 		if (!this->badblock_pattern) {
 			this->badblock_pattern = (mtd->writesize > 512) ? &largepage_flashbased : &smallpage_flashbased;
@@ -1180,10 +1429,8 @@ int nand_default_bbt(struct mtd_info *mt
 	} else {
 		this->bbt_td = NULL;
 		this->bbt_md = NULL;
-		if (!this->badblock_pattern) {
-			this->badblock_pattern = (mtd->writesize > 512) ?
-			    &largepage_memorybased : &smallpage_memorybased;
-		}
+		if (!this->badblock_pattern)
+			nand_create_default_bbt_descr(this);
 	}
 	return nand_scan_bbt(mtd, this->badblock_pattern);
 }
diff -Naurp linux-2.6.34.org/drivers/mtd/nand/nx_nand/nx_nand.c linux-2.6.34/drivers/mtd/nand/nx_nand/nx_nand.c
--- linux-2.6.34.org/drivers/mtd/nand/nx_nand/nx_nand.c	2011-04-14 23:17:31.000000000 -0500
+++ linux-2.6.34/drivers/mtd/nand/nx_nand/nx_nand.c	2011-04-14 23:20:21.000000000 -0500
@@ -55,8 +55,8 @@
 
 #ifdef CONFIG_MTD_NX_NAND_HWECC
 /**
-*  OOB structure
-*/
+ *  OOB structure
+ */
 /* For 4K LPF */
 static struct nand_ecclayout nx_nand_oob_128 = {
     .eccbytes = 96,
@@ -73,61 +73,61 @@ static struct nand_ecclayout nx_nand_oob
 
     .oobfree = {
         {.offset = 2,
-         .length = 2},
+            .length = 2},
         {.offset = 16,
-         .length = 4},
+            .length = 4},
         {.offset = 32,
-         .length = 4},
+            .length = 4},
         {.offset = 48,
-         .length = 4},
+            .length = 4},
         {.offset = 64,
-         .length = 4},
+            .length = 4},
         {.offset = 80,
-         .length = 4},
+            .length = 4},
         {.offset = 96,
-         .length = 4},
+            .length = 4},
         {.offset = 112,
-         .length = 4},
+            .length = 4},
     }
 };
 
 /* For LPF */
 static struct nand_ecclayout nx_nand_oob_64 = {
-   .eccbytes = 48,
-   .eccpos = {
-          4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
-         20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
-         36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
-         52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63},
-   .oobfree = {
-      {.offset = 2,
-       .length = 2},
-      {.offset = 16,
-       .length = 4},
-      {.offset = 32,
-       .length = 4},
-      {.offset = 48,
-       .length = 4},
-   }
+    .eccbytes = 48,
+    .eccpos = {
+        4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
+        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
+        36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
+        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63},
+    .oobfree = {
+        {.offset = 2,
+            .length = 2},
+        {.offset = 16,
+            .length = 4},
+        {.offset = 32,
+            .length = 4},
+        {.offset = 48,
+            .length = 4},
+    }
 };
 
 /* For SPF */
 static struct nand_ecclayout nx_nand_oob_16 = {
-      .eccbytes = 16,
-            .eccpos = {
-                  4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
-            },
-            .oobfree = {
-            {
-                  .offset = 0,
-                  .length = 4},
-            }
-      };
+    .eccbytes = 16,
+    .eccpos = {
+        4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
+    },
+    .oobfree = {
+        {
+            .offset = 0,
+            .length = 4},
+    }
+};
 #endif
 
 /**
-*  Flash based BBT information for LPF
-*/
+ *  Flash based BBT information for LPF
+ */
 
 #ifdef CONFIG_MTD_NX_NAND_HWECC
 
@@ -135,992 +135,993 @@ static uint8_t nx_bbt_pattern[] = {'N', 
 static uint8_t nx_mirror_pattern[] = {'P', 'X', 'N' };
 
 static struct nand_bbt_descr nx_bbt_main = {
-   .options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
-      | NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
-   .offs =  0,
-   .len = 3,
-   .veroffs = 3,
-   .maxblocks = 4,
-   .pattern = nx_bbt_pattern
+    .options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+        | NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+    .offs =  0,
+    .len = 3,
+    .veroffs = 3,
+    .maxblocks = 4,
+    .pattern = nx_bbt_pattern
 };
 
 static struct nand_bbt_descr nx_bbt_mirror = {
-   .options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
-      | NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
-   .offs =  0,
-   .len = 3,
-   .veroffs = 3,
-   .maxblocks = 4,
-   .pattern = nx_mirror_pattern
+    .options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+        | NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+    .offs =  0,
+    .len = 3,
+    .veroffs = 3,
+    .maxblocks = 4,
+    .pattern = nx_mirror_pattern
 };
 
 #endif
 
 /**
-* NAND control structure
-*/
+ * NAND control structure
+ */
 struct nx_nand_ctrl *nx_nc = NULL;
 
 /**
-* MTD Partitions structure 
-*/
+ * MTD Partitions structure 
+ */
 static struct mtd_partition partition_info1[] = {
-   {
-      .name = (char *)"bootcode",
-      .offset = 0,
-      .size   = 16*1024,
-   },
-   {
-      .name = (char *)"Flash partition 0",
-      .offset = MTDPART_OFS_APPEND,
-      .size   = (2*1024*1024)-(16*1024),
-   },
-   {
-      .name = (char *)"Flash partition 1",
-      .offset = MTDPART_OFS_APPEND,
-      .size   = 2*1024*1024,
-   },
-   {
-      .name = (char *)"Flash partition 2",
-      .offset = MTDPART_OFS_APPEND,
-      .size   = MTDPART_SIZ_FULL,
-   }
+    {
+        .name = (char *)"bootcode",
+        .offset = 0,
+        .size   = 16*1024,
+    },
+    {
+        .name = (char *)"Flash partition 0",
+        .offset = MTDPART_OFS_APPEND,
+        .size   = (2*1024*1024)-(16*1024),
+    },
+    {
+        .name = (char *)"Flash partition 1",
+        .offset = MTDPART_OFS_APPEND,
+        .size   = 2*1024*1024,
+    },
+    {
+        .name = (char *)"Flash partition 2",
+        .offset = MTDPART_OFS_APPEND,
+        .size   = MTDPART_SIZ_FULL,
+    }
 };
 
 struct mtd_partition partition_info2[] = {
-   {
-      .name = (char *)"Bootloader (256K)",
-      .offset = 0,
-      .size   = (256*1024),
-   },
-   {
-      .name = (char *)"2. kernel-image (12M)",
-      .offset = (256*1024),
-      .size   = (12*1024*1024),
-   },
-   {
-      .name = (char *)"3. AVDSP Image (12M)",
-      .offset = ((256*1024) + (12*1024*1024)), 
-      .size   = (12*1024*1024),
-   },
-   {
-      .name = (char *)"4. RFS-SELP-SISC-NXP (12M-CRAMFS)",
-      .offset = ((256*1024) + (12*1024*1024)+(12*1024*1024)), 
-      .size   = (12*1024*1024),
-   },
-   {
-      .name = (char *)"5. DTV APP(40M-CRAMFS)",
-      .offset = ((256*1024) + (12*1024*1024)+(12*1024*1024)+(12*1024*1024)), 
-      .size   = (40*1024*1024),
-   },
-   {
-      .name = (char *)"6. RW Area (5M-JFFS2) ",
-      .offset = ((256*1024) + (12*1024*1024)+(12*1024*1024)+(12*1024*1024)+(40*1024*1024)), 
-      .size   = 5*1024*1024,
-   },
-   {
-      .name = (char *)"7. TEMP (40M-JFFS2) ",
-      .offset = ((256*1024) + (12*1024*1024)+(12*1024*1024)+(12*1024*1024)+(40*1024*1024)+(5*1024*1024)), 
-      .size   = 40*1024*1024,
-   },
+    {
+        .name = (char *)"Bootloader (256K)",
+        .offset = 0,
+        .size   = (256*1024),
+    },
+    {
+        .name = (char *)"2. kernel-image (12M)",
+        .offset = (256*1024),
+        .size   = (12*1024*1024),
+    },
+    {
+        .name = (char *)"3. AVDSP Image (12M)",
+        .offset = ((256*1024) + (12*1024*1024)), 
+        .size   = (12*1024*1024),
+    },
+    {
+        .name = (char *)"4. RFS-SELP-SISC-NXP (12M-CRAMFS)",
+        .offset = ((256*1024) + (12*1024*1024)+(12*1024*1024)), 
+        .size   = (12*1024*1024),
+    },
+    {
+        .name = (char *)"5. DTV APP(40M-CRAMFS)",
+        .offset = ((256*1024) + (12*1024*1024)+(12*1024*1024)+(12*1024*1024)), 
+        .size   = (40*1024*1024),
+    },
+    {
+        .name = (char *)"6. RW Area (5M-JFFS2) ",
+        .offset = ((256*1024) + (12*1024*1024)+(12*1024*1024)+(12*1024*1024)+(40*1024*1024)), 
+        .size   = 5*1024*1024,
+    },
+    {
+        .name = (char *)"7. TEMP (40M-JFFS2) ",
+        .offset = ((256*1024) + (12*1024*1024)+(12*1024*1024)+(12*1024*1024)+(40*1024*1024)+(5*1024*1024)), 
+        .size   = 40*1024*1024,
+    },
 };
 
 /**
-* MTD command line partition parser 
-*/
+ * MTD command line partition parser 
+ */
 /*We don't need nxpart parser */
 /*const char *part_probes[] = { "cmdlinepart", "nxpart", NULL };*/
 
 const char *part_probes[] = { "cmdlinepart", NULL };
 
 #define NX_NAND_READ_INT   (NX_NAND_INT_DEC_UNCOR | \
-                                           NX_NAND_INT_DEC_0_ERR | \
-                                           NX_NAND_INT_DEC_1_ERR | \
-                                           NX_NAND_INT_DEC_2_ERR | \
-                                           NX_NAND_INT_DEC_3_ERR | \
-                                           NX_NAND_INT_DEC_4_ERR | \
-                                          NX_NAND_INT_DEC_5_ERR)
+        NX_NAND_INT_DEC_0_ERR | \
+        NX_NAND_INT_DEC_1_ERR | \
+        NX_NAND_INT_DEC_2_ERR | \
+        NX_NAND_INT_DEC_3_ERR | \
+        NX_NAND_INT_DEC_4_ERR | \
+        NX_NAND_INT_DEC_5_ERR)
 
 /*------------------------------------------------------------------------------------
-* Internal functions 
---------------------------------------------------------------------------------------*/
+ * Internal functions 
+ --------------------------------------------------------------------------------------*/
 #ifdef CONFIG_MTD_NX_NAND_DMAC
 /**
-* nx_nand_dmac_init - Configure the DMAC scatter gather list
-* @nc: NAND control structure
-* @read: Read command
-* @req: Request structure
-* @stgt: Scatter gather array
-*
-* Initialise the DMAC scatter gather list
-*/
+ * nx_nand_dmac_init - Configure the DMAC scatter gather list
+ * @nc: NAND control structure
+ * @read: Read command
+ * @req: Request structure
+ * @stgt: Scatter gather array
+ *
+ * Initialise the DMAC scatter gather list
+ */
 static inline void nx_nand_dmac_init(struct nx_nand_ctrl *nc, 
-         uint32_t cmd, nx_dmac_tfr_t *req, nx_dmac_stgt_t *stgt)
+        uint32_t cmd, nx_dmac_tfr_t *req, nx_dmac_stgt_t *stgt)
 {
-   int i;
+    int i;
 
-   if(cmd) {
-         
-      /* Read Main Area */
-      for(i=0; i < nc->num_blks; i++) {
-         stgt[i].src_addr = NX_NAND_AHB_BUF;     
-      stgt[i].dst_addr = nc->dmabuf_phy + (i * NX_NAND_BLK_SIZE);
-      stgt[i].tfr_size = NX_NAND_BLK_SIZE >> 2;    
-         stgt[i].flowctl = nx_dmac_per2mem_dma;         
-         stgt[i].src_per = 0;              
-      stgt[i].dst_per = 0;
-         stgt[i].src_ahb = 1;              /* Source AHB master 1 */
-      stgt[i].dst_ahb = 0;              /* Dest AHB master 0 */
-      stgt[i].src_inc = true;
-      stgt[i].dst_inc = true;
-      stgt[i].src_brst = nx_dmac_128;
-      stgt[i].dst_brst = nx_dmac_128;
-      stgt[i].src_width = nx_dmac_width_32;
-      stgt[i].dst_width = nx_dmac_width_32;
-      }
-   
-      /* Read OOB area */
-      stgt[i].src_addr = NX_NAND_AHB_BUF + NX_NAND_BLK_SIZE;     
-   stgt[i].dst_addr = nc->dmabuf_phy + (i * NX_NAND_BLK_SIZE);
-   stgt[i].tfr_size = nc->mtd.oobsize >> 2;    
-      stgt[i].flowctl = nx_dmac_per2mem_dma;         
-      stgt[i].src_ahb = 1;              /* Source AHB master 1 */
-   stgt[i].dst_ahb = 0;              /* Dest AHB master 0 */
-      stgt[i].src_per = 0;              
-      stgt[i].dst_per = 0;
-      stgt[i].src_inc = true;
-      stgt[i].dst_inc = true;
-      if(nc->mtd.oobsize == 128) {
-         stgt[i].src_brst = nx_dmac_32;
-         stgt[i].dst_brst = nx_dmac_32;
-      }
-      else if(nc->mtd.oobsize == 64) {
-         stgt[i].src_brst = nx_dmac_16;
-         stgt[i].dst_brst = nx_dmac_16;
-      }
-      else {
-         stgt[i].src_brst = nx_dmac_4;
-         stgt[i].dst_brst = nx_dmac_4;
-      }
-   stgt[i].src_width = nx_dmac_width_32;
-   stgt[i].dst_width = nx_dmac_width_32;
-   }
-   else { 
-      
-      /* Write OOB area */
-      i=0;  
-      stgt[i].dst_addr = NX_NAND_AHB_BUF + NX_NAND_BLK_SIZE;     
-   stgt[i].src_addr = nc->dmabuf_phy + (nc->num_blks * NX_NAND_BLK_SIZE);
-   stgt[i].tfr_size = nc->mtd.oobsize >> 2;    
-      stgt[i].flowctl = nx_dmac_mem2per_dma;         
-      stgt[i].src_ahb = 0;              /* Source AHB master 0 */
-      stgt[i].dst_ahb = 1;              /* Dest AHB master 1 */
-      stgt[i].src_per = 0;              
-      stgt[i].dst_per = 0;
-      stgt[i].src_inc = true;
-      stgt[i].dst_inc = true;
-      if(nc->mtd.oobsize == 128) {
-         stgt[i].src_brst = nx_dmac_32;
-         stgt[i].dst_brst = nx_dmac_32;
-      }
-      else if(nc->mtd.oobsize == 64) {
-         stgt[i].src_brst = nx_dmac_16;
-         stgt[i].dst_brst = nx_dmac_16;
-      }
-      else {
-         stgt[i].src_brst = nx_dmac_4;
-         stgt[i].dst_brst = nx_dmac_4;
-      }
-   stgt[i].src_width = nx_dmac_width_32;
-   stgt[i].dst_width = nx_dmac_width_32;
-         
-      /* Write Main area */
-      for(i=1; i< (nc->num_blks+1); i++) {
-      stgt[i].src_addr = nc->dmabuf_phy + ( (i-1) * NX_NAND_BLK_SIZE);
-         stgt[i].dst_addr = NX_NAND_AHB_BUF;     
-      stgt[i].tfr_size = NX_NAND_BLK_SIZE >> 2;    
-         stgt[i].flowctl = nx_dmac_mem2per_dma;         
-         stgt[i].src_per = 0;             
-      stgt[i].dst_per = 0;
-         stgt[i].src_ahb = 0;              /* Source AHB master 0 */
-      stgt[i].dst_ahb = 1;              /* Dest AHB master 1 */
-      stgt[i].src_inc = true;
-      stgt[i].dst_inc = true;
-      stgt[i].src_brst = nx_dmac_128;
-      stgt[i].dst_brst = nx_dmac_128;
-      stgt[i].src_width = nx_dmac_width_32;
-      stgt[i].dst_width = nx_dmac_width_32;
-      }
-   }
- 
-   req->num_reqs = nc->num_blks + 1;
-   req->req = &stgt[0];
-}
-#endif
-
-/**
-* nx_nand_cmd_addr - Send cmd & address cycles to chip
-* @nc: NAND control structure
-* @cmd: Command to be send
-* @data: command or data
-* @last: Last cycle
-*
-* Send command & address cycles to chip for small page chips
-*/
+    if(cmd) {
+
+        /* Read Main Area */
+        for(i=0; i < nc->num_blks; i++) {
+            stgt[i].src_addr = NX_NAND_AHB_BUF;     
+            stgt[i].dst_addr = nc->dmabuf_phy + (i * NX_NAND_BLK_SIZE);
+            stgt[i].tfr_size = NX_NAND_BLK_SIZE >> 2;    
+            stgt[i].flowctl = nx_dmac_per2mem_dma;         
+            stgt[i].src_per = 0;              
+            stgt[i].dst_per = 0;
+            stgt[i].src_ahb = 1;              /* Source AHB master 1 */
+            stgt[i].dst_ahb = 0;              /* Dest AHB master 0 */
+            stgt[i].src_inc = true;
+            stgt[i].dst_inc = true;
+            stgt[i].src_brst = nx_dmac_128;
+            stgt[i].dst_brst = nx_dmac_128;
+            stgt[i].src_width = nx_dmac_width_32;
+            stgt[i].dst_width = nx_dmac_width_32;
+        }
+
+        /* Read OOB area */
+        stgt[i].src_addr = NX_NAND_AHB_BUF + NX_NAND_BLK_SIZE;     
+        stgt[i].dst_addr = nc->dmabuf_phy + (i * NX_NAND_BLK_SIZE);
+        stgt[i].tfr_size = nc->mtd.oobsize >> 2;    
+        stgt[i].flowctl = nx_dmac_per2mem_dma;         
+        stgt[i].src_ahb = 1;              /* Source AHB master 1 */
+        stgt[i].dst_ahb = 0;              /* Dest AHB master 0 */
+        stgt[i].src_per = 0;              
+        stgt[i].dst_per = 0;
+        stgt[i].src_inc = true;
+        stgt[i].dst_inc = true;
+        if(nc->mtd.oobsize == 128) {
+            stgt[i].src_brst = nx_dmac_32;
+            stgt[i].dst_brst = nx_dmac_32;
+        }
+        else if(nc->mtd.oobsize == 64) {
+            stgt[i].src_brst = nx_dmac_16;
+            stgt[i].dst_brst = nx_dmac_16;
+        }
+        else {
+            stgt[i].src_brst = nx_dmac_4;
+            stgt[i].dst_brst = nx_dmac_4;
+        }
+        stgt[i].src_width = nx_dmac_width_32;
+        stgt[i].dst_width = nx_dmac_width_32;
+    }
+    else { 
+
+        /* Write OOB area */
+        i=0;  
+        stgt[i].dst_addr = NX_NAND_AHB_BUF + NX_NAND_BLK_SIZE;     
+        stgt[i].src_addr = nc->dmabuf_phy + (nc->num_blks * NX_NAND_BLK_SIZE);
+        stgt[i].tfr_size = nc->mtd.oobsize >> 2;    
+        stgt[i].flowctl = nx_dmac_mem2per_dma;         
+        stgt[i].src_ahb = 0;              /* Source AHB master 0 */
+        stgt[i].dst_ahb = 1;              /* Dest AHB master 1 */
+        stgt[i].src_per = 0;              
+        stgt[i].dst_per = 0;
+        stgt[i].src_inc = true;
+        stgt[i].dst_inc = true;
+        if(nc->mtd.oobsize == 128) {
+            stgt[i].src_brst = nx_dmac_32;
+            stgt[i].dst_brst = nx_dmac_32;
+        }
+        else if(nc->mtd.oobsize == 64) {
+            stgt[i].src_brst = nx_dmac_16;
+            stgt[i].dst_brst = nx_dmac_16;
+        }
+        else {
+            stgt[i].src_brst = nx_dmac_4;
+            stgt[i].dst_brst = nx_dmac_4;
+        }
+        stgt[i].src_width = nx_dmac_width_32;
+        stgt[i].dst_width = nx_dmac_width_32;
+
+        /* Write Main area */
+        for(i=1; i< (nc->num_blks+1); i++) {
+            stgt[i].src_addr = nc->dmabuf_phy + ( (i-1) * NX_NAND_BLK_SIZE);
+            stgt[i].dst_addr = NX_NAND_AHB_BUF;     
+            stgt[i].tfr_size = NX_NAND_BLK_SIZE >> 2;    
+            stgt[i].flowctl = nx_dmac_mem2per_dma;         
+            stgt[i].src_per = 0;             
+            stgt[i].dst_per = 0;
+            stgt[i].src_ahb = 0;              /* Source AHB master 0 */
+            stgt[i].dst_ahb = 1;              /* Dest AHB master 1 */
+            stgt[i].src_inc = true;
+            stgt[i].dst_inc = true;
+            stgt[i].src_brst = nx_dmac_128;
+            stgt[i].dst_brst = nx_dmac_128;
+            stgt[i].src_width = nx_dmac_width_32;
+            stgt[i].dst_width = nx_dmac_width_32;
+        }
+    }
+
+    req->num_reqs = nc->num_blks + 1;
+    req->req = &stgt[0];
+}
+
+#endif
+
+/**
+ * nx_nand_cmd_addr - Send cmd & address cycles to chip
+ * @nc: NAND control structure
+ * @cmd: Command to be send
+ * @data: command or data
+ * @last: Last cycle
+ *
+ * Send command & address cycles to chip for small page chips
+ */
 static inline void nx_nand_cmd_addr(struct nx_nand_ctrl *nc, uint32_t cmd,
-                 uint32_t data, int last)
+        uint32_t data, int last)
 {
-   tmhwEfmc_CmdAddr_t   cmd_addr;
-   
-   /* Chip enable */
-   cmd_addr.deviceNum = (0 << (nc->slotid + NX_NAND_CMD_FIFO_CE_START));
-
-   /* Cmd or address */
-   switch(cmd)
-   {
-      case NX_NAND_CMD_FIFO_ADDR_CYC:
-         cmd_addr.cycleType = tmhwEfmc_AddrCycle;
-         break;
-      
-      case NX_NAND_CMD_FIFO_CMD_CYC:
-         cmd_addr.cycleType = tmhwEfmc_CmdCycle;
-         break;
-      
-      case NX_NAND_CMD_FIFO_POST_CMD:
-         cmd_addr.cycleType = tmhwEfmc_PostWrCmdCycle;
-         break;
-      
-      default:
-         printk(KERN_ERR "nx_nand:Invalid cmd \r\n"); 
-         return;
-   }
-
-   /* Last cmd or addr cycle */
-   if(last)
-      cmd_addr.lastCycle = TM_TRUE;
-   else
-      cmd_addr.lastCycle = TM_FALSE;
-   
-   /* Addr or Cmd */
-   cmd_addr.data = data;
-   
-   /* Send to chip */
-   tmhwEfmc_WriteCmdAddr(0, &cmd_addr);
+    tmhwEfmc_CmdAddr_t   cmd_addr;
+
+    /* Chip enable */
+    cmd_addr.deviceNum = (0 << (nc->slotid + NX_NAND_CMD_FIFO_CE_START));
+
+    /* Cmd or address */
+    switch(cmd)
+    {
+        case NX_NAND_CMD_FIFO_ADDR_CYC:
+            cmd_addr.cycleType = tmhwEfmc_AddrCycle;
+            break;
+
+        case NX_NAND_CMD_FIFO_CMD_CYC:
+            cmd_addr.cycleType = tmhwEfmc_CmdCycle;
+            break;
+
+        case NX_NAND_CMD_FIFO_POST_CMD:
+            cmd_addr.cycleType = tmhwEfmc_PostWrCmdCycle;
+            break;
+
+        default:
+            printk(KERN_ERR "nx_nand:Invalid cmd \r\n"); 
+            return;
+    }
+
+    /* Last cmd or addr cycle */
+    if(last)
+        cmd_addr.lastCycle = TM_TRUE;
+    else
+        cmd_addr.lastCycle = TM_FALSE;
+
+    /* Addr or Cmd */
+    cmd_addr.data = data;
+
+    /* Send to chip */
+    tmhwEfmc_WriteCmdAddr(0, &cmd_addr);
 }
 
 /*------------------------------------------------------------------------------------
-* Performance Measurement functions 
---------------------------------------------------------------------------------------*/
+ * Performance Measurement functions 
+ --------------------------------------------------------------------------------------*/
 #ifdef CONFIG_MTD_PERF_MEAS
 
 #define TSU_CYCLE_TIME   (75)  // 75nsec
 
 int nand_perf_meas(struct mtd_info *mtd,  uint32_t start, uint32_t end,
-            enum mtd_meas_oper oper)
+        enum mtd_meas_oper oper)
 {
-   int i;
-   uint32_t diff, min, max, sum, ave;
+    int i;
+    uint32_t diff, min, max, sum, ave;
 
-   if(!mtd->perf.cmd_meas) {
-      printk(KERN_INFO "Operation Not Set\r\n");
-      return 0;
-   }
-
-   /* Check if mode valid */
-   if(mtd->perf.cmd_meas != oper) {
-      printk(KERN_INFO "Not correct operation Set\r\n");
-      return 0;
-   }
-
-   /* Check if number of iterations still valid */
-   if(mtd->perf.cnt >= mtd->perf.num_iter){
-      //printk(KERN_INFO "Iterations cnt: 0x%x iter: 0x%x \r\n", mtd->perf.cnt, mtd->perf.num_iter);
-      return 0;
-   }
-
-   /* store value */
-   diff = end - start;
-   mtd->perf.values[mtd->perf.cnt] = diff; 
-   mtd->perf.cnt++;
-   if(mtd->perf.cnt == mtd->perf.num_iter) {
-
-      /* Get min value */
-      min = 0xFFFFFFFF;
-      for(i=0; i < mtd->perf.cnt; i++)
-      {
-         if(mtd->perf.values[i] < min) {
-            min = mtd->perf.values[i];
-         }
-      }
-      //mtd->perf.data.min_time = min;
-      mtd->perf.data.min_time = (min * TSU_CYCLE_TIME);
-      
-      /* Get max value */
-      max = 0x0;
-      for(i=0; i < mtd->perf.cnt; i++)
-      {
-         if(mtd->perf.values[i] > max) {
-            max = mtd->perf.values[i];
-         }
-      }
-      //mtd->perf.data.max_time = max;
-      mtd->perf.data.max_time = (max * TSU_CYCLE_TIME);
-
-      sum = 0;
-      for(i=0; i < mtd->perf.cnt; i++) {
-         //printk(KERN_INFO "iter: %d cycles: 0x%x \r\n", i, mtd->perf.values[i]);
-         sum += mtd->perf.values[i];
-      }
-      ave = sum / mtd->perf.cnt;
-      //mtd->perf.data.ave_time = ave;
-      mtd->perf.data.ave_time = (ave * TSU_CYCLE_TIME);
-      //mtd->perf.cmd_meas = MTD_MEAS_NONE;
-      //mtd->perf.cnt = 0;
-   }
-   
-   return 1;
+    if(!mtd->perf.cmd_meas) {
+        printk(KERN_INFO "Operation Not Set\r\n");
+        return 0;
+    }
+
+    /* Check if mode valid */
+    if(mtd->perf.cmd_meas != oper) {
+        printk(KERN_INFO "Not correct operation Set\r\n");
+        return 0;
+    }
+
+    /* Check if number of iterations still valid */
+    if(mtd->perf.cnt >= mtd->perf.num_iter){
+        //printk(KERN_INFO "Iterations cnt: 0x%x iter: 0x%x \r\n", mtd->perf.cnt, mtd->perf.num_iter);
+        return 0;
+    }
+
+    /* store value */
+    diff = end - start;
+    mtd->perf.values[mtd->perf.cnt] = diff; 
+    mtd->perf.cnt++;
+    if(mtd->perf.cnt == mtd->perf.num_iter) {
+
+        /* Get min value */
+        min = 0xFFFFFFFF;
+        for(i=0; i < mtd->perf.cnt; i++)
+        {
+            if(mtd->perf.values[i] < min) {
+                min = mtd->perf.values[i];
+            }
+        }
+        //mtd->perf.data.min_time = min;
+        mtd->perf.data.min_time = (min * TSU_CYCLE_TIME);
+
+        /* Get max value */
+        max = 0x0;
+        for(i=0; i < mtd->perf.cnt; i++)
+        {
+            if(mtd->perf.values[i] > max) {
+                max = mtd->perf.values[i];
+            }
+        }
+        //mtd->perf.data.max_time = max;
+        mtd->perf.data.max_time = (max * TSU_CYCLE_TIME);
+
+        sum = 0;
+        for(i=0; i < mtd->perf.cnt; i++) {
+            //printk(KERN_INFO "iter: %d cycles: 0x%x \r\n", i, mtd->perf.values[i]);
+            sum += mtd->perf.values[i];
+        }
+        ave = sum / mtd->perf.cnt;
+        //mtd->perf.data.ave_time = ave;
+        mtd->perf.data.ave_time = (ave * TSU_CYCLE_TIME);
+        //mtd->perf.cmd_meas = MTD_MEAS_NONE;
+        //mtd->perf.cnt = 0;
+    }
+
+    return 1;
 }
 #endif
- 
+
 /*------------------------------------------------------------------------------------
-* NAND chip specific functions 
---------------------------------------------------------------------------------------*/
+ * NAND chip specific functions 
+ --------------------------------------------------------------------------------------*/
 #ifdef CONFIG_MTD_NX_NAND_HWECC
 /**
-* nx_nand_calculate_ecc - HW ECC calculate
-* @mtd: MTD information structure
-* @dat: Databuffer
-* @ecc_code: ECC code buffer
-*
-* Dummy function for HW ECC calculation
-*/
+ * nx_nand_calculate_ecc - HW ECC calculate
+ * @mtd: MTD information structure
+ * @dat: Databuffer
+ * @ecc_code: ECC code buffer
+ *
+ * Dummy function for HW ECC calculation
+ */
 static int nx_nand_calculate_ecc(struct mtd_info *mtd ATTRIBUTE_UNUSED, const uint8_t *dat ATTRIBUTE_UNUSED,
-                     uint8_t *ecc_code ATTRIBUTE_UNUSED)
+        uint8_t *ecc_code ATTRIBUTE_UNUSED)
 {
-   return 0;
+    return 0;
 }
 
 /**
-* nx_nand_correct_data - HW ECC correct
-* @mtd: MTD information structure
-* @dat: Databuffer
-* @read_ecc: Read ECC code buffer
-* @calc_ecc: Calculated ECC buffer
-*
-* Dummy function for HW ECC calculation
-*/
+ * nx_nand_correct_data - HW ECC correct
+ * @mtd: MTD information structure
+ * @dat: Databuffer
+ * @read_ecc: Read ECC code buffer
+ * @calc_ecc: Calculated ECC buffer
+ *
+ * Dummy function for HW ECC calculation
+ */
 static int nx_nand_correct_data(struct mtd_info *mtd ATTRIBUTE_UNUSED, uint8_t *dat ATTRIBUTE_UNUSED,
-                   uint8_t *read_ecc ATTRIBUTE_UNUSED, uint8_t *calc_ecc ATTRIBUTE_UNUSED)
+        uint8_t *read_ecc ATTRIBUTE_UNUSED, uint8_t *calc_ecc ATTRIBUTE_UNUSED)
 {
-   return 0;
+    return 0;
 }
 
 /**
-* nx_nand_hwctl - HW ECC control function
-* @mtd: MTD information structure
-* @mode: Mode
-*
-* Dummy function for HW ECC calculation
-*/
+ * nx_nand_hwctl - HW ECC control function
+ * @mtd: MTD information structure
+ * @mode: Mode
+ *
+ * Dummy function for HW ECC calculation
+ */
 static void nx_nand_hwctl(struct mtd_info *mtd ATTRIBUTE_UNUSED, int mode ATTRIBUTE_UNUSED)
 {
-   return;
+    return;
 }
 
 #endif
 
 /**
-* nx_nand_select_chip - Enable or Disable chip
-* @mtd: MTD information structure
-* @chipnr: Chip number
-*
-* Enable the chip if it chipnr >= 0, else disable the chip
-*/
+ * nx_nand_select_chip - Enable or Disable chip
+ * @mtd: MTD information structure
+ * @chipnr: Chip number
+ *
+ * Enable the chip if it chipnr >= 0, else disable the chip
+ */
 static void nx_nand_select_chip(struct mtd_info *mtd, int chipnr)
 {
-   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+
+    if(chipnr == -1)
+        return;
 
-   if(chipnr == -1)
-      return;
-   
-   /* Store the value in nand control structure 
-    * Chip enable/disable done in command function */
-   nc->slotid = chipnr;
+    /* Store the value in nand control structure 
+     * Chip enable/disable done in command function */
+    nc->slotid = chipnr;
 }
 
 /**
-* nx_nand_dev_ready - Check device ready
-* @mtd: MTD information structure
-*
-* Return true if the device is ready, false otherwise
-*/
+ * nx_nand_dev_ready - Check device ready
+ * @mtd: MTD information structure
+ *
+ * Return true if the device is ready, false otherwise
+ */
 static int nx_nand_dev_ready(struct mtd_info *mtd)
 {
-   tmhwEfmc_ReadBusySignal_t dev_stat;
-   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
-   
-   /* Get status from controller */
-   tmhwEfmc_GetBusyStatus(nc->unitid, nc->slotid, &dev_stat);
-
-   /* Return with R/B status */
-   return (dev_stat.rbEdge_Status_Ready);
+    tmhwEfmc_ReadBusySignal_t dev_stat;
+    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+
+    /* Get status from controller */
+    tmhwEfmc_GetBusyStatus(nc->unitid, nc->slotid, &dev_stat);
+
+    /* Return with R/B status */
+    return (dev_stat.rbEdge_Status_Ready);
 }
 
 /**
-* nx_nand_read_byte - Read a byte from chip
-* @mtd: MTD information structure
-*
-* Read a byte from the nand chip
-*/
+ * nx_nand_read_byte - Read a byte from chip
+ * @mtd: MTD information structure
+ *
+ * Read a byte from the nand chip
+ */
 static uint8_t nx_nand_read_byte(struct mtd_info *mtd)
 {
-   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
-   uint16_t data;
+    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+    uint16_t data;
+
+    /* Read 16-bit word */
+    tmhwEfmc_ReadSingleData(nc->unitid, &data);
 
-   /* Read 16-bit word */
-   tmhwEfmc_ReadSingleData(nc->unitid, &data);
-   
-   return (uint8_t) cpu_to_le16(data);
+    return (uint8_t) cpu_to_le16(data);
 }
 
 /**
-* nx_nand_read_byte16 - Read a byte from 16bit chip
-* @mtd: MTD information structure
-*
-* Read a byte from the 16bit nand chip
-*/
+ * nx_nand_read_byte16 - Read a byte from 16bit chip
+ * @mtd: MTD information structure
+ *
+ * Read a byte from the 16bit nand chip
+ */
 static uint8_t nx_nand_read_byte16(struct mtd_info *mtd)
 {
-   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
-   uint16_t data;
+    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+    uint16_t data;
 
-   /* Read byte word */
-   tmhwEfmc_ReadSingleData(nc->unitid, &data);
-   
-   return (uint8_t) cpu_to_le16(data);
+    /* Read byte word */
+    tmhwEfmc_ReadSingleData(nc->unitid, &data);
+
+    return (uint8_t) cpu_to_le16(data);
 }
 
 /**
-* nx_nand_read_buf - Read data from chip
-* @mtd: MTD information structure
-* @buf: Data buffer
-* @len: Transfer size
-*
-* Read specified number of bytes from the driver buffer
-*/
+ * nx_nand_read_buf - Read data from chip
+ * @mtd: MTD information structure
+ * @buf: Data buffer
+ * @len: Transfer size
+ *
+ * Read specified number of bytes from the driver buffer
+ */
 static void nx_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
 {
-   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
-   
-   /* Copy from driver buffer */
-   memcpy(buf, nc->dmabuf + nc->offset, len);
-   nc->offset += len;
+    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+
+    /* Copy from driver buffer */
+    memcpy(buf, nc->dmabuf + nc->offset, len);
+    nc->offset += len;
 }
 
 /**
-* nx_nand_read_page_raw - Read 1 page data from chip
-* @mtd: MTD information structure
-* @chip: Chip information structure
-* @buf: Data buffer
-*
-* Read a full page + oob into the buffer
-*/
+ * nx_nand_read_page_raw - Read 1 page data from chip
+ * @mtd: MTD information structure
+ * @chip: Chip information structure
+ * @buf: Data buffer
+ *
+ * Read a full page + oob into the buffer
+ */
 static int nx_nand_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
-              uint8_t *buf, int page)
+        uint8_t *buf, int page)
 {
-   chip->read_buf(mtd, buf, mtd->writesize);
-   chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+    chip->read_buf(mtd, buf, mtd->writesize);
+    chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
 
-   return 0;
+    return 0;
 }
 
 #ifdef CONFIG_MTD_NX_NAND_HWECC
 /**
-* nx_nand_read_page - Read 1 page data from chip with HWECC
-* @mtd: MTD information structure
-* @chip: Chip information structure
-* @buf: Data buffer
-*
-* Read a full page + oob into the buffer
-*/
+ * nx_nand_read_page - Read 1 page data from chip with HWECC
+ * @mtd: MTD information structure
+ * @chip: Chip information structure
+ * @buf: Data buffer
+ *
+ * Read a full page + oob into the buffer
+ */
 static int nx_nand_read_page(struct mtd_info *mtd, struct nand_chip *chip,
-              uint8_t *buf, int page)
+        uint8_t *buf, int page)
 {
-   int stat=0, i;
-   uint32_t j;
-   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
-   int eccsteps = chip->ecc.steps;
-   int no_all_ffs=0;
-   
+    int stat=0, i;
+    uint32_t j;
+    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+    int eccsteps = chip->ecc.steps;
+    int no_all_ffs=0;
+
 #ifdef CONFIG_MTD_PERF_MEAS
-   volatile uint32_t start, end1;
+    volatile uint32_t start, end1;
 #endif
 
 #ifdef CONFIG_MTD_PERF_MEAS
-   start = readl(TSU_COUNTER_REG);
+    start = readl(TSU_COUNTER_REG);
 #endif
-   
-   /* Read page data */
-   nx_nand_read_page_raw(mtd, chip, buf, page);
-
-   /* Check ECC status */
-   for (i = 0 ; i<eccsteps; i++) {
-         
-      if(nc->ecc_status[i] == NX_NAND_INT_DEC_UNCOR) {
-   
-         for(j=0; j < mtd->writesize; j++) {
-            if(buf[j] != 0xFF) {
-               no_all_ffs = 1;
-               break;
-            }
-         }
-
-         if(no_all_ffs) {  
-            printk(KERN_INFO "step %d: ECC failed \r\n", j);   
-            mtd->ecc_stats.failed++;
-         }
-      }
-      else {
-         /* Update stats */   
-         switch (nc->ecc_status[i])
-         {
-            case NX_NAND_INT_DEC_1_ERR:
-               printk(KERN_INFO "step %d:ECC 1 bit corrected \r\n", i); 
-               stat = 1;
-               break;
-            
-            case NX_NAND_INT_DEC_2_ERR:
-               printk(KERN_INFO "step %d:ECC 2 bits corrected \r\n", i);   
-               stat = 2;
-               break;
-               
-            case NX_NAND_INT_DEC_3_ERR:
-               printk(KERN_INFO "step %d:ECC 3 bits corrected \r\n", i);   
-               stat = 3;
-               break;
-               
-            case NX_NAND_INT_DEC_4_ERR:
-               printk(KERN_INFO "step %d:ECC 4 bits corrected \r\n", i);   
-               stat = 4;
-               break;
-               
-            case NX_NAND_INT_DEC_5_ERR:
-               printk(KERN_INFO "step %d:ECC 5 bits corrected \r\n", i);   
-               stat = 5;
-               break;
-         }
-         mtd->ecc_stats.corrected += stat;
-      }
-   }
+
+    /* Read page data */
+    nx_nand_read_page_raw(mtd, chip, buf, page);
+
+    /* Check ECC status */
+    for (i = 0 ; i<eccsteps; i++) {
+
+        if(nc->ecc_status[i] == NX_NAND_INT_DEC_UNCOR) {
+
+            for(j=0; j < mtd->writesize; j++) {
+                if(buf[j] != 0xFF) {
+                    no_all_ffs = 1;
+                    break;
+                }
+            }
+
+            if(no_all_ffs) {  
+                printk(KERN_INFO "step %d: ECC failed \r\n", j);   
+                mtd->ecc_stats.failed++;
+            }
+        }
+        else {
+            /* Update stats */   
+            switch (nc->ecc_status[i])
+            {
+                case NX_NAND_INT_DEC_1_ERR:
+                    printk(KERN_INFO "step %d:ECC 1 bit corrected \r\n", i); 
+                    stat = 1;
+                    break;
+
+                case NX_NAND_INT_DEC_2_ERR:
+                    printk(KERN_INFO "step %d:ECC 2 bits corrected \r\n", i);   
+                    stat = 2;
+                    break;
+
+                case NX_NAND_INT_DEC_3_ERR:
+                    printk(KERN_INFO "step %d:ECC 3 bits corrected \r\n", i);   
+                    stat = 3;
+                    break;
+
+                case NX_NAND_INT_DEC_4_ERR:
+                    printk(KERN_INFO "step %d:ECC 4 bits corrected \r\n", i);   
+                    stat = 4;
+                    break;
+
+                case NX_NAND_INT_DEC_5_ERR:
+                    printk(KERN_INFO "step %d:ECC 5 bits corrected \r\n", i);   
+                    stat = 5;
+                    break;
+            }
+            mtd->ecc_stats.corrected += stat;
+        }
+    }
 
 #ifdef CONFIG_MTD_PERF_MEAS
-   end1 = readl(TSU_COUNTER_REG);
-   nand_perf_meas(mtd, start, end1, MTD_MEAS_READ);
+    end1 = readl(TSU_COUNTER_REG);
+    nand_perf_meas(mtd, start, end1, MTD_MEAS_READ);
 #endif
-   
-   return 0;
+
+    return 0;
 }
 #endif
 
 /**
-* nx_nand_read_oob - Read OOB data
-* @mtd: MTD information structure
-* @chip: Chip information structure
-* @page: Page address
-* @sndcmd: Send command flag
-*
-* Read OOB data into the buffer
-*/
+ * nx_nand_read_oob - Read OOB data
+ * @mtd: MTD information structure
+ * @chip: Chip information structure
+ * @page: Page address
+ * @sndcmd: Send command flag
+ *
+ * Read OOB data into the buffer
+ */
 static int nx_nand_read_oob(struct mtd_info *mtd, struct nand_chip *chip,
-              int page, int sndcmd)
+        int page, int sndcmd)
 {
-   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
-   uint8_t *buf = chip->oob_poi;
-   int status = 0;
-  int length = mtd->oobsize;
-   int column, addr, i;
-   uint16_t data;
-   tmhwEfmc_PageConfig_t   page_cfg;
-
-   if(mtd->flags & MTD_USE_DEV_OOB_LAYOUT) {
-   
-      /* Use Device OOB layout (Main page data followed by OOB data) */    
-      /* No page operation  for OOB */
-      page_cfg.includeOOB = true;
-      page_cfg.operType = tmhwEfmc_Nothing;
-      page_cfg.includeAES = false;
-      page_cfg.includeECC = false;
-      tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
-   
-      /* Send READOOB command */ 
-      if(sndcmd) {
-         chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
-      }
-   
-      /* Check if CE DON't care is supported */
-      column = nc->cur_col;
-      i = 0;
-      while(length) {
-      
-         /* Send Address & cmd cycles */
-         if(sndcmd) {
-         
-            nx_nand_cmd_addr(nc, 1, nc->cur_cmd, 0);
-   
-            if(nc->lb_chip) {
-               addr = column & NX_NAND_SP_ADDR_MASK;
-               nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-               addr = (column >> 8) & NX_NAND_SP_ADDR_MASK;
-               nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-               addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-               nx_nand_cmd_addr(nc, 0, addr, 0);
-               
-               addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-               nx_nand_cmd_addr(nc, 0, addr, 0);
-         
-               /* if > 2Gb, extra address cycle */
-               if (nc->chip.chipsize >= (1 << 28)) {
-                  addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-                  nx_nand_cmd_addr(nc, 0, addr, 0);
-               }
-            
-               /* Send Read confirm command */
-               nx_nand_cmd_addr(nc, 1, NAND_CMD_READSTART, 1);
+    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+    uint8_t *buf = chip->oob_poi;
+    int status = 0;
+    int length = mtd->oobsize;
+    int column, addr, i;
+    uint16_t data;
+    tmhwEfmc_PageConfig_t   page_cfg;
+
+    if(mtd->flags & MTD_USE_DEV_OOB_LAYOUT) {
+
+        /* Use Device OOB layout (Main page data followed by OOB data) */    
+        /* No page operation  for OOB */
+        page_cfg.includeOOB = true;
+        page_cfg.operType = tmhwEfmc_Nothing;
+        page_cfg.includeAES = false;
+        page_cfg.includeECC = false;
+        tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+
+        /* Send READOOB command */ 
+        if(sndcmd) {
+            chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
+        }
+
+        /* Check if CE DON't care is supported */
+        column = nc->cur_col;
+        i = 0;
+        while(length) {
+
+            /* Send Address & cmd cycles */
+            if(sndcmd) {
+
+                nx_nand_cmd_addr(nc, 1, nc->cur_cmd, 0);
+
+                if(nc->lb_chip) {
+                    addr = column & NX_NAND_SP_ADDR_MASK;
+                    nx_nand_cmd_addr(nc, 0, addr, 0);
+
+                    addr = (column >> 8) & NX_NAND_SP_ADDR_MASK;
+                    nx_nand_cmd_addr(nc, 0, addr, 0);
+
+                    addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+                    nx_nand_cmd_addr(nc, 0, addr, 0);
+
+                    addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+                    nx_nand_cmd_addr(nc, 0, addr, 0);
+
+                    /* if > 2Gb, extra address cycle */
+                    if (nc->chip.chipsize >= (1 << 28)) {
+                        addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+                        nx_nand_cmd_addr(nc, 0, addr, 0);
+                    }
+
+                    /* Send Read confirm command */
+                    nx_nand_cmd_addr(nc, 1, NAND_CMD_READSTART, 1);
+                }
+                else {
+                    addr = column & NX_NAND_SP_ADDR_MASK;
+                    nx_nand_cmd_addr(nc, 0, addr, 0);
+
+                    addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+                    nx_nand_cmd_addr(nc, 0, addr, 0);
+
+                    /* if > 64Mb, extra adddress cycle */
+                    if (nc->chip.chipsize > (32 << 20)) {
+                        addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+                        nx_nand_cmd_addr(nc, 0, addr, 0);
+
+                        addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+                        nx_nand_cmd_addr(nc, 0, addr, 1);
+                    }
+                    else {
+                        addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+                        nx_nand_cmd_addr(nc, 0, addr, 1);
+                    }
+                }
+                sndcmd = 0;
+
+                /* Wait for completion */
+                udelay(chip->chip_delay);
             }
-            else {
-               addr = column & NX_NAND_SP_ADDR_MASK;
-               nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-               addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-               nx_nand_cmd_addr(nc, 0, addr, 0);
-         
-               /* if > 64Mb, extra adddress cycle */
-               if (nc->chip.chipsize > (32 << 20)) {
-                  addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-                  nx_nand_cmd_addr(nc, 0, addr, 0);
-               
-                  addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-                  nx_nand_cmd_addr(nc, 0, addr, 1);
-               }
-               else {
-                  addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-                  nx_nand_cmd_addr(nc, 0, addr, 1);
-               }
+
+            /* Write data into chip */
+            status  = tmhwEfmc_ReadSingleData(nc->unitid, &data);    
+            buf[i] = (uint8_t) data; 
+            //printk(KERN_INFO "ReadSingle data 0x%x 0x%x \r\n", buf[i], data);
+
+            length--;
+            i++;
+
+            if(!nx_nc->cedontcare) {
+                sndcmd = 1; 
+                column++;
             }
+        }
+    }
+    else {
+        /* Use IP_2017 OOB layout - (512 Bytes data + 16 bytes OOB data) */
+        /* Use IP_2017 OOB layout - Read page */
+
+        /* Send READOOB command */ 
+        if(sndcmd) {
+            chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
             sndcmd = 0;
+        }
+
+        /* Copy into user buffer */
+        nc->offset = mtd->writesize;
+        chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+    }
 
-            /* Wait for completion */
-            udelay(chip->chip_delay);
-         }
-
-         /* Write data into chip */
-         status  = tmhwEfmc_ReadSingleData(nc->unitid, &data);    
-         buf[i] = (uint8_t) data; 
-         //printk(KERN_INFO "ReadSingle data 0x%x 0x%x \r\n", buf[i], data);
-      
-         length--;
-         i++;
-      
-         if(!nx_nc->cedontcare) {
-            sndcmd = 1; 
-            column++;
-         }
-      }
-   }
-   else {
-      /* Use IP_2017 OOB layout - (512 Bytes data + 16 bytes OOB data) */
-      /* Use IP_2017 OOB layout - Read page */
-         
-      /* Send READOOB command */ 
-      if(sndcmd) {
-         chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
-         sndcmd = 0;
-      }
-
-      /* Copy into user buffer */
-      nc->offset = mtd->writesize;
-      chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
-   }
-   
-   return 0;
+    return 0;
 }
 
 /**
-* nx_nand_write_buf - Write data into chip
-* @mtd: MTD information structure
-* @buf: Data buffer
-* @len: Transfer size
-*
-* Write specified number of bytes into the nand chip
-*/
+ * nx_nand_write_buf - Write data into chip
+ * @mtd: MTD information structure
+ * @buf: Data buffer
+ * @len: Transfer size
+ *
+ * Write specified number of bytes into the nand chip
+ */
 static void nx_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, 
-      int len)
+        int len)
 {
-   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
 
-   /* Copy data to driver buffer */
-   memcpy(nc->dmabuf + nc->offset, buf, len);
-   nc->offset += len;
+    /* Copy data to driver buffer */
+    memcpy(nc->dmabuf + nc->offset, buf, len);
+    nc->offset += len;
 }
 
 /**
-* nx_nand_write_page_raw - Write 1 page data into chip
-* @mtd: MTD information structure
-* @chip: Chip information structure
-* @buf: Data buffer
-*
-* Write a full page + oob into the buffer
-*/
+ * nx_nand_write_page_raw - Write 1 page data into chip
+ * @mtd: MTD information structure
+ * @chip: Chip information structure
+ * @buf: Data buffer
+ *
+ * Write a full page + oob into the buffer
+ */
 static void nx_nand_write_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
-              const uint8_t *buf)
+        const uint8_t *buf)
 {
-   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
-   uint32_t intr=0;
-   uint16_t addr;
-   tmhwEfmc_PageConfig_t page_cfg;
+    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+    uint32_t intr=0;
+    uint16_t addr;
+    tmhwEfmc_PageConfig_t page_cfg;
 
 #ifdef CONFIG_MTD_NX_NAND_DMAC   
-   int chanid, status;
-   tmhwEfmc_DmaConfig_t dma_cfg;
-   nx_dmac_tfr_t           req;
-   nx_dmac_stgt_t       stgt[(mtd->writesize/NX_NAND_BLK_SIZE)+1];
+    int chanid, status;
+    tmhwEfmc_DmaConfig_t dma_cfg;
+    nx_dmac_tfr_t           req;
+    nx_dmac_stgt_t       stgt[(mtd->writesize/NX_NAND_BLK_SIZE)+1];
 #endif
 
 #ifdef CONFIG_MTD_PERF_MEAS
-   uint32_t start, end1;
+    uint32_t start, end1;
 #endif
 
 #ifdef CONFIG_MTD_PERF_MEAS
-   start = readl(TSU_COUNTER_REG);
+    start = readl(TSU_COUNTER_REG);
 #endif
-   
-   /* Copy data into buffer */
-   chip->write_buf(mtd, buf, mtd->writesize);
-   chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+    /* Copy data into buffer */
+    chip->write_buf(mtd, buf, mtd->writesize);
+    chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
 
 #ifdef CONFIG_MTD_NX_NAND_DMAC   
-   
-   /* Scatter gather list for DMAC */
-   nx_nand_dmac_init(nc, 0, &req, stgt);
-   
-   /* Flow control */
-   dma_cfg.enableM2PDma = tmhwEfmc_Enable;
-   dma_cfg.enableP2MDma = tmhwEfmc_Disable;
-   tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
-
-   chanid = nx_dmac_tfr(&req);
-   if(chanid < 0) {
-      printk(KERN_ERR "nx_nand: NAND_SEQIN DMAC config \r\n"); 
-      return;
-   }
-
-   /* Page operation */
-   page_cfg.includeOOB = true;
-   page_cfg.operType = tmhwEfmc_PageWrite;
-   
-   if(nc->aes) {
-      page_cfg.includeAES = true;
-   }
-   else {
-      page_cfg.includeAES = false;
-   }
-   
-   if(nc->hwecc) {
-      page_cfg.includeECC = true;
-   }
-   else {
-      page_cfg.includeECC = false;
-   }
-   tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
-   
-   /* Clear the interrupts */
-   intr = NX_NAND_INT_SEQ_WRITE;
-   intr |= 1 << (NX_NAND_INT_READY_START + nc->slotid);
-   tmhwEfmc_IntClear(nc->unitid, intr);
-   
-   /* Enable the SEQ READ PAGE DONE interrupt */
-   tmhwEfmc_IntEnable(nc->unitid, intr);
-
-   /* Send address cycles & command */
-   nc->done = false;
-   nx_nand_cmd_addr(nc, 1, NAND_CMD_SEQIN, 0);
-   
-   if(nc->lb_chip) {
-      addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-      addr = (nc->cur_col >> 8) & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-      addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-         
-      addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-      /* if > 2Gb, extra address cycle */
-      if (nc->chip.chipsize >= (1 << 28)) {
-         addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-         nx_nand_cmd_addr(nc, 0, addr, 0);
-      }
-   }
-   else {
-      addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-      addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-         
-      addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-
-      /* if > 64Mb, extra adddress cycle */
-      if (nc->chip.chipsize > (32 << 20)) {
-         addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-         nx_nand_cmd_addr(nc, 0, addr, 0);
-      }
-   }
-   
-   /* Send post write command */
-   nx_nand_cmd_addr(nc, 2, NAND_CMD_PAGEPROG, 1);
-
-   /* Complete DMAC transfer */
-   status = nx_dmac_tfr_comp(chanid);
-   if(status) {
-      printk(KERN_ERR "nx_nand: write_page_raw \r\n");   
-      return;
-   }
-   
-   /* Wait for READY interrupt */   
-   wait_event(nc->nand_queue, (nc->done != false));
-   
-   /* Disable interrupts */   
-   tmhwEfmc_IntDisable(nc->unitid, intr);
-      
-   /* Disable Flow control */
-   dma_cfg.enableM2PDma = tmhwEfmc_Disable;
-   dma_cfg.enableP2MDma = tmhwEfmc_Disable;
-   tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
-   
+
+    /* Scatter gather list for DMAC */
+    nx_nand_dmac_init(nc, 0, &req, stgt);
+
+    /* Flow control */
+    dma_cfg.enableM2PDma = tmhwEfmc_Enable;
+    dma_cfg.enableP2MDma = tmhwEfmc_Disable;
+    tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
+
+    chanid = nx_dmac_tfr(&req);
+    if(chanid < 0) {
+        printk(KERN_ERR "nx_nand: NAND_SEQIN DMAC config \r\n"); 
+        return;
+    }
+
+    /* Page operation */
+    page_cfg.includeOOB = true;
+    page_cfg.operType = tmhwEfmc_PageWrite;
+
+    if(nc->aes) {
+        page_cfg.includeAES = true;
+    }
+    else {
+        page_cfg.includeAES = false;
+    }
+
+    if(nc->hwecc) {
+        page_cfg.includeECC = true;
+    }
+    else {
+        page_cfg.includeECC = false;
+    }
+    tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+
+    /* Clear the interrupts */
+    intr = NX_NAND_INT_SEQ_WRITE;
+    intr |= 1 << (NX_NAND_INT_READY_START + nc->slotid);
+    tmhwEfmc_IntClear(nc->unitid, intr);
+
+    /* Enable the SEQ READ PAGE DONE interrupt */
+    tmhwEfmc_IntEnable(nc->unitid, intr);
+
+    /* Send address cycles & command */
+    nc->done = false;
+    nx_nand_cmd_addr(nc, 1, NAND_CMD_SEQIN, 0);
+
+    if(nc->lb_chip) {
+        addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
+        nx_nand_cmd_addr(nc, 0, addr, 0);
+
+        addr = (nc->cur_col >> 8) & NX_NAND_SP_ADDR_MASK;
+        nx_nand_cmd_addr(nc, 0, addr, 0);
+
+        addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+        nx_nand_cmd_addr(nc, 0, addr, 0);
+
+        addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+        nx_nand_cmd_addr(nc, 0, addr, 0);
+
+        /* if > 2Gb, extra address cycle */
+        if (nc->chip.chipsize >= (1 << 28)) {
+            addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+            nx_nand_cmd_addr(nc, 0, addr, 0);
+        }
+    }
+    else {
+        addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
+        nx_nand_cmd_addr(nc, 0, addr, 0);
+
+        addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+        nx_nand_cmd_addr(nc, 0, addr, 0);
+
+        addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+        nx_nand_cmd_addr(nc, 0, addr, 0);
+
+        /* if > 64Mb, extra adddress cycle */
+        if (nc->chip.chipsize > (32 << 20)) {
+            addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+            nx_nand_cmd_addr(nc, 0, addr, 0);
+        }
+    }
+
+    /* Send post write command */
+    nx_nand_cmd_addr(nc, 2, NAND_CMD_PAGEPROG, 1);
+
+    /* Complete DMAC transfer */
+    status = nx_dmac_tfr_comp(chanid);
+    if(status) {
+        printk(KERN_ERR "nx_nand: write_page_raw \r\n");   
+        return;
+    }
+
+    /* Wait for READY interrupt */   
+    wait_event(nc->nand_queue, (nc->done != false));
+
+    /* Disable interrupts */   
+    tmhwEfmc_IntDisable(nc->unitid, intr);
+
+    /* Disable Flow control */
+    dma_cfg.enableM2PDma = tmhwEfmc_Disable;
+    dma_cfg.enableP2MDma = tmhwEfmc_Disable;
+    tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
+
 #else 
-   
-   /* Init page operation */
-   nc->blk_index = 0;
-
-   /* Send Cmd & address to chip */
-   page_cfg.includeOOB = true;
-   page_cfg.operType = tmhwEfmc_PageWrite;
-   if(nc->aes) {
-      intr |= NX_NAND_INT_AES_DEC;
-      page_cfg.includeAES = true;
-   }
-   else {
-      page_cfg.includeAES = false;
-   }
-
-   if(nc->hwecc) {
-      intr |= NX_NAND_INT_ENC;
-      page_cfg.includeECC = true;
-   }
-   else {
-      page_cfg.includeECC = false;
-      intr |= NX_NAND_INT_BLK_WRITE;
-   }
-   tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
-
-   /* Int Enable */
-   intr |= (NX_NAND_INT_OOB_WRITE | (1 << (NX_NAND_INT_READY_START + nc->slotid)));
-   tmhwEfmc_IntClear(nc->unitid, intr);
-   tmhwEfmc_IntEnable(nc->unitid, intr);
-   
-   /* Send the address commands to chip */
-   nc->done = false;
-   nx_nand_cmd_addr(nc,1, NAND_CMD_SEQIN, 0);
-   
-   if(nc->lb_chip) {
-      addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-      addr = (nc->cur_col >> 8) & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-      addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-      addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-      if (nc->chip.chipsize >= (1 << 28)) {
+
+    /* Init page operation */
+    nc->blk_index = 0;
+
+    /* Send Cmd & address to chip */
+    page_cfg.includeOOB = true;
+    page_cfg.operType = tmhwEfmc_PageWrite;
+    if(nc->aes) {
+        intr |= NX_NAND_INT_AES_DEC;
+        page_cfg.includeAES = true;
+    }
+    else {
+        page_cfg.includeAES = false;
+    }
+
+    if(nc->hwecc) {
+        intr |= NX_NAND_INT_ENC;
+        page_cfg.includeECC = true;
+    }
+    else {
+        page_cfg.includeECC = false;
+        intr |= NX_NAND_INT_BLK_WRITE;
+    }
+    tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+
+    /* Int Enable */
+    intr |= (NX_NAND_INT_OOB_WRITE | (1 << (NX_NAND_INT_READY_START + nc->slotid)));
+    tmhwEfmc_IntClear(nc->unitid, intr);
+    tmhwEfmc_IntEnable(nc->unitid, intr);
+
+    /* Send the address commands to chip */
+    nc->done = false;
+    nx_nand_cmd_addr(nc,1, NAND_CMD_SEQIN, 0);
+
+    if(nc->lb_chip) {
+        addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
+        nx_nand_cmd_addr(nc, 0, addr, 0);
+
+        addr = (nc->cur_col >> 8) & NX_NAND_SP_ADDR_MASK;
+        nx_nand_cmd_addr(nc, 0, addr, 0);
+
+        addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+        nx_nand_cmd_addr(nc, 0, addr, 0);
+
+        addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+        nx_nand_cmd_addr(nc, 0, addr, 0);
+
+        if (nc->chip.chipsize >= (1 << 28)) {
             addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
             nx_nand_cmd_addr(nc, 0, addr, 0);
-      }
-   }
-   else {
-      addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-      addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-      addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-      if (nc->chip.chipsize > (32 << 20)) {
-         addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-         nx_nand_cmd_addr(nc, 0, addr, 0);
-      }
-   }
-   
-   /* Post write command */
-   nx_nand_cmd_addr(nc, 2, NAND_CMD_PAGEPROG, 1);
-   
-   /* Wait for READY interrupt */   
-   wait_event(nc->nand_queue, (nc->done != false));
+        }
+    }
+    else {
+        addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
+        nx_nand_cmd_addr(nc, 0, addr, 0);
+
+        addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+        nx_nand_cmd_addr(nc, 0, addr, 0);
 
-   /* Disable interrupts */
-   tmhwEfmc_IntDisable(nc->unitid, intr);
+        addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+        nx_nand_cmd_addr(nc, 0, addr, 0);
+
+        if (nc->chip.chipsize > (32 << 20)) {
+            addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+            nx_nand_cmd_addr(nc, 0, addr, 0);
+        }
+    }
+
+    /* Post write command */
+    nx_nand_cmd_addr(nc, 2, NAND_CMD_PAGEPROG, 1);
+
+    /* Wait for READY interrupt */   
+    wait_event(nc->nand_queue, (nc->done != false));
+
+    /* Disable interrupts */
+    tmhwEfmc_IntDisable(nc->unitid, intr);
 
 #endif
 
 #ifdef CONFIG_MTD_PERF_MEAS
-   end1 = readl(TSU_COUNTER_REG);
-   nand_perf_meas(mtd, start, end1, MTD_MEAS_WRITE);
+    end1 = readl(TSU_COUNTER_REG);
+    nand_perf_meas(mtd, start, end1, MTD_MEAS_WRITE);
 #endif
-   
-   return;
+
+    return;
 }
 
 #ifdef CONFIG_MTD_NX_NAND_HWECC
 /**
-* nx_nand_write_page - Write 1 page data into chip when HW ECC enabled
-* @mtd: MTD information structure
-* @chip: Chip information structure
-* @buf: Data buffer
-*
-* Write a full page + oob into the buffer
-*/
+ * nx_nand_write_page - Write 1 page data into chip when HW ECC enabled
+ * @mtd: MTD information structure
+ * @chip: Chip information structure
+ * @buf: Data buffer
+ *
+ * Write a full page + oob into the buffer
+ */
 static void nx_nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
-              const uint8_t *buf)
+        const uint8_t *buf)
 {
 
 #ifdef CONFIG_MTD_PERF_MEAS
-   uint32_t start, end1;
+    uint32_t start, end1;
 #endif
 
 #ifdef CONFIG_MTD_PERF_MEAS
-   start = readl(TSU_COUNTER_REG);
+    start = readl(TSU_COUNTER_REG);
 #endif
-   
-   nx_nand_write_page_raw(mtd, chip, buf);
-   
+
+    nx_nand_write_page_raw(mtd, chip, buf);
+
 #ifdef CONFIG_MTD_PERF_MEAS
-   end1 = readl(TSU_COUNTER_REG);
-   nand_perf_meas(mtd, start, end1, MTD_MEAS_WRITE);
+    end1 = readl(TSU_COUNTER_REG);
+    nand_perf_meas(mtd, start, end1, MTD_MEAS_WRITE);
 #endif
-   
-   return;
+
+    return;
 }
 #endif
 
@@ -1128,749 +1129,789 @@ static u_char temp_buf[NAND_MAX_PAGESIZE
 #define  OOB_BYTES_PER_BLK  (16)
 
 /**
-* nx_nand_write_oob - Write OOB data
-* @mtd: MTD information structure
-* @chip: Chip information structure
-* @page: Page address
-*
-* Write OOB data into the chip
-*/
+ * nx_nand_write_oob - Write OOB data
+ * @mtd: MTD information structure
+ * @chip: Chip information structure
+ * @page: Page address
+ *
+ * Write OOB data into the chip
+ */
 static int nx_nand_write_oob(struct mtd_info *mtd, struct nand_chip *chip,
-              int page)
+        int page)
 {
 
-   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
-   int status = 0;
-   int sndcmd = 1;
-  const uint8_t *buf = chip->oob_poi;
-  int length;
-   int column, addr, i;
-   uint16_t data;
-   tmhwEfmc_PageConfig_t   page_cfg;
-   bool  ecc_old, aes_old;
-   u_char *temp1;
-   uint8_t   *oob_poi_orig;
-   
-   if(mtd->flags & MTD_USE_DEV_OOB_LAYOUT) {
-      /* Use Device OOB layout -  write only OOB data */    
-      /* No page operation */
-      page_cfg.includeOOB = true;
-      page_cfg.operType = tmhwEfmc_Nothing;
-      page_cfg.includeAES = false;
-      page_cfg.includeECC = false;
-      tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
-
-      /* Send SEQIN command */
-      chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
-
-      /* Write to driver buffer */
-      length = mtd->oobsize;
-      chip->write_buf(mtd, buf, length);
-
-      /* Check if CE DON't care is supported */
-      column = nc->cur_col;
-      i = 0;
-      while(length) {
-         /* Send Address & cmd cycles */
-         if(sndcmd) {
-            nx_nand_cmd_addr(nc, 1, NAND_CMD_SEQIN, 0);
-   
-            if(nc->lb_chip) {
-               addr = column & NX_NAND_SP_ADDR_MASK;
-               nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-               addr = (column >> 8) & NX_NAND_SP_ADDR_MASK;
-               nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-               addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-               nx_nand_cmd_addr(nc, 0, addr, 0);
-               
-               /* if > 2Gb, extra address cycle */
-               if (nc->chip.chipsize >= (1 << 28)) {
-                  addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-                  nx_nand_cmd_addr(nc, 0, addr, 0);
-               
-                  addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-                  nx_nand_cmd_addr(nc, 0, addr, 1);
-               }
-               else {
-                  addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-                  nx_nand_cmd_addr(nc, 0, addr, 1);
-               }
+    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+    int status = 0;
+    int sndcmd = 1;
+    const uint8_t *buf = chip->oob_poi;
+    int length;
+    int column, addr, i;
+    uint16_t data;
+    tmhwEfmc_PageConfig_t   page_cfg;
+    bool  ecc_old, aes_old;
+    u_char *temp1;
+    uint8_t   *oob_poi_orig;
+
+    if(mtd->flags & MTD_USE_DEV_OOB_LAYOUT) {
+        /* Use Device OOB layout -  write only OOB data */    
+        /* No page operation */
+        page_cfg.includeOOB = true;
+        page_cfg.operType = tmhwEfmc_Nothing;
+        page_cfg.includeAES = false;
+        page_cfg.includeECC = false;
+        tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+
+        /* Send SEQIN command */
+        chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
+
+        /* Write to driver buffer */
+        length = mtd->oobsize;
+        chip->write_buf(mtd, buf, length);
+
+        /* Check if CE DON't care is supported */
+        column = nc->cur_col;
+        i = 0;
+        while(length) {
+            /* Send Address & cmd cycles */
+            if(sndcmd) {
+                nx_nand_cmd_addr(nc, 1, NAND_CMD_SEQIN, 0);
+
+                if(nc->lb_chip) {
+                    addr = column & NX_NAND_SP_ADDR_MASK;
+                    nx_nand_cmd_addr(nc, 0, addr, 0);
+
+                    addr = (column >> 8) & NX_NAND_SP_ADDR_MASK;
+                    nx_nand_cmd_addr(nc, 0, addr, 0);
+
+                    addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+                    nx_nand_cmd_addr(nc, 0, addr, 0);
+
+                    /* if > 2Gb, extra address cycle */
+                    if (nc->chip.chipsize >= (1 << 28)) {
+                        addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+                        nx_nand_cmd_addr(nc, 0, addr, 0);
+
+                        addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+                        nx_nand_cmd_addr(nc, 0, addr, 1);
+                    }
+                    else {
+                        addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+                        nx_nand_cmd_addr(nc, 0, addr, 1);
+                    }
+                }
+                else {
+                    addr = column & NX_NAND_SP_ADDR_MASK;
+                    nx_nand_cmd_addr(nc, 0, addr, 0);
+
+                    addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+                    nx_nand_cmd_addr(nc, 0, addr, 0);
+
+                    /* if > 64Mb, extra adddress cycle */
+                    if (nc->chip.chipsize > (32 << 20)) {
+                        addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+                        nx_nand_cmd_addr(nc, 0, addr, 0);
+
+                        addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+                        nx_nand_cmd_addr(nc, 0, addr, 1);
+                    }
+                    else {
+                        addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+                        nx_nand_cmd_addr(nc, 0, addr, 1);
+                    }
+                }
+                sndcmd = 0;
             }
-            else {
-               addr = column & NX_NAND_SP_ADDR_MASK;
-               nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-               addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-               nx_nand_cmd_addr(nc, 0, addr, 0);
-         
-               /* if > 64Mb, extra adddress cycle */
-               if (nc->chip.chipsize > (32 << 20)) {
-                  addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-                  nx_nand_cmd_addr(nc, 0, addr, 0);
-               
-                  addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-                  nx_nand_cmd_addr(nc, 0, addr, 1);
-               }
-               else {
-                  addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-                  nx_nand_cmd_addr(nc, 0, addr, 1);
-               }
+
+            /* Write data into chip */
+            data = buf[i];
+            status  = tmhwEfmc_WriteSingleData(nc->unitid, data);    
+
+            length--;
+            i++;
+
+            if(!nx_nc->cedontcare) {
+                sndcmd = 1; 
+                column++;
             }
-            sndcmd = 0;
-         }
+        }
 
-         /* Write data into chip */
-         data = buf[i];
-         status  = tmhwEfmc_WriteSingleData(nc->unitid, data);    
-      
-         length--;
-         i++;
-      
-         if(!nx_nc->cedontcare) {
-            sndcmd = 1; 
-            column++;
-         }
-      }
-   
-      /* write  confirm command */
-      nx_nand_cmd_addr(nc, 1, NAND_CMD_PAGEPROG, 1);
-      }
-      else {
-         /* Use IP_2017 OOB layout - write page */
-         /* Store ECC,AES values & Disbale */   
-         ecc_old = nc->hwecc;
-         aes_old = nc->aes;
-         oob_poi_orig = chip->oob_poi;
-         nc->hwecc = false;
-         nc->aes = false;
-      
-         /* Send SEQIN command */
-         chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0, page);
-         
-         /* Initialise temp_buf */
-         memset(temp_buf, 0xff, (mtd->writesize + mtd->oobsize));
-
-         /* copy OOB */ 
-         temp1 = temp_buf;
-         for(i=0; i < nc->num_blks; i++) {
+        /* write  confirm command */
+        nx_nand_cmd_addr(nc, 1, NAND_CMD_PAGEPROG, 1);
+    }
+    else {
+        /* Use IP_2017 OOB layout - write page */
+        /* Store ECC,AES values & Disbale */   
+        ecc_old = nc->hwecc;
+        aes_old = nc->aes;
+        oob_poi_orig = chip->oob_poi;
+        nc->hwecc = false;
+        nc->aes = false;
+
+        /* Send SEQIN command */
+        chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0, page);
+
+        /* Initialise temp_buf */
+        memset(temp_buf, 0xff, (mtd->writesize + mtd->oobsize));
+
+        /* copy OOB */ 
+        temp1 = temp_buf;
+        for(i=0; i < nc->num_blks; i++) {
             temp1 += NX_NAND_BLK_SIZE;
             memcpy(temp1, (chip->oob_poi + (i * OOB_BYTES_PER_BLK)), OOB_BYTES_PER_BLK);
             temp1 += OOB_BYTES_PER_BLK;   
-         }
-         chip->oob_poi = &temp_buf[mtd->writesize];
+        }
+        chip->oob_poi = &temp_buf[mtd->writesize];
+
+        /* Call write page raw */
+        nx_nand_write_page_raw(mtd, chip, temp_buf);
+
+        /* Restore ECC,AES values */  
+        chip->oob_poi = oob_poi_orig;
+        nc->hwecc = ecc_old;
+        nc->aes = aes_old;
+    }
 
-         /* Call write page raw */
-         nx_nand_write_page_raw(mtd, chip, temp_buf);
+    /* Send command to program the OOB data */
+    chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
 
-         /* Restore ECC,AES values */  
-         chip->oob_poi = oob_poi_orig;
-         nc->hwecc = ecc_old;
-         nc->aes = aes_old;
-   }
-   
-   /* Send command to program the OOB data */
-  chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
-
-  status = chip->waitfunc(mtd, chip);
-
-  return status & NAND_STATUS_FAIL ? -EIO : 0;
+    status = chip->waitfunc(mtd, chip);
+
+    return status & NAND_STATUS_FAIL ? -EIO : 0;
 }
 
 /**
-* nx_nand_command - Command function for small page chips
-* @mtd: MTD information structure
-* @cmd: Command
-* @column: Column address
-* @page_addr: Page address
-*
-* Command control function:
-*/
+ * nx_nand_command - Command function for small page chips
+ * @mtd: MTD information structure
+ * @cmd: Command
+ * @column: Column address
+ * @page_addr: Page address
+ *
+ * Command control function:
+ */
 static void nx_nand_command(struct mtd_info *mtd, unsigned int cmd,
-              int column, int page_addr)
+        int column, int page_addr)
 {
-   tmhwEfmc_PageConfig_t   page_cfg;
-   uint16_t addr;
-   uint32_t intr=0;
-   int   status;
-   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+    tmhwEfmc_PageConfig_t   page_cfg;
+    uint16_t addr;
+    uint32_t intr=0;
+    int   status, i;
+    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
 
 #ifdef CONFIG_MTD_NX_NAND_DMAC 
-   int   chanid;
-   tmhwEfmc_DmaConfig_t dma_cfg;
-   nx_dmac_tfr_t           req;
-   nx_dmac_stgt_t       stgt[(mtd->writesize/NX_NAND_BLK_SIZE)+1];
-#endif
-
-   /* Store the command, colmn & page address */
-   nc->cur_cmd = cmd;
-   if(column == -1)
-      column = 0;
-   nc->cur_col = column;
-   if(page_addr == -1)
-      page_addr = 0;
-   nc->cur_page = page_addr;
-
-   /*
-    * Issue the correct first command, when we write to
-    * the device.
-    */
-   switch(cmd) {
-   case NAND_CMD_SEQIN:
-      nc->offset = 0;
-      /* Address cycles & command will be sent in write_page_raw */
-      break;
+    int   chanid;
+    tmhwEfmc_DmaConfig_t dma_cfg;
+    nx_dmac_tfr_t           req;
+    nx_dmac_stgt_t       stgt[(mtd->writesize/NX_NAND_BLK_SIZE)+1];
+#endif
+
+    /* Store the command, colmn & page address */
+    nc->cur_cmd = cmd;
+    if(column == -1)
+        column = 0;
+    nc->cur_col = column;
+    if(page_addr == -1)
+        page_addr = 0;
+    nc->cur_page = page_addr;
+
+    /*
+     * Issue the correct first command, when we write to
+     * the device.
+     */
+    switch(cmd) {
+        case NAND_CMD_SEQIN:
+            nc->offset = 0;
+            /* Address cycles & command will be sent in write_page_raw */
+            break;
 
 #ifdef CONFIG_MTD_NX_NAND_DMAC 
-   case NAND_CMD_PAGEPROG:
-      break;
-      
-   case NAND_CMD_RESET:
-   case NAND_CMD_STATUS:
-      nx_nand_cmd_addr(nc, 1, cmd, 1);
-      break;
-      
+        case NAND_CMD_PAGEPROG:
+            break;
+
+        case NAND_CMD_RESET:
+        case NAND_CMD_STATUS:
+            nx_nand_cmd_addr(nc, 1, cmd, 1);
+            break;
+
 #else 
-   case NAND_CMD_PAGEPROG:
-      /* Post write command feature used */
-      break;
-   
-   case NAND_CMD_RESET:
-   case NAND_CMD_STATUS:
-      nx_nand_cmd_addr(nc, 1, cmd, 1);
-      break;
-#endif
-
-   case NAND_CMD_ERASE1:
-      /* Enable READY interupt */
-      intr |= (1 << (NX_NAND_INT_READY_START + nc->slotid));
-      tmhwEfmc_IntClear(nc->unitid, intr);
-      tmhwEfmc_IntEnable(nc->unitid, intr);
-      
-      /* Send address cycles & command */
-      nc->done = false;
-      
-      nx_nand_cmd_addr(nc, 1, NAND_CMD_ERASE1, 0);
-      
-      addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-      addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-      if (nc->chip.chipsize > (32 << 20)) {
-         addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-         nx_nand_cmd_addr(nc, 0, addr, 0);
-      }
-      
-      nx_nand_cmd_addr(nc, 1, NAND_CMD_ERASE2, 1);
-      
-      /* Wait for the completion */ 
-      wait_event(nc->nand_queue, (nc->done != false));
-      
-      /* Disable READY interrupt */
-      tmhwEfmc_IntDisable(nc->unitid, intr);
-
-      break;
-
-   case NAND_CMD_ERASE2:
-      /* Already done in CMD_ERASE1 */
-      break;
+        case NAND_CMD_PAGEPROG:
+            /* Post write command feature used */
+            break;
+
+        case NAND_CMD_RESET:
+        case NAND_CMD_STATUS:
+            nx_nand_cmd_addr(nc, 1, cmd, 1);
+            break;
+#endif
 
-   case NAND_CMD_READ0:
-      nc->offset = 0;
+        case NAND_CMD_ERASE1:
+            /* Enable READY interupt */
+            intr |= (1 << (NX_NAND_INT_READY_START + nc->slotid));
+            tmhwEfmc_IntClear(nc->unitid, intr);
+            tmhwEfmc_IntEnable(nc->unitid, intr);
+
+            /* Send address cycles & command */
+            nc->done = false;
+
+            nx_nand_cmd_addr(nc, 1, NAND_CMD_ERASE1, 0);
+
+            addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+            nx_nand_cmd_addr(nc, 0, addr, 0);
+
+            addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+            nx_nand_cmd_addr(nc, 0, addr, 0);
+
+            if (nc->chip.chipsize > (32 << 20)) {
+                addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+                nx_nand_cmd_addr(nc, 0, addr, 0);
+            }
+
+            nx_nand_cmd_addr(nc, 1, NAND_CMD_ERASE2, 1);
+
+            /* Wait for the completion */ 
+            wait_event(nc->nand_queue, (nc->done != false));
+
+            /* Disable READY interrupt */
+            tmhwEfmc_IntDisable(nc->unitid, intr);
+
+            break;
+
+        case NAND_CMD_ERASE2:
+            /* Already done in CMD_ERASE1 */
+            break;
+
+        case NAND_CMD_READ0:
+            nc->offset = 0;
 
 #ifdef CONFIG_MTD_NX_NAND_DMAC
-      /* Start the DMAC */
-      nx_nand_dmac_init(nc, 1, &req, stgt);
- 
-      /* Configure Flow control */
-      dma_cfg.enableM2PDma = tmhwEfmc_Disable;
-      dma_cfg.enableP2MDma = tmhwEfmc_Enable;
-      tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
-
-      /* Enable the SEQ READ PAGE DONE interrupt */
-      intr |= NX_NAND_INT_SEQ_READ;
-      tmhwEfmc_IntClear(nc->unitid, intr);
-      tmhwEfmc_IntEnable(nc->unitid, intr);
-
-      /* Page operation */
-      page_cfg.includeOOB = true;
-      page_cfg.operType = tmhwEfmc_PageRead;
-      if(nc->aes) {
-         page_cfg.includeAES = true;
-      }
-      else {
-         page_cfg.includeAES = false;
-      }
-      if(nc->hwecc) {
-         page_cfg.includeECC = true;
-      }
-      else {
-         page_cfg.includeECC = false;
-      }
-      tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
-
-      chanid = nx_dmac_tfr(&req);
-      if(chanid < 0) {
-         printk(KERN_ERR "nx_nand: NAND_READ0 DMAC config \r\n"); 
-         return;
-      }
-
-      /* Send address cycles & command */
-      nx_nand_cmd_addr(nc, 1, NAND_CMD_READ0, 0);
-      
-      addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-      addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-      if (nc->chip.chipsize > (32 << 20)) {
-         addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-         nx_nand_cmd_addr(nc, 0, addr, 0);
-         addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-         nx_nand_cmd_addr(nc, 0, addr, 1);
-      }
-      else {
-         addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-         nx_nand_cmd_addr(nc, 0, addr, 1);
-      }
-
-      /* Complete DMAC transfer */
-      status = nx_dmac_tfr_comp(chanid);
-      if(status) {
-         printk(KERN_ERR "nx_nand: NAND_READ0 DMAC complete\r\n");   
-         return;
-      }
-   
-      /* Disable interrupts */   
-      tmhwEfmc_IntDisable(nc->unitid, intr);
-      
-      /* Disable Flow control */
-      dma_cfg.enableM2PDma = tmhwEfmc_Disable;
-      dma_cfg.enableP2MDma = tmhwEfmc_Disable;
-      tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
-   
+            /* Start the DMAC */
+            nx_nand_dmac_init(nc, 1, &req, stgt);
+
+            /* Configure Flow control */
+            dma_cfg.enableM2PDma = tmhwEfmc_Disable;
+            dma_cfg.enableP2MDma = tmhwEfmc_Enable;
+            tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
+
+            /* Enable the SEQ READ PAGE DONE interrupt */
+            intr |= NX_NAND_INT_SEQ_READ;
+            tmhwEfmc_IntClear(nc->unitid, intr);
+            tmhwEfmc_IntEnable(nc->unitid, intr);
+
+            /* Page operation */
+            page_cfg.includeOOB = true;
+            page_cfg.operType = tmhwEfmc_PageRead;
+            if(nc->aes) {
+                page_cfg.includeAES = true;
+            }
+            else {
+                page_cfg.includeAES = false;
+            }
+            if(nc->hwecc) {
+                page_cfg.includeECC = true;
+            }
+            else {
+                page_cfg.includeECC = false;
+            }
+            tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+
+            chanid = nx_dmac_tfr(&req);
+            if(chanid < 0) {
+                printk(KERN_ERR "nx_nand: NAND_READ0 DMAC config \r\n"); 
+                return;
+            }
+
+            /* Send address cycles & command */
+            nx_nand_cmd_addr(nc, 1, NAND_CMD_READ0, 0);
+
+            addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
+            nx_nand_cmd_addr(nc, 0, addr, 0);
+
+            addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+            nx_nand_cmd_addr(nc, 0, addr, 0);
+
+            if (nc->chip.chipsize > (32 << 20)) {
+                addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+                nx_nand_cmd_addr(nc, 0, addr, 0);
+                addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+                nx_nand_cmd_addr(nc, 0, addr, 1);
+            }
+            else {
+                addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+                nx_nand_cmd_addr(nc, 0, addr, 1);
+            }
+
+            /* Complete DMAC transfer */
+            status = nx_dmac_tfr_comp(chanid);
+            if(status) {
+                printk(KERN_ERR "nx_nand: NAND_READ0 DMAC complete\r\n");   
+                return;
+            }
+
+            /* Disable interrupts */   
+            tmhwEfmc_IntDisable(nc->unitid, intr);
+
+            /* Disable Flow control */
+            dma_cfg.enableM2PDma = tmhwEfmc_Disable;
+            dma_cfg.enableP2MDma = tmhwEfmc_Disable;
+            tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
+
 #else
-      
-      nc->blk_index = 0;
-   
-      /* Init page operation */
-      page_cfg.includeOOB = true;
-      page_cfg.operType = tmhwEfmc_PageRead;
-      if(nc->aes) {
-         intr |= NX_NAND_INT_AES_DEC;
-         page_cfg.includeAES = true;
-      }
-      else {
-         page_cfg.includeAES = false;
-      }
-
-      if(nc->hwecc) {
-         intr |= NX_NAND_INT_DEC;
-         page_cfg.includeECC = true;
-      }
-      else {
-         page_cfg.includeECC = false;
-         intr |= NX_NAND_INT_BLK_READ;
-      }
-      tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
-      
-      intr |= NX_NAND_INT_OOB_READ;
-      tmhwEfmc_IntClear(nc->unitid, intr);
-      tmhwEfmc_IntEnable(nc->unitid, NX_NAND_INT_OOB_READ);
-
-      /* Send the address commands to chip */
-      nc->done = false;
-      
-      nx_nand_cmd_addr(nc, 1, NAND_CMD_READ0, 0);
-      addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
-      
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-      
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-      if (nc->chip.chipsize > (32 << 20)) {
-         addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-         nx_nand_cmd_addr(nc, 0, addr, 0);
-         addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-         nx_nand_cmd_addr(nc, 0, addr, 1);
-      }
-      else {
-         addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-         nx_nand_cmd_addr(nc, 0, addr, 1);
-      }
-
-      /* Wait for the completion */ 
-      wait_event(nc->nand_queue, (nc->done != false));
-      
-      /* Disable interrupts */
-      tmhwEfmc_IntDisable(nc->unitid, intr);
-      
-#endif
-      break;
-
-   case NAND_CMD_READOOB:
-      /* Offset to OOB area in driver buffer */
-      nc->offset = mtd->writesize;
-      nc->blk_index = (nc->num_blks * NX_NAND_BLK_SIZE);
-   
-      /* Enable the OOB block request */
-      tmhwEfmc_IntClear(nc->unitid, NX_NAND_INT_OOB_READ);
-      tmhwEfmc_IntEnable(nc->unitid, NX_NAND_INT_OOB_READ);
-
-      /* Init page operation command */
-      page_cfg.includeOOB = true;
-      page_cfg.operType = tmhwEfmc_PageRead;
-      if(nc->aes) {
-         page_cfg.includeAES = true;
-      }
-      else {
-         page_cfg.includeAES = false;
-      }
-      if(nc->hwecc) {
-         page_cfg.includeECC = true;
-      }
-      else {
-         page_cfg.includeECC = false;
-      }
-      tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
-
-      /* Send cmd & address cycles */
-      nc->done = false;
-      
-      nx_nand_cmd_addr(nc, 1, NAND_CMD_READOOB, 0);
-      addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
-      
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-      
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-      if (nc->chip.chipsize > (32 << 20)) {
-         addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-         nx_nand_cmd_addr(nc, 0, addr, 0);
-         addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-         nx_nand_cmd_addr(nc, 0, addr, 1);
-      }
-      else {
-         addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-         nx_nand_cmd_addr(nc, 0, addr, 1);
-      }
-      
-      /* Wait for the completion */ 
-      wait_event(nc->nand_queue, (nc->done != false));
-      
-      /* Disable the OOB block request */
-      tmhwEfmc_IntDisable(nc->unitid, NX_NAND_INT_OOB_READ);
-      
-      break;
-
-   case NAND_CMD_READID:
-      
-      /* Init page operation command */
-      page_cfg.includeOOB = false;
-      page_cfg.operType = tmhwEfmc_Nothing;
-      if(nc->aes) {
-         page_cfg.includeAES = true;
-      }
-      else {
-         page_cfg.includeAES = false;
-      }
-      
-      if(nc->hwecc) {
-         page_cfg.includeECC = true;
-      }
-      else {
-         page_cfg.includeECC = false;
-      }
-      
-      tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
-      
-      nx_nand_cmd_addr(nc, 1, cmd, 0);
-      nx_nand_cmd_addr(nc, 0, column, 1);
-      break;
-
-   default:
-      printk(KERN_ERR "nxnand: command not supported %d \n", cmd);
-   }
-}
-
-/**
-* nx_nand_command_lp - Command function for large page chips
-* @mtd: MTD information structure
-* @cmd: Command
-* @column: Column address
-* @page_addr: Page address
-*
-* Command control function:
-*/
+
+            nc->blk_index = 0;
+
+            /* Init page operation */
+            page_cfg.includeOOB = true;
+            page_cfg.operType = tmhwEfmc_PageRead;
+            if(nc->aes) {
+                intr |= NX_NAND_INT_AES_DEC;
+                page_cfg.includeAES = true;
+            }
+            else {
+                page_cfg.includeAES = false;
+            }
+
+            if(nc->hwecc) {
+                intr |= NX_NAND_INT_DEC;
+                page_cfg.includeECC = true;
+            }
+            else {
+                page_cfg.includeECC = false;
+                intr |= NX_NAND_INT_BLK_READ;
+            }
+            tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+
+            intr |= NX_NAND_INT_OOB_READ;
+            tmhwEfmc_IntClear(nc->unitid, intr);
+            tmhwEfmc_IntEnable(nc->unitid, NX_NAND_INT_OOB_READ);
+
+            /* Send the address commands to chip */
+            nc->done = false;
+
+            nx_nand_cmd_addr(nc, 1, NAND_CMD_READ0, 0);
+            addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
+
+            nx_nand_cmd_addr(nc, 0, addr, 0);
+            addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+
+            nx_nand_cmd_addr(nc, 0, addr, 0);
+
+            if (nc->chip.chipsize > (32 << 20)) {
+                addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+                nx_nand_cmd_addr(nc, 0, addr, 0);
+                addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+                nx_nand_cmd_addr(nc, 0, addr, 1);
+            }
+            else {
+                addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+                nx_nand_cmd_addr(nc, 0, addr, 1);
+            }
+
+            /* Wait for the completion */ 
+            wait_event(nc->nand_queue, (nc->done != false));
+
+            /* Disable interrupts */
+            tmhwEfmc_IntDisable(nc->unitid, intr);
+
+#endif
+            break;
+
+        case NAND_CMD_READOOB:
+            /* Offset to OOB area in driver buffer */
+            nc->offset = mtd->writesize;
+            nc->blk_index = (nc->num_blks * NX_NAND_BLK_SIZE);
+
+            /* Enable the OOB block request */
+            tmhwEfmc_IntClear(nc->unitid, NX_NAND_INT_OOB_READ);
+            tmhwEfmc_IntEnable(nc->unitid, NX_NAND_INT_OOB_READ);
+
+            /* Init page operation command */
+            page_cfg.includeOOB = true;
+            page_cfg.operType = tmhwEfmc_PageRead;
+            if(nc->aes) {
+                page_cfg.includeAES = true;
+            }
+            else {
+                page_cfg.includeAES = false;
+            }
+            if(nc->hwecc) {
+                page_cfg.includeECC = true;
+            }
+            else {
+                page_cfg.includeECC = false;
+            }
+            tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+
+            /* Send cmd & address cycles */
+            nc->done = false;
+
+            nx_nand_cmd_addr(nc, 1, NAND_CMD_READOOB, 0);
+            addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
+
+            nx_nand_cmd_addr(nc, 0, addr, 0);
+            addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+
+            nx_nand_cmd_addr(nc, 0, addr, 0);
+
+            if (nc->chip.chipsize > (32 << 20)) {
+                addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+                nx_nand_cmd_addr(nc, 0, addr, 0);
+                addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+                nx_nand_cmd_addr(nc, 0, addr, 1);
+            }
+            else {
+                addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+                nx_nand_cmd_addr(nc, 0, addr, 1);
+            }
+
+            /* Wait for the completion */ 
+            wait_event(nc->nand_queue, (nc->done != false));
+
+            /* Disable the OOB block request */
+            tmhwEfmc_IntDisable(nc->unitid, NX_NAND_INT_OOB_READ);
+
+            break;
+
+        case NAND_CMD_READID:
+
+            /* Init page operation command */
+            page_cfg.includeOOB = false;
+            page_cfg.operType = tmhwEfmc_Nothing;
+            if(nc->aes) {
+                page_cfg.includeAES = true;
+            }
+            else {
+                page_cfg.includeAES = false;
+            }
+
+            if(nc->hwecc) {
+                page_cfg.includeECC = true;
+            }
+            else {
+                page_cfg.includeECC = false;
+            }
+
+            tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+
+            nx_nand_cmd_addr(nc, 1, cmd, 0);
+            nx_nand_cmd_addr(nc, 0, column, 1);
+            break;
+
+        case NAND_CMD_PARAM:
+            nc->offset = 0;
+
+            page_cfg.includeOOB = false;
+            page_cfg.operType = tmhwEfmc_Nothing;
+            page_cfg.includeAES = false;
+            page_cfg.includeECC = false;
+
+            tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);
+
+            nx_nand_cmd_addr(nc, 1, cmd, 0);
+            nx_nand_cmd_addr(nc, 0, 0x0, 1);
+
+            /* Read PARAM Page and 2 Redundant Parameter Pages */
+            for (i=0; i < (3 * sizeof(struct nand_onfi_params)); i++)
+            {
+                nc->dmabuf[i]=nx_nand_read_byte(mtd);
+            }
+            break;
+
+        default:
+            printk(KERN_ERR "nxnand: command not supported %d \n", cmd);
+    }
+}
+
+/**
+ * nx_nand_command_lp - Command function for large page chips
+ * @mtd: MTD information structure
+ * @cmd: Command
+ * @column: Column address
+ * @page_addr: Page address
+ *
+ * Command control function:
+ */
 static void nx_nand_command_lp(struct mtd_info *mtd, unsigned int cmd,
-              int column, int page_addr)
+        int column, int page_addr)
 {
-   tmhwEfmc_PageConfig_t   page_cfg;
-   uint16_t addr;
-   uint32_t intr=0;
-   int   status;
-   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+    tmhwEfmc_PageConfig_t   page_cfg;
+    uint16_t addr;
+    uint32_t intr=0;
+    int   status, i;
+    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
 
 #ifdef CONFIG_MTD_NX_NAND_DMAC 
-   int   chanid;
-   tmhwEfmc_DmaConfig_t dma_cfg;
-   nx_dmac_tfr_t           req;
-   nx_dmac_stgt_t       stgt[(mtd->writesize/NX_NAND_BLK_SIZE)+1];
-#endif
-
-   /* Store the command, colmn & page address */
-   if(cmd == NAND_CMD_READOOB) {
-      cmd = NAND_CMD_READ0;
-
-      /* If Device OOB layout, read data in read_OOB function */ 
-      if(mtd->flags & MTD_USE_DEV_OOB_LAYOUT) {
-         nc->cur_cmd = cmd;
-         nc->cur_col = mtd->writesize;
-         nc->cur_page = page_addr;
-         return;
-      }
-   }
-
-   /* Store cmd, addresses */
-   nc->cur_cmd = cmd;
-   if(column == -1)
-      column = 0;
-   nc->cur_col = column;
-   if(page_addr == -1)
-      page_addr = 0;
-   nc->cur_page =  (page_addr);
-
-   /*
-    * Issue the correct first command, when we write to
-    * the device.
-    */
-   switch(cmd) {
-   case NAND_CMD_SEQIN:
-      nc->offset = column;
-      /* Address cycles & command will be sent in write_page_raw */
-      break;
+    int   chanid;
+    tmhwEfmc_DmaConfig_t dma_cfg;
+    nx_dmac_tfr_t           req;
+    nx_dmac_stgt_t       stgt[(mtd->writesize/NX_NAND_BLK_SIZE)+1];
+#endif
+
+    /* Store the command, colmn & page address */
+    if(cmd == NAND_CMD_READOOB) {
+        cmd = NAND_CMD_READ0;
+
+        /* If Device OOB layout, read data in read_OOB function */ 
+        if(mtd->flags & MTD_USE_DEV_OOB_LAYOUT) {
+            nc->cur_cmd = cmd;
+            nc->cur_col = mtd->writesize;
+            nc->cur_page = page_addr;
+            return;
+        }
+    }
+
+    /* Store cmd, addresses */
+    nc->cur_cmd = cmd;
+    if(column == -1)
+        column = 0;
+    nc->cur_col = column;
+    if(page_addr == -1)
+        page_addr = 0;
+    nc->cur_page =  (page_addr);
+
+    /*
+     * Issue the correct first command, when we write to
+     * the device.
+     */
+    switch(cmd) {
+        case NAND_CMD_SEQIN:
+            nc->offset = column;
+            /* Address cycles & command will be sent in write_page_raw */
+            break;
 
 #ifdef CONFIG_MTD_NX_NAND_DMAC 
-   case NAND_CMD_PAGEPROG:
-      break;
-      
-   case NAND_CMD_RESET:
-   case NAND_CMD_STATUS:
-      nx_nand_cmd_addr(nc, 1, cmd, 1);
-      break;
-      
+        case NAND_CMD_PAGEPROG:
+            break;
+
+        case NAND_CMD_RESET:
+        case NAND_CMD_STATUS:
+            nx_nand_cmd_addr(nc, 1, cmd, 1);
+            break;
+
 #else 
-   case NAND_CMD_PAGEPROG:
-      /* Post write command feature used */
-      break;
-   
-   case NAND_CMD_RESET:
-   case NAND_CMD_STATUS:
-      nx_nand_cmd_addr(nc, 1, cmd, 1);
-      break;
-#endif
-
-   case NAND_CMD_ERASE1:
-      /* Enable READY interupt */
-      intr = 1 << (NX_NAND_INT_READY_START + nc->slotid);
-      tmhwEfmc_IntClear(nc->unitid, intr);
-      tmhwEfmc_IntEnable(nc->unitid, intr);
-      
-      /* Send address cycles & command */
-      nc->done = false;
-      
-      nx_nand_cmd_addr(nc, 1, NAND_CMD_ERASE1, 0);
-      
-      addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-      addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-      if (nc->chip.chipsize >= (1 << 28)) {
-         addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-         nx_nand_cmd_addr(nc, 0, addr, 0);
-      }
-      nx_nand_cmd_addr(nc, 1, NAND_CMD_ERASE2, 1);
-      
-      /* Wait for the completion */ 
-      wait_event(nc->nand_queue, (nc->done != false));
-      
-      /* Disable READY interrupt */
-      tmhwEfmc_IntDisable(nc->unitid, intr);
-      break;
-
-   case NAND_CMD_ERASE2:
-      /* Already done in CMD_ERASE1 */
-      break;
+        case NAND_CMD_PAGEPROG:
+            /* Post write command feature used */
+            break;
+
+        case NAND_CMD_RESET:
+        case NAND_CMD_STATUS:
+            nx_nand_cmd_addr(nc, 1, cmd, 1);
+            break;
+#endif
+
+        case NAND_CMD_ERASE1:
+            /* Enable READY interupt */
+            intr = 1 << (NX_NAND_INT_READY_START + nc->slotid);
+            tmhwEfmc_IntClear(nc->unitid, intr);
+            tmhwEfmc_IntEnable(nc->unitid, intr);
+
+            /* Send address cycles & command */
+            nc->done = false;
+
+            nx_nand_cmd_addr(nc, 1, NAND_CMD_ERASE1, 0);
+
+            addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+            nx_nand_cmd_addr(nc, 0, addr, 0);
 
-   case NAND_CMD_READ0:
-      nc->offset = column;
+            addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+            nx_nand_cmd_addr(nc, 0, addr, 0);
+
+            if (nc->chip.chipsize >= (1 << 28)) {
+                addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+                nx_nand_cmd_addr(nc, 0, addr, 0);
+            }
+            nx_nand_cmd_addr(nc, 1, NAND_CMD_ERASE2, 1);
+
+            /* Wait for the completion */ 
+            wait_event(nc->nand_queue, (nc->done != false));
+
+            /* Disable READY interrupt */
+            tmhwEfmc_IntDisable(nc->unitid, intr);
+            break;
+
+        case NAND_CMD_ERASE2:
+            /* Already done in CMD_ERASE1 */
+            break;
+
+        case NAND_CMD_READ0:
+            nc->offset = column;
 
 #ifdef CONFIG_MTD_NX_NAND_DMAC
-      /* Start the DMAC */
-      nx_nand_dmac_init(nc, 1, &req, stgt);
- 
-      /* Configure Flow control */
-      dma_cfg.enableM2PDma = tmhwEfmc_Disable;
-      dma_cfg.enableP2MDma = tmhwEfmc_Enable;
-      tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
-
-      /* Enable the SEQ READ PAGE DONE interrupt */
-      intr = NX_NAND_INT_SEQ_READ;
-      tmhwEfmc_IntClear(nc->unitid, intr);
-      tmhwEfmc_IntEnable(nc->unitid, intr);
-
-      /* Page operation */
-      page_cfg.includeOOB = true;
-      page_cfg.operType = tmhwEfmc_PageRead;
-      if(nc->aes) {
-         page_cfg.includeAES = true;
-      }
-      else {
-         page_cfg.includeAES = false;
-      }
-      if(nc->hwecc) {
-         page_cfg.includeECC = true;
-      }
-      else {
-         page_cfg.includeECC = false;
-      }
-      tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
-
-      chanid = nx_dmac_tfr(&req);
-      if(chanid < 0) {
-         printk(KERN_ERR "nx_nand: NAND_READ0 DMAC config \r\n"); 
-         return;
-      }
-
-      /* Send address cycles & command */
-      nc->done = false;
-      nx_nand_cmd_addr(nc, 1, NAND_CMD_READ0, 0);
-
-      addr = column & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-      addr = (column >> 8) & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-      addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-      addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      
-      if (nc->chip.chipsize >= (1 << 28)) {
-         addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-         nx_nand_cmd_addr(nc, 0, addr, 0);
-      }
-      
-      nx_nand_cmd_addr(nc, 1, NAND_CMD_READSTART, 1);
-
-      /* Wait for the completion */ 
-      wait_event(nc->nand_queue, (nc->done != false));
-      
-      /* Complete DMAC transfer */
-      status = nx_dmac_tfr_comp(chanid);
-      if(status) {
-         printk(KERN_ERR "nx_nand: NAND_READ0 DMAC complete\r\n");   
-         return;
-      }
-   
-      /* Disable interrupts */   
-      tmhwEfmc_IntDisable(nc->unitid, intr);
-      
-      /* Disable Flow control */
-      dma_cfg.enableM2PDma = tmhwEfmc_Disable;
-      dma_cfg.enableP2MDma = tmhwEfmc_Disable;
-      tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
-   
+            /* Start the DMAC */
+            nx_nand_dmac_init(nc, 1, &req, stgt);
+
+            /* Configure Flow control */
+            dma_cfg.enableM2PDma = tmhwEfmc_Disable;
+            dma_cfg.enableP2MDma = tmhwEfmc_Enable;
+            tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
+
+            /* Enable the SEQ READ PAGE DONE interrupt */
+            intr = NX_NAND_INT_SEQ_READ;
+            tmhwEfmc_IntClear(nc->unitid, intr);
+            tmhwEfmc_IntEnable(nc->unitid, intr);
+
+            /* Page operation */
+            page_cfg.includeOOB = true;
+            page_cfg.operType = tmhwEfmc_PageRead;
+            if(nc->aes) {
+                page_cfg.includeAES = true;
+            }
+            else {
+                page_cfg.includeAES = false;
+            }
+            if(nc->hwecc) {
+                page_cfg.includeECC = true;
+            }
+            else {
+                page_cfg.includeECC = false;
+            }
+            tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+
+            chanid = nx_dmac_tfr(&req);
+            if(chanid < 0) {
+                printk(KERN_ERR "nx_nand: NAND_READ0 DMAC config \r\n"); 
+                return;
+            }
+
+            /* Send address cycles & command */
+            nc->done = false;
+            nx_nand_cmd_addr(nc, 1, NAND_CMD_READ0, 0);
+
+            addr = column & NX_NAND_SP_ADDR_MASK;
+            nx_nand_cmd_addr(nc, 0, addr, 0);
+
+            addr = (column >> 8) & NX_NAND_SP_ADDR_MASK;
+            nx_nand_cmd_addr(nc, 0, addr, 0);
+
+            addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+            nx_nand_cmd_addr(nc, 0, addr, 0);
+
+            addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+            nx_nand_cmd_addr(nc, 0, addr, 0);
+
+            if (nc->chip.chipsize >= (1 << 28)) {
+                addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+                nx_nand_cmd_addr(nc, 0, addr, 0);
+            }
+
+            nx_nand_cmd_addr(nc, 1, NAND_CMD_READSTART, 1);
+
+            /* Wait for the completion */ 
+            wait_event(nc->nand_queue, (nc->done != false));
+
+            /* Complete DMAC transfer */
+            status = nx_dmac_tfr_comp(chanid);
+            if(status) {
+                printk(KERN_ERR "nx_nand: NAND_READ0 DMAC complete\r\n");   
+                return;
+            }
+
+            /* Disable interrupts */   
+            tmhwEfmc_IntDisable(nc->unitid, intr);
+
+            /* Disable Flow control */
+            dma_cfg.enableM2PDma = tmhwEfmc_Disable;
+            dma_cfg.enableP2MDma = tmhwEfmc_Disable;
+            tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
+
 #else
-   
-      nc->blk_index = 0;
-   
-      /* Init page operation */
-      page_cfg.includeOOB = true;
-      intr |= NX_NAND_INT_OOB_READ;
-      page_cfg.operType = tmhwEfmc_PageRead;
-      if(nc->aes) {
-         intr |= NX_NAND_INT_AES_DEC;
-         page_cfg.includeAES = true;
-      }
-      else {
-         page_cfg.includeAES = false;
-      }
-
-      if(nc->hwecc) {
-         intr |= NX_NAND_INT_DEC;
-         page_cfg.includeECC = true;
-      }
-      else {
-         page_cfg.includeECC = false;
-         intr |= NX_NAND_INT_BLK_READ;
-      }
-      tmhwEfmc_IntClear(nc->unitid, intr);
-      tmhwEfmc_IntEnable(nc->unitid, intr);
-      tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
-
-      /* Send the address commands to chip */
-      nc->done = false;
-      /* Send address cycles & command */
-      nx_nand_cmd_addr(nc, 1, NAND_CMD_READ0, 0);
-      addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      addr = (nc->cur_col >> 8) & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-      nx_nand_cmd_addr(nc, 0, addr, 0);
-      if (nc->chip.chipsize >= (1 << 28)) {
-         addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-         nx_nand_cmd_addr(nc, 0, addr, 0);
-      }
-      nx_nand_cmd_addr(nc, 1, NAND_CMD_READSTART, 1);
-      
-      /* Wait for the completion */ 
-      wait_event(nc->nand_queue, (nc->done != false));
-      
-      /* Disable interrupts */
-      tmhwEfmc_IntDisable(nc->unitid, intr);
-      
-#endif
-      break;
-      
-   case NAND_CMD_READID:
-      page_cfg.includeOOB = false;
-      page_cfg.operType = tmhwEfmc_Nothing;
-      if(nc->aes) {
-         page_cfg.includeAES = true;
-      }
-      else {
-         page_cfg.includeAES = false;
-      }
-      
-      if(nc->hwecc) {
-         page_cfg.includeECC = true;
-      }
-      else {
-         page_cfg.includeECC = false;
-      }
-      tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
-
-      nx_nand_cmd_addr(nc, 1, cmd, 0);
-      nx_nand_cmd_addr(nc, 0, column, 1);
-      break;
-
-   default:
-      printk(KERN_ERR "nxnand: command not supported %d \n", cmd);
-   }
+
+            nc->blk_index = 0;
+
+            /* Init page operation */
+            page_cfg.includeOOB = true;
+            intr |= NX_NAND_INT_OOB_READ;
+            page_cfg.operType = tmhwEfmc_PageRead;
+            if(nc->aes) {
+                intr |= NX_NAND_INT_AES_DEC;
+                page_cfg.includeAES = true;
+            }
+            else {
+                page_cfg.includeAES = false;
+            }
+
+            if(nc->hwecc) {
+                intr |= NX_NAND_INT_DEC;
+                page_cfg.includeECC = true;
+            }
+            else {
+                page_cfg.includeECC = false;
+                intr |= NX_NAND_INT_BLK_READ;
+            }
+            tmhwEfmc_IntClear(nc->unitid, intr);
+            tmhwEfmc_IntEnable(nc->unitid, intr);
+            tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+
+            /* Send the address commands to chip */
+            nc->done = false;
+            /* Send address cycles & command */
+            nx_nand_cmd_addr(nc, 1, NAND_CMD_READ0, 0);
+            addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
+            nx_nand_cmd_addr(nc, 0, addr, 0);
+            addr = (nc->cur_col >> 8) & NX_NAND_SP_ADDR_MASK;
+            nx_nand_cmd_addr(nc, 0, addr, 0);
+            addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+            nx_nand_cmd_addr(nc, 0, addr, 0);
+            addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+            nx_nand_cmd_addr(nc, 0, addr, 0);
+            if (nc->chip.chipsize >= (1 << 28)) {
+                addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+                nx_nand_cmd_addr(nc, 0, addr, 0);
+            }
+            nx_nand_cmd_addr(nc, 1, NAND_CMD_READSTART, 1);
+
+            /* Wait for the completion */ 
+            wait_event(nc->nand_queue, (nc->done != false));
+
+            /* Disable interrupts */
+            tmhwEfmc_IntDisable(nc->unitid, intr);
+
+#endif
+            break;
+
+        case NAND_CMD_READID:
+            page_cfg.includeOOB = false;
+            page_cfg.operType = tmhwEfmc_Nothing;
+            if(nc->aes) {
+                page_cfg.includeAES = true;
+            }
+            else {
+                page_cfg.includeAES = false;
+            }
+
+            if(nc->hwecc) {
+                page_cfg.includeECC = true;
+            }
+            else {
+                page_cfg.includeECC = false;
+            }
+            tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+
+            nx_nand_cmd_addr(nc, 1, cmd, 0);
+            nx_nand_cmd_addr(nc, 0, column, 1);
+            break;
+
+        case NAND_CMD_PARAM:
+            nc->offset = 0;
+
+            page_cfg.includeOOB = false;
+            page_cfg.operType = tmhwEfmc_Nothing;
+            page_cfg.includeAES = false;
+            page_cfg.includeECC = false;
+
+            tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);
+
+            nx_nand_cmd_addr(nc, 1, cmd, 0);
+            nx_nand_cmd_addr(nc, 0, 0, 1);
+
+            /* Read PARAM Page and 2 Redundant Parameter Pages */
+            for (i=0; i < (3 * sizeof(struct nand_onfi_params)); i++)
+            {
+                nc->dmabuf[i]=nx_nand_read_byte(mtd);
+            }
+            break;
+
+        default:
+            printk(KERN_ERR "nxnand: command not supported %d \n", cmd);
+    }
 }
 
 /**
@@ -1883,546 +1924,562 @@ static void nx_nand_command_lp(struct mt
  */
 static int nx_nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip ATTRIBUTE_UNUSED)
 {
-   struct mtd_oob_ops ops;
-   uint8_t  buf[NAND_MAX_OOBSIZE];
-  int ret;
-   u8 bad;
-   int res = 0;
-   struct nand_chip *chip = mtd->priv;
-
-   printk(KERN_INFO "Bad block check 0x%x \r\n", (int)ofs);
-   
-   mtd->flags |= MTD_USE_DEV_OOB_LAYOUT;
-   
-   /* Read OOB data */
-  ops.ooblen = mtd->oobsize;
-  ops.oobbuf = buf;
-  ops.ooboffs = 0;
-  ops.datbuf = NULL;
-  ops.mode = MTD_OOB_PLACE;
-  ret = mtd->read_oob(mtd, ofs, &ops);
-  if (ret) {
-      printk(KERN_INFO "READOOB failed 0x%x \r\n", ret);
-    return ret;
-   }
-   mtd->flags &= ~MTD_USE_DEV_OOB_LAYOUT;
-   
-   /* Check the bad block marker */ 
-   bad = buf[chip->badblockpos];
-   if (bad != 0xff) {
-      res = 1;
-   }
-   
-   printk(KERN_INFO "Bad block res 0x%x \r\n", res);
-      
-   return res;
+    struct mtd_oob_ops ops;
+    uint8_t  buf[NAND_MAX_OOBSIZE];
+    int ret;
+    u8 bad;
+    int res = 0;
+    struct nand_chip *chip = mtd->priv;
+
+    printk(KERN_INFO "Bad block check 0x%x \r\n", (int)ofs);
+
+    mtd->flags |= MTD_USE_DEV_OOB_LAYOUT;
+
+    /* Read OOB data */
+    ops.ooblen = mtd->oobsize;
+    ops.oobbuf = buf;
+    ops.ooboffs = 0;
+    ops.datbuf = NULL;
+    ops.mode = MTD_OOB_PLACE;
+    ret = mtd->read_oob(mtd, ofs, &ops);
+    if (ret) {
+        printk(KERN_INFO "READOOB failed 0x%x \r\n", ret);
+        return ret;
+    }
+    mtd->flags &= ~MTD_USE_DEV_OOB_LAYOUT;
+
+    /* Check the bad block marker */ 
+    bad = buf[chip->badblockpos];
+    if (bad != 0xff) {
+        res = 1;
+    }
+
+    printk(KERN_INFO "Bad block res 0x%x \r\n", res);
+
+    return res;
 }
 
 /*------------------------------------------------------------------------------------
-* Partitions scan functions 
---------------------------------------------------------------------------------------*/
+ * Partitions scan functions 
+ --------------------------------------------------------------------------------------*/
 /**
-* nx_nand_scan_partitions - Partition creation function
-* @mtd: MTD information structure
-*
-* Scan the part table
-*/
+ * nx_nand_scan_partitions - Partition creation function
+ * @mtd: MTD information structure
+ *
+ * Scan the part table
+ */
 static void nx_nand_scan_partitions(struct mtd_info *mtd)
 {
-   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
-   struct mtd_partition *parts = NULL;
-   int res;
-
-   res = parse_mtd_partitions(mtd, part_probes, &parts, 0);
-   if (res <= 0) {
-      if(nc->lb_chip) { 
-         parts = partition_info2;
-         res = ARRAY_SIZE(partition_info2);
-      }
-      else {
-         parts = partition_info1;
-         res = ARRAY_SIZE(partition_info1);
-      }
-   } else {
-      nc->partinfo = parts;
-   }
+    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+    struct mtd_partition *parts = NULL;
+    int res;
+
+    res = parse_mtd_partitions(mtd, part_probes, &parts, 0);
+    if (res <= 0) {
+        if(nc->lb_chip) { 
+            parts = partition_info2;
+            res = ARRAY_SIZE(partition_info2);
+        }
+        else {
+            parts = partition_info1;
+            res = ARRAY_SIZE(partition_info1);
+        }
+    } else {
+        nc->partinfo = parts;
+    }
 
-   add_mtd_partitions(mtd, parts, res);
+    add_mtd_partitions(mtd, parts, res);
 }
 
 extern void mtd_blktrans_stop(void);
 extern int mtd_blktrans_restart(void);
 
 /**
-* nx_nand_repartition - Repatition function
-* @mtd: MTD information structure
-*
-* Repartition a device
-*/
+ * nx_nand_repartition - Repatition function
+ * @mtd: MTD information structure
+ *
+ * Repartition a device
+ */
 static int nx_nand_repartition(struct mtd_info *mtd)
 {
-   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
 
-   /* Hack alert: sysfs is unfixable broken in this kernel !! */
-   //mtd_blktrans_stop();
+    /* Hack alert: sysfs is unfixable broken in this kernel !! */
+    //mtd_blktrans_stop();
 
-   /* Deregister partitions */
-   del_mtd_partitions(mtd);
+    /* Deregister partitions */
+    del_mtd_partitions(mtd);
 
-   /* Hack alert: sysfs is unfixable broken in this kernel !! */
-   //mtd_blktrans_restart();
+    /* Hack alert: sysfs is unfixable broken in this kernel !! */
+    //mtd_blktrans_restart();
 
-   /* Free the previous allocated partition array */
-   if (nc->partinfo) {
-      kfree(nc->partinfo);
-      nc->partinfo = NULL;
-   }
+    /* Free the previous allocated partition array */
+    if (nc->partinfo) {
+        kfree(nc->partinfo);
+        nc->partinfo = NULL;
+    }
 
-   nx_nand_scan_partitions(mtd);
-   return 0;
+    nx_nand_scan_partitions(mtd);
+    return 0;
 }
 
 /**
-* nx_nand_ctrl_isr - NAND controller ISR function 
-* @irq_no: IRQ number
-* @dev_id: Device ID
-*
-* Handles the NAND Controller interrupt events
-*/
+ * nx_nand_ctrl_isr - NAND controller ISR function 
+ * @irq_no: IRQ number
+ * @dev_id: Device ID
+ *
+ * Handles the NAND Controller interrupt events
+ */
 static irqreturn_t nx_nand_ctrl_isr(int irq_no ATTRIBUTE_UNUSED, void *dev_id)
 {
 #ifdef CONFIG_MTD_NX_NAND_DMAC   
-   int i;
+    int i;
 #endif
-   
-   uint32_t int_stat;
-   uint32_t int_ena;
-   struct nx_nand_ctrl  *nc=(struct nx_nand_ctrl *)dev_id;
-      
-   /* Read the interrupt status & chan ID */
-   tmhwEfmc_IntGetStatus(nc->unitid, (ptmhwEfmc_IntMask_t) &int_stat);
-   int_ena = readl(nx_nc->ctrl_base + NX_NAND_INT_ENA_OFFSET);
+
+    uint32_t int_stat;
+    uint32_t int_ena;
+    struct nx_nand_ctrl  *nc=(struct nx_nand_ctrl *)dev_id;
+
+    /* Read the interrupt status & chan ID */
+    tmhwEfmc_IntGetStatus(nc->unitid, (ptmhwEfmc_IntMask_t) &int_stat);
+    int_ena = readl(nx_nc->ctrl_base + NX_NAND_INT_ENA_OFFSET);
 
 #ifdef CONFIG_MTD_NX_NAND_DMAC   
-   /* Clear the interrupt */
-   tmhwEfmc_IntClear(nc->unitid, int_stat);
-   
-   if(nc->cur_cmd == NAND_CMD_READ0) {
-      if(nc->hwecc) {
-         for(i=0; i < nc->num_blks; i++)  {
-            nc->ecc_status[i] = (int_stat & (NX_NAND_INT_DEC_UNCOR | 
-                                                            NX_NAND_INT_DEC_0_ERR | 
-                                                            NX_NAND_INT_DEC_1_ERR |
-                                                            NX_NAND_INT_DEC_2_ERR |
-                                                            NX_NAND_INT_DEC_3_ERR |
-                                                            NX_NAND_INT_DEC_4_ERR |
-                                                            NX_NAND_INT_DEC_5_ERR));
-         }
-      }
-      
-      if((int_stat & NX_NAND_INT_SEQ_READ) && (int_ena & NX_NAND_INT_SEQ_READ)) {
-         nc->done = true; 
-         wake_up(&nc->nand_queue); 
-      }
-   }
-   
-   if(nc->cur_cmd == NAND_CMD_SEQIN) {
-      if((int_stat & NX_NAND_INT_SEQ_WRITE) && (int_ena & NX_NAND_INT_SEQ_WRITE)) {
-         tmhwEfmc_IntClear(nc->unitid, NX_NAND_INT_SEQ_WRITE);
-      }
-      
-      if((int_stat & (1 << (NX_NAND_INT_READY_START + nc->slotid))) && (int_ena & (1 << (NX_NAND_INT_READY_START + nc->slotid)))) {
-         tmhwEfmc_IntClear(nc->unitid, (1 << (NX_NAND_INT_READY_START + nc->slotid)));
-         nc->done = true;
-         wake_up(&nc->nand_queue);
-      }
-   }
-   
-   /* Erase command */
-   if(nc->cur_cmd == NAND_CMD_ERASE1) {
-      if((int_stat & (1 << (NX_NAND_INT_READY_START + nc->slotid))) && (int_ena & (1 << (NX_NAND_INT_READY_START + nc->slotid)))) {
-         tmhwEfmc_IntClear(nc->unitid, (1 << (NX_NAND_INT_READY_START + nc->slotid)));
-         nc->done = true;
-         wake_up(&nc->nand_queue);
-      }
-   }
-   
+    /* Clear the interrupt */
+    tmhwEfmc_IntClear(nc->unitid, int_stat);
+
+    if(nc->cur_cmd == NAND_CMD_READ0) {
+        if(nc->hwecc) {
+            for(i=0; i < nc->num_blks; i++)  {
+                nc->ecc_status[i] = (int_stat & (NX_NAND_INT_DEC_UNCOR | 
+                            NX_NAND_INT_DEC_0_ERR | 
+                            NX_NAND_INT_DEC_1_ERR |
+                            NX_NAND_INT_DEC_2_ERR |
+                            NX_NAND_INT_DEC_3_ERR |
+                            NX_NAND_INT_DEC_4_ERR |
+                            NX_NAND_INT_DEC_5_ERR));
+            }
+        }
+
+        if((int_stat & NX_NAND_INT_SEQ_READ) && (int_ena & NX_NAND_INT_SEQ_READ)) {
+            nc->done = true; 
+            wake_up(&nc->nand_queue); 
+        }
+    }
+
+    if(nc->cur_cmd == NAND_CMD_SEQIN) {
+        if((int_stat & NX_NAND_INT_SEQ_WRITE) && (int_ena & NX_NAND_INT_SEQ_WRITE)) {
+            tmhwEfmc_IntClear(nc->unitid, NX_NAND_INT_SEQ_WRITE);
+        }
+
+        if((int_stat & (1 << (NX_NAND_INT_READY_START + nc->slotid))) && (int_ena & (1 << (NX_NAND_INT_READY_START + nc->slotid)))) {
+            tmhwEfmc_IntClear(nc->unitid, (1 << (NX_NAND_INT_READY_START + nc->slotid)));
+            nc->done = true;
+            wake_up(&nc->nand_queue);
+        }
+    }
+
+    /* Erase command */
+    if(nc->cur_cmd == NAND_CMD_ERASE1) {
+        if((int_stat & (1 << (NX_NAND_INT_READY_START + nc->slotid))) && (int_ena & (1 << (NX_NAND_INT_READY_START + nc->slotid)))) {
+            tmhwEfmc_IntClear(nc->unitid, (1 << (NX_NAND_INT_READY_START + nc->slotid)));
+            nc->done = true;
+            wake_up(&nc->nand_queue);
+        }
+    }
+
 #else
-   
-   /* Write command */
-   if((nc->cur_cmd == NAND_CMD_SEQIN) || (nc->cur_cmd == NAND_CMD_PAGEPROG)) {
-      if((int_stat & NX_NAND_INT_OOB_WRITE) && (int_ena & NX_NAND_INT_OOB_WRITE)) {
-         tmhwEfmc_WriteOobData(nc->unitid, nc->slotid, nc->dmabuf+nc->mtd.writesize);
-         tmhwEfmc_IntClear(nc->unitid, int_stat);
-      }
-
-      if(nc->hwecc) {
-         if((int_stat & NX_NAND_INT_ENC) && (int_ena & NX_NAND_INT_ENC)) {
-            tmhwEfmc_WriteBufData(nc->unitid, nc->slotid, nc->dmabuf+(nc->blk_index*NX_NAND_BLK_SIZE));
-            nc->blk_index++;
+
+    /* Write command */
+    if((nc->cur_cmd == NAND_CMD_SEQIN) || (nc->cur_cmd == NAND_CMD_PAGEPROG)) {
+        if((int_stat & NX_NAND_INT_OOB_WRITE) && (int_ena & NX_NAND_INT_OOB_WRITE)) {
+            tmhwEfmc_WriteOobData(nc->unitid, nc->slotid, nc->dmabuf+nc->mtd.writesize);
+            tmhwEfmc_IntClear(nc->unitid, int_stat);
+        }
+
+        if(nc->hwecc) {
+            if((int_stat & NX_NAND_INT_ENC) && (int_ena & NX_NAND_INT_ENC)) {
+                tmhwEfmc_WriteBufData(nc->unitid, nc->slotid, nc->dmabuf+(nc->blk_index*NX_NAND_BLK_SIZE));
+                nc->blk_index++;
+                tmhwEfmc_IntClear(nc->unitid, int_stat);
+            }
+        }
+        else {
+            if((int_stat & NX_NAND_INT_BLK_WRITE) && (int_ena & NX_NAND_INT_BLK_WRITE)){
+                tmhwEfmc_WriteBufData(nc->unitid, nc->slotid, nc->dmabuf + (nc->blk_index*NX_NAND_BLK_SIZE));
+                nc->blk_index++;
+                tmhwEfmc_IntClear(nc->unitid, int_stat);
+            }
+        }
+
+        if((int_stat & NX_NAND_INT_SEQ_WRITE) && (int_ena & NX_NAND_INT_SEQ_WRITE)) {
+            tmhwEfmc_IntClear(nc->unitid, int_stat);
+        }
+
+        if((int_stat & (1 << (NX_NAND_INT_READY_START + nc->slotid))) && (int_ena & (1 << (NX_NAND_INT_READY_START + nc->slotid)))) {
             tmhwEfmc_IntClear(nc->unitid, int_stat);
-         }
-      }
-      else {
-         if((int_stat & NX_NAND_INT_BLK_WRITE) && (int_ena & NX_NAND_INT_BLK_WRITE)){
-            tmhwEfmc_WriteBufData(nc->unitid, nc->slotid, nc->dmabuf + (nc->blk_index*NX_NAND_BLK_SIZE));
-            nc->blk_index++;
+            nc->done = true;
+            wake_up(&nc->nand_queue);
+        }
+    }
+
+    /* Read command */
+    if((nc->cur_cmd == NAND_CMD_READ0) || (nc->cur_cmd == NAND_CMD_READOOB)) {
+        if((int_stat & NX_NAND_INT_OOB_READ) && (int_ena & NX_NAND_INT_OOB_READ)) {
+            tmhwEfmc_ReadOobData(nc->unitid, nc->slotid, nc->dmabuf+nc->mtd.writesize);
             tmhwEfmc_IntClear(nc->unitid, int_stat);
-         }
-      }
-      
-      if((int_stat & NX_NAND_INT_SEQ_WRITE) && (int_ena & NX_NAND_INT_SEQ_WRITE)) {
-         tmhwEfmc_IntClear(nc->unitid, int_stat);
-      }
-      
-      if((int_stat & (1 << (NX_NAND_INT_READY_START + nc->slotid))) && (int_ena & (1 << (NX_NAND_INT_READY_START + nc->slotid)))) {
-         tmhwEfmc_IntClear(nc->unitid, int_stat);
-         nc->done = true;
-         wake_up(&nc->nand_queue);
-      }
-   }
-   
-   /* Read command */
-   if((nc->cur_cmd == NAND_CMD_READ0) || (nc->cur_cmd == NAND_CMD_READOOB)) {
-      if((int_stat & NX_NAND_INT_OOB_READ) && (int_ena & NX_NAND_INT_OOB_READ)) {
-         tmhwEfmc_ReadOobData(nc->unitid, nc->slotid, nc->dmabuf+nc->mtd.writesize);
-         tmhwEfmc_IntClear(nc->unitid, int_stat);
-         nc->done = true;
-         wake_up(&nc->nand_queue);
-      }
-      
-      if(nc->hwecc) {
-         if((int_stat & NX_NAND_INT_DEC) && (int_ena & NX_NAND_INT_DEC)) {
-            tmhwEfmc_ReadBufData(nc->unitid, nc->slotid, nc->dmabuf+(nc->blk_index * NX_NAND_BLK_SIZE));
-            nc->ecc_status[nc->blk_index] = (int_stat & (NX_NAND_INT_DEC_UNCOR | 
-                                                            NX_NAND_INT_DEC_0_ERR | 
-                                                            NX_NAND_INT_DEC_1_ERR |
-                                                            NX_NAND_INT_DEC_2_ERR |
-                                                            NX_NAND_INT_DEC_3_ERR |
-                                                            NX_NAND_INT_DEC_4_ERR |
-                                                            NX_NAND_INT_DEC_5_ERR));
-            nc->blk_index++;
+            nc->done = true;
+            wake_up(&nc->nand_queue);
+        }
+
+        if(nc->hwecc) {
+            if((int_stat & NX_NAND_INT_DEC) && (int_ena & NX_NAND_INT_DEC)) {
+                tmhwEfmc_ReadBufData(nc->unitid, nc->slotid, nc->dmabuf+(nc->blk_index * NX_NAND_BLK_SIZE));
+                nc->ecc_status[nc->blk_index] = (int_stat & (NX_NAND_INT_DEC_UNCOR | 
+                            NX_NAND_INT_DEC_0_ERR | 
+                            NX_NAND_INT_DEC_1_ERR |
+                            NX_NAND_INT_DEC_2_ERR |
+                            NX_NAND_INT_DEC_3_ERR |
+                            NX_NAND_INT_DEC_4_ERR |
+                            NX_NAND_INT_DEC_5_ERR));
+                nc->blk_index++;
+                tmhwEfmc_IntClear(nc->unitid, int_stat);
+            }
+        }
+        else {
+            if((int_stat & NX_NAND_INT_BLK_READ) && (int_ena & NX_NAND_INT_BLK_READ)) {
+                tmhwEfmc_ReadBufData(nc->unitid, nc->slotid, nc->dmabuf+(nc->blk_index * NX_NAND_BLK_SIZE));
+                nc->blk_index++;
+                tmhwEfmc_IntClear(nc->unitid, int_stat);
+            }
+        }
+
+        if((int_stat & NX_NAND_INT_SEQ_READ) && (int_ena & NX_NAND_INT_SEQ_READ) ){
             tmhwEfmc_IntClear(nc->unitid, int_stat);
-         }
-      }
-      else {
-         if((int_stat & NX_NAND_INT_BLK_READ) && (int_ena & NX_NAND_INT_BLK_READ)) {
-            tmhwEfmc_ReadBufData(nc->unitid, nc->slotid, nc->dmabuf+(nc->blk_index * NX_NAND_BLK_SIZE));
-            nc->blk_index++;
+        }
+    }
+
+    /* Erase command */
+    if(nc->cur_cmd == NAND_CMD_ERASE1) {
+        if((int_stat & (1 << (NX_NAND_INT_READY_START + nc->slotid))) && (int_ena & (1 << (NX_NAND_INT_READY_START + nc->slotid)))) {
             tmhwEfmc_IntClear(nc->unitid, int_stat);
-         }
-      }
-      
-      if((int_stat & NX_NAND_INT_SEQ_READ) && (int_ena & NX_NAND_INT_SEQ_READ) ){
-         tmhwEfmc_IntClear(nc->unitid, int_stat);
-      }
-   }
-   
-   /* Erase command */
-   if(nc->cur_cmd == NAND_CMD_ERASE1) {
-      if((int_stat & (1 << (NX_NAND_INT_READY_START + nc->slotid))) && (int_ena & (1 << (NX_NAND_INT_READY_START + nc->slotid)))) {
-         tmhwEfmc_IntClear(nc->unitid, int_stat);
-         nc->done = true;
-         wake_up(&nc->nand_queue);
-      }
-   }
+            nc->done = true;
+            wake_up(&nc->nand_queue);
+        }
+    }
 #endif   
-   return IRQ_HANDLED;
+    return IRQ_HANDLED;
 }
 
 /**
-* nx_nand_probe - Module probe function
-* @pdev: Device structure
-*
-* Probes the device & do the initialisation
-*/
+ * nx_nand_probe - Module probe function
+ * @pdev: Device structure
+ *
+ * Probes the device & do the initialisation
+ */
 static int nx_nand_probe(struct platform_device *pdev)
 {
-   struct resource *res1, *res2;
-   struct nand_chip *chip;
-   struct mtd_info *mtd;
-   tmhwEfmc_Capabilities_t pcaps;
-   tmhwEfmc_FlashConfig_t  pconfig;
-   int ret=0;  
-
-   /* Allocate memory for nand control structure */
-   nx_nc = kzalloc(sizeof(struct nx_nand_ctrl), GFP_KERNEL);
-   if (!nx_nc) {
-      printk(KERN_ERR "nx_nand: NAND ctrl mem alloc \r\n");
-      return -ENOMEM;
-   }
-
-   /* Unit ID */
-   nx_nc->unitid = 0;
-
-   /* Get I/O resource */
-   res1 = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-   if (!res1) {
-      printk(KERN_ERR "nx_nand: NAND get resource \r\n");   
-      ret = -ENXIO;
-      goto out_free1;
-   }
-   
-   /* Ioremap controller base */
-   nx_nc->ctrl_base = devm_ioremap(&pdev->dev, res1->start, (res1->end-res1->start+1));
-   if (!nx_nc->ctrl_base) {
-      printk(KERN_ERR "nx_nand: NAND base devm_iormep \r\n");  
-      ret = -ENOMEM;
-      goto out_free1;
-   }
-
-   /* Get interrupt resource */
-   res2 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-   if (!res2) {
-      printk(KERN_ERR "nx_nand: NAND get resource \r\n");   
-      ret = -ENXIO;
-      goto out_free1;
-   }
-   
-   /* Alloc IRQ */
-   ret = devm_request_irq (&pdev->dev, res2->start, 
-         nx_nand_ctrl_isr, IRQF_DISABLED, "nx_2070", nx_nc);
-   if (ret < 0){
-      printk(KERN_ERR "nx_nand: NAND irq alloc \r\n");   
-      goto out_free1;
-   }
-   
+    struct resource *res1, *res2;
+    struct nand_chip *chip;
+    struct mtd_info *mtd;
+    tmhwEfmc_Capabilities_t pcaps;
+    tmhwEfmc_FlashConfig_t  pconfig;
+    int ret=0;  
+
+    /* Allocate memory for nand control structure */
+    nx_nc = kzalloc(sizeof(struct nx_nand_ctrl), GFP_KERNEL);
+    if (!nx_nc) {
+        printk(KERN_ERR "nx_nand: NAND ctrl mem alloc \r\n");
+        return -ENOMEM;
+    }
+
+    /* Unit ID */
+    nx_nc->unitid = 0;
+
+    /* Get I/O resource */
+    res1 = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (!res1) {
+        printk(KERN_ERR "nx_nand: NAND get resource \r\n");   
+        ret = -ENXIO;
+        goto out_free1;
+    }
+
+    /* Ioremap controller base */
+    nx_nc->ctrl_base = devm_ioremap(&pdev->dev, res1->start, (res1->end-res1->start+1));
+    if (!nx_nc->ctrl_base) {
+        printk(KERN_ERR "nx_nand: NAND base devm_iormep \r\n");  
+        ret = -ENOMEM;
+        goto out_free1;
+    }
+
+    /* Get interrupt resource */
+    res2 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+    if (!res2) {
+        printk(KERN_ERR "nx_nand: NAND get resource \r\n");   
+        ret = -ENXIO;
+        goto out_free1;
+    }
+
+    /* Alloc IRQ */
+    ret = devm_request_irq (&pdev->dev, res2->start, 
+            nx_nand_ctrl_isr, IRQF_DISABLED, "nx_2070", nx_nc);
+    if (ret < 0){
+        printk(KERN_ERR "nx_nand: NAND irq alloc \r\n");   
+        goto out_free1;
+    }
+
 #ifndef CONFIG_MTD_NX_NAND_DMAC
-   /* Ioremap AHB buffer for interrupt flow control */
-   nx_nc->ahb_buf = devm_ioremap(&pdev->dev, NX_NAND_AHB_BUF, NX_NAND_AHB_BUF_MAX_SIZE);
-   if (!nx_nc->ahb_buf) {
-      goto out_free1;
-   }
-#endif
-   
-   /* Store in dev structure */
-   dev_set_drvdata(&pdev->dev, nx_nc);
-   
-   /* Store in HwAPI config */
-   gktmhwEfmc_Config[nx_nc->unitid].baseAddress = (uint32_t) nx_nc->ctrl_base;
-   gktmhwEfmc_Config[nx_nc->unitid].ahbMemAddress = (uint8_t *)nx_nc->ahb_buf;
-
-   /* Init wait queue */
-   init_waitqueue_head(&nx_nc->nand_queue);
-   
-   /* Read the control configuration & store */
-   ret = tmhwEfmc_GetCapabilities(nx_nc->unitid, &pcaps);
-   nx_nc->aes = pcaps.supportAES;
-   nx_nc->slots = pcaps.maxDevices;
-   nx_nc->slotid = 0;
-   
-   /* Flash configuration */
-   ret = tmhwEfmc_GetFlashConfig(nx_nc->unitid, nx_nc->slotid, &pconfig);
-      
-   /* Initialise the lbchip flag to false */
-   nx_nc->cedontcare = pconfig.enableCENDontCare; /* CE don;t care support */
-   nx_nc->lb_chip = 0;
-   mtd = &nx_nc->mtd;
-   mtd->owner = THIS_MODULE;
-   /* mtd->name = "nx_2017"; This has to come from the platform driver*/
-   mtd->name = pdev->name;
-   chip = &nx_nc->chip;
-   mtd->priv = chip;
-
-   /* Initialize hardware controller structure */
-   spin_lock_init(&nx_nc->nandctrl.lock);
-   init_waitqueue_head(&nx_nc->nandctrl.wq);
-   chip->controller = &nx_nc->nandctrl;
-
-   /* Store reference to the nx_nand structure */
-   chip->priv = nx_nc;
-   
-   /* Chip Information */
-   chip->chip_delay = 0;
-   chip->options = NAND_NO_AUTOINCR | NAND_ALLOW_CLEAR_BBT |
-      NAND_NO_SUBPAGE_WRITE;
-   chip->select_chip = nx_nand_select_chip;
-   chip->dev_ready = nx_nand_dev_ready;
-   if (pconfig.dataWidth) {
-      chip->options |= NAND_BUSWIDTH_16;
-      chip->read_byte = nx_nand_read_byte16;
-   } else {
-      chip->read_byte = nx_nand_read_byte;
-   }
-
-   chip->cmdfunc = nx_nand_command;
-   chip->ecc.read_page_raw = nx_nand_read_page_raw;
-   chip->ecc.write_page_raw = nx_nand_write_page_raw;
-   chip->ecc.read_oob = nx_nand_read_oob;
-   chip->ecc.write_oob = nx_nand_write_oob;
-   chip->read_buf = nx_nand_read_buf;
-   chip->write_buf = nx_nand_write_buf;
-   chip->block_bad = nx_nand_block_bad;
-   
+    /* Ioremap AHB buffer for interrupt flow control */
+    nx_nc->ahb_buf = devm_ioremap(&pdev->dev, NX_NAND_AHB_BUF, NX_NAND_AHB_BUF_MAX_SIZE);
+    if (!nx_nc->ahb_buf) {
+        goto out_free1;
+    }
+#endif
+
+    /* Store in dev structure */
+    dev_set_drvdata(&pdev->dev, nx_nc);
+
+    /* Store in HwAPI config */
+    gktmhwEfmc_Config[nx_nc->unitid].baseAddress = (uint32_t) nx_nc->ctrl_base;
+    gktmhwEfmc_Config[nx_nc->unitid].ahbMemAddress = (uint8_t *)nx_nc->ahb_buf;
+
+    /* Init wait queue */
+    init_waitqueue_head(&nx_nc->nand_queue);
+
+    /* Read the control configuration & store */
+    ret = tmhwEfmc_GetCapabilities(nx_nc->unitid, &pcaps);
+    nx_nc->aes = pcaps.supportAES;
+    nx_nc->slots = pcaps.maxDevices;
+    nx_nc->slotid = 0;
+
+    /* Flash configuration */
+    ret = tmhwEfmc_GetFlashConfig(nx_nc->unitid, nx_nc->slotid, &pconfig);
+
+    /* Initialise the lbchip flag to false */
+    nx_nc->cedontcare = pconfig.enableCENDontCare; /* CE don;t care support */
+    nx_nc->lb_chip = 0;
+    mtd = &nx_nc->mtd;
+    mtd->owner = THIS_MODULE;
+    /* mtd->name = "nx_2017"; This has to come from the platform driver*/
+    mtd->name = pdev->name;
+    chip = &nx_nc->chip;
+    mtd->priv = chip;
+
+    /* Initialize hardware controller structure */
+    spin_lock_init(&nx_nc->nandctrl.lock);
+    init_waitqueue_head(&nx_nc->nandctrl.wq);
+    chip->controller = &nx_nc->nandctrl;
+
+    /* Store reference to the nx_nand structure */
+    chip->priv = nx_nc;
+
+    /* Chip Information */
+    chip->chip_delay = 0;
+    chip->options = NAND_NO_AUTOINCR | NAND_ALLOW_CLEAR_BBT |
+        NAND_NO_SUBPAGE_WRITE;
+    chip->select_chip = nx_nand_select_chip;
+    chip->dev_ready = nx_nand_dev_ready;
+    if (pconfig.dataWidth) {
+        chip->options |= NAND_BUSWIDTH_16;
+        chip->read_byte = nx_nand_read_byte16;
+    } else {
+        chip->read_byte = nx_nand_read_byte;
+    }
+
+    chip->cmdfunc = nx_nand_command;
+    chip->ecc.read_page_raw = nx_nand_read_page_raw;
+    chip->ecc.write_page_raw = nx_nand_write_page_raw;
+    chip->ecc.read_oob = nx_nand_read_oob;
+    chip->ecc.write_oob = nx_nand_write_oob;
+    chip->read_buf = nx_nand_read_buf;
+    chip->write_buf = nx_nand_write_buf;
+    chip->block_bad = nx_nand_block_bad;
+
 #ifdef CONFIG_MTD_NX_NAND_HWECC
-   nx_nc->hwecc = true;
-   chip->ecc.read_page = nx_nand_read_page;
-   chip->ecc.write_page = nx_nand_write_page;
-   chip->ecc.mode = NAND_ECC_HW_SYNDROME;
-   chip->ecc.calculate = nx_nand_calculate_ecc;
-   chip->ecc.correct = nx_nand_correct_data;
-   chip->ecc.hwctl = nx_nand_hwctl;
-   chip->ecc.size = 512;
-   chip->ecc.bytes = 12;
-   chip->bbt_td = &nx_bbt_main;  
-   chip->bbt_md = &nx_bbt_mirror;
+    nx_nc->hwecc = true;
+    chip->ecc.read_page = nx_nand_read_page;
+    chip->ecc.write_page = nx_nand_write_page;
+    chip->ecc.mode = NAND_ECC_HW_SYNDROME;
+    chip->ecc.calculate = nx_nand_calculate_ecc;
+    chip->ecc.correct = nx_nand_correct_data;
+    chip->ecc.hwctl = nx_nand_hwctl;
+    chip->ecc.size = 512;
+    chip->ecc.bytes = 12;
+    chip->bbt_td = &nx_bbt_main;  
+    chip->bbt_md = &nx_bbt_mirror;
 #endif
 
 #ifdef CONFIG_MTD_NX_NAND_SWECC
-   nx_nc->hwecc = false;
-   chip->ecc.mode = NAND_ECC_SOFT;
+    nx_nc->hwecc = false;
+    chip->ecc.mode = NAND_ECC_SOFT;
 #endif
 
 #ifdef CONFIG_MTD_NX_NAND_NONEECC
-   chip->ecc.read_page = nx_nand_read_page_raw;
-   chip->ecc.write_page = nx_nand_write_page_raw;
-   nx_nc->hwecc = false;
-   chip->ecc.mode = NAND_ECC_NONE;
-#endif
-   
-   /* Call chip identify function */
-   if(nand_scan_ident(mtd, 1)) {
-      printk(KERN_ERR "nx_nand: NAND scan ident \r\n");  
-      ret = -ENXIO;
-      goto out_free1;
-   }
-   
-   /* Calculate number of 512byte blocks in a page */
-   nx_nc->num_blks = mtd->writesize >> 9;
-   
-   /* Allocate ECC status array */
-   nx_nc->ecc_status = kzalloc(sizeof(int) * nx_nc->num_blks, GFP_KERNEL);
-   if(!nx_nc->ecc_status) {
-      printk(KERN_ERR "nx_nand: ECC status alloc \r\n");
-      ret = -ENOMEM;
-      goto out_free1;
-   }
-
-   /* Allocate internal driver buffer */
-   nx_nc->dmabuf = dmam_alloc_coherent(&pdev->dev,
-         mtd->writesize + mtd->oobsize, 
-         &nx_nc->dmabuf_phy, GFP_DMA | GFP_KERNEL);
-   if(!nx_nc->dmabuf) {
-      printk(KERN_ERR "nx_nand: DMA buf alloc \r\n");
-      ret = -ENOMEM;
-      goto out_free1;
-   }
-
-   if(chip->options & NAND_SAMSUNG_LP_OPTIONS) {
-      chip->cmdfunc = nx_nand_command_lp;
-      nx_nc->lb_chip = 1;
-   }
+    chip->ecc.read_page = nx_nand_read_page_raw;
+    chip->ecc.write_page = nx_nand_write_page_raw;
+    nx_nc->hwecc = false;
+    chip->ecc.mode = NAND_ECC_NONE;
+#endif
 
-   chip->options |= NAND_ALLOW_CLEAR_BBT | NAND_NO_SUBPAGE_WRITE | NAND_USE_FLASH_BBT;
+    /* Allocate temp driver buffer for ONFI PARAM page read */
+    nx_nc->dmabuf = dmam_alloc_coherent(&pdev->dev,
+            8*NX_NAND_BLK_SIZE, 
+            &nx_nc->dmabuf_phy, GFP_DMA | GFP_KERNEL);
+    if(!nx_nc->dmabuf) {
+        printk(KERN_ERR "nx_nand: DMA buf alloc \r\n");
+        ret = -ENOMEM;
+        goto out_free1;
+    }
+
+    /* Call chip identify function */
+    if(nand_scan_ident(mtd, 1, NULL)) {
+        printk(KERN_ERR "nx_nand: NAND scan ident \r\n");  
+        ret = -ENXIO;
+        goto out_free1;
+    }
+
+    /* Free temp driver buffer */
+    dmam_free_coherent(&pdev->dev,
+            8*NX_NAND_BLK_SIZE,
+            nx_nc->dmabuf,
+            nx_nc->dmabuf_phy);
+
+    /* Calculate number of 512byte blocks in a page */
+    nx_nc->num_blks = mtd->writesize >> 9;
+
+    /* Allocate ECC status array */
+    nx_nc->ecc_status = kzalloc(sizeof(int) * nx_nc->num_blks, GFP_KERNEL);
+    if(!nx_nc->ecc_status) {
+        printk(KERN_ERR "nx_nand: ECC status alloc \r\n");
+        ret = -ENOMEM;
+        goto out_free1;
+    }
+
+    /* Allocate internal driver buffer */
+    nx_nc->dmabuf = dmam_alloc_coherent(&pdev->dev,
+            mtd->writesize + mtd->oobsize, 
+            &nx_nc->dmabuf_phy, GFP_DMA | GFP_KERNEL);
+    if(!nx_nc->dmabuf) {
+        printk(KERN_ERR "nx_nand: DMA buf alloc \r\n");
+        ret = -ENOMEM;
+        goto out_free1;
+    }
+
+    if(mtd->writesize > 512) {
+        chip->cmdfunc = nx_nand_command_lp;
+        nx_nc->lb_chip = 1;
+    }
+
+    chip->options |= NAND_ALLOW_CLEAR_BBT | NAND_NO_SUBPAGE_WRITE | NAND_USE_FLASH_BBT ;
 
 #ifdef CONFIG_MTD_NX_NAND_HWECC
-   switch (mtd->oobsize) {
-      case 16:
-         chip->ecc.layout = &nx_nand_oob_16;
-         break;
-      case 64:
-         chip->ecc.layout = &nx_nand_oob_64;
-         break;
-     case 128:
-        chip->ecc.layout = &nx_nand_oob_128;
-        break;
-      default:
-         printk(KERN_WARNING "No oob scheme defined for "
-                "oobsize %d\n", mtd->oobsize);
-         BUG();
-   }
+    switch (mtd->oobsize) {
+        case 16:
+            chip->ecc.layout = &nx_nand_oob_16;
+            break;
+        case 64:
+            chip->ecc.layout = &nx_nand_oob_64;
+            break;
+        case 128:
+            chip->ecc.layout = &nx_nand_oob_128;
+            break;
+        default:
+            printk(KERN_WARNING "No oob scheme defined for "
+                    "oobsize %d\n", mtd->oobsize);
+            BUG();
+    }
 #endif   
-   
-   if(nand_scan_tail(mtd)) {
-      printk(KERN_ERR "nx_nand: NAND scan tail \r\n");   
-      ret = -ENXIO;
-      goto out_free1;
-   }
-   
-   mtd->repartition = nx_nand_repartition;
+
+    if(nand_scan_tail(mtd)) {
+        printk(KERN_ERR "nx_nand: NAND scan tail \r\n");   
+        ret = -ENXIO;
+        goto out_free1;
+    }
+
+    mtd->repartition = nx_nand_repartition;
 
 #ifdef CONFIG_MTD_PERF_MEAS
-   mtd->perf_meas = mtd_perf_meas;
+    mtd->perf_meas = mtd_perf_meas;
 #endif
-   
-   /* Scan for the partitions */
-   nx_nand_scan_partitions(mtd);
 
-   return 0;
+    /* Scan for the partitions */
+    nx_nand_scan_partitions(mtd);
+
+    return 0;
 
 out_free1:  
-   kfree(nx_nc);
+    kfree(nx_nc);
 
-   return ret;
+    return ret;
 }
 
 /**
-* nx_nand_remove - Module remove function
-* @pdev: Device structure
-*
-* Removes the device & do the deinitialisation
-*/
+ * nx_nand_remove - Module remove function
+ * @pdev: Device structure
+ *
+ * Removes the device & do the deinitialisation
+ */
 static int nx_nand_remove(struct platform_device *pdev)
 {
-   struct nx_nand_ctrl *nc = dev_get_drvdata(&pdev->dev);
+    struct nx_nand_ctrl *nc = dev_get_drvdata(&pdev->dev);
 
-   /* Release resources */
-   nand_release(&nc->mtd);
+    /* Release resources */
+    nand_release(&nc->mtd);
 
-   /* Free DMA buf */
-   kfree(nc);
-   
-   return 0;
+    /* Free DMA buf */
+    kfree(nc);
+
+    return 0;
 }
 
 #ifdef CONFIG_PM
 
 static int nx_nand_suspend(struct platform_device *pdev, pm_message_t state)
 {
-   struct nx_nand_ctrl *nc = dev_get_drvdata(&pdev->dev);
-   int ret = 0;
-   unsigned long val;
-
-   if (nc)
-   { 
-      if(nc->mtd.suspend)
-         ret = nc->mtd.suspend(&nc->mtd);
-
-      /* Put the controller (IP2017) into power down mode */
-      if(!ret)
-      {
-         val = readl((nc->ctrl_base + NX_NAND_POWER_DOWN_CFG_OFFSET));
-
-         val &= ~NX_NAND_POWER_DOWN_MASK;
-         val |= (NX_NAND_POWER_DOWN_ENABLE & NX_NAND_POWER_DOWN_MASK);
-
-         writel(val, (nc->ctrl_base + NX_NAND_POWER_DOWN_CFG_OFFSET));
-      }
-   }
+    struct nx_nand_ctrl *nc = dev_get_drvdata(&pdev->dev);
+    int ret = 0;
+    unsigned long val;
+
+    if (nc)
+    { 
+        if(nc->mtd.suspend)
+            ret = nc->mtd.suspend(&nc->mtd);
+
+        /* Put the controller (IP2017) into power down mode */
+        if(!ret)
+        {
+            val = readl((nc->ctrl_base + NX_NAND_POWER_DOWN_CFG_OFFSET));
+
+            val &= ~NX_NAND_POWER_DOWN_MASK;
+            val |= (NX_NAND_POWER_DOWN_ENABLE & NX_NAND_POWER_DOWN_MASK);
 
-   return ret;
+            writel(val, (nc->ctrl_base + NX_NAND_POWER_DOWN_CFG_OFFSET));
+        }
+    }
+
+    return ret;
 }
 
 static int nx_nand_resume(struct platform_device *pdev)
 {
-   struct nx_nand_ctrl *nc = dev_get_drvdata(&pdev->dev);
-   unsigned long val;
+    struct nx_nand_ctrl *nc = dev_get_drvdata(&pdev->dev);
+    unsigned long val;
 
-   if (nc)
-   {
-      /* Bring the controller out of power down mode */
-      val = readl((nc->ctrl_base + NX_NAND_POWER_DOWN_CFG_OFFSET));
+    if (nc)
+    {
+        /* Bring the controller out of power down mode */
+        val = readl((nc->ctrl_base + NX_NAND_POWER_DOWN_CFG_OFFSET));
 
-      val &= ~NX_NAND_POWER_DOWN_MASK;
-      val |= (NX_NAND_POWER_DOWN_DISABLE & NX_NAND_POWER_DOWN_MASK);
+        val &= ~NX_NAND_POWER_DOWN_MASK;
+        val |= (NX_NAND_POWER_DOWN_DISABLE & NX_NAND_POWER_DOWN_MASK);
 
-      writel(val, (nc->ctrl_base + NX_NAND_POWER_DOWN_CFG_OFFSET));
+        writel(val, (nc->ctrl_base + NX_NAND_POWER_DOWN_CFG_OFFSET));
 
-      if (nc->mtd.resume)
-         nc->mtd.resume(&nc->mtd);
-   }
+        if (nc->mtd.resume)
+            nc->mtd.resume(&nc->mtd);
+    }
 
-   return 0;
+    return 0;
 }
 #else
 
@@ -2432,39 +2489,39 @@ static int nx_nand_resume(struct platfor
 #endif
 
 /**
-* NAND device registration
-*/
+ * NAND device registration
+ */
 static struct platform_driver nx_nand_driver = {
-   .probe      = nx_nand_probe,
-   .remove     = nx_nand_remove,
-   .suspend    = nx_nand_suspend,
-   .resume     = nx_nand_resume,
-   .driver     = {
-      .name = "nx_2017",
-      .owner   = THIS_MODULE,
-   },
+    .probe      = nx_nand_probe,
+    .remove     = nx_nand_remove,
+    .suspend    = nx_nand_suspend,
+    .resume     = nx_nand_resume,
+    .driver     = {
+        .name = "nx_2017",
+        .owner   = THIS_MODULE,
+    },
 };
 
 /**
-* nx_nand_init - Module initialisation function
-*
-* Register the NAND driver
-*/
+ * nx_nand_init - Module initialisation function
+ *
+ * Register the NAND driver
+ */
 static int __init nx_nand_init(void)
 {
-   return platform_driver_register(&nx_nand_driver);
+    return platform_driver_register(&nx_nand_driver);
 }
 module_init(nx_nand_init);
 
 #ifdef MODULE
 /**
-* nx_nand_exit - Module exit function
-*
-* Unregister the NAND driver
-*/
+ * nx_nand_exit - Module exit function
+ *
+ * Unregister the NAND driver
+ */
 static void __exit nx_nand_exit(void)
 {
-   platform_driver_unregister(&nx_nand_driver);
+    platform_driver_unregister(&nx_nand_driver);
 }
 module_exit(nx_nand_exit);
 #endif
@@ -2472,5 +2529,5 @@ module_exit(nx_nand_exit);
 EXPORT_SYMBOL(nx_nc);
 
 MODULE_LICENSE("GPL");
-MODULE_AUTHOR("NXP B.V.");
+MODULE_AUTHOR("TRIDENT MICROSYSTEMS");
 MODULE_DESCRIPTION("NAND Flash driver for IP_2070 NAND controller");
diff -Naurp linux-2.6.34.org/drivers/mtd/nand/nx_nand/tmhwEfmc/src/tmhwEfmc.c linux-2.6.34/drivers/mtd/nand/nx_nand/tmhwEfmc/src/tmhwEfmc.c
--- linux-2.6.34.org/drivers/mtd/nand/nx_nand/tmhwEfmc/src/tmhwEfmc.c	2011-04-06 19:08:15.000000000 -0500
+++ linux-2.6.34/drivers/mtd/nand/nx_nand/tmhwEfmc/src/tmhwEfmc.c	2011-04-14 12:52:48.000000000 -0500
@@ -34,6 +34,7 @@
 /*-----------------------------------------------------------------------------
 * Project specific include files:
 *-----------------------------------------------------------------------------*/
+#include <linux/io.h>
 #include "tmNxTypes.h"
 #include "tmNxCompId.h"
 
diff -Naurp linux-2.6.34.org/drivers/mtd/nand/nx_nand/tmhwEfmc/src/tmhwEfmc_Vhip.h linux-2.6.34/drivers/mtd/nand/nx_nand/tmhwEfmc/src/tmhwEfmc_Vhip.h
--- linux-2.6.34.org/drivers/mtd/nand/nx_nand/tmhwEfmc/src/tmhwEfmc_Vhip.h	2011-04-06 19:08:15.000000000 -0500
+++ linux-2.6.34/drivers/mtd/nand/nx_nand/tmhwEfmc/src/tmhwEfmc_Vhip.h	2011-04-13 15:38:01.000000000 -0500
@@ -53,12 +53,11 @@ extern "C"
 * Typedefs and Macros
 *-----------------------------------------------------------------------------*/
 #ifndef TMVH_GEN_READ
-#define TMVH_GEN_READ(address,result) \
-        (result) = (*(volatile UInt32 *)(address))
+#define TMVH_GEN_READ(_address_,_result_) {_result_ = readl(_address_);}
 #endif
 
 #ifndef TMVH_GEN_WRITE
-#define TMVH_GEN_WRITE(address,value) (*((volatile UInt32 *)(address)) = (value))
+#define TMVH_GEN_WRITE(_address_,_value_) writel(_value_,_address_)
 #endif
 
 /**---------------------------------------------------------------------------*/
diff -Naurp linux-2.6.34.org/include/linux/mtd/bbm.h linux-2.6.34/include/linux/mtd/bbm.h
--- linux-2.6.34.org/include/linux/mtd/bbm.h	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/include/linux/mtd/bbm.h	2011-04-13 13:14:38.000000000 -0500
@@ -82,6 +82,14 @@ struct nand_bbt_descr {
 #define NAND_BBT_SAVECONTENT	0x00002000
 /* Search good / bad pattern on the first and the second page */
 #define NAND_BBT_SCAN2NDPAGE	0x00004000
+/* Search good / bad pattern on the last page of the eraseblock */
+#define NAND_BBT_SCANLASTPAGE	0x00008000
+/* Chip stores bad block marker on BOTH 1st and 6th bytes of OOB */
+#define NAND_BBT_SCANBYTE1AND6 0x00100000
+/* The nand_bbt_descr was created dynamicaly and must be freed */
+#define NAND_BBT_DYNAMICSTRUCT 0x00200000
+/* The bad block table does not OOB for marker */
+#define NAND_BBT_NO_OOB		0x00400000
 
 /* The maximum number of blocks to scan for a bbt */
 #define NAND_BBT_SCAN_MAXBLOCKS	4
diff -Naurp linux-2.6.34.org/include/linux/mtd/mtd.h linux-2.6.34/include/linux/mtd/mtd.h
--- linux-2.6.34.org/include/linux/mtd/mtd.h	2011-04-06 19:08:21.000000000 -0500
+++ linux-2.6.34/include/linux/mtd/mtd.h	2011-04-13 12:41:36.000000000 -0500
@@ -120,6 +120,17 @@ struct mtd_info {
 	 */
 	uint32_t writesize;
 
+	/*
+	 * Size of the write buffer used by the MTD. MTD devices having a write
+	 * buffer can write multiple writesize chunks at a time. E.g. while
+	 * writing 4 * writesize bytes to a device with 2 * writesize bytes
+	 * buffer the MTD driver can (but doesn't have to) do 2 writesize
+	 * operations, but not 4. Currently, all NANDs have writebufsize
+	 * equivalent to writesize (NAND page size). Some NOR flashes do have
+	 * writebufsize greater than writesize.
+	 */
+	uint32_t writebufsize;
+
 	uint32_t oobsize;   // Amount of OOB data per block (e.g. 16)
 	uint32_t oobavail;  // Available OOB bytes per block
 
diff -Naurp linux-2.6.34.org/include/linux/mtd/nand.h linux-2.6.34/include/linux/mtd/nand.h
--- linux-2.6.34.org/include/linux/mtd/nand.h	2011-04-06 19:08:17.000000000 -0500
+++ linux-2.6.34/include/linux/mtd/nand.h	2011-04-14 12:17:29.000000000 -0500
@@ -25,11 +25,15 @@
 #include <linux/mtd/bbm.h>
 
 struct mtd_info;
+struct nand_flash_dev;
 /* Scan and identify a NAND device */
 extern int nand_scan (struct mtd_info *mtd, int max_chips);
-/* Separate phases of nand_scan(), allowing board driver to intervene
- * and override command or ECC setup according to flash type */
-extern int nand_scan_ident(struct mtd_info *mtd, int max_chips);
+/*
+ * Separate phases of nand_scan(), allowing board driver to intervene
+ * and override command or ECC setup according to flash type.
+ */
+extern int nand_scan_ident(struct mtd_info *mtd, int max_chips,
+			   struct nand_flash_dev *table);
 extern int nand_scan_tail(struct mtd_info *mtd);
 
 /* Free resources held by the NAND device */
@@ -80,8 +84,13 @@ extern void nand_wait_ready(struct mtd_i
 #define NAND_CMD_RNDIN		0x85
 #define NAND_CMD_READID		0x90
 #define NAND_CMD_ERASE2		0xd0
+#define NAND_CMD_PARAM		0xec
 #define NAND_CMD_RESET		0xff
 
+#define NAND_CMD_LOCK		0x2a
+#define NAND_CMD_UNLOCK1	0x23
+#define NAND_CMD_UNLOCK2	0x24
+
 /* Extended commands for large page devices */
 #define NAND_CMD_READSTART	0x30
 #define NAND_CMD_RNDOUTSTART	0xE0
@@ -172,6 +181,11 @@ typedef enum {
 /* Allow clearing of bad block table entries */
 #define NAND_ALLOW_CLEAR_BBT	0x00000400
 
+/* Device is one of 'new' xD cards that expose fake nand command set */
+#define NAND_BROKEN_XD		0x00000400
+
+/* Device behaves just like nand, but is readonly */
+#define NAND_ROM		0x00000800
 
 /* Options valid for Samsung large page devices */
 #define NAND_SAMSUNG_LP_OPTIONS \
@@ -200,6 +214,13 @@ typedef enum {
 #define NAND_OWN_BUFFERS	0x00040000
 /* Chip may not exist, so silence any errors in scan */
 #define NAND_SCAN_SILENT_NODEV	0x00080000
+/*
+ * If passed additionally to NAND_USE_FLASH_BBT then BBT code will not touch
+ * the OOB area.
+ */
+#define NAND_USE_FLASH_BBT_NO_OOB	0x00100000
+/* Create an empty BBT with no vendor information if the BBT is available */
+#define NAND_CREATE_EMPTY_BBT		0x00200000
 
 /* Options set by nand scan */
 /* Nand scan has allocated controller struct */
@@ -212,6 +233,70 @@ typedef enum {
 /* Keep gcc happy */
 struct nand_chip;
 
+struct nand_onfi_params {
+	/* rev info and features block */
+	/* 'O' 'N' 'F' 'I'  */
+	u8 sig[4];
+	__le16 revision;
+	__le16 features;
+	__le16 opt_cmd;
+	u8 reserved[22];
+
+	/* manufacturer information block */
+	char manufacturer[12];
+	char model[20];
+	u8 jedec_id;
+	__le16 date_code;
+	u8 reserved2[13];
+
+	/* memory organization block */
+	__le32 byte_per_page;
+	__le16 spare_bytes_per_page;
+	__le32 data_bytes_per_ppage;
+	__le16 spare_bytes_per_ppage;
+	__le32 pages_per_block;
+	__le32 blocks_per_lun;
+	u8 lun_count;
+	u8 addr_cycles;
+	u8 bits_per_cell;
+	__le16 bb_per_lun;
+	__le16 block_endurance;
+	u8 guaranteed_good_blocks;
+	__le16 guaranteed_block_endurance;
+	u8 programs_per_page;
+	u8 ppage_attr;
+	u8 ecc_bits;
+	u8 interleaved_bits;
+	u8 interleaved_ops;
+	u8 reserved3[13];
+
+	/* electrical parameter block */
+	u8 io_pin_capacitance_max;
+	__le16 async_timing_mode;
+	__le16 program_cache_timing_mode;
+	__le16 t_prog;
+	__le16 t_bers;
+	__le16 t_r;
+	__le16 t_ccs;
+	__le16 src_sync_timing_mode;
+	__le16 src_ssync_features;
+	__le16 clk_pin_capacitance_typ;
+	__le16 io_pin_capacitance_typ;
+	__le16 input_pin_capacitance_typ;
+	u8 input_pin_capacitance_max;
+	u8 driver_strenght_support;
+	__le16 t_int_r;
+	__le16 t_ald;
+	u8 reserved4[7];
+
+	/* vendor */
+	u8 reserved5[90];
+
+	__le16 crc;
+} __attribute__((packed));
+
+#define ONFI_CRC_BASE	0x4F4E
+
 /**
  * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independent devices
  * @lock:               protection lock
@@ -371,6 +456,8 @@ struct nand_chip {
 	int		(*block_markbad)(struct mtd_info *mtd, loff_t ofs);
 	void		(*cmd_ctrl)(struct mtd_info *mtd, int dat,
 				    unsigned int ctrl);
+	int (*init_size)(struct mtd_info *mtd, struct nand_chip *this,
+			u8 *id_data);
 	int		(*dev_ready)(struct mtd_info *mtd);
 	void		(*cmdfunc)(struct mtd_info *mtd, unsigned command, int column, int page_addr);
 	int		(*waitfunc)(struct mtd_info *mtd, struct nand_chip *this);
@@ -394,6 +481,10 @@ struct nand_chip {
 	int		subpagesize;
 	uint8_t		cellinfo;
 	int		badblockpos;
+	int badblockbits;
+
+	int onfi_version;
+	struct nand_onfi_params	onfi_params;
 
 	flstate_t	state;
 
diff -Naurp linux-2.6.34.org/include/mtd/mtd-abi.h linux-2.6.34/include/mtd/mtd-abi.h
--- linux-2.6.34.org/include/mtd/mtd-abi.h	2011-04-14 23:17:31.000000000 -0500
+++ linux-2.6.34/include/mtd/mtd-abi.h	2011-04-13 12:11:52.000000000 -0500
@@ -130,13 +130,14 @@ struct nand_oobfree {
 };
 
 #define MTD_MAX_OOBFREE_ENTRIES	8
+#define MTD_MAX_ECCPOS_ENTRIES	96
 /*
  * ECC layout control structure. Exported to userspace for
  * diagnosis and to allow creation of raw images
  */
 struct nand_ecclayout {
 	__u32 eccbytes;
-	__u32 eccpos[96];
+	__u32 eccpos[MTD_MAX_ECCPOS_ENTRIES];
 	__u32 oobavail;
 	struct nand_oobfree oobfree[MTD_MAX_OOBFREE_ENTRIES];
 };
