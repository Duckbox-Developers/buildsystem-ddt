diff -Naurp linux-2.6.34_orig/arch/arm/mach-apollo/include/mach/nx_nand_dev.h linux-2.6.34/arch/arm/mach-apollo/include/mach/nx_nand_dev.h
--- linux-2.6.34_orig/arch/arm/mach-apollo/include/mach/nx_nand_dev.h	2011-05-12 17:15:58.132045000 +0530
+++ linux-2.6.34/arch/arm/mach-apollo/include/mach/nx_nand_dev.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,122 +0,0 @@
-/*
- * Copyright 2010 Trident Microsystems (Far East) Ltd. 
- * All prior copyright rights in this work and the accompanying software 
- * products transferred to Trident Microsystems (Far East) Ltd. by written 
- * agreement.  All rights reserved.
- */
-/*
- * Device driver for EFMC IP_2070.
- *
- * Copyright (C) 2008 NXP B.V.
- * All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- * Revision history
- * Version  	Author           Date          Remarks
- * 0.0.1	Bangaragiri G		20080402	Draft-Initial version
- * 0.1.0	Bangaragiri G		20080804	Proposal-After self review
- * 0.2.0	Bangaragiri G		20080925	Proposal-After including review comments
- * 1.0.0	Bangaragiri G		20090305	Accepted-After testing on TV550M0 board
- * 1.1.0	Bangaragiri G		20090318	Accepted-Updates after OneNAND tests
- * 1.1.0	Sundarapandian A	20090720	Updated for APOLLO
- */
- 
-#ifndef __ARCH_MACH_NX_NAND_DEV_H
-#define __ARCH_MACH_NX_NAND_DEV_H
-
-
-/* FIXME: To be taken from glb.h */
-#define   APOLLO_IP2017_BASE          (0xE0631000)
-#define	  APOLLO_IP2017_LEN           (4096)
-#define   APOLLO_INT_FLASH_CTRL_NAND  (141)  /* Fixme, has to come from irqs.h !! */
-#if 0
-#define   PNX8XXX_ESMC_BASE           (0x1BE2A000)
-#define	  PNX8XXX_ESMC_LEN		      (4096)
-#define	  PNX8XXX_AHB_ONENAND_BASE    (0x1BC60000)
-#define	  PNX8XXX_ONENAND_LEN         (128 * 1024)
-#endif
-
-/* NAND/OneNAND select bit in GLB_MISC2 */
-#define NAND_SELECT  (0x00000100)
-
-/* OneNAND defines */
-#define ONENAND_MAX_PAGE_SIZE  (2048)
-#define ONENAND_2016_AHB_SIZE  (0x40000000)	
-
-/* Base address defintions */
-#define NX_NAND_AHB_INTFC_BUF  	      (0x0000000) /* Physical address of AHB buffer */
-
-/* Max Data buffer size */
-#define NX_NAND_BLK_SIZE          (512)
-
-/* Max OOB buffer size */
-#define NX_NAND_MAX_OOB_SIZE      (128)
-
-/* Maximum AHB buffer size */
-#define NX_NAND_AHB_BUF_MAX_SIZE  (NX_NAND_BLK_SIZE+NX_NAND_MAX_OOB_SIZE)
-
-/* NAND CONTROLLER register definitions */
-#define NX_NAND_INT_ENA_OFFSET    (0xFE4)
-
-#define NX_NAND_POWER_DOWN_CFG_OFFSET (0xFF4)
-#define   NX_NAND_POWER_DOWN_MASK     (0x00000001)
-#define   NX_NAND_POWER_DOWN_ENABLE   (1UL<<0)
-#define   NX_NAND_POWER_DOWN_DISABLE  (0UL<<0)
-
-#define NX_NAND_INT_READY_START   (20)
-
-
-#define NX_NAND_INT_OOB_READ      (1<<0)
-#define NX_NAND_INT_OOB_WRITE     (1<<1)
-#define NX_NAND_INT_BLK_READ      (1<<2)
-#define NX_NAND_INT_BLK_WRITE     (1<<3)
-#define NX_NAND_INT_ENC           (1<<4)
-#define NX_NAND_INT_DEC           (1<<5)
-#define NX_NAND_INT_DEC_0_ERR     (1<<6)
-#define NX_NAND_INT_DEC_1_ERR     (1<<7)
-#define NX_NAND_INT_DEC_2_ERR     (1<<8)
-#define NX_NAND_INT_DEC_3_ERR     (1<<9)
-#define NX_NAND_INT_DEC_4_ERR     (1<<10)
-#define NX_NAND_INT_DEC_5_ERR     (1<<11)
-#define NX_NAND_INT_DEC_UNCOR     (1<<12)
-#define NX_NAND_INT_AES_DEC       (1<<13)
-#define NX_NAND_INT_SEQ_READ      (1<<14)
-#define NX_NAND_INT_SEQ_WRITE     (1<<15)
-#define NX_NAND_INT_BUSY1         (1<<16)
-#define NX_NAND_INT_BUSY2         (1<<17)
-#define NX_NAND_INT_BUSY3         (1<<18)
-#define NX_NAND_INT_BUSY4         (1<<19)
-#define NX_NAND_INT_READY1        (1<<20)
-#define NX_NAND_INT_READY2        (1<<21)
-#define NX_NAND_INT_READY3        (1<<22)
-#define NX_NAND_INT_READY4        (1<<23)
-
-/* Position of address */
-#define NX_NAND_SP_ADDR_MASK      (0xFF)
-#define NX_NAND_SP_ADDR_MASK1     (0x03)
-
-#define NX_NAND_SP_ADDR1_POS      (0)
-#define NX_NAND_SP_ADDR2_POS      (9)
-#define NX_NAND_SP_ADDR3_POS      (17)
-#define NX_NAND_SP_ADDR4_POS      (29)
-
-/* Cmd FIFO bit information */
-#define NX_NAND_CMD_FIFO_CE_START  (19)
-#define NX_NAND_CMD_FIFO_ADDR_CYC  (0x0)
-#define NX_NAND_CMD_FIFO_CMD_CYC   (0x1)
-#define NX_NAND_CMD_FIFO_POST_CMD  (0x2)
-
-#endif /* __ARCH_MACH_NX_NAND_DEV_H */
diff -Naurp linux-2.6.34_orig/arch/arm/mach-apollo/nand.c linux-2.6.34/arch/arm/mach-apollo/nand.c
--- linux-2.6.34_orig/arch/arm/mach-apollo/nand.c	2011-05-12 17:16:00.984886000 +0530
+++ linux-2.6.34/arch/arm/mach-apollo/nand.c	2011-05-05 15:34:25.546644000 +0530
@@ -44,15 +44,15 @@ static int __init apollo_nand_init(void)
 		return -ENOMEM;
 	}
 
-        /*
-         * Don't change this. According to Nitin, Devin derived
-         * it and different values cause erratic behaviour.
-         */
-        if (PCI_HOST_MODE_ENABLED) {
+   /*
+    * Don't change this. According to Nitin, Deven derived
+    * it and different values cause erratic behaviour.
+    */
+   if (PCI_HOST_MODE_ENABLED) {
       writel(0x3FE, base + 0x010);
-        } else {
-      writel(0x3F, base + 0x010);
-        }
+   } else {
+    writel(0x3F, base + 0x010);
+   }
 
 	iounmap(base);
 
diff -Naurp linux-2.6.34_orig/arch/arm/mach-kronos/include/mach/nx_nand_dev.h linux-2.6.34/arch/arm/mach-kronos/include/mach/nx_nand_dev.h
--- linux-2.6.34_orig/arch/arm/mach-kronos/include/mach/nx_nand_dev.h	2011-05-12 17:15:59.928962000 +0530
+++ linux-2.6.34/arch/arm/mach-kronos/include/mach/nx_nand_dev.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,122 +0,0 @@
-/*
- * Copyright 2010 Trident Microsystems (Far East) Ltd. 
- * All prior copyright rights in this work and the accompanying software 
- * products transferred to Trident Microsystems (Far East) Ltd. by written 
- * agreement.  All rights reserved.
- */
-/*
- * Device driver for EFMC IP_2070.
- *
- * Copyright (C) 2008 NXP B.V.
- * All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- * Revision history
- * Version  	Author           Date          Remarks
- * 0.0.1	Bangaragiri G		20080402	Draft-Initial version
- * 0.1.0	Bangaragiri G		20080804	Proposal-After self review
- * 0.2.0	Bangaragiri G		20080925	Proposal-After including review comments
- * 1.0.0	Bangaragiri G		20090305	Accepted-After testing on TV550M0 board
- * 1.1.0	Bangaragiri G		20090318	Accepted-Updates after OneNAND tests
- * 1.1.0	Sundarapandian A	20090720	Updated for APOLLO
- */
- 
-#ifndef __ARCH_MACH_NX_NAND_DEV_H
-#define __ARCH_MACH_NX_NAND_DEV_H
-
-
-/* FIXME: To be taken from glb.h */
-#define   APOLLO_IP2017_BASE          (0xE0631000)
-#define	  APOLLO_IP2017_LEN           (4096)
-#define   APOLLO_INT_FLASH_CTRL_NAND  (141)  /* Fixme, has to come from irqs.h !! */
-#if 0
-#define   PNX8XXX_ESMC_BASE           (0x1BE2A000)
-#define	  PNX8XXX_ESMC_LEN		      (4096)
-#define	  PNX8XXX_AHB_ONENAND_BASE    (0x1BC60000)
-#define	  PNX8XXX_ONENAND_LEN         (128 * 1024)
-#endif
-
-/* NAND/OneNAND select bit in GLB_MISC2 */
-#define NAND_SELECT  (0x00000100)
-
-/* OneNAND defines */
-#define ONENAND_MAX_PAGE_SIZE  (2048)
-#define ONENAND_2016_AHB_SIZE  (0x40000000)	
-
-/* Base address defintions */
-#define NX_NAND_AHB_INTFC_BUF  	      (0x0000000) /* Physical address of AHB buffer */
-
-/* Max Data buffer size */
-#define NX_NAND_BLK_SIZE          (512)
-
-/* Max OOB buffer size */
-#define NX_NAND_MAX_OOB_SIZE      (128)
-
-/* Maximum AHB buffer size */
-#define NX_NAND_AHB_BUF_MAX_SIZE  (NX_NAND_BLK_SIZE+NX_NAND_MAX_OOB_SIZE)
-
-/* NAND CONTROLLER register definitions */
-#define NX_NAND_INT_ENA_OFFSET    (0xFE4)
-
-#define NX_NAND_POWER_DOWN_CFG_OFFSET (0xFF4)
-#define   NX_NAND_POWER_DOWN_MASK     (0x00000001)
-#define   NX_NAND_POWER_DOWN_ENABLE   (1UL<<0)
-#define   NX_NAND_POWER_DOWN_DISABLE  (0UL<<0)
-
-#define NX_NAND_INT_READY_START   (20)
-
-
-#define NX_NAND_INT_OOB_READ      (1<<0)
-#define NX_NAND_INT_OOB_WRITE     (1<<1)
-#define NX_NAND_INT_BLK_READ      (1<<2)
-#define NX_NAND_INT_BLK_WRITE     (1<<3)
-#define NX_NAND_INT_ENC           (1<<4)
-#define NX_NAND_INT_DEC           (1<<5)
-#define NX_NAND_INT_DEC_0_ERR     (1<<6)
-#define NX_NAND_INT_DEC_1_ERR     (1<<7)
-#define NX_NAND_INT_DEC_2_ERR     (1<<8)
-#define NX_NAND_INT_DEC_3_ERR     (1<<9)
-#define NX_NAND_INT_DEC_4_ERR     (1<<10)
-#define NX_NAND_INT_DEC_5_ERR     (1<<11)
-#define NX_NAND_INT_DEC_UNCOR     (1<<12)
-#define NX_NAND_INT_AES_DEC       (1<<13)
-#define NX_NAND_INT_SEQ_READ      (1<<14)
-#define NX_NAND_INT_SEQ_WRITE     (1<<15)
-#define NX_NAND_INT_BUSY1         (1<<16)
-#define NX_NAND_INT_BUSY2         (1<<17)
-#define NX_NAND_INT_BUSY3         (1<<18)
-#define NX_NAND_INT_BUSY4         (1<<19)
-#define NX_NAND_INT_READY1        (1<<20)
-#define NX_NAND_INT_READY2        (1<<21)
-#define NX_NAND_INT_READY3        (1<<22)
-#define NX_NAND_INT_READY4        (1<<23)
-
-/* Position of address */
-#define NX_NAND_SP_ADDR_MASK      (0xFF)
-#define NX_NAND_SP_ADDR_MASK1     (0x03)
-
-#define NX_NAND_SP_ADDR1_POS      (0)
-#define NX_NAND_SP_ADDR2_POS      (9)
-#define NX_NAND_SP_ADDR3_POS      (17)
-#define NX_NAND_SP_ADDR4_POS      (29)
-
-/* Cmd FIFO bit information */
-#define NX_NAND_CMD_FIFO_CE_START  (19)
-#define NX_NAND_CMD_FIFO_ADDR_CYC  (0x0)
-#define NX_NAND_CMD_FIFO_CMD_CYC   (0x1)
-#define NX_NAND_CMD_FIFO_POST_CMD  (0x2)
-
-#endif /* __ARCH_MACH_NX_NAND_DEV_H */
diff -Naurp linux-2.6.34_orig/drivers/mtd/nand/nx_nand/Makefile linux-2.6.34/drivers/mtd/nand/nx_nand/Makefile
--- linux-2.6.34_orig/drivers/mtd/nand/nx_nand/Makefile	2011-05-12 17:15:58.510047000 +0530
+++ linux-2.6.34/drivers/mtd/nand/nx_nand/Makefile	2011-05-05 12:41:15.463417000 +0530
@@ -10,6 +10,7 @@ HWAPI_FLAGS-y +=  -Idrivers/mtd/nand/nx_
 
 nx_nand_flags-$(CONFIG_SOC_PNX85500) := -DTMFL_PNX_ID=85500
 nx_nand_flags-$(CONFIG_ARCH_APOLLO) := -DMIPSEL
+nx_nand_flags-$(CONFIG_ARCH_KRONOS) := -DMIPSEL
 
 EXTRA_CFLAGS   := $(HWAPI_FLAGS-y)
 EXTRA_CFLAGS += $(nx_nand_flags-y) -DLINUX_BUILD -DLINUX -DMONTAVISTA_GNU -DTMFL_OS_IS_HPUNIX=0
diff -Naurp linux-2.6.34_orig/drivers/mtd/nand/nx_nand/nx_nand.c linux-2.6.34/drivers/mtd/nand/nx_nand/nx_nand.c
--- linux-2.6.34_orig/drivers/mtd/nand/nx_nand/nx_nand.c	2011-05-12 17:16:01.228822000 +0530
+++ linux-2.6.34/drivers/mtd/nand/nx_nand/nx_nand.c	2011-05-13 11:32:40.568945000 +0530
@@ -22,9 +22,13 @@
  * Version     Author           Date          Remarks    
  * 0.0.1    Bangaragiri G        20080318    Draft-Initial version
  * 0.1.0    Bangaragiri G        20080804    Proposal-After self review
- * 0.2.0    Bangaragiri G        20080925    Proposal-After including review comments
- * 1.0.0    Bangaragiri G        20090305    Accepted-After testing on TV550M0 board
- * 1.1.0    Bangaragiri G        20090313    Accepted-After DMAC updates for OneNAND
+ * 0.2.0    Bangaragiri G        20080925    Proposal-After including review 
+ *                                           comments
+ * 1.0.0    Bangaragiri G        20090305    Accepted-After testing on TV550M0 
+ *                                           board
+ * 1.1.0    Bangaragiri G        20090313    Accepted-After DMAC updates for 
+ *                                           OneNAND
+ * 2.0.0    Deven Balani         20110515    Supported Kronos NAND controller
  */
 
 #include <linux/wait.h>
@@ -37,92 +41,78 @@
 #include <linux/nx_dmac.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
-#include <mach/nx_nand_dev.h>
 
-#include "nx_nand.h"
 #include "tmhwEfmc.h"
 #include "tmhwEfmc_Cfg.h"
 #include "tmhwEfmc_Vhip.h"
-
-#ifdef CONFIG_MTD_PERF_MEAS
-#include <mach-pnx85500/glb.h>
-#define  TSU_COUNTER_REG      (volatile unsigned int *)(PNX8XXX_MMIO_BASE_VIRT + 0x14C0C0)
-#endif
+#include "nx_nand.h"
 
 #define ATTRIBUTE_UNUSED __attribute__ ((__unused__))
 
 #define  NUM_OOB_OVERLAP_DATA (16 * 3)
 
 #ifdef CONFIG_MTD_NX_NAND_HWECC
+#if defined (CONFIG_ARCH_APOLLO)
 /**
  *  OOB structure
  */
 /* For 4K LPF */
 static struct nand_ecclayout nx_nand_oob_128 = {
-    .eccbytes = 96,
-    .eccpos = {
-        4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
-        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
-        36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
-        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
-        68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
-        84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
-        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
-        116, 117, 118, 119, 120, 121, 122, 123, 124, 125,126, 127
-    },
-
-    .oobfree = {
-        {.offset = 2,
-            .length = 2},
-        {.offset = 16,
-            .length = 4},
-        {.offset = 32,
-            .length = 4},
-        {.offset = 48,
-            .length = 4},
-        {.offset = 64,
-            .length = 4},
-        {.offset = 80,
-            .length = 4},
-        {.offset = 96,
-            .length = 4},
-        {.offset = 112,
-            .length = 4},
-    }
+   .eccbytes = 96,
+   .eccpos = {
+         4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
+         20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
+         36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
+         52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
+         68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
+         84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
+         100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
+         116, 117, 118, 119, 120, 121, 122, 123, 124, 125,126, 127
+      },
+
+   .oobfree = {
+         {.offset =  2, .length = 2},
+         {.offset = 16, .length = 4},
+         {.offset = 32, .length = 4},
+         {.offset = 48, .length = 4},
+         {.offset = 64, .length = 4},
+         {.offset = 80, .length = 4},
+         {.offset = 96, .length = 4},
+         {.offset = 112,.length = 4},
+      }
 };
 
 /* For LPF */
 static struct nand_ecclayout nx_nand_oob_64 = {
-    .eccbytes = 48,
-    .eccpos = {
-        4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
-        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
-        36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
-        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63},
-    .oobfree = {
-        {.offset = 2,
-            .length = 2},
-        {.offset = 16,
-            .length = 4},
-        {.offset = 32,
-            .length = 4},
-        {.offset = 48,
-            .length = 4},
-    }
+   .eccbytes = 48,
+   .eccpos = {
+         4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
+         20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
+         36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
+         52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63
+      },
+
+   .oobfree = {
+         {.offset = 2, .length = 2},
+         {.offset = 16,.length = 4},
+         {.offset = 32,.length = 4},
+         {.offset = 48,.length = 4},
+      }
 };
 
 /* For SPF */
 static struct nand_ecclayout nx_nand_oob_16 = {
-    .eccbytes = 16,
-    .eccpos = {
-        4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
-    },
-    .oobfree = {
-        {
-            .offset = 0,
-            .length = 4},
-    }
+   .eccbytes = 16,
+   .eccpos = {
+         4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
+      },
+   .oobfree = {
+         { .offset = 0, .length = 4},
+      }
 };
+#else
+static struct nand_ecclayout nx_nand_oob;
+#endif
 #endif
 
 /**
@@ -135,23 +125,23 @@ static uint8_t nx_bbt_pattern[] = {'N', 
 static uint8_t nx_mirror_pattern[] = {'P', 'X', 'N' };
 
 static struct nand_bbt_descr nx_bbt_main = {
-    .options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
-        | NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
-    .offs =  0,
-    .len = 3,
-    .veroffs = 3,
-    .maxblocks = 4,
-    .pattern = nx_bbt_pattern
+   .options =  NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE |
+               NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+   .offs =  0,
+   .len = 3,
+   .veroffs = 3,
+   .maxblocks = 4,
+   .pattern = nx_bbt_pattern
 };
 
 static struct nand_bbt_descr nx_bbt_mirror = {
-    .options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
-        | NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
-    .offs =  0,
-    .len = 3,
-    .veroffs = 3,
-    .maxblocks = 4,
-    .pattern = nx_mirror_pattern
+   .options =  NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE |
+               NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+   .offs =  0,
+   .len = 3,
+   .veroffs = 3,
+   .maxblocks = 4,
+   .pattern = nx_mirror_pattern
 };
 
 #endif
@@ -162,67 +152,69 @@ static struct nand_bbt_descr nx_bbt_mirr
 struct nx_nand_ctrl *nx_nc = NULL;
 
 /**
- * MTD Partitions structure 
+ * MTD Partitions structures 
  */
 static struct mtd_partition partition_info1[] = {
-    {
-        .name = (char *)"bootcode",
-        .offset = 0,
-        .size   = 16*1024,
-    },
-    {
-        .name = (char *)"Flash partition 0",
-        .offset = MTDPART_OFS_APPEND,
-        .size   = (2*1024*1024)-(16*1024),
-    },
-    {
-        .name = (char *)"Flash partition 1",
-        .offset = MTDPART_OFS_APPEND,
-        .size   = 2*1024*1024,
-    },
-    {
-        .name = (char *)"Flash partition 2",
-        .offset = MTDPART_OFS_APPEND,
-        .size   = MTDPART_SIZ_FULL,
-    }
+   {
+      .name = (char *)"bootcode",
+      .offset = 0,
+      .size   = 16*1024,
+   },
+   {
+      .name = (char *)"Flash partition 0",
+      .offset = MTDPART_OFS_APPEND,
+      .size   = (2*1024*1024)-(16*1024),
+   },
+   {
+      .name = (char *)"Flash partition 1",
+      .offset = MTDPART_OFS_APPEND,
+      .size   = 2*1024*1024,
+   },
+   {
+      .name = (char *)"Flash partition 2",
+      .offset = MTDPART_OFS_APPEND,
+      .size   = MTDPART_SIZ_FULL,
+   }
 };
 
 struct mtd_partition partition_info2[] = {
-    {
-        .name = (char *)"Bootloader (256K)",
-        .offset = 0,
-        .size   = (256*1024),
-    },
-    {
-        .name = (char *)"2. kernel-image (12M)",
-        .offset = (256*1024),
-        .size   = (12*1024*1024),
-    },
-    {
-        .name = (char *)"3. AVDSP Image (12M)",
-        .offset = ((256*1024) + (12*1024*1024)), 
-        .size   = (12*1024*1024),
-    },
-    {
-        .name = (char *)"4. RFS-SELP-SISC-NXP (12M-CRAMFS)",
-        .offset = ((256*1024) + (12*1024*1024)+(12*1024*1024)), 
-        .size   = (12*1024*1024),
-    },
-    {
-        .name = (char *)"5. DTV APP(40M-CRAMFS)",
-        .offset = ((256*1024) + (12*1024*1024)+(12*1024*1024)+(12*1024*1024)), 
-        .size   = (40*1024*1024),
-    },
-    {
-        .name = (char *)"6. RW Area (5M-JFFS2) ",
-        .offset = ((256*1024) + (12*1024*1024)+(12*1024*1024)+(12*1024*1024)+(40*1024*1024)), 
-        .size   = 5*1024*1024,
-    },
-    {
-        .name = (char *)"7. TEMP (40M-JFFS2) ",
-        .offset = ((256*1024) + (12*1024*1024)+(12*1024*1024)+(12*1024*1024)+(40*1024*1024)+(5*1024*1024)), 
-        .size   = 40*1024*1024,
-    },
+   {
+      .name = (char *)"Bootloader (256K)",
+      .offset = 0,
+      .size   = (256*1024),
+   },
+   {
+      .name = (char *)"2. kernel-image (12M)",
+      .offset = (256*1024),
+      .size   = (12*1024*1024),
+   },
+   {
+      .name = (char *)"3. AVDSP Image (12M)",
+      .offset = ((256*1024) + (12*1024*1024)), 
+      .size   = (12*1024*1024),
+   },
+   {
+      .name = (char *)"4. RFS-SELP-SISC-NXP (12M-CRAMFS)",
+      .offset = ((256*1024) + (12*1024*1024)+(12*1024*1024)), 
+      .size   = (12*1024*1024),
+   },
+   {
+      .name = (char *)"5. DTV APP(40M-CRAMFS)",
+      .offset = ((256*1024) + (12*1024*1024)+(12*1024*1024)+(12*1024*1024)), 
+      .size   = (40*1024*1024),
+   },
+   {
+      .name = (char *)"6. RW Area (5M-JFFS2) ",
+      .offset = ((256*1024) + (12*1024*1024)+(12*1024*1024)+(12*1024*1024)+
+         (40*1024*1024)), 
+      .size   = 5*1024*1024,
+   },
+   {
+      .name = (char *)"7. TEMP (40M-JFFS2) ",
+      .offset = ((256*1024) + (12*1024*1024)+(12*1024*1024)+(12*1024*1024)+
+         (40*1024*1024)+(5*1024*1024)), 
+      .size   = 40*1024*1024,
+   },
 };
 
 /**
@@ -233,17 +225,9 @@ struct mtd_partition partition_info2[] =
 
 const char *part_probes[] = { "cmdlinepart", NULL };
 
-#define NX_NAND_READ_INT   (NX_NAND_INT_DEC_UNCOR | \
-        NX_NAND_INT_DEC_0_ERR | \
-        NX_NAND_INT_DEC_1_ERR | \
-        NX_NAND_INT_DEC_2_ERR | \
-        NX_NAND_INT_DEC_3_ERR | \
-        NX_NAND_INT_DEC_4_ERR | \
-        NX_NAND_INT_DEC_5_ERR)
-
-/*------------------------------------------------------------------------------------
- * Internal functions 
- --------------------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------
+* Internal functions 
+------------------------------------------------------------------------------*/
 #ifdef CONFIG_MTD_NX_NAND_DMAC
 /**
  * nx_nand_dmac_init - Configure the DMAC scatter gather list
@@ -255,108 +239,119 @@ const char *part_probes[] = { "cmdlinepa
  * Initialise the DMAC scatter gather list
  */
 static inline void nx_nand_dmac_init(struct nx_nand_ctrl *nc, 
-        uint32_t cmd, nx_dmac_tfr_t *req, nx_dmac_stgt_t *stgt)
+   uint32_t cmd, nx_dmac_tfr_t *req, nx_dmac_stgt_t *stgt)
 {
-    int i;
+   int i;
 
-    if(cmd) {
+   if(cmd) {
 
-        /* Read Main Area */
-        for(i=0; i < nc->num_blks; i++) {
-            stgt[i].src_addr = NX_NAND_AHB_BUF;     
-            stgt[i].dst_addr = nc->dmabuf_phy + (i * NX_NAND_BLK_SIZE);
-            stgt[i].tfr_size = NX_NAND_BLK_SIZE >> 2;    
-            stgt[i].flowctl = nx_dmac_per2mem_dma;         
-            stgt[i].src_per = 0;              
-            stgt[i].dst_per = 0;
-            stgt[i].src_ahb = 1;              /* Source AHB master 1 */
-            stgt[i].dst_ahb = 0;              /* Dest AHB master 0 */
-            stgt[i].src_inc = true;
-            stgt[i].dst_inc = true;
+      /* Read Main Area */
+      for(i=0; i < nc->num_blks; i++) {
+         stgt[i].src_addr = NX_NAND_AHB_BUF;
+         stgt[i].dst_addr = nc->dmabuf_phy + (i * nc->blk_size);
+         stgt[i].tfr_size = nc->blk_size >> 2;    
+         stgt[i].flowctl = nx_dmac_per2mem_dma;         
+         stgt[i].src_per = 0;              
+         stgt[i].dst_per = 0;
+         stgt[i].src_ahb = 1;              /* Source AHB master 1 */
+         stgt[i].dst_ahb = 0;              /* Dest AHB master 0 */
+         stgt[i].src_inc = true;
+         stgt[i].dst_inc = true;
+         if ( nc->blk_size == NX_NAND_BLK_SIZE ) {
+            stgt[i].src_brst = nx_dmac_256;
+            stgt[i].dst_brst = nx_dmac_256;
+         } 
+         else {
             stgt[i].src_brst = nx_dmac_128;
             stgt[i].dst_brst = nx_dmac_128;
+         }
             stgt[i].src_width = nx_dmac_width_32;
             stgt[i].dst_width = nx_dmac_width_32;
-        }
+      }
 
-        /* Read OOB area */
-        stgt[i].src_addr = NX_NAND_AHB_BUF + NX_NAND_BLK_SIZE;     
-        stgt[i].dst_addr = nc->dmabuf_phy + (i * NX_NAND_BLK_SIZE);
-        stgt[i].tfr_size = nc->mtd.oobsize >> 2;    
-        stgt[i].flowctl = nx_dmac_per2mem_dma;         
-        stgt[i].src_ahb = 1;              /* Source AHB master 1 */
-        stgt[i].dst_ahb = 0;              /* Dest AHB master 0 */
-        stgt[i].src_per = 0;              
-        stgt[i].dst_per = 0;
-        stgt[i].src_inc = true;
-        stgt[i].dst_inc = true;
-        if(nc->mtd.oobsize == 128) {
-            stgt[i].src_brst = nx_dmac_32;
-            stgt[i].dst_brst = nx_dmac_32;
-        }
-        else if(nc->mtd.oobsize == 64) {
-            stgt[i].src_brst = nx_dmac_16;
-            stgt[i].dst_brst = nx_dmac_16;
-        }
-        else {
-            stgt[i].src_brst = nx_dmac_4;
-            stgt[i].dst_brst = nx_dmac_4;
-        }
-        stgt[i].src_width = nx_dmac_width_32;
-        stgt[i].dst_width = nx_dmac_width_32;
-    }
-    else { 
-
-        /* Write OOB area */
-        i=0;  
-        stgt[i].dst_addr = NX_NAND_AHB_BUF + NX_NAND_BLK_SIZE;     
-        stgt[i].src_addr = nc->dmabuf_phy + (nc->num_blks * NX_NAND_BLK_SIZE);
-        stgt[i].tfr_size = nc->mtd.oobsize >> 2;    
-        stgt[i].flowctl = nx_dmac_mem2per_dma;         
-        stgt[i].src_ahb = 0;              /* Source AHB master 0 */
-        stgt[i].dst_ahb = 1;              /* Dest AHB master 1 */
-        stgt[i].src_per = 0;              
-        stgt[i].dst_per = 0;
-        stgt[i].src_inc = true;
-        stgt[i].dst_inc = true;
-        if(nc->mtd.oobsize == 128) {
-            stgt[i].src_brst = nx_dmac_32;
-            stgt[i].dst_brst = nx_dmac_32;
-        }
-        else if(nc->mtd.oobsize == 64) {
-            stgt[i].src_brst = nx_dmac_16;
-            stgt[i].dst_brst = nx_dmac_16;
-        }
-        else {
-            stgt[i].src_brst = nx_dmac_4;
-            stgt[i].dst_brst = nx_dmac_4;
-        }
-        stgt[i].src_width = nx_dmac_width_32;
-        stgt[i].dst_width = nx_dmac_width_32;
-
-        /* Write Main area */
-        for(i=1; i< (nc->num_blks+1); i++) {
-            stgt[i].src_addr = nc->dmabuf_phy + ( (i-1) * NX_NAND_BLK_SIZE);
-            stgt[i].dst_addr = NX_NAND_AHB_BUF;     
-            stgt[i].tfr_size = NX_NAND_BLK_SIZE >> 2;    
-            stgt[i].flowctl = nx_dmac_mem2per_dma;         
-            stgt[i].src_per = 0;             
-            stgt[i].dst_per = 0;
-            stgt[i].src_ahb = 0;              /* Source AHB master 0 */
-            stgt[i].dst_ahb = 1;              /* Dest AHB master 1 */
-            stgt[i].src_inc = true;
-            stgt[i].dst_inc = true;
+      /* Read OOB area */
+      stgt[i].src_addr = NX_NAND_AHB_BUF + NX_NAND_BLK_SIZE;
+      stgt[i].dst_addr = nc->dmabuf_phy + (i * nc->blk_size);
+      stgt[i].tfr_size = nc->mtd.oobsize >> 2;    
+      stgt[i].flowctl = nx_dmac_per2mem_dma;         
+      stgt[i].src_ahb = 1;              /* Source AHB master 1 */
+      stgt[i].dst_ahb = 0;              /* Dest AHB master 0 */
+      stgt[i].src_per = 0;              
+      stgt[i].dst_per = 0;
+      stgt[i].src_inc = true;
+      stgt[i].dst_inc = true;
+      if(nc->mtd.oobsize == 128) {
+         stgt[i].src_brst = nx_dmac_32;
+         stgt[i].dst_brst = nx_dmac_32;
+      }
+      else if(nc->mtd.oobsize == 64) {
+         stgt[i].src_brst = nx_dmac_16;
+         stgt[i].dst_brst = nx_dmac_16;
+      }
+      else {
+         stgt[i].src_brst = nx_dmac_4;
+         stgt[i].dst_brst = nx_dmac_4;
+      }
+      stgt[i].src_width = nx_dmac_width_32;
+      stgt[i].dst_width = nx_dmac_width_32;
+
+   } 
+   else { 
+      /* Write OOB area */
+      i=0;  
+      stgt[i].dst_addr = NX_NAND_AHB_BUF + NX_NAND_BLK_SIZE;     
+      stgt[i].src_addr = nc->dmabuf_phy + (nc->num_blks * nc->blk_size);
+      stgt[i].tfr_size = nc->mtd.oobsize >> 2;    
+      stgt[i].flowctl = nx_dmac_mem2per_dma;         
+      stgt[i].src_ahb = 0;              /* Source AHB master 0 */
+      stgt[i].dst_ahb = 1;              /* Dest AHB master 1 */
+      stgt[i].src_per = 0;              
+      stgt[i].dst_per = 0;
+      stgt[i].src_inc = true;
+      stgt[i].dst_inc = true;
+      if(nc->mtd.oobsize == 128) {
+         stgt[i].src_brst = nx_dmac_32;
+         stgt[i].dst_brst = nx_dmac_32;
+      }
+      else if(nc->mtd.oobsize == 64) {
+         stgt[i].src_brst = nx_dmac_16;
+         stgt[i].dst_brst = nx_dmac_16;
+      }
+      else {
+         stgt[i].src_brst = nx_dmac_4;
+         stgt[i].dst_brst = nx_dmac_4;
+      }
+      stgt[i].src_width = nx_dmac_width_32;
+      stgt[i].dst_width = nx_dmac_width_32;
+
+      /* Write Main area */
+      for(i=1; i< (nc->num_blks+1); i++) {
+         stgt[i].src_addr = nc->dmabuf_phy + ( (i-1) * nc->blk_size);
+         stgt[i].dst_addr = NX_NAND_AHB_BUF;
+         stgt[i].tfr_size = nc->blk_size >> 2;
+         stgt[i].flowctl = nx_dmac_mem2per_dma;
+         stgt[i].src_per = 0;
+         stgt[i].dst_per = 0;
+         stgt[i].src_ahb = 0;              /* Source AHB master 0 */
+         stgt[i].dst_ahb = 1;              /* Dest AHB master 1 */
+         stgt[i].src_inc = true;
+         stgt[i].dst_inc = true;
+         if ( nc->blk_size == NX_NAND_BLK_SIZE ) {
+            stgt[i].src_brst = nx_dmac_256;
+            stgt[i].dst_brst = nx_dmac_256;
+         } 
+         else {
             stgt[i].src_brst = nx_dmac_128;
             stgt[i].dst_brst = nx_dmac_128;
+         }
             stgt[i].src_width = nx_dmac_width_32;
             stgt[i].dst_width = nx_dmac_width_32;
-        }
-    }
+      }
+   }
 
-    req->num_reqs = nc->num_blks + 1;
-    req->req = &stgt[0];
+   req->num_reqs = nc->num_blks + 1;
+   req->req = &stgt[0];
 }
-
 #endif
 
 /**
@@ -369,123 +364,49 @@ static inline void nx_nand_dmac_init(str
  * Send command & address cycles to chip for small page chips
  */
 static inline void nx_nand_cmd_addr(struct nx_nand_ctrl *nc, uint32_t cmd,
-        uint32_t data, int last)
+   uint32_t data, int last)
 {
-    tmhwEfmc_CmdAddr_t   cmd_addr;
+   tmhwEfmc_CmdAddr_t   cmd_addr;
 
-    /* Chip enable */
-    cmd_addr.deviceNum = (0 << (nc->slotid + NX_NAND_CMD_FIFO_CE_START));
+   /* Chip enable */
+   cmd_addr.deviceNum = (0 << (nc->slotid + NX_NAND_CMD_FIFO_CE_START));
 
-    /* Cmd or address */
-    switch(cmd)
-    {
-        case NX_NAND_CMD_FIFO_ADDR_CYC:
-            cmd_addr.cycleType = tmhwEfmc_AddrCycle;
-            break;
+   /* Cmd or address */
+   switch(cmd) {
 
-        case NX_NAND_CMD_FIFO_CMD_CYC:
-            cmd_addr.cycleType = tmhwEfmc_CmdCycle;
-            break;
+      case NX_NAND_CMD_FIFO_ADDR_CYC:
+         cmd_addr.cycleType = tmhwEfmc_AddrCycle;
+      break;
 
-        case NX_NAND_CMD_FIFO_POST_CMD:
-            cmd_addr.cycleType = tmhwEfmc_PostWrCmdCycle;
-            break;
+      case NX_NAND_CMD_FIFO_CMD_CYC:
+         cmd_addr.cycleType = tmhwEfmc_CmdCycle;
+      break;
 
-        default:
-            printk(KERN_ERR "nx_nand:Invalid cmd \r\n"); 
-            return;
-    }
+      case NX_NAND_CMD_FIFO_POST_CMD:
+         cmd_addr.cycleType = tmhwEfmc_PostWrCmdCycle;
+      break;
 
-    /* Last cmd or addr cycle */
-    if(last)
-        cmd_addr.lastCycle = TM_TRUE;
-    else
-        cmd_addr.lastCycle = TM_FALSE;
-
-    /* Addr or Cmd */
-    cmd_addr.data = data;
-
-    /* Send to chip */
-    tmhwEfmc_WriteCmdAddr(0, &cmd_addr);
-}
-
-/*------------------------------------------------------------------------------------
- * Performance Measurement functions 
- --------------------------------------------------------------------------------------*/
-#ifdef CONFIG_MTD_PERF_MEAS
-
-#define TSU_CYCLE_TIME   (75)  // 75nsec
-
-int nand_perf_meas(struct mtd_info *mtd,  uint32_t start, uint32_t end,
-        enum mtd_meas_oper oper)
-{
-    int i;
-    uint32_t diff, min, max, sum, ave;
-
-    if(!mtd->perf.cmd_meas) {
-        printk(KERN_INFO "Operation Not Set\r\n");
-        return 0;
-    }
-
-    /* Check if mode valid */
-    if(mtd->perf.cmd_meas != oper) {
-        printk(KERN_INFO "Not correct operation Set\r\n");
-        return 0;
-    }
-
-    /* Check if number of iterations still valid */
-    if(mtd->perf.cnt >= mtd->perf.num_iter){
-        //printk(KERN_INFO "Iterations cnt: 0x%x iter: 0x%x \r\n", mtd->perf.cnt, mtd->perf.num_iter);
-        return 0;
-    }
-
-    /* store value */
-    diff = end - start;
-    mtd->perf.values[mtd->perf.cnt] = diff; 
-    mtd->perf.cnt++;
-    if(mtd->perf.cnt == mtd->perf.num_iter) {
-
-        /* Get min value */
-        min = 0xFFFFFFFF;
-        for(i=0; i < mtd->perf.cnt; i++)
-        {
-            if(mtd->perf.values[i] < min) {
-                min = mtd->perf.values[i];
-            }
-        }
-        //mtd->perf.data.min_time = min;
-        mtd->perf.data.min_time = (min * TSU_CYCLE_TIME);
-
-        /* Get max value */
-        max = 0x0;
-        for(i=0; i < mtd->perf.cnt; i++)
-        {
-            if(mtd->perf.values[i] > max) {
-                max = mtd->perf.values[i];
-            }
-        }
-        //mtd->perf.data.max_time = max;
-        mtd->perf.data.max_time = (max * TSU_CYCLE_TIME);
-
-        sum = 0;
-        for(i=0; i < mtd->perf.cnt; i++) {
-            //printk(KERN_INFO "iter: %d cycles: 0x%x \r\n", i, mtd->perf.values[i]);
-            sum += mtd->perf.values[i];
-        }
-        ave = sum / mtd->perf.cnt;
-        //mtd->perf.data.ave_time = ave;
-        mtd->perf.data.ave_time = (ave * TSU_CYCLE_TIME);
-        //mtd->perf.cmd_meas = MTD_MEAS_NONE;
-        //mtd->perf.cnt = 0;
-    }
-
-    return 1;
+      default:
+         printk(KERN_ERR "nx_nand:Invalid cmd \r\n"); 
+      return;
+   }
+
+   /* Last cmd or addr cycle */
+   if(last)
+      cmd_addr.lastCycle = TM_TRUE;
+   else
+      cmd_addr.lastCycle = TM_FALSE;
+
+   /* Addr or Cmd */
+   cmd_addr.data = data;
+
+   /* Send to chip */
+   tmhwEfmc_WriteCmdAddr(0, &cmd_addr);
 }
-#endif
 
-/*------------------------------------------------------------------------------------
- * NAND chip specific functions 
- --------------------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------
+* NAND chip specific functions 
+------------------------------------------------------------------------------*/
 #ifdef CONFIG_MTD_NX_NAND_HWECC
 /**
  * nx_nand_calculate_ecc - HW ECC calculate
@@ -495,10 +416,10 @@ int nand_perf_meas(struct mtd_info *mtd,
  *
  * Dummy function for HW ECC calculation
  */
-static int nx_nand_calculate_ecc(struct mtd_info *mtd ATTRIBUTE_UNUSED, const uint8_t *dat ATTRIBUTE_UNUSED,
-        uint8_t *ecc_code ATTRIBUTE_UNUSED)
+static int nx_nand_calculate_ecc(struct mtd_info *mtd ATTRIBUTE_UNUSED, 
+   const uint8_t *dat ATTRIBUTE_UNUSED,uint8_t *ecc_code ATTRIBUTE_UNUSED)
 {
-    return 0;
+   return 0;
 }
 
 /**
@@ -510,10 +431,11 @@ static int nx_nand_calculate_ecc(struct 
  *
  * Dummy function for HW ECC calculation
  */
-static int nx_nand_correct_data(struct mtd_info *mtd ATTRIBUTE_UNUSED, uint8_t *dat ATTRIBUTE_UNUSED,
-        uint8_t *read_ecc ATTRIBUTE_UNUSED, uint8_t *calc_ecc ATTRIBUTE_UNUSED)
+static int nx_nand_correct_data(struct mtd_info *mtd ATTRIBUTE_UNUSED, 
+   uint8_t *dat ATTRIBUTE_UNUSED, uint8_t *read_ecc ATTRIBUTE_UNUSED, 
+   uint8_t *calc_ecc ATTRIBUTE_UNUSED)
 {
-    return 0;
+   return 0;
 }
 
 /**
@@ -523,11 +445,11 @@ static int nx_nand_correct_data(struct m
  *
  * Dummy function for HW ECC calculation
  */
-static void nx_nand_hwctl(struct mtd_info *mtd ATTRIBUTE_UNUSED, int mode ATTRIBUTE_UNUSED)
+static void nx_nand_hwctl(struct mtd_info *mtd ATTRIBUTE_UNUSED, 
+   int mode ATTRIBUTE_UNUSED)
 {
-    return;
+   return;
 }
-
 #endif
 
 /**
@@ -539,14 +461,14 @@ static void nx_nand_hwctl(struct mtd_inf
  */
 static void nx_nand_select_chip(struct mtd_info *mtd, int chipnr)
 {
-    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
 
-    if(chipnr == -1)
-        return;
+   if(chipnr == -1)
+      return;
 
-    /* Store the value in nand control structure 
-     * Chip enable/disable done in command function */
-    nc->slotid = chipnr;
+   /* Store the value in nand control structure 
+    * Chip enable/disable done in command function */
+   nc->slotid = chipnr;
 }
 
 /**
@@ -557,14 +479,14 @@ static void nx_nand_select_chip(struct m
  */
 static int nx_nand_dev_ready(struct mtd_info *mtd)
 {
-    tmhwEfmc_ReadBusySignal_t dev_stat;
-    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+   tmhwEfmc_ReadBusySignal_t dev_stat;
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
 
-    /* Get status from controller */
-    tmhwEfmc_GetBusyStatus(nc->unitid, nc->slotid, &dev_stat);
+   /* Get status from controller */
+   tmhwEfmc_GetBusyStatus(nc->unitid, nc->slotid, &dev_stat);
 
-    /* Return with R/B status */
-    return (dev_stat.rbEdge_Status_Ready);
+   /* Return with R/B status */
+   return (dev_stat.rbEdge_Status_Ready);
 }
 
 /**
@@ -575,13 +497,13 @@ static int nx_nand_dev_ready(struct mtd_
  */
 static uint8_t nx_nand_read_byte(struct mtd_info *mtd)
 {
-    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
-    uint16_t data;
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+   uint16_t data;
 
-    /* Read 16-bit word */
-    tmhwEfmc_ReadSingleData(nc->unitid, &data);
+   /* Read 16-bit word */
+   tmhwEfmc_ReadSingleData(nc->unitid, &data);
 
-    return (uint8_t) cpu_to_le16(data);
+   return (uint8_t) cpu_to_le16(data);
 }
 
 /**
@@ -592,13 +514,13 @@ static uint8_t nx_nand_read_byte(struct 
  */
 static uint8_t nx_nand_read_byte16(struct mtd_info *mtd)
 {
-    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
-    uint16_t data;
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+   uint16_t data;
 
-    /* Read byte word */
-    tmhwEfmc_ReadSingleData(nc->unitid, &data);
+   /* Read byte word */
+   tmhwEfmc_ReadSingleData(nc->unitid, &data);
 
-    return (uint8_t) cpu_to_le16(data);
+   return (uint8_t) cpu_to_le16(data);
 }
 
 /**
@@ -611,11 +533,11 @@ static uint8_t nx_nand_read_byte16(struc
  */
 static void nx_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
 {
-    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
 
-    /* Copy from driver buffer */
-    memcpy(buf, nc->dmabuf + nc->offset, len);
-    nc->offset += len;
+   /* Copy from driver buffer */
+   memcpy(buf, nc->dmabuf + nc->offset, len);
+   nc->offset += len;
 }
 
 /**
@@ -627,12 +549,12 @@ static void nx_nand_read_buf(struct mtd_
  * Read a full page + oob into the buffer
  */
 static int nx_nand_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
-        uint8_t *buf, int page)
+   uint8_t *buf, int page)
 {
-    chip->read_buf(mtd, buf, mtd->writesize);
-    chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+chip->read_buf(mtd, buf, mtd->writesize);
+chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
 
-    return 0;
+return 0;
 }
 
 #ifdef CONFIG_MTD_NX_NAND_HWECC
@@ -645,81 +567,81 @@ static int nx_nand_read_page_raw(struct 
  * Read a full page + oob into the buffer
  */
 static int nx_nand_read_page(struct mtd_info *mtd, struct nand_chip *chip,
-        uint8_t *buf, int page)
+   uint8_t *buf, int page)
 {
-    int stat=0, i;
-    uint32_t j;
-    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
-    int eccsteps = chip->ecc.steps;
-    int no_all_ffs=0;
-
-#ifdef CONFIG_MTD_PERF_MEAS
-    volatile uint32_t start, end1;
+   int i, stat=0;
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+   int eccsteps = chip->ecc.steps;
+#if defined (CONFIG_ARCH_APOLLO)
+   uint32_t j;
+   int no_all_ffs=0;
 #endif
 
-#ifdef CONFIG_MTD_PERF_MEAS
-    start = readl(TSU_COUNTER_REG);
-#endif
+   /* Read page data */
+   nx_nand_read_page_raw(mtd, chip, buf, page);
 
-    /* Read page data */
-    nx_nand_read_page_raw(mtd, chip, buf, page);
+   /* Check ECC status */
+   for (i = 0 ; i<eccsteps; i++) {
+#if defined (CONFIG_ARCH_APOLLO)
+      if(nc->ecc_status[i] == NX_NAND_INT_DEC_UNCOR) {
 
-    /* Check ECC status */
-    for (i = 0 ; i<eccsteps; i++) {
+         for(j=0; j < mtd->writesize; j++) {
+            if(buf[j] != 0xFF) {
+               no_all_ffs = 1;
+               break;
+            }
+         }
 
-        if(nc->ecc_status[i] == NX_NAND_INT_DEC_UNCOR) {
+         if(no_all_ffs) {
+            printk(KERN_INFO "step %d: ECC failed \r\n", j);
+            mtd->ecc_stats.failed++;
+         }
+      } 
+      else {
+         /* Update stats */
+         switch (nc->ecc_status[i]) {
+            case NX_NAND_INT_DEC_1_ERR:
+               printk(KERN_INFO "step %d:ECC 1 bit corrected \r\n", i); 
+               stat = 1;
+            break;
 
-            for(j=0; j < mtd->writesize; j++) {
-                if(buf[j] != 0xFF) {
-                    no_all_ffs = 1;
-                    break;
-                }
-            }
+            case NX_NAND_INT_DEC_2_ERR:
+               printk(KERN_INFO "step %d:ECC 2 bits corrected \r\n", i);   
+               stat = 2;
+            break;
 
-            if(no_all_ffs) {  
-                printk(KERN_INFO "step %d: ECC failed \r\n", j);   
-                mtd->ecc_stats.failed++;
-            }
-        }
-        else {
-            /* Update stats */   
-            switch (nc->ecc_status[i])
-            {
-                case NX_NAND_INT_DEC_1_ERR:
-                    printk(KERN_INFO "step %d:ECC 1 bit corrected \r\n", i); 
-                    stat = 1;
-                    break;
-
-                case NX_NAND_INT_DEC_2_ERR:
-                    printk(KERN_INFO "step %d:ECC 2 bits corrected \r\n", i);   
-                    stat = 2;
-                    break;
-
-                case NX_NAND_INT_DEC_3_ERR:
-                    printk(KERN_INFO "step %d:ECC 3 bits corrected \r\n", i);   
-                    stat = 3;
-                    break;
-
-                case NX_NAND_INT_DEC_4_ERR:
-                    printk(KERN_INFO "step %d:ECC 4 bits corrected \r\n", i);   
-                    stat = 4;
-                    break;
-
-                case NX_NAND_INT_DEC_5_ERR:
-                    printk(KERN_INFO "step %d:ECC 5 bits corrected \r\n", i);   
-                    stat = 5;
-                    break;
-            }
-            mtd->ecc_stats.corrected += stat;
-        }
-    }
+            case NX_NAND_INT_DEC_3_ERR:
+               printk(KERN_INFO "step %d:ECC 3 bits corrected \r\n", i);   
+               stat = 3;
+            break;
 
-#ifdef CONFIG_MTD_PERF_MEAS
-    end1 = readl(TSU_COUNTER_REG);
-    nand_perf_meas(mtd, start, end1, MTD_MEAS_READ);
-#endif
+            case NX_NAND_INT_DEC_4_ERR:
+               printk(KERN_INFO "step %d:ECC 4 bits corrected \r\n", i);   
+               stat = 4;
+            break;
 
-    return 0;
+            case NX_NAND_INT_DEC_5_ERR:
+               printk(KERN_INFO "step %d:ECC 5 bits corrected \r\n", i);   
+               stat = 5;
+            break;
+         }
+         mtd->ecc_stats.corrected += stat;
+      }
+#else /* CONFIG_ARCH_KRONOS */
+      if (nc->page_rw_status_fifo.PageRdStatus[i].uncorrectable) {
+
+         mtd->ecc_stats.failed++;
+
+      } 
+      else if (nc->page_rw_status_fifo.PageRdStatus[i].corrected) {
+
+         stat = nc->page_rw_status_fifo.PageRdStatus[i].num_errors;
+         printk(KERN_INFO "step %d:ECC %d bits corrected \r\n", i, stat);
+         mtd->ecc_stats.corrected += stat;
+      }
+#endif
+   }
+   return 0;
 }
 #endif
 
@@ -733,119 +655,119 @@ static int nx_nand_read_page(struct mtd_
  * Read OOB data into the buffer
  */
 static int nx_nand_read_oob(struct mtd_info *mtd, struct nand_chip *chip,
-        int page, int sndcmd)
+   int page, int sndcmd)
 {
-    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
-    uint8_t *buf = chip->oob_poi;
-    int status = 0;
-    int length = mtd->oobsize;
-    int column, addr, i;
-    uint16_t data;
-    tmhwEfmc_PageConfig_t   page_cfg;
-
-    if(mtd->flags & MTD_USE_DEV_OOB_LAYOUT) {
-
-        /* Use Device OOB layout (Main page data followed by OOB data) */    
-        /* No page operation  for OOB */
-        page_cfg.includeOOB = true;
-        page_cfg.operType = tmhwEfmc_Nothing;
-        page_cfg.includeAES = false;
-        page_cfg.includeECC = false;
-        tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
-
-        /* Send READOOB command */ 
-        if(sndcmd) {
-            chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
-        }
-
-        /* Check if CE DON't care is supported */
-        column = nc->cur_col;
-        i = 0;
-        while(length) {
-
-            /* Send Address & cmd cycles */
-            if(sndcmd) {
-
-                nx_nand_cmd_addr(nc, 1, nc->cur_cmd, 0);
-
-                if(nc->lb_chip) {
-                    addr = column & NX_NAND_SP_ADDR_MASK;
-                    nx_nand_cmd_addr(nc, 0, addr, 0);
-
-                    addr = (column >> 8) & NX_NAND_SP_ADDR_MASK;
-                    nx_nand_cmd_addr(nc, 0, addr, 0);
-
-                    addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-                    nx_nand_cmd_addr(nc, 0, addr, 0);
-
-                    addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-                    nx_nand_cmd_addr(nc, 0, addr, 0);
-
-                    /* if > 2Gb, extra address cycle */
-                    if (nc->chip.chipsize >= (1 << 28)) {
-                        addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-                        nx_nand_cmd_addr(nc, 0, addr, 0);
-                    }
-
-                    /* Send Read confirm command */
-                    nx_nand_cmd_addr(nc, 1, NAND_CMD_READSTART, 1);
-                }
-                else {
-                    addr = column & NX_NAND_SP_ADDR_MASK;
-                    nx_nand_cmd_addr(nc, 0, addr, 0);
-
-                    addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-                    nx_nand_cmd_addr(nc, 0, addr, 0);
-
-                    /* if > 64Mb, extra adddress cycle */
-                    if (nc->chip.chipsize > (32 << 20)) {
-                        addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-                        nx_nand_cmd_addr(nc, 0, addr, 0);
-
-                        addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-                        nx_nand_cmd_addr(nc, 0, addr, 1);
-                    }
-                    else {
-                        addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-                        nx_nand_cmd_addr(nc, 0, addr, 1);
-                    }
-                }
-                sndcmd = 0;
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+   uint8_t *buf = chip->oob_poi;
+   int status = 0;
+   int length = mtd->oobsize;
+   int column, addr, i;
+   uint16_t data;
+   tmhwEfmc_PageConfig_t   page_cfg;
+
+   if(mtd->flags & MTD_USE_DEV_OOB_LAYOUT) {
+
+      /* Use Device OOB layout (Main page data followed by OOB data) */    
+      /* No page operation for OOB */
+      page_cfg.includeOOB = true;
+      page_cfg.operType = tmhwEfmc_Nothing;
+      page_cfg.includeAES = false;
+      page_cfg.includeECC = false;
+      tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+
+      /* Send READOOB command */ 
+      if(sndcmd) {
+         chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
+      }
+
+      /* Check if CE DON't care is supported */
+      column = nc->cur_col;
+      i = 0;
+      while(length) {
+
+         /* Send Address & cmd cycles */
+         if(sndcmd) {
+
+            nx_nand_cmd_addr(nc, 1, nc->cur_cmd, 0);
+
+            if(nc->lb_chip) {
+               addr = column & NX_NAND_SP_ADDR_MASK;
+               nx_nand_cmd_addr(nc, 0, addr, 0);
+
+               addr = (column >> 8) & NX_NAND_SP_ADDR_MASK;
+               nx_nand_cmd_addr(nc, 0, addr, 0);
+
+               addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+               nx_nand_cmd_addr(nc, 0, addr, 0);
+
+               addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+               nx_nand_cmd_addr(nc, 0, addr, 0);
+
+               /* if > 2Gb, extra address cycle */
+               if (nc->chip.chipsize >= (1 << 28)) {
+                  addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+                  nx_nand_cmd_addr(nc, 0, addr, 0);
+               }
+
+               /* Send Read confirm command */
+               nx_nand_cmd_addr(nc, 1, NAND_CMD_READSTART, 1);
+            } 
+            else {
+               addr = column & NX_NAND_SP_ADDR_MASK;
+               nx_nand_cmd_addr(nc, 0, addr, 0);
 
-                /* Wait for completion */
-                udelay(chip->chip_delay);
-            }
+               addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+               nx_nand_cmd_addr(nc, 0, addr, 0);
 
-            /* Write data into chip */
-            status  = tmhwEfmc_ReadSingleData(nc->unitid, &data);    
-            buf[i] = (uint8_t) data; 
-            //printk(KERN_INFO "ReadSingle data 0x%x 0x%x \r\n", buf[i], data);
-
-            length--;
-            i++;
-
-            if(!nx_nc->cedontcare) {
-                sndcmd = 1; 
-                column++;
+               /* if > 64Mb, extra adddress cycle */
+               if (nc->chip.chipsize > (32 << 20)) {
+                  addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+                  nx_nand_cmd_addr(nc, 0, addr, 0);
+
+                  addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+                  nx_nand_cmd_addr(nc, 0, addr, 1);
+               } 
+               else {
+                  addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+                  nx_nand_cmd_addr(nc, 0, addr, 1);
+               }
             }
-        }
-    }
-    else {
-        /* Use IP_2017 OOB layout - (512 Bytes data + 16 bytes OOB data) */
-        /* Use IP_2017 OOB layout - Read page */
-
-        /* Send READOOB command */ 
-        if(sndcmd) {
-            chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
             sndcmd = 0;
-        }
 
-        /* Copy into user buffer */
-        nc->offset = mtd->writesize;
-        chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
-    }
+            /* Wait for completion */
+            udelay(chip->chip_delay);
+         }
+
+         /* Write data into chip */
+         status  = tmhwEfmc_ReadSingleData(nc->unitid, &data);    
+         buf[i] = (uint8_t) data; 
+         //printk(KERN_INFO "ReadSingle data 0x%x 0x%x \r\n", buf[i], data);
+
+         length--;
+         i++;
+
+         if(!nx_nc->cedontcare) {
+            sndcmd = 1; 
+            column++;
+         }
+      }
+   } 
+   else {
+      /* Use IP_2017 OOB layout - (512 Bytes data + 16 bytes OOB data) */
+      /* Use IP_2017 OOB layout - Read page */
+
+      /* Send READOOB command */ 
+      if(sndcmd) {
+         chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
+         sndcmd = 0;
+      }
+
+      /* Copy into user buffer */
+      nc->offset = mtd->writesize;
+      chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+   }
 
-    return 0;
+   return 0;
 }
 
 /**
@@ -857,13 +779,13 @@ static int nx_nand_read_oob(struct mtd_i
  * Write specified number of bytes into the nand chip
  */
 static void nx_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, 
-        int len)
+   int len)
 {
-    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
 
-    /* Copy data to driver buffer */
-    memcpy(nc->dmabuf + nc->offset, buf, len);
-    nc->offset += len;
+   /* Copy data to driver buffer */
+   memcpy(nc->dmabuf + nc->offset, buf, len);
+   nc->offset += len;
 }
 
 /**
@@ -875,222 +797,204 @@ static void nx_nand_write_buf(struct mtd
  * Write a full page + oob into the buffer
  */
 static void nx_nand_write_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
-        const uint8_t *buf)
+   const uint8_t *buf)
 {
-    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
-    uint32_t intr=0;
-    uint16_t addr;
-    tmhwEfmc_PageConfig_t page_cfg;
-
-#ifdef CONFIG_MTD_NX_NAND_DMAC   
-    int chanid, status;
-    tmhwEfmc_DmaConfig_t dma_cfg;
-    nx_dmac_tfr_t           req;
-    nx_dmac_stgt_t       stgt[(mtd->writesize/NX_NAND_BLK_SIZE)+1];
-#endif
-
-#ifdef CONFIG_MTD_PERF_MEAS
-    uint32_t start, end1;
-#endif
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+   uint32_t intr=0;
+   uint16_t addr;
+   tmhwEfmc_PageConfig_t page_cfg;
 
-#ifdef CONFIG_MTD_PERF_MEAS
-    start = readl(TSU_COUNTER_REG);
+#ifdef CONFIG_MTD_NX_NAND_DMAC
+   int chanid, status;
+   tmhwEfmc_DmaConfig_t dma_cfg;
+   nx_dmac_tfr_t        req;
+   nx_dmac_stgt_t       stgt[(mtd->writesize/nc->blk_size)+1];
 #endif
 
-    /* Copy data into buffer */
-    chip->write_buf(mtd, buf, mtd->writesize);
-    chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+   /* Copy data into buffer */
+   chip->write_buf(mtd, buf, mtd->writesize);
+   chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
 
 #ifdef CONFIG_MTD_NX_NAND_DMAC   
+   /* Scatter gather list for DMAC */
+   nx_nand_dmac_init(nc, 0, &req, stgt);
 
-    /* Scatter gather list for DMAC */
-    nx_nand_dmac_init(nc, 0, &req, stgt);
-
-    /* Flow control */
-    dma_cfg.enableM2PDma = tmhwEfmc_Enable;
-    dma_cfg.enableP2MDma = tmhwEfmc_Disable;
-    tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
-
-    chanid = nx_dmac_tfr(&req);
-    if(chanid < 0) {
-        printk(KERN_ERR "nx_nand: NAND_SEQIN DMAC config \r\n"); 
-        return;
-    }
-
-    /* Page operation */
-    page_cfg.includeOOB = true;
-    page_cfg.operType = tmhwEfmc_PageWrite;
-
-    if(nc->aes) {
-        page_cfg.includeAES = true;
-    }
-    else {
-        page_cfg.includeAES = false;
-    }
-
-    if(nc->hwecc) {
-        page_cfg.includeECC = true;
-    }
-    else {
-        page_cfg.includeECC = false;
-    }
-    tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
-
-    /* Clear the interrupts */
-    intr = NX_NAND_INT_SEQ_WRITE;
-    intr |= 1 << (NX_NAND_INT_READY_START + nc->slotid);
-    tmhwEfmc_IntClear(nc->unitid, intr);
-
-    /* Enable the SEQ READ PAGE DONE interrupt */
-    tmhwEfmc_IntEnable(nc->unitid, intr);
-
-    /* Send address cycles & command */
-    nc->done = false;
-    nx_nand_cmd_addr(nc, 1, NAND_CMD_SEQIN, 0);
-
-    if(nc->lb_chip) {
-        addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
-        nx_nand_cmd_addr(nc, 0, addr, 0);
-
-        addr = (nc->cur_col >> 8) & NX_NAND_SP_ADDR_MASK;
-        nx_nand_cmd_addr(nc, 0, addr, 0);
-
-        addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-        nx_nand_cmd_addr(nc, 0, addr, 0);
-
-        addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-        nx_nand_cmd_addr(nc, 0, addr, 0);
-
-        /* if > 2Gb, extra address cycle */
-        if (nc->chip.chipsize >= (1 << 28)) {
-            addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-            nx_nand_cmd_addr(nc, 0, addr, 0);
-        }
-    }
-    else {
-        addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
-        nx_nand_cmd_addr(nc, 0, addr, 0);
-
-        addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-        nx_nand_cmd_addr(nc, 0, addr, 0);
-
-        addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-        nx_nand_cmd_addr(nc, 0, addr, 0);
-
-        /* if > 64Mb, extra adddress cycle */
-        if (nc->chip.chipsize > (32 << 20)) {
-            addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-            nx_nand_cmd_addr(nc, 0, addr, 0);
-        }
-    }
-
-    /* Send post write command */
-    nx_nand_cmd_addr(nc, 2, NAND_CMD_PAGEPROG, 1);
-
-    /* Complete DMAC transfer */
-    status = nx_dmac_tfr_comp(chanid);
-    if(status) {
-        printk(KERN_ERR "nx_nand: write_page_raw \r\n");   
-        return;
-    }
-
-    /* Wait for READY interrupt */   
-    wait_event(nc->nand_queue, (nc->done != false));
-
-    /* Disable interrupts */   
-    tmhwEfmc_IntDisable(nc->unitid, intr);
-
-    /* Disable Flow control */
-    dma_cfg.enableM2PDma = tmhwEfmc_Disable;
-    dma_cfg.enableP2MDma = tmhwEfmc_Disable;
-    tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
+   /* Flow control */
+   dma_cfg.enableM2PDma = tmhwEfmc_Enable;
+   dma_cfg.enableP2MDma = tmhwEfmc_Disable;
+   tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
+
+   chanid = nx_dmac_tfr(&req);
+   if(chanid < 0) {
+      printk(KERN_ERR "nx_nand: NAND_SEQIN DMAC config \r\n"); 
+      return;
+   }
+
+   /* Page operation */
+   page_cfg.includeOOB = true;
+   page_cfg.operType = tmhwEfmc_PageWrite;
+   if(nc->aes) {
+      page_cfg.includeAES = true;
+   } 
+   else {
+      page_cfg.includeAES = false;
+   }
+   if(nc->hwecc) {
+      page_cfg.includeECC = true;
+   } 
+   else {
+      page_cfg.includeECC = false;
+   }
+   tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);
+
+   /* Clear the interrupts */
+   intr = NX_NAND_INT_SEQ_WRITE;
+   intr |= 1 << (NX_NAND_INT_READY_START + nc->slotid);
+   tmhwEfmc_IntClear(nc->unitid, intr);
+
+   /* Enable the SEQ READ PAGE DONE interrupt */
+   tmhwEfmc_IntEnable(nc->unitid, intr);
+
+   /* Send address cycles & command */
+   nc->done = false;
+   nx_nand_cmd_addr(nc, 1, NAND_CMD_SEQIN, 0);
+
+   if(nc->lb_chip) {
+      addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+
+      addr = (nc->cur_col >> 8) & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+
+      addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+
+      addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+
+      /* if > 2Gb, extra address cycle */
+      if (nc->chip.chipsize >= (1 << 28)) {
+         addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
+      }
+   } 
+   else {
+      addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+
+      addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+
+      addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+
+      /* if > 64Mb, extra adddress cycle */
+      if (nc->chip.chipsize > (32 << 20)) {
+         addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
+      }
+   }
+
+   /* Send post write command */
+   nx_nand_cmd_addr(nc, 2, NAND_CMD_PAGEPROG, 1);
+
+   /* Complete DMAC transfer */
+   status = nx_dmac_tfr_comp(chanid);
+   if(status) {
+      printk(KERN_ERR "nx_nand: write_page_raw \r\n");
+      return;
+   }
+
+   /* Wait for READY interrupt */   
+   wait_event(nc->nand_queue, (nc->done != false));
+
+   /* Disable interrupts */   
+   tmhwEfmc_IntDisable(nc->unitid, intr);
+
+   /* Disable Flow control */
+   dma_cfg.enableM2PDma = tmhwEfmc_Disable;
+   dma_cfg.enableP2MDma = tmhwEfmc_Disable;
+   tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
 
 #else 
 
-    /* Init page operation */
-    nc->blk_index = 0;
-
-    /* Send Cmd & address to chip */
-    page_cfg.includeOOB = true;
-    page_cfg.operType = tmhwEfmc_PageWrite;
-    if(nc->aes) {
-        intr |= NX_NAND_INT_AES_DEC;
-        page_cfg.includeAES = true;
-    }
-    else {
-        page_cfg.includeAES = false;
-    }
-
-    if(nc->hwecc) {
-        intr |= NX_NAND_INT_ENC;
-        page_cfg.includeECC = true;
-    }
-    else {
-        page_cfg.includeECC = false;
-        intr |= NX_NAND_INT_BLK_WRITE;
-    }
-    tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
-
-    /* Int Enable */
-    intr |= (NX_NAND_INT_OOB_WRITE | (1 << (NX_NAND_INT_READY_START + nc->slotid)));
-    tmhwEfmc_IntClear(nc->unitid, intr);
-    tmhwEfmc_IntEnable(nc->unitid, intr);
-
-    /* Send the address commands to chip */
-    nc->done = false;
-    nx_nand_cmd_addr(nc,1, NAND_CMD_SEQIN, 0);
-
-    if(nc->lb_chip) {
-        addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
-        nx_nand_cmd_addr(nc, 0, addr, 0);
-
-        addr = (nc->cur_col >> 8) & NX_NAND_SP_ADDR_MASK;
-        nx_nand_cmd_addr(nc, 0, addr, 0);
-
-        addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-        nx_nand_cmd_addr(nc, 0, addr, 0);
+   /* Init page operation */
+   nc->blk_index = 0;
 
-        addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-        nx_nand_cmd_addr(nc, 0, addr, 0);
+   /* Send Cmd & address to chip */
+   page_cfg.includeOOB = true;
+   page_cfg.operType = tmhwEfmc_PageWrite;
+   if(nc->aes) {
+      intr |= NX_NAND_INT_AES_DEC;
+      page_cfg.includeAES = true;
+   }
+   else {
+      page_cfg.includeAES = false;
+   }
+   if(nc->hwecc) {
+      intr |= NX_NAND_INT_ENC;
+      page_cfg.includeECC = true;
+   }
+   else {
+      page_cfg.includeECC = false;
+      intr |= NX_NAND_INT_BLK_WRITE;
+   }
+   tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+
+   /* Int Enable */
+   intr |= (NX_NAND_INT_OOB_WRITE | 
+      (1 << (NX_NAND_INT_READY_START + nc->slotid)));
+   tmhwEfmc_IntClear(nc->unitid, intr);
+   tmhwEfmc_IntEnable(nc->unitid, intr);
+
+   /* Send the address commands to chip */
+   nc->done = false;
+   nx_nand_cmd_addr(nc,1, NAND_CMD_SEQIN, 0);
+
+   if(nc->lb_chip) {
+      addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+
+      addr = (nc->cur_col >> 8) & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+
+      addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+
+      addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+
+      if (nc->chip.chipsize >= (1 << 28)) {
+         addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
+      }
+   }
+   else {
+      addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+
+      addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+
+      addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+      nx_nand_cmd_addr(nc, 0, addr, 0);
+
+      if (nc->chip.chipsize > (32 << 20)) {
+         addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
+      }
+   }
+
+   /* Post write command */
+   nx_nand_cmd_addr(nc, 2, NAND_CMD_PAGEPROG, 1);
 
-        if (nc->chip.chipsize >= (1 << 28)) {
-            addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-            nx_nand_cmd_addr(nc, 0, addr, 0);
-        }
-    }
-    else {
-        addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
-        nx_nand_cmd_addr(nc, 0, addr, 0);
-
-        addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-        nx_nand_cmd_addr(nc, 0, addr, 0);
-
-        addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-        nx_nand_cmd_addr(nc, 0, addr, 0);
-
-        if (nc->chip.chipsize > (32 << 20)) {
-            addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-            nx_nand_cmd_addr(nc, 0, addr, 0);
-        }
-    }
-
-    /* Post write command */
-    nx_nand_cmd_addr(nc, 2, NAND_CMD_PAGEPROG, 1);
-
-    /* Wait for READY interrupt */   
-    wait_event(nc->nand_queue, (nc->done != false));
-
-    /* Disable interrupts */
-    tmhwEfmc_IntDisable(nc->unitid, intr);
+   /* Wait for READY interrupt */   
+   wait_event(nc->nand_queue, (nc->done != false));
 
+   /* Disable interrupts */
+   tmhwEfmc_IntDisable(nc->unitid, intr);
 #endif
-
-#ifdef CONFIG_MTD_PERF_MEAS
-    end1 = readl(TSU_COUNTER_REG);
-    nand_perf_meas(mtd, start, end1, MTD_MEAS_WRITE);
-#endif
-
-    return;
+   return;
 }
 
 #ifdef CONFIG_MTD_NX_NAND_HWECC
@@ -1103,30 +1007,15 @@ static void nx_nand_write_page_raw(struc
  * Write a full page + oob into the buffer
  */
 static void nx_nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
-        const uint8_t *buf)
+   const uint8_t *buf)
 {
-
-#ifdef CONFIG_MTD_PERF_MEAS
-    uint32_t start, end1;
-#endif
-
-#ifdef CONFIG_MTD_PERF_MEAS
-    start = readl(TSU_COUNTER_REG);
-#endif
-
-    nx_nand_write_page_raw(mtd, chip, buf);
-
-#ifdef CONFIG_MTD_PERF_MEAS
-    end1 = readl(TSU_COUNTER_REG);
-    nand_perf_meas(mtd, start, end1, MTD_MEAS_WRITE);
-#endif
-
-    return;
+   nx_nand_write_page_raw(mtd, chip, buf);
+   return;
 }
 #endif
 
 static u_char temp_buf[NAND_MAX_PAGESIZE+NAND_MAX_OOBSIZE];
-#define  OOB_BYTES_PER_BLK  (16)
+#define  OOB_BYTES_PER_BLK  (mtd->oobsize/nc->num_blks)
 
 /**
  * nx_nand_write_oob - Write OOB data
@@ -1137,146 +1026,153 @@ static u_char temp_buf[NAND_MAX_PAGESIZE
  * Write OOB data into the chip
  */
 static int nx_nand_write_oob(struct mtd_info *mtd, struct nand_chip *chip,
-        int page)
+   int page)
 {
-
-    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
-    int status = 0;
-    int sndcmd = 1;
-    const uint8_t *buf = chip->oob_poi;
-    int length;
-    int column, addr, i;
-    uint16_t data;
-    tmhwEfmc_PageConfig_t   page_cfg;
-    bool  ecc_old, aes_old;
-    u_char *temp1;
-    uint8_t   *oob_poi_orig;
-
-    if(mtd->flags & MTD_USE_DEV_OOB_LAYOUT) {
-        /* Use Device OOB layout -  write only OOB data */    
-        /* No page operation */
-        page_cfg.includeOOB = true;
-        page_cfg.operType = tmhwEfmc_Nothing;
-        page_cfg.includeAES = false;
-        page_cfg.includeECC = false;
-        tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
-
-        /* Send SEQIN command */
-        chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
-
-        /* Write to driver buffer */
-        length = mtd->oobsize;
-        chip->write_buf(mtd, buf, length);
-
-        /* Check if CE DON't care is supported */
-        column = nc->cur_col;
-        i = 0;
-        while(length) {
-            /* Send Address & cmd cycles */
-            if(sndcmd) {
-                nx_nand_cmd_addr(nc, 1, NAND_CMD_SEQIN, 0);
-
-                if(nc->lb_chip) {
-                    addr = column & NX_NAND_SP_ADDR_MASK;
-                    nx_nand_cmd_addr(nc, 0, addr, 0);
-
-                    addr = (column >> 8) & NX_NAND_SP_ADDR_MASK;
-                    nx_nand_cmd_addr(nc, 0, addr, 0);
-
-                    addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-                    nx_nand_cmd_addr(nc, 0, addr, 0);
-
-                    /* if > 2Gb, extra address cycle */
-                    if (nc->chip.chipsize >= (1 << 28)) {
-                        addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-                        nx_nand_cmd_addr(nc, 0, addr, 0);
-
-                        addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-                        nx_nand_cmd_addr(nc, 0, addr, 1);
-                    }
-                    else {
-                        addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-                        nx_nand_cmd_addr(nc, 0, addr, 1);
-                    }
-                }
-                else {
-                    addr = column & NX_NAND_SP_ADDR_MASK;
-                    nx_nand_cmd_addr(nc, 0, addr, 0);
-
-                    addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-                    nx_nand_cmd_addr(nc, 0, addr, 0);
-
-                    /* if > 64Mb, extra adddress cycle */
-                    if (nc->chip.chipsize > (32 << 20)) {
-                        addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-                        nx_nand_cmd_addr(nc, 0, addr, 0);
-
-                        addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-                        nx_nand_cmd_addr(nc, 0, addr, 1);
-                    }
-                    else {
-                        addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-                        nx_nand_cmd_addr(nc, 0, addr, 1);
-                    }
-                }
-                sndcmd = 0;
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+   int status = 0;
+   int sndcmd = 1;
+   const uint8_t *buf = chip->oob_poi;
+   int length;
+   int column, addr, i;
+   uint16_t data;
+   tmhwEfmc_PageConfig_t   page_cfg;
+   bool  ecc_old, aes_old;
+   u_char *temp1;
+   uint8_t   *oob_poi_orig;
+   u_int32_t remaining_data;
+
+   if(mtd->flags & MTD_USE_DEV_OOB_LAYOUT) {
+      /* Use Device OOB layout -  write only OOB data */    
+      /* No page operation for OOB */
+      page_cfg.includeOOB = true;
+      page_cfg.operType = tmhwEfmc_Nothing;
+      page_cfg.includeAES = false;
+      page_cfg.includeECC = false;
+      tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);
+
+      /* Send SEQIN command */
+      chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
+
+      /* Write to driver buffer */
+      length = mtd->oobsize;
+      chip->write_buf(mtd, buf, length);
+
+      /* Check if CE DON't care is supported */
+      column = nc->cur_col;
+      i = 0;
+      while(length) {
+         /* Send Address & cmd cycles */
+         if(sndcmd) {
+            nx_nand_cmd_addr(nc, 1, NAND_CMD_SEQIN, 0);
+
+            if(nc->lb_chip) {
+               addr = column & NX_NAND_SP_ADDR_MASK;
+               nx_nand_cmd_addr(nc, 0, addr, 0);
+
+               addr = (column >> 8) & NX_NAND_SP_ADDR_MASK;
+               nx_nand_cmd_addr(nc, 0, addr, 0);
+
+               addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+               nx_nand_cmd_addr(nc, 0, addr, 0);
+
+               /* if > 2Gb, extra address cycle */
+               if (nc->chip.chipsize >= (1 << 28)) {
+                  addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+                  nx_nand_cmd_addr(nc, 0, addr, 0);
+
+                  addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+                  nx_nand_cmd_addr(nc, 0, addr, 1);
+               }
+               else {
+                  addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+                  nx_nand_cmd_addr(nc, 0, addr, 1);
+               }
             }
+            else {
+               addr = column & NX_NAND_SP_ADDR_MASK;
+               nx_nand_cmd_addr(nc, 0, addr, 0);
+
+               addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+               nx_nand_cmd_addr(nc, 0, addr, 0);
 
-            /* Write data into chip */
-            data = buf[i];
-            status  = tmhwEfmc_WriteSingleData(nc->unitid, data);    
-
-            length--;
-            i++;
-
-            if(!nx_nc->cedontcare) {
-                sndcmd = 1; 
-                column++;
+               /* if > 64Mb, extra adddress cycle */
+               if (nc->chip.chipsize > (32 << 20)) {
+                  addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+                  nx_nand_cmd_addr(nc, 0, addr, 0);
+
+                  addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+                  nx_nand_cmd_addr(nc, 0, addr, 1);
+               }
+               else {
+                  addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+                  nx_nand_cmd_addr(nc, 0, addr, 1);
+               }
             }
-        }
+            sndcmd = 0;
+         }
 
-        /* write  confirm command */
-        nx_nand_cmd_addr(nc, 1, NAND_CMD_PAGEPROG, 1);
-    }
-    else {
-        /* Use IP_2017 OOB layout - write page */
-        /* Store ECC,AES values & Disbale */   
-        ecc_old = nc->hwecc;
-        aes_old = nc->aes;
-        oob_poi_orig = chip->oob_poi;
-        nc->hwecc = false;
-        nc->aes = false;
-
-        /* Send SEQIN command */
-        chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0, page);
-
-        /* Initialise temp_buf */
-        memset(temp_buf, 0xff, (mtd->writesize + mtd->oobsize));
-
-        /* copy OOB */ 
-        temp1 = temp_buf;
-        for(i=0; i < nc->num_blks; i++) {
-            temp1 += NX_NAND_BLK_SIZE;
-            memcpy(temp1, (chip->oob_poi + (i * OOB_BYTES_PER_BLK)), OOB_BYTES_PER_BLK);
-            temp1 += OOB_BYTES_PER_BLK;   
-        }
-        chip->oob_poi = &temp_buf[mtd->writesize];
-
-        /* Call write page raw */
-        nx_nand_write_page_raw(mtd, chip, temp_buf);
-
-        /* Restore ECC,AES values */  
-        chip->oob_poi = oob_poi_orig;
-        nc->hwecc = ecc_old;
-        nc->aes = aes_old;
-    }
+         /* Write data into chip */
+         data = buf[i];
+         status  = tmhwEfmc_WriteSingleData(nc->unitid, data);    
+
+         length--;
+         i++;
+
+         if(!nx_nc->cedontcare) {
+            sndcmd = 1; 
+            column++;
+         }
+      }
+
+      /* write  confirm command */
+      nx_nand_cmd_addr(nc, 1, NAND_CMD_PAGEPROG, 1);
+   }
+   else {
+      /* Use IP_2017 OOB layout - write page */
+      /* Store ECC,AES values & Disbale */   
+      ecc_old = nc->hwecc;
+      aes_old = nc->aes;
+      oob_poi_orig = chip->oob_poi;
+      nc->hwecc = false;
+      nc->aes = false;
+
+      /* Send SEQIN command */
+      chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0, page);
+
+      /* Initialise temp_buf */
+      memset(temp_buf, 0xff, (mtd->writesize + mtd->oobsize));
+
+      /* copy OOB */ 
+      temp1 = temp_buf;
+      for(i=0; i < nc->num_blks; i++) {
+         temp1 += nc->blk_size;
+         memcpy(temp1, (chip->oob_poi + (i * OOB_BYTES_PER_BLK)), 
+            OOB_BYTES_PER_BLK);
+         temp1 += OOB_BYTES_PER_BLK;
+      }
+      /* copy remaining oob bytes */
+      remaining_data = (mtd->oobsize - (nc->num_blks * OOB_BYTES_PER_BLK));
+      if ( remaining_data ) {
+         memcpy(temp1, (chip->oob_poi + (i * OOB_BYTES_PER_BLK)), 
+            remaining_data);
+      }
+      chip->oob_poi = &temp_buf[mtd->writesize];
+
+      /* Call write page raw */
+      nx_nand_write_page_raw(mtd, chip, temp_buf);
+
+      /* Restore ECC,AES values */  
+      chip->oob_poi = oob_poi_orig;
+      nc->hwecc = ecc_old;
+      nc->aes = aes_old;
+   }
 
-    /* Send command to program the OOB data */
-    chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+   /* Send command to program the OOB data */
+   chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
 
-    status = chip->waitfunc(mtd, chip);
+   status = chip->waitfunc(mtd, chip);
 
-    return status & NAND_STATUS_FAIL ? -EIO : 0;
+   return status & NAND_STATUS_FAIL ? -EIO : 0;
 }
 
 /**
@@ -1289,335 +1185,323 @@ static int nx_nand_write_oob(struct mtd_
  * Command control function:
  */
 static void nx_nand_command(struct mtd_info *mtd, unsigned int cmd,
-        int column, int page_addr)
+   int column, int page_addr)
 {
-    tmhwEfmc_PageConfig_t   page_cfg;
-    uint16_t addr;
-    uint32_t intr=0;
-    int   status, i;
-    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+   tmhwEfmc_PageConfig_t   page_cfg;
+   uint16_t addr;
+   uint32_t intr=0;
+   int i;
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
 
 #ifdef CONFIG_MTD_NX_NAND_DMAC 
-    int   chanid;
-    tmhwEfmc_DmaConfig_t dma_cfg;
-    nx_dmac_tfr_t           req;
-    nx_dmac_stgt_t       stgt[(mtd->writesize/NX_NAND_BLK_SIZE)+1];
-#endif
-
-    /* Store the command, colmn & page address */
-    nc->cur_cmd = cmd;
-    if(column == -1)
-        column = 0;
-    nc->cur_col = column;
-    if(page_addr == -1)
-        page_addr = 0;
-    nc->cur_page = page_addr;
-
-    /*
-     * Issue the correct first command, when we write to
-     * the device.
-     */
-    switch(cmd) {
-        case NAND_CMD_SEQIN:
-            nc->offset = 0;
-            /* Address cycles & command will be sent in write_page_raw */
-            break;
-
-#ifdef CONFIG_MTD_NX_NAND_DMAC 
-        case NAND_CMD_PAGEPROG:
-            break;
-
-        case NAND_CMD_RESET:
-        case NAND_CMD_STATUS:
-            nx_nand_cmd_addr(nc, 1, cmd, 1);
-            break;
-
-#else 
-        case NAND_CMD_PAGEPROG:
-            /* Post write command feature used */
-            break;
-
-        case NAND_CMD_RESET:
-        case NAND_CMD_STATUS:
-            nx_nand_cmd_addr(nc, 1, cmd, 1);
-            break;
-#endif
-
-        case NAND_CMD_ERASE1:
-            /* Enable READY interupt */
-            intr |= (1 << (NX_NAND_INT_READY_START + nc->slotid));
-            tmhwEfmc_IntClear(nc->unitid, intr);
-            tmhwEfmc_IntEnable(nc->unitid, intr);
+   int   chanid;
+   int   status;
+   tmhwEfmc_DmaConfig_t dma_cfg;
+   nx_dmac_tfr_t        req;
+   nx_dmac_stgt_t       stgt[(mtd->writesize/nc->blk_size)+1];
+#endif
+
+   /* Store the command, colmn & page address */
+   nc->cur_cmd = cmd;
+   if(column == -1)
+      column = 0;
+   nc->cur_col = column;
+   if(page_addr == -1)
+      page_addr = 0;
+   nc->cur_page = page_addr;
+
+   /*
+    * Issue the correct first command, when we write to
+    * the device.
+    */
+   switch(cmd) {
+      case NAND_CMD_SEQIN:
+         nc->offset = 0;
+         /* Address cycles & command will be sent in write_page_raw */
+         break;
+
+      case NAND_CMD_PAGEPROG:
+         /* Post write command feature used */
+         break;
+
+      case NAND_CMD_RESET:
+      case NAND_CMD_STATUS:
+         /* No page operation */
+         page_cfg.includeOOB = false;
+         page_cfg.operType = tmhwEfmc_Nothing;
+         page_cfg.includeAES = false;
+         page_cfg.includeECC = false;
+         tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);
+
+         nx_nand_cmd_addr(nc, 1, cmd, 1);
+         break;
+
+      case NAND_CMD_ERASE1:
+         /* Enable READY interupt */
+         intr |= (1 << (NX_NAND_INT_READY_START + nc->slotid));
+         tmhwEfmc_IntClear(nc->unitid, intr);
+         tmhwEfmc_IntEnable(nc->unitid, intr);
+
+         /* No page operation */
+         page_cfg.includeOOB = false;
+         page_cfg.operType = tmhwEfmc_Nothing;
+         page_cfg.includeAES = false;
+         page_cfg.includeECC = false;
+         tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+
+         /* Send address cycles & command */
+         nc->done = false;
+
+         nx_nand_cmd_addr(nc, 1, NAND_CMD_ERASE1, 0);
 
-            /* Send address cycles & command */
-            nc->done = false;
+         addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
 
-            nx_nand_cmd_addr(nc, 1, NAND_CMD_ERASE1, 0);
+         addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
 
-            addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-            nx_nand_cmd_addr(nc, 0, addr, 0);
-
-            addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+         if (nc->chip.chipsize > (32 << 20)) {
+            addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
             nx_nand_cmd_addr(nc, 0, addr, 0);
+         }
 
-            if (nc->chip.chipsize > (32 << 20)) {
-                addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-                nx_nand_cmd_addr(nc, 0, addr, 0);
-            }
-
-            nx_nand_cmd_addr(nc, 1, NAND_CMD_ERASE2, 1);
+         nx_nand_cmd_addr(nc, 1, NAND_CMD_ERASE2, 1);
 
-            /* Wait for the completion */ 
-            wait_event(nc->nand_queue, (nc->done != false));
+         /* Wait for the completion */ 
+         wait_event(nc->nand_queue, (nc->done != false));
 
-            /* Disable READY interrupt */
-            tmhwEfmc_IntDisable(nc->unitid, intr);
+         /* Disable READY interrupt */
+         tmhwEfmc_IntDisable(nc->unitid, intr);
 
-            break;
+         break;
 
-        case NAND_CMD_ERASE2:
-            /* Already done in CMD_ERASE1 */
-            break;
+      case NAND_CMD_ERASE2:
+         /* Already done in CMD_ERASE1 */
+         break;
 
-        case NAND_CMD_READ0:
-            nc->offset = 0;
+      case NAND_CMD_READ0:
+         nc->offset = 0;
 
 #ifdef CONFIG_MTD_NX_NAND_DMAC
-            /* Start the DMAC */
-            nx_nand_dmac_init(nc, 1, &req, stgt);
+         /* Start the DMAC */
+         nx_nand_dmac_init(nc, 1, &req, stgt);
 
-            /* Configure Flow control */
-            dma_cfg.enableM2PDma = tmhwEfmc_Disable;
-            dma_cfg.enableP2MDma = tmhwEfmc_Enable;
-            tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
-
-            /* Enable the SEQ READ PAGE DONE interrupt */
-            intr |= NX_NAND_INT_SEQ_READ;
-            tmhwEfmc_IntClear(nc->unitid, intr);
-            tmhwEfmc_IntEnable(nc->unitid, intr);
-
-            /* Page operation */
-            page_cfg.includeOOB = true;
-            page_cfg.operType = tmhwEfmc_PageRead;
-            if(nc->aes) {
-                page_cfg.includeAES = true;
-            }
-            else {
-                page_cfg.includeAES = false;
-            }
-            if(nc->hwecc) {
-                page_cfg.includeECC = true;
-            }
-            else {
-                page_cfg.includeECC = false;
-            }
-            tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+         /* Configure Flow control */
+         dma_cfg.enableM2PDma = tmhwEfmc_Disable;
+         dma_cfg.enableP2MDma = tmhwEfmc_Enable;
+         tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
+
+         /* Enable the SEQ READ PAGE DONE interrupt */
+         intr |= NX_NAND_INT_SEQ_READ;
+         tmhwEfmc_IntClear(nc->unitid, intr);
+         tmhwEfmc_IntEnable(nc->unitid, intr);
+
+         /* Page operation */
+         page_cfg.includeOOB = true;
+         page_cfg.operType = tmhwEfmc_PageRead;
+         if(nc->aes) {
+            page_cfg.includeAES = true;
+         }
+         else {
+            page_cfg.includeAES = false;
+         }
+         if(nc->hwecc) {
+            page_cfg.includeECC = true;
+         }
+         else {
+            page_cfg.includeECC = false;
+         }
+         tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
 
-            chanid = nx_dmac_tfr(&req);
-            if(chanid < 0) {
-                printk(KERN_ERR "nx_nand: NAND_READ0 DMAC config \r\n"); 
-                return;
-            }
+         chanid = nx_dmac_tfr(&req);
+         if(chanid < 0) {
+            printk(KERN_ERR "nx_nand: NAND_READ0 DMAC config \r\n"); 
+            return;
+         }
 
-            /* Send address cycles & command */
-            nx_nand_cmd_addr(nc, 1, NAND_CMD_READ0, 0);
+         /* Send address cycles & command */
+         nx_nand_cmd_addr(nc, 1, NAND_CMD_READ0, 0);
 
-            addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
-            nx_nand_cmd_addr(nc, 0, addr, 0);
+         addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
 
-            addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-            nx_nand_cmd_addr(nc, 0, addr, 0);
-
-            if (nc->chip.chipsize > (32 << 20)) {
-                addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-                nx_nand_cmd_addr(nc, 0, addr, 0);
-                addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-                nx_nand_cmd_addr(nc, 0, addr, 1);
-            }
-            else {
-                addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-                nx_nand_cmd_addr(nc, 0, addr, 1);
-            }
+         addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
 
-            /* Complete DMAC transfer */
-            status = nx_dmac_tfr_comp(chanid);
-            if(status) {
-                printk(KERN_ERR "nx_nand: NAND_READ0 DMAC complete\r\n");   
-                return;
-            }
+         if (nc->chip.chipsize > (32 << 20)) {
+            addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+            nx_nand_cmd_addr(nc, 0, addr, 0);
+            addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+            nx_nand_cmd_addr(nc, 0, addr, 1);
+         }
+         else {
+            addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+            nx_nand_cmd_addr(nc, 0, addr, 1);
+         }
 
-            /* Disable interrupts */   
-            tmhwEfmc_IntDisable(nc->unitid, intr);
+         /* Complete DMAC transfer */
+         status = nx_dmac_tfr_comp(chanid);
+         if(status) {
+            printk(KERN_ERR "nx_nand: NAND_READ0 DMAC complete\r\n");   
+            return;
+         }
 
-            /* Disable Flow control */
-            dma_cfg.enableM2PDma = tmhwEfmc_Disable;
-            dma_cfg.enableP2MDma = tmhwEfmc_Disable;
-            tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
+         /* Disable interrupts */   
+         tmhwEfmc_IntDisable(nc->unitid, intr);
 
+         /* Disable Flow control */
+         dma_cfg.enableM2PDma = tmhwEfmc_Disable;
+         dma_cfg.enableP2MDma = tmhwEfmc_Disable;
+         tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
 #else
+         nc->blk_index = 0;
 
-            nc->blk_index = 0;
+         /* Init page operation */
+         page_cfg.includeOOB = true;
+         page_cfg.operType = tmhwEfmc_PageRead;
+         if(nc->aes) {
+            intr |= NX_NAND_INT_AES_DEC;
+            page_cfg.includeAES = true;
+         }
+         else {
+            page_cfg.includeAES = false;
+         }
 
-            /* Init page operation */
-            page_cfg.includeOOB = true;
-            page_cfg.operType = tmhwEfmc_PageRead;
-            if(nc->aes) {
-                intr |= NX_NAND_INT_AES_DEC;
-                page_cfg.includeAES = true;
-            }
-            else {
-                page_cfg.includeAES = false;
-            }
+         if(nc->hwecc) {
+            intr |= NX_NAND_INT_DEC;
+            page_cfg.includeECC = true;
+         }
+         else {
+            page_cfg.includeECC = false;
+            intr |= NX_NAND_INT_BLK_READ;
+         }
+         tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
 
-            if(nc->hwecc) {
-                intr |= NX_NAND_INT_DEC;
-                page_cfg.includeECC = true;
-            }
-            else {
-                page_cfg.includeECC = false;
-                intr |= NX_NAND_INT_BLK_READ;
-            }
-            tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+         intr |= NX_NAND_INT_OOB_READ;
+         tmhwEfmc_IntClear(nc->unitid, intr);
+         tmhwEfmc_IntEnable(nc->unitid, NX_NAND_INT_OOB_READ);
 
-            intr |= NX_NAND_INT_OOB_READ;
-            tmhwEfmc_IntClear(nc->unitid, intr);
-            tmhwEfmc_IntEnable(nc->unitid, NX_NAND_INT_OOB_READ);
+         /* Send the address commands to chip */
+         nc->done = false;
 
-            /* Send the address commands to chip */
-            nc->done = false;
+         nx_nand_cmd_addr(nc, 1, NAND_CMD_READ0, 0);
+         addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
 
-            nx_nand_cmd_addr(nc, 1, NAND_CMD_READ0, 0);
-            addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
+         addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
 
-            nx_nand_cmd_addr(nc, 0, addr, 0);
-            addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
 
+         if (nc->chip.chipsize > (32 << 20)) {
+            addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
             nx_nand_cmd_addr(nc, 0, addr, 0);
+            addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+            nx_nand_cmd_addr(nc, 0, addr, 1);
+         }
+         else {
+            addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+            nx_nand_cmd_addr(nc, 0, addr, 1);
+         }
 
-            if (nc->chip.chipsize > (32 << 20)) {
-                addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-                nx_nand_cmd_addr(nc, 0, addr, 0);
-                addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-                nx_nand_cmd_addr(nc, 0, addr, 1);
-            }
-            else {
-                addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-                nx_nand_cmd_addr(nc, 0, addr, 1);
-            }
-
-            /* Wait for the completion */ 
-            wait_event(nc->nand_queue, (nc->done != false));
-
-            /* Disable interrupts */
-            tmhwEfmc_IntDisable(nc->unitid, intr);
+         /* Wait for the completion */ 
+         wait_event(nc->nand_queue, (nc->done != false));
 
+         /* Disable interrupts */
+         tmhwEfmc_IntDisable(nc->unitid, intr);
 #endif
-            break;
+         break;
+
+      case NAND_CMD_READOOB:
+         /* Offset to OOB area in driver buffer */
+         nc->offset = mtd->writesize;
+         nc->blk_index = (nc->num_blks * nc->blk_size);
+
+         /* Enable the OOB block request */
+         tmhwEfmc_IntClear(nc->unitid, NX_NAND_INT_OOB_READ);
+         tmhwEfmc_IntEnable(nc->unitid, NX_NAND_INT_OOB_READ);
+
+         /* Init page operation command */
+         page_cfg.includeOOB = true;
+         page_cfg.operType = tmhwEfmc_PageRead;
+         if(nc->aes) {
+            page_cfg.includeAES = true;
+         }
+         else {
+            page_cfg.includeAES = false;
+         }
+         if(nc->hwecc) {
+            page_cfg.includeECC = true;
+         }
+         else {
+            page_cfg.includeECC = false;
+         }
+         tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
 
-        case NAND_CMD_READOOB:
-            /* Offset to OOB area in driver buffer */
-            nc->offset = mtd->writesize;
-            nc->blk_index = (nc->num_blks * NX_NAND_BLK_SIZE);
-
-            /* Enable the OOB block request */
-            tmhwEfmc_IntClear(nc->unitid, NX_NAND_INT_OOB_READ);
-            tmhwEfmc_IntEnable(nc->unitid, NX_NAND_INT_OOB_READ);
-
-            /* Init page operation command */
-            page_cfg.includeOOB = true;
-            page_cfg.operType = tmhwEfmc_PageRead;
-            if(nc->aes) {
-                page_cfg.includeAES = true;
-            }
-            else {
-                page_cfg.includeAES = false;
-            }
-            if(nc->hwecc) {
-                page_cfg.includeECC = true;
-            }
-            else {
-                page_cfg.includeECC = false;
-            }
-            tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+         /* Send cmd & address cycles */
+         nc->done = false;
 
-            /* Send cmd & address cycles */
-            nc->done = false;
+         nx_nand_cmd_addr(nc, 1, NAND_CMD_READOOB, 0);
+         addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
 
-            nx_nand_cmd_addr(nc, 1, NAND_CMD_READOOB, 0);
-            addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
+         addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
 
-            nx_nand_cmd_addr(nc, 0, addr, 0);
-            addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
 
+         if (nc->chip.chipsize > (32 << 20)) {
+            addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
             nx_nand_cmd_addr(nc, 0, addr, 0);
+            addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+            nx_nand_cmd_addr(nc, 0, addr, 1);
+         }
+         else {
+            addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+            nx_nand_cmd_addr(nc, 0, addr, 1);
+         }
 
-            if (nc->chip.chipsize > (32 << 20)) {
-                addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-                nx_nand_cmd_addr(nc, 0, addr, 0);
-                addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-                nx_nand_cmd_addr(nc, 0, addr, 1);
-            }
-            else {
-                addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-                nx_nand_cmd_addr(nc, 0, addr, 1);
-            }
-
-            /* Wait for the completion */ 
-            wait_event(nc->nand_queue, (nc->done != false));
-
-            /* Disable the OOB block request */
-            tmhwEfmc_IntDisable(nc->unitid, NX_NAND_INT_OOB_READ);
-
-            break;
-
-        case NAND_CMD_READID:
-
-            /* Init page operation command */
-            page_cfg.includeOOB = false;
-            page_cfg.operType = tmhwEfmc_Nothing;
-            if(nc->aes) {
-                page_cfg.includeAES = true;
-            }
-            else {
-                page_cfg.includeAES = false;
-            }
-
-            if(nc->hwecc) {
-                page_cfg.includeECC = true;
-            }
-            else {
-                page_cfg.includeECC = false;
-            }
-
-            tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
-
-            nx_nand_cmd_addr(nc, 1, cmd, 0);
-            nx_nand_cmd_addr(nc, 0, column, 1);
-            break;
-
-        case NAND_CMD_PARAM:
-            nc->offset = 0;
-
-            page_cfg.includeOOB = false;
-            page_cfg.operType = tmhwEfmc_Nothing;
-            page_cfg.includeAES = false;
-            page_cfg.includeECC = false;
-
-            tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);
+         /* Wait for the completion */ 
+         wait_event(nc->nand_queue, (nc->done != false));
 
-            nx_nand_cmd_addr(nc, 1, cmd, 0);
-            nx_nand_cmd_addr(nc, 0, 0x0, 1);
+         /* Disable the OOB block request */
+         tmhwEfmc_IntDisable(nc->unitid, NX_NAND_INT_OOB_READ);
 
-            /* Read PARAM Page and 2 Redundant Parameter Pages */
-            for (i=0; i < (3 * sizeof(struct nand_onfi_params)); i++)
-            {
-                nc->dmabuf[i]=nx_nand_read_byte(mtd);
-            }
-            break;
-
-        default:
-            printk(KERN_ERR "nxnand: command not supported %d \n", cmd);
-    }
+         break;
+
+      case NAND_CMD_READID:
+         /* No page operation */
+         page_cfg.includeOOB = false;
+         page_cfg.operType = tmhwEfmc_Nothing;
+         page_cfg.includeAES = false;
+         page_cfg.includeECC = false;
+         tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);
+
+         nx_nand_cmd_addr(nc, 1, cmd, 0);
+         nx_nand_cmd_addr(nc, 0, column, 1);
+         break;
+
+      case NAND_CMD_PARAM:
+         nc->offset = 0;
+
+         /* No page operation */
+         page_cfg.includeOOB = false;
+         page_cfg.operType = tmhwEfmc_Nothing;
+         page_cfg.includeAES = false;
+         page_cfg.includeECC = false;
+         tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);
+
+         nx_nand_cmd_addr(nc, 1, cmd, 0);
+         nx_nand_cmd_addr(nc, 0, 0x0, 1);
+
+         /* Read PARAM Page and 2 Redundant Parameter Pages */
+         for (i=0; i < (3 * sizeof(struct nand_onfi_params)); i++)
+         {
+            nc->dmabuf[i]=nx_nand_read_byte(mtd);
+         }
+         break;
+
+      default:
+         printk(KERN_ERR "nxnand: command not supported %d \n", cmd);
+   }
 }
 
 /**
@@ -1630,288 +1514,279 @@ static void nx_nand_command(struct mtd_i
  * Command control function:
  */
 static void nx_nand_command_lp(struct mtd_info *mtd, unsigned int cmd,
-        int column, int page_addr)
+   int column, int page_addr)
 {
-    tmhwEfmc_PageConfig_t   page_cfg;
-    uint16_t addr;
-    uint32_t intr=0;
-    int   status, i;
-    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
-
-#ifdef CONFIG_MTD_NX_NAND_DMAC 
-    int   chanid;
-    tmhwEfmc_DmaConfig_t dma_cfg;
-    nx_dmac_tfr_t           req;
-    nx_dmac_stgt_t       stgt[(mtd->writesize/NX_NAND_BLK_SIZE)+1];
-#endif
-
-    /* Store the command, colmn & page address */
-    if(cmd == NAND_CMD_READOOB) {
-        cmd = NAND_CMD_READ0;
-
-        /* If Device OOB layout, read data in read_OOB function */ 
-        if(mtd->flags & MTD_USE_DEV_OOB_LAYOUT) {
-            nc->cur_cmd = cmd;
-            nc->cur_col = mtd->writesize;
-            nc->cur_page = page_addr;
-            return;
-        }
-    }
-
-    /* Store cmd, addresses */
-    nc->cur_cmd = cmd;
-    if(column == -1)
-        column = 0;
-    nc->cur_col = column;
-    if(page_addr == -1)
-        page_addr = 0;
-    nc->cur_page =  (page_addr);
-
-    /*
-     * Issue the correct first command, when we write to
-     * the device.
-     */
-    switch(cmd) {
-        case NAND_CMD_SEQIN:
-            nc->offset = column;
-            /* Address cycles & command will be sent in write_page_raw */
-            break;
+   tmhwEfmc_PageConfig_t   page_cfg;
+   uint16_t addr;
+   uint32_t intr=0;
+   int i;
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
 
 #ifdef CONFIG_MTD_NX_NAND_DMAC 
-        case NAND_CMD_PAGEPROG:
-            break;
-
-        case NAND_CMD_RESET:
-        case NAND_CMD_STATUS:
-            nx_nand_cmd_addr(nc, 1, cmd, 1);
-            break;
-
-#else 
-        case NAND_CMD_PAGEPROG:
-            /* Post write command feature used */
-            break;
-
-        case NAND_CMD_RESET:
-        case NAND_CMD_STATUS:
-            nx_nand_cmd_addr(nc, 1, cmd, 1);
-            break;
-#endif
-
-        case NAND_CMD_ERASE1:
-            /* Enable READY interupt */
-            intr = 1 << (NX_NAND_INT_READY_START + nc->slotid);
-            tmhwEfmc_IntClear(nc->unitid, intr);
-            tmhwEfmc_IntEnable(nc->unitid, intr);
+   int   status; 
+   int   chanid;
+   tmhwEfmc_DmaConfig_t dma_cfg;
+   nx_dmac_tfr_t           req;
+   nx_dmac_stgt_t       stgt[(mtd->writesize/nc->blk_size)+1];
+#endif
+
+   /* Store the command, colmn & page address */
+   if(cmd == NAND_CMD_READOOB) {
+      cmd = NAND_CMD_READ0;
+
+      /* If Device OOB layout, read data in read_OOB function */ 
+      if(mtd->flags & MTD_USE_DEV_OOB_LAYOUT) {
+         nc->cur_cmd = cmd;
+         nc->cur_col = mtd->writesize;
+         nc->cur_page = page_addr;
+         return;
+      }
+   }
+
+   /* Store cmd, addresses */
+   nc->cur_cmd = cmd;
+   if(column == -1)
+      column = 0;
+   nc->cur_col = column;
+   if(page_addr == -1)
+      page_addr = 0;
+   nc->cur_page =  (page_addr);
+
+   /*
+    * Issue the correct first command, when we write to
+    * the device.
+    */
+   switch(cmd) {
+      case NAND_CMD_SEQIN:
+         nc->offset = column;
+         /* Address cycles & command will be sent in write_page_raw */
+         break;
+
+      case NAND_CMD_PAGEPROG:
+         /* Post write command feature used */
+         break;
+
+      case NAND_CMD_RESET:
+      case NAND_CMD_STATUS:
+         /* No page operation */
+         page_cfg.includeOOB = false;
+         page_cfg.operType = tmhwEfmc_Nothing;
+         page_cfg.includeAES = false;
+         page_cfg.includeECC = false;
+         tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);
+
+         nx_nand_cmd_addr(nc, 1, cmd, 1);
+         break;
+
+      case NAND_CMD_ERASE1:
+         /* Enable READY interupt */
+         intr = 1 << (NX_NAND_INT_READY_START + nc->slotid);
+         tmhwEfmc_IntClear(nc->unitid, intr);
+         tmhwEfmc_IntEnable(nc->unitid, intr);
+
+         /* No page operation */
+         page_cfg.includeOOB = false;
+         page_cfg.operType = tmhwEfmc_Nothing;
+         page_cfg.includeAES = false;
+         page_cfg.includeECC = false;
+         tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);
+
+         /* Send address cycles & command */
+         nc->done = false;
+
+         nx_nand_cmd_addr(nc, 1, NAND_CMD_ERASE1, 0);
 
-            /* Send address cycles & command */
-            nc->done = false;
+         addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
 
-            nx_nand_cmd_addr(nc, 1, NAND_CMD_ERASE1, 0);
+         addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
 
-            addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-            nx_nand_cmd_addr(nc, 0, addr, 0);
-
-            addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+         if (nc->chip.chipsize >= (1 << 28)) {
+            addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
             nx_nand_cmd_addr(nc, 0, addr, 0);
+         }
+         nx_nand_cmd_addr(nc, 1, NAND_CMD_ERASE2, 1);
 
-            if (nc->chip.chipsize >= (1 << 28)) {
-                addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-                nx_nand_cmd_addr(nc, 0, addr, 0);
-            }
-            nx_nand_cmd_addr(nc, 1, NAND_CMD_ERASE2, 1);
+         /* Wait for the completion */ 
+         wait_event(nc->nand_queue, (nc->done != false));
 
-            /* Wait for the completion */ 
-            wait_event(nc->nand_queue, (nc->done != false));
-
-            /* Disable READY interrupt */
-            tmhwEfmc_IntDisable(nc->unitid, intr);
-            break;
-
-        case NAND_CMD_ERASE2:
-            /* Already done in CMD_ERASE1 */
-            break;
+         /* Disable READY interrupt */
+         tmhwEfmc_IntDisable(nc->unitid, intr);
+         break;
+
+      case NAND_CMD_ERASE2:
+         /* Already done in CMD_ERASE1 */
+         break;
 
-        case NAND_CMD_READ0:
-            nc->offset = column;
+      case NAND_CMD_READ0:
+         nc->offset = column;
 
 #ifdef CONFIG_MTD_NX_NAND_DMAC
-            /* Start the DMAC */
-            nx_nand_dmac_init(nc, 1, &req, stgt);
+         /* Start the DMAC */
+         nx_nand_dmac_init(nc, 1, &req, stgt);
 
-            /* Configure Flow control */
-            dma_cfg.enableM2PDma = tmhwEfmc_Disable;
-            dma_cfg.enableP2MDma = tmhwEfmc_Enable;
-            tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
-
-            /* Enable the SEQ READ PAGE DONE interrupt */
-            intr = NX_NAND_INT_SEQ_READ;
-            tmhwEfmc_IntClear(nc->unitid, intr);
-            tmhwEfmc_IntEnable(nc->unitid, intr);
-
-            /* Page operation */
-            page_cfg.includeOOB = true;
-            page_cfg.operType = tmhwEfmc_PageRead;
-            if(nc->aes) {
-                page_cfg.includeAES = true;
-            }
-            else {
-                page_cfg.includeAES = false;
-            }
-            if(nc->hwecc) {
-                page_cfg.includeECC = true;
-            }
-            else {
-                page_cfg.includeECC = false;
-            }
-            tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+         /* Configure Flow control */
+         dma_cfg.enableM2PDma = tmhwEfmc_Disable;
+         dma_cfg.enableP2MDma = tmhwEfmc_Enable;
+         tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
+
+         /* Enable the SEQ READ PAGE DONE interrupt */
+         intr = NX_NAND_INT_SEQ_READ;
+         tmhwEfmc_IntClear(nc->unitid, intr);
+         tmhwEfmc_IntEnable(nc->unitid, intr);
+
+         /* Page operation */
+         page_cfg.includeOOB = true;
+         page_cfg.operType = tmhwEfmc_PageRead;
+         if(nc->aes) {
+            page_cfg.includeAES = true;
+         }
+         else {
+            page_cfg.includeAES = false;
+         }
+         if(nc->hwecc) {
+            page_cfg.includeECC = true;
+         }
+         else {
+            page_cfg.includeECC = false;
+         }
+         tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
 
-            chanid = nx_dmac_tfr(&req);
-            if(chanid < 0) {
-                printk(KERN_ERR "nx_nand: NAND_READ0 DMAC config \r\n"); 
-                return;
-            }
+         chanid = nx_dmac_tfr(&req);
+         if(chanid < 0) {
+            printk(KERN_ERR "nx_nand: NAND_READ0 DMAC config \r\n"); 
+            return;
+         }
 
-            /* Send address cycles & command */
-            nc->done = false;
-            nx_nand_cmd_addr(nc, 1, NAND_CMD_READ0, 0);
+         /* Send address cycles & command */
+         nc->done = false;
+         nx_nand_cmd_addr(nc, 1, NAND_CMD_READ0, 0);
 
-            addr = column & NX_NAND_SP_ADDR_MASK;
-            nx_nand_cmd_addr(nc, 0, addr, 0);
+         addr = column & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
 
-            addr = (column >> 8) & NX_NAND_SP_ADDR_MASK;
-            nx_nand_cmd_addr(nc, 0, addr, 0);
+         addr = (column >> 8) & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
 
-            addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-            nx_nand_cmd_addr(nc, 0, addr, 0);
+         addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
 
-            addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
-            nx_nand_cmd_addr(nc, 0, addr, 0);
+         addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
 
-            if (nc->chip.chipsize >= (1 << 28)) {
-                addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-                nx_nand_cmd_addr(nc, 0, addr, 0);
-            }
+         if (nc->chip.chipsize >= (1 << 28)) {
+            addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
+            nx_nand_cmd_addr(nc, 0, addr, 0);
+         }
 
-            nx_nand_cmd_addr(nc, 1, NAND_CMD_READSTART, 1);
+         nx_nand_cmd_addr(nc, 1, NAND_CMD_READSTART, 1);
 
-            /* Wait for the completion */ 
-            wait_event(nc->nand_queue, (nc->done != false));
+         /* Wait for the completion */ 
+         wait_event(nc->nand_queue, (nc->done != false));
 
-            /* Complete DMAC transfer */
-            status = nx_dmac_tfr_comp(chanid);
-            if(status) {
-                printk(KERN_ERR "nx_nand: NAND_READ0 DMAC complete\r\n");   
-                return;
-            }
+         /* Complete DMAC transfer */
+         status = nx_dmac_tfr_comp(chanid);
+         if(status) {
+            printk(KERN_ERR "nx_nand: NAND_READ0 DMAC complete\r\n");   
+            return;
+         }
 
-            /* Disable interrupts */   
-            tmhwEfmc_IntDisable(nc->unitid, intr);
+         /* Disable interrupts */   
+         tmhwEfmc_IntDisable(nc->unitid, intr);
 
-            /* Disable Flow control */
-            dma_cfg.enableM2PDma = tmhwEfmc_Disable;
-            dma_cfg.enableP2MDma = tmhwEfmc_Disable;
-            tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
+         /* Disable Flow control */
+         dma_cfg.enableM2PDma = tmhwEfmc_Disable;
+         dma_cfg.enableP2MDma = tmhwEfmc_Disable;
+         tmhwEfmc_SetDmaConfig(nc->unitid, &dma_cfg);
 
 #else
+         nc->blk_index = 0;
 
-            nc->blk_index = 0;
-
-            /* Init page operation */
-            page_cfg.includeOOB = true;
-            intr |= NX_NAND_INT_OOB_READ;
-            page_cfg.operType = tmhwEfmc_PageRead;
-            if(nc->aes) {
-                intr |= NX_NAND_INT_AES_DEC;
-                page_cfg.includeAES = true;
-            }
-            else {
-                page_cfg.includeAES = false;
-            }
+         /* Init page operation */
+         page_cfg.includeOOB = true;
+         intr |= NX_NAND_INT_OOB_READ;
+         page_cfg.operType = tmhwEfmc_PageRead;
+         if(nc->aes) {
+            intr |= NX_NAND_INT_AES_DEC;
+            page_cfg.includeAES = true;
+         }
+         else {
+            page_cfg.includeAES = false;
+         }
 
-            if(nc->hwecc) {
-                intr |= NX_NAND_INT_DEC;
-                page_cfg.includeECC = true;
-            }
-            else {
-                page_cfg.includeECC = false;
-                intr |= NX_NAND_INT_BLK_READ;
-            }
-            tmhwEfmc_IntClear(nc->unitid, intr);
-            tmhwEfmc_IntEnable(nc->unitid, intr);
-            tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
-
-            /* Send the address commands to chip */
-            nc->done = false;
-            /* Send address cycles & command */
-            nx_nand_cmd_addr(nc, 1, NAND_CMD_READ0, 0);
-            addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
-            nx_nand_cmd_addr(nc, 0, addr, 0);
-            addr = (nc->cur_col >> 8) & NX_NAND_SP_ADDR_MASK;
-            nx_nand_cmd_addr(nc, 0, addr, 0);
-            addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
-            nx_nand_cmd_addr(nc, 0, addr, 0);
-            addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+         if(nc->hwecc) {
+            intr |= NX_NAND_INT_DEC;
+            page_cfg.includeECC = true;
+         }
+         else {
+            page_cfg.includeECC = false;
+            intr |= NX_NAND_INT_BLK_READ;
+         }
+         tmhwEfmc_IntClear(nc->unitid, intr);
+         tmhwEfmc_IntEnable(nc->unitid, intr);
+         tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
+
+         /* Send the address commands to chip */
+         nc->done = false;
+         /* Send address cycles & command */
+         nx_nand_cmd_addr(nc, 1, NAND_CMD_READ0, 0);
+         addr = nc->cur_col & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
+         addr = (nc->cur_col >> 8) & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
+         addr = nc->cur_page & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
+         addr = (nc->cur_page >> 8) & NX_NAND_SP_ADDR_MASK;
+         nx_nand_cmd_addr(nc, 0, addr, 0);
+         if (nc->chip.chipsize >= (1 << 28)) {
+            addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
             nx_nand_cmd_addr(nc, 0, addr, 0);
-            if (nc->chip.chipsize >= (1 << 28)) {
-                addr = (nc->cur_page >> 16) & NX_NAND_SP_ADDR_MASK;
-                nx_nand_cmd_addr(nc, 0, addr, 0);
-            }
-            nx_nand_cmd_addr(nc, 1, NAND_CMD_READSTART, 1);
-
-            /* Wait for the completion */ 
-            wait_event(nc->nand_queue, (nc->done != false));
+         }
+         nx_nand_cmd_addr(nc, 1, NAND_CMD_READSTART, 1);
 
-            /* Disable interrupts */
-            tmhwEfmc_IntDisable(nc->unitid, intr);
+         /* Wait for the completion */ 
+         wait_event(nc->nand_queue, (nc->done != false));
 
+         /* Disable interrupts */
+         tmhwEfmc_IntDisable(nc->unitid, intr);
 #endif
-            break;
-
-        case NAND_CMD_READID:
-            page_cfg.includeOOB = false;
-            page_cfg.operType = tmhwEfmc_Nothing;
-            if(nc->aes) {
-                page_cfg.includeAES = true;
-            }
-            else {
-                page_cfg.includeAES = false;
-            }
-
-            if(nc->hwecc) {
-                page_cfg.includeECC = true;
-            }
-            else {
-                page_cfg.includeECC = false;
-            }
-            tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);  
-
-            nx_nand_cmd_addr(nc, 1, cmd, 0);
-            nx_nand_cmd_addr(nc, 0, column, 1);
-            break;
-
-        case NAND_CMD_PARAM:
-            nc->offset = 0;
-
-            page_cfg.includeOOB = false;
-            page_cfg.operType = tmhwEfmc_Nothing;
-            page_cfg.includeAES = false;
-            page_cfg.includeECC = false;
-
-            tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);
-
-            nx_nand_cmd_addr(nc, 1, cmd, 0);
-            nx_nand_cmd_addr(nc, 0, 0, 1);
-
-            /* Read PARAM Page and 2 Redundant Parameter Pages */
-            for (i=0; i < (3 * sizeof(struct nand_onfi_params)); i++)
-            {
-                nc->dmabuf[i]=nx_nand_read_byte(mtd);
-            }
-            break;
-
-        default:
-            printk(KERN_ERR "nxnand: command not supported %d \n", cmd);
-    }
+         break;
+
+      case NAND_CMD_READID:
+         /* No page operation */
+         page_cfg.includeOOB = false;
+         page_cfg.operType = tmhwEfmc_Nothing;
+         page_cfg.includeAES = false;
+         page_cfg.includeECC = false;
+         tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);
+
+         nx_nand_cmd_addr(nc, 1, cmd, 0);
+         nx_nand_cmd_addr(nc, 0, column, 1);
+         break;
+
+      case NAND_CMD_PARAM:
+         nc->offset = 0;
+
+         /* No page operation */
+         page_cfg.includeOOB = false;
+         page_cfg.operType = tmhwEfmc_Nothing;
+         page_cfg.includeAES = false;
+         page_cfg.includeECC = false;
+         tmhwEfmc_InitPageOp(nc->unitid, &page_cfg);
+
+         nx_nand_cmd_addr(nc, 1, cmd, 0);
+         nx_nand_cmd_addr(nc, 0, 0, 1);
+
+         /* Read PARAM Page and 2 Redundant Parameter Pages */
+         for (i=0; i < (3 * sizeof(struct nand_onfi_params)); i++) {
+            nc->dmabuf[i]=nx_nand_read_byte(mtd);
+         }
+         break;
+
+      default:
+      printk(KERN_ERR "nxnand: command not supported %d \n", cmd);
+   }
 }
 
 /**
@@ -1922,46 +1797,47 @@ static void nx_nand_command_lp(struct mt
  *
  * Check, if the block is bad.
  */
-static int nx_nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip ATTRIBUTE_UNUSED)
+static int nx_nand_block_bad(struct mtd_info *mtd, loff_t ofs, 
+   int getchip ATTRIBUTE_UNUSED)
 {
-    struct mtd_oob_ops ops;
-    uint8_t  buf[NAND_MAX_OOBSIZE];
-    int ret;
-    u8 bad;
-    int res = 0;
-    struct nand_chip *chip = mtd->priv;
-
-    printk(KERN_INFO "Bad block check 0x%x \r\n", (int)ofs);
-
-    mtd->flags |= MTD_USE_DEV_OOB_LAYOUT;
-
-    /* Read OOB data */
-    ops.ooblen = mtd->oobsize;
-    ops.oobbuf = buf;
-    ops.ooboffs = 0;
-    ops.datbuf = NULL;
-    ops.mode = MTD_OOB_PLACE;
-    ret = mtd->read_oob(mtd, ofs, &ops);
-    if (ret) {
-        printk(KERN_INFO "READOOB failed 0x%x \r\n", ret);
-        return ret;
-    }
-    mtd->flags &= ~MTD_USE_DEV_OOB_LAYOUT;
-
-    /* Check the bad block marker */ 
-    bad = buf[chip->badblockpos];
-    if (bad != 0xff) {
-        res = 1;
-    }
+   struct mtd_oob_ops ops;
+   uint8_t  buf[NAND_MAX_OOBSIZE];
+   int ret;
+   u8 bad;
+   int res = 0;
+   struct nand_chip *chip = mtd->priv;
+
+   printk(KERN_INFO "Bad block check 0x%x \r\n", (int)ofs);
+
+   mtd->flags |= MTD_USE_DEV_OOB_LAYOUT;
+
+   /* Read OOB data */
+   ops.ooblen = mtd->oobsize;
+   ops.oobbuf = buf;
+   ops.ooboffs = 0;
+   ops.datbuf = NULL;
+   ops.mode = MTD_OOB_PLACE;
+   ret = mtd->read_oob(mtd, ofs, &ops);
+   if (ret) {
+      printk(KERN_INFO "READOOB failed 0x%x \r\n", ret);
+      return ret;
+   }
+   mtd->flags &= ~MTD_USE_DEV_OOB_LAYOUT;
+
+   /* Check the bad block marker */ 
+   bad = buf[chip->badblockpos];
+   if (bad != 0xff) {
+      res = 1;
+   }
 
-    printk(KERN_INFO "Bad block res 0x%x \r\n", res);
+   printk(KERN_INFO "Bad block res 0x%x \r\n", res);
 
-    return res;
+   return res;
 }
 
-/*------------------------------------------------------------------------------------
+/*----------------------------------------------------------------------------
  * Partitions scan functions 
- --------------------------------------------------------------------------------------*/
+------------------------------------------------------------------------------*/
 /**
  * nx_nand_scan_partitions - Partition creation function
  * @mtd: MTD information structure
@@ -1970,30 +1846,28 @@ static int nx_nand_block_bad(struct mtd_
  */
 static void nx_nand_scan_partitions(struct mtd_info *mtd)
 {
-    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
-    struct mtd_partition *parts = NULL;
-    int res;
-
-    res = parse_mtd_partitions(mtd, part_probes, &parts, 0);
-    if (res <= 0) {
-        if(nc->lb_chip) { 
-            parts = partition_info2;
-            res = ARRAY_SIZE(partition_info2);
-        }
-        else {
-            parts = partition_info1;
-            res = ARRAY_SIZE(partition_info1);
-        }
-    } else {
-        nc->partinfo = parts;
-    }
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
+   struct mtd_partition *parts = NULL;
+   int res;
+
+   res = parse_mtd_partitions(mtd, part_probes, &parts, 0);
+   if (res <= 0) {
+      if(nc->lb_chip) { 
+         parts = partition_info2;
+         res = ARRAY_SIZE(partition_info2);
+      }
+      else {
+         parts = partition_info1;
+         res = ARRAY_SIZE(partition_info1);
+      }
+   } 
+   else {
+      nc->partinfo = parts;
+   }
 
-    add_mtd_partitions(mtd, parts, res);
+   add_mtd_partitions(mtd, parts, res);
 }
 
-extern void mtd_blktrans_stop(void);
-extern int mtd_blktrans_restart(void);
-
 /**
  * nx_nand_repartition - Repatition function
  * @mtd: MTD information structure
@@ -2002,25 +1876,19 @@ extern int mtd_blktrans_restart(void);
  */
 static int nx_nand_repartition(struct mtd_info *mtd)
 {
-    struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
-
-    /* Hack alert: sysfs is unfixable broken in this kernel !! */
-    //mtd_blktrans_stop();
-
-    /* Deregister partitions */
-    del_mtd_partitions(mtd);
+   struct nx_nand_ctrl *nc = container_of(mtd, struct nx_nand_ctrl, mtd);
 
-    /* Hack alert: sysfs is unfixable broken in this kernel !! */
-    //mtd_blktrans_restart();
+   /* Deregister partitions */
+   del_mtd_partitions(mtd);
 
-    /* Free the previous allocated partition array */
-    if (nc->partinfo) {
-        kfree(nc->partinfo);
-        nc->partinfo = NULL;
-    }
+   /* Free the previous allocated partition array */
+   if (nc->partinfo) {
+      kfree(nc->partinfo);
+      nc->partinfo = NULL;
+   }
 
-    nx_nand_scan_partitions(mtd);
-    return 0;
+   nx_nand_scan_partitions(mtd);
+   return 0;
 }
 
 /**
@@ -2032,143 +1900,166 @@ static int nx_nand_repartition(struct mt
  */
 static irqreturn_t nx_nand_ctrl_isr(int irq_no ATTRIBUTE_UNUSED, void *dev_id)
 {
-#ifdef CONFIG_MTD_NX_NAND_DMAC   
-    int i;
-#endif
+   uint32_t int_stat;
+   uint32_t int_ena;
+   struct nx_nand_ctrl  *nc=(struct nx_nand_ctrl *)dev_id;
+
+   /* Read the interrupt status & chan ID */
+   tmhwEfmc_IntGetStatus(nc->unitid, (ptmhwEfmc_IntMask_t) &int_stat);
+   int_ena = readl(nx_nc->ctrl_base + NX_NAND_INT_ENA_OFFSET);
 
-    uint32_t int_stat;
-    uint32_t int_ena;
-    struct nx_nand_ctrl  *nc=(struct nx_nand_ctrl *)dev_id;
-
-    /* Read the interrupt status & chan ID */
-    tmhwEfmc_IntGetStatus(nc->unitid, (ptmhwEfmc_IntMask_t) &int_stat);
-    int_ena = readl(nx_nc->ctrl_base + NX_NAND_INT_ENA_OFFSET);
-
-#ifdef CONFIG_MTD_NX_NAND_DMAC   
-    /* Clear the interrupt */
-    tmhwEfmc_IntClear(nc->unitid, int_stat);
-
-    if(nc->cur_cmd == NAND_CMD_READ0) {
-        if(nc->hwecc) {
-            for(i=0; i < nc->num_blks; i++)  {
-                nc->ecc_status[i] = (int_stat & (NX_NAND_INT_DEC_UNCOR | 
-                            NX_NAND_INT_DEC_0_ERR | 
-                            NX_NAND_INT_DEC_1_ERR |
-                            NX_NAND_INT_DEC_2_ERR |
-                            NX_NAND_INT_DEC_3_ERR |
-                            NX_NAND_INT_DEC_4_ERR |
-                            NX_NAND_INT_DEC_5_ERR));
-            }
-        }
-
-        if((int_stat & NX_NAND_INT_SEQ_READ) && (int_ena & NX_NAND_INT_SEQ_READ)) {
-            nc->done = true; 
-            wake_up(&nc->nand_queue); 
-        }
-    }
-
-    if(nc->cur_cmd == NAND_CMD_SEQIN) {
-        if((int_stat & NX_NAND_INT_SEQ_WRITE) && (int_ena & NX_NAND_INT_SEQ_WRITE)) {
-            tmhwEfmc_IntClear(nc->unitid, NX_NAND_INT_SEQ_WRITE);
-        }
-
-        if((int_stat & (1 << (NX_NAND_INT_READY_START + nc->slotid))) && (int_ena & (1 << (NX_NAND_INT_READY_START + nc->slotid)))) {
-            tmhwEfmc_IntClear(nc->unitid, (1 << (NX_NAND_INT_READY_START + nc->slotid)));
-            nc->done = true;
-            wake_up(&nc->nand_queue);
-        }
-    }
-
-    /* Erase command */
-    if(nc->cur_cmd == NAND_CMD_ERASE1) {
-        if((int_stat & (1 << (NX_NAND_INT_READY_START + nc->slotid))) && (int_ena & (1 << (NX_NAND_INT_READY_START + nc->slotid)))) {
-            tmhwEfmc_IntClear(nc->unitid, (1 << (NX_NAND_INT_READY_START + nc->slotid)));
-            nc->done = true;
-            wake_up(&nc->nand_queue);
-        }
-    }
+#ifdef CONFIG_MTD_NX_NAND_DMAC
+   /* Clear the interrupt */
+   tmhwEfmc_IntClear(nc->unitid, int_stat);
 
+   if(nc->cur_cmd == NAND_CMD_READ0) {
+#if defined (CONFIG_ARCH_APOLLO)
+      if(nc->hwecc) {
+         int i;
+         for(i=0; i < nc->num_blks; i++)  {
+            nc->ecc_status[i] = (int_stat & (NX_NAND_INT_DEC_UNCOR | 
+                                             NX_NAND_INT_DEC_0_ERR | 
+                                             NX_NAND_INT_DEC_1_ERR |
+                                             NX_NAND_INT_DEC_2_ERR |
+                                             NX_NAND_INT_DEC_3_ERR |
+                                             NX_NAND_INT_DEC_4_ERR |
+                                             NX_NAND_INT_DEC_5_ERR));
+         }
+      }
+#endif
+
+      if((int_stat & NX_NAND_INT_SEQ_READ) && 
+         (int_ena & NX_NAND_INT_SEQ_READ)) {
+#if defined (CONFIG_ARCH_KRONOS)
+         tmhwEfmc_GetPageRWStatusFifo(nc->unitid, &nc->page_rw_status_fifo);
+#endif
+         nc->done = true; 
+         wake_up(&nc->nand_queue); 
+      }
+   }
+
+   if(nc->cur_cmd == NAND_CMD_SEQIN) {
+      if((int_stat & NX_NAND_INT_SEQ_WRITE) && 
+         (int_ena & NX_NAND_INT_SEQ_WRITE)) {
+         tmhwEfmc_IntClear(nc->unitid, NX_NAND_INT_SEQ_WRITE);
+      }
+
+      if((int_stat & (1 << (NX_NAND_INT_READY_START + nc->slotid))) && 
+         (int_ena & (1 << (NX_NAND_INT_READY_START + nc->slotid)))) {
+         tmhwEfmc_IntClear(nc->unitid, 
+            (1 << (NX_NAND_INT_READY_START + nc->slotid)));
+#if defined (CONFIG_ARCH_KRONOS)
+         tmhwEfmc_GetPageRWStatusFifo(nc->unitid, &nc->page_rw_status_fifo);
+#endif
+         nc->done = true;
+         wake_up(&nc->nand_queue);
+      }
+   }
+
+   /* Erase command */
+   if(nc->cur_cmd == NAND_CMD_ERASE1) {
+      if((int_stat & (1 << (NX_NAND_INT_READY_START + nc->slotid))) && 
+         (int_ena & (1 << (NX_NAND_INT_READY_START + nc->slotid)))) {
+         tmhwEfmc_IntClear(nc->unitid, 
+            (1 << (NX_NAND_INT_READY_START + nc->slotid)));
+         nc->done = true;
+         wake_up(&nc->nand_queue);
+      }
+   }
 #else
-
-    /* Write command */
-    if((nc->cur_cmd == NAND_CMD_SEQIN) || (nc->cur_cmd == NAND_CMD_PAGEPROG)) {
-        if((int_stat & NX_NAND_INT_OOB_WRITE) && (int_ena & NX_NAND_INT_OOB_WRITE)) {
-            tmhwEfmc_WriteOobData(nc->unitid, nc->slotid, nc->dmabuf+nc->mtd.writesize);
+   /* Write command */
+   if((nc->cur_cmd == NAND_CMD_SEQIN) || (nc->cur_cmd == NAND_CMD_PAGEPROG)) {
+      if((int_stat & NX_NAND_INT_OOB_WRITE) && 
+         (int_ena & NX_NAND_INT_OOB_WRITE)) {
+         tmhwEfmc_WriteOobData(nc->unitid, nc->slotid, 
+            nc->dmabuf+nc->mtd.writesize);
+         tmhwEfmc_IntClear(nc->unitid, int_stat);
+      }
+
+      if(nc->hwecc) {
+         if((int_stat & NX_NAND_INT_ENC) && (int_ena & NX_NAND_INT_ENC)) {
+            tmhwEfmc_WriteBufData(nc->unitid, nc->slotid, 
+               nc->dmabuf+(nc->blk_index*nc->blk_size));
+            nc->blk_index++;
             tmhwEfmc_IntClear(nc->unitid, int_stat);
-        }
-
-        if(nc->hwecc) {
-            if((int_stat & NX_NAND_INT_ENC) && (int_ena & NX_NAND_INT_ENC)) {
-                tmhwEfmc_WriteBufData(nc->unitid, nc->slotid, nc->dmabuf+(nc->blk_index*NX_NAND_BLK_SIZE));
-                nc->blk_index++;
-                tmhwEfmc_IntClear(nc->unitid, int_stat);
-            }
-        }
-        else {
-            if((int_stat & NX_NAND_INT_BLK_WRITE) && (int_ena & NX_NAND_INT_BLK_WRITE)){
-                tmhwEfmc_WriteBufData(nc->unitid, nc->slotid, nc->dmabuf + (nc->blk_index*NX_NAND_BLK_SIZE));
-                nc->blk_index++;
-                tmhwEfmc_IntClear(nc->unitid, int_stat);
-            }
-        }
-
-        if((int_stat & NX_NAND_INT_SEQ_WRITE) && (int_ena & NX_NAND_INT_SEQ_WRITE)) {
+         }
+      }
+      else {
+         if((int_stat & NX_NAND_INT_BLK_WRITE) && 
+            (int_ena & NX_NAND_INT_BLK_WRITE)){
+            tmhwEfmc_WriteBufData(nc->unitid, 
+               nc->slotid, nc->dmabuf + (nc->blk_index*nc->blk_size));
+            nc->blk_index++;
             tmhwEfmc_IntClear(nc->unitid, int_stat);
-        }
+         }
+      }
 
-        if((int_stat & (1 << (NX_NAND_INT_READY_START + nc->slotid))) && (int_ena & (1 << (NX_NAND_INT_READY_START + nc->slotid)))) {
+      if((int_stat & NX_NAND_INT_SEQ_WRITE) && 
+         (int_ena & NX_NAND_INT_SEQ_WRITE)) {
+         tmhwEfmc_IntClear(nc->unitid, int_stat);
+      }
+
+      if((int_stat & (1 << (NX_NAND_INT_READY_START + nc->slotid))) && 
+         (int_ena & (1 << (NX_NAND_INT_READY_START + nc->slotid)))) {
+         tmhwEfmc_IntClear(nc->unitid, int_stat);
+         nc->done = true;
+         wake_up(&nc->nand_queue);
+      }
+   }
+
+   /* Read command */
+   if((nc->cur_cmd == NAND_CMD_READ0) || (nc->cur_cmd == NAND_CMD_READOOB)) {
+      if((int_stat & NX_NAND_INT_OOB_READ) && 
+         (int_ena & NX_NAND_INT_OOB_READ)) {
+         tmhwEfmc_ReadOobData(nc->unitid, nc->slotid, 
+            nc->dmabuf+nc->mtd.writesize);
+         tmhwEfmc_IntClear(nc->unitid, int_stat);
+         nc->done = true;
+         wake_up(&nc->nand_queue);
+      }
+
+      if(nc->hwecc) {
+         if((int_stat & NX_NAND_INT_DEC) && (int_ena & NX_NAND_INT_DEC)) {
+            tmhwEfmc_ReadBufData(nc->unitid, nc->slotid, 
+               nc->dmabuf+(nc->blk_index * nc->blk_size));
+            nc->ecc_status[nc->blk_index] = (int_stat & (NX_NAND_INT_DEC_UNCOR | 
+                                                         NX_NAND_INT_DEC_0_ERR | 
+                                                         NX_NAND_INT_DEC_1_ERR |
+                                                         NX_NAND_INT_DEC_2_ERR |
+                                                         NX_NAND_INT_DEC_3_ERR |
+                                                         NX_NAND_INT_DEC_4_ERR |
+                                                         NX_NAND_INT_DEC_5_ERR));
+            nc->blk_index++;
             tmhwEfmc_IntClear(nc->unitid, int_stat);
-            nc->done = true;
-            wake_up(&nc->nand_queue);
-        }
-    }
-
-    /* Read command */
-    if((nc->cur_cmd == NAND_CMD_READ0) || (nc->cur_cmd == NAND_CMD_READOOB)) {
-        if((int_stat & NX_NAND_INT_OOB_READ) && (int_ena & NX_NAND_INT_OOB_READ)) {
-            tmhwEfmc_ReadOobData(nc->unitid, nc->slotid, nc->dmabuf+nc->mtd.writesize);
+         }
+      }
+      else {
+         if((int_stat & NX_NAND_INT_BLK_READ) && 
+            (int_ena & NX_NAND_INT_BLK_READ)) {
+            tmhwEfmc_ReadBufData(nc->unitid, nc->slotid, 
+               nc->dmabuf+(nc->blk_index * nc->blk_size));
+            nc->blk_index++;
             tmhwEfmc_IntClear(nc->unitid, int_stat);
-            nc->done = true;
-            wake_up(&nc->nand_queue);
-        }
-
-        if(nc->hwecc) {
-            if((int_stat & NX_NAND_INT_DEC) && (int_ena & NX_NAND_INT_DEC)) {
-                tmhwEfmc_ReadBufData(nc->unitid, nc->slotid, nc->dmabuf+(nc->blk_index * NX_NAND_BLK_SIZE));
-                nc->ecc_status[nc->blk_index] = (int_stat & (NX_NAND_INT_DEC_UNCOR | 
-                            NX_NAND_INT_DEC_0_ERR | 
-                            NX_NAND_INT_DEC_1_ERR |
-                            NX_NAND_INT_DEC_2_ERR |
-                            NX_NAND_INT_DEC_3_ERR |
-                            NX_NAND_INT_DEC_4_ERR |
-                            NX_NAND_INT_DEC_5_ERR));
-                nc->blk_index++;
-                tmhwEfmc_IntClear(nc->unitid, int_stat);
-            }
-        }
-        else {
-            if((int_stat & NX_NAND_INT_BLK_READ) && (int_ena & NX_NAND_INT_BLK_READ)) {
-                tmhwEfmc_ReadBufData(nc->unitid, nc->slotid, nc->dmabuf+(nc->blk_index * NX_NAND_BLK_SIZE));
-                nc->blk_index++;
-                tmhwEfmc_IntClear(nc->unitid, int_stat);
-            }
-        }
+         }
+      }
 
-        if((int_stat & NX_NAND_INT_SEQ_READ) && (int_ena & NX_NAND_INT_SEQ_READ) ){
-            tmhwEfmc_IntClear(nc->unitid, int_stat);
-        }
-    }
-
-    /* Erase command */
-    if(nc->cur_cmd == NAND_CMD_ERASE1) {
-        if((int_stat & (1 << (NX_NAND_INT_READY_START + nc->slotid))) && (int_ena & (1 << (NX_NAND_INT_READY_START + nc->slotid)))) {
-            tmhwEfmc_IntClear(nc->unitid, int_stat);
-            nc->done = true;
-            wake_up(&nc->nand_queue);
-        }
-    }
-#endif   
-    return IRQ_HANDLED;
+      if((int_stat & NX_NAND_INT_SEQ_READ) && 
+         (int_ena & NX_NAND_INT_SEQ_READ) ) {
+         tmhwEfmc_IntClear(nc->unitid, int_stat);
+      }
+   }
+
+   /* Erase command */
+   if(nc->cur_cmd == NAND_CMD_ERASE1) {
+      if((int_stat & (1 << (NX_NAND_INT_READY_START + nc->slotid))) && 
+         (int_ena & (1 << (NX_NAND_INT_READY_START + nc->slotid)))) {
+         tmhwEfmc_IntClear(nc->unitid, int_stat);
+         nc->done = true;
+         wake_up(&nc->nand_queue);
+      }
+   }
+#endif
+   return IRQ_HANDLED;
 }
 
 /**
@@ -2179,238 +2070,309 @@ static irqreturn_t nx_nand_ctrl_isr(int 
  */
 static int nx_nand_probe(struct platform_device *pdev)
 {
-    struct resource *res1, *res2;
-    struct nand_chip *chip;
-    struct mtd_info *mtd;
-    tmhwEfmc_Capabilities_t pcaps;
-    tmhwEfmc_FlashConfig_t  pconfig;
-    int ret=0;  
-
-    /* Allocate memory for nand control structure */
-    nx_nc = kzalloc(sizeof(struct nx_nand_ctrl), GFP_KERNEL);
-    if (!nx_nc) {
-        printk(KERN_ERR "nx_nand: NAND ctrl mem alloc \r\n");
-        return -ENOMEM;
-    }
-
-    /* Unit ID */
-    nx_nc->unitid = 0;
-
-    /* Get I/O resource */
-    res1 = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-    if (!res1) {
-        printk(KERN_ERR "nx_nand: NAND get resource \r\n");   
-        ret = -ENXIO;
-        goto out_free1;
-    }
-
-    /* Ioremap controller base */
-    nx_nc->ctrl_base = devm_ioremap(&pdev->dev, res1->start, (res1->end-res1->start+1));
-    if (!nx_nc->ctrl_base) {
-        printk(KERN_ERR "nx_nand: NAND base devm_iormep \r\n");  
-        ret = -ENOMEM;
-        goto out_free1;
-    }
-
-    /* Get interrupt resource */
-    res2 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-    if (!res2) {
-        printk(KERN_ERR "nx_nand: NAND get resource \r\n");   
-        ret = -ENXIO;
-        goto out_free1;
-    }
-
-    /* Alloc IRQ */
-    ret = devm_request_irq (&pdev->dev, res2->start, 
-            nx_nand_ctrl_isr, IRQF_DISABLED, "nx_2070", nx_nc);
-    if (ret < 0){
-        printk(KERN_ERR "nx_nand: NAND irq alloc \r\n");   
-        goto out_free1;
-    }
+   int                     ret=0;
+   struct resource         *res1, *res2;
+   struct nand_chip        *chip;
+   struct mtd_info         *mtd;
+   tmhwEfmc_Capabilities_t pcaps;
+   tmhwEfmc_FlashConfig_t  pconfig;
+#if defined (CONFIG_ARCH_KRONOS)
+   tmhwEfmc_ModeCtrl_t     pModeCtrl;
+   tmhwEfmc_FlashConfig_t  FlashConfig;
+   tmhwEfmc_OobInfo_t      pOobInfo;
+#endif
+
+   /* Allocate memory for nand control structure */
+   nx_nc = kzalloc(sizeof(struct nx_nand_ctrl), GFP_KERNEL);
+   if (!nx_nc) {
+      printk(KERN_ERR "nx_nand: NAND ctrl mem alloc \r\n");
+      return -ENOMEM;
+   }
+
+   /* Unit ID */
+   nx_nc->unitid = 0;
+
+   /* Get I/O resource */
+   res1 = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+   if (!res1) {
+      printk(KERN_ERR "nx_nand: NAND get resource \r\n");   
+      ret = -ENXIO;
+      goto out_free1;
+   }
+
+   /* Ioremap controller base */
+   nx_nc->ctrl_base = devm_ioremap(&pdev->dev, res1->start, 
+      (res1->end-res1->start+1));
+   if (!nx_nc->ctrl_base) {
+      printk(KERN_ERR "nx_nand: NAND base devm_iormep \r\n");  
+      ret = -ENOMEM;
+      goto out_free1;
+   }
+
+   /* Get interrupt resource */
+   res2 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+   if (!res2) {
+      printk(KERN_ERR "nx_nand: NAND get resource \r\n");   
+      ret = -ENXIO;
+      goto out_free1;
+   }
+
+   /* Alloc IRQ */
+   ret = devm_request_irq (&pdev->dev, res2->start, 
+      nx_nand_ctrl_isr, IRQF_DISABLED, "nx_2070", nx_nc);
+   if (ret < 0){
+      printk(KERN_ERR "nx_nand: NAND irq alloc \r\n");   
+      goto out_free1;
+   }
 
 #ifndef CONFIG_MTD_NX_NAND_DMAC
-    /* Ioremap AHB buffer for interrupt flow control */
-    nx_nc->ahb_buf = devm_ioremap(&pdev->dev, NX_NAND_AHB_BUF, NX_NAND_AHB_BUF_MAX_SIZE);
-    if (!nx_nc->ahb_buf) {
-        goto out_free1;
-    }
-#endif
-
-    /* Store in dev structure */
-    dev_set_drvdata(&pdev->dev, nx_nc);
-
-    /* Store in HwAPI config */
-    gktmhwEfmc_Config[nx_nc->unitid].baseAddress = (uint32_t) nx_nc->ctrl_base;
-    gktmhwEfmc_Config[nx_nc->unitid].ahbMemAddress = (uint8_t *)nx_nc->ahb_buf;
-
-    /* Init wait queue */
-    init_waitqueue_head(&nx_nc->nand_queue);
-
-    /* Read the control configuration & store */
-    ret = tmhwEfmc_GetCapabilities(nx_nc->unitid, &pcaps);
-    nx_nc->aes = pcaps.supportAES;
-    nx_nc->slots = pcaps.maxDevices;
-    nx_nc->slotid = 0;
-
-    /* Flash configuration */
-    ret = tmhwEfmc_GetFlashConfig(nx_nc->unitid, nx_nc->slotid, &pconfig);
-
-    /* Initialise the lbchip flag to false */
-    nx_nc->cedontcare = pconfig.enableCENDontCare; /* CE don;t care support */
-    nx_nc->lb_chip = 0;
-    mtd = &nx_nc->mtd;
-    mtd->owner = THIS_MODULE;
-    /* mtd->name = "nx_2017"; This has to come from the platform driver*/
-    mtd->name = pdev->name;
-    chip = &nx_nc->chip;
-    mtd->priv = chip;
-
-    /* Initialize hardware controller structure */
-    spin_lock_init(&nx_nc->nandctrl.lock);
-    init_waitqueue_head(&nx_nc->nandctrl.wq);
-    chip->controller = &nx_nc->nandctrl;
-
-    /* Store reference to the nx_nand structure */
-    chip->priv = nx_nc;
-
-    /* Chip Information */
-    chip->chip_delay = 0;
-    chip->options = NAND_NO_AUTOINCR | NAND_ALLOW_CLEAR_BBT |
-        NAND_NO_SUBPAGE_WRITE;
-    chip->select_chip = nx_nand_select_chip;
-    chip->dev_ready = nx_nand_dev_ready;
-    if (pconfig.dataWidth) {
-        chip->options |= NAND_BUSWIDTH_16;
-        chip->read_byte = nx_nand_read_byte16;
-    } else {
-        chip->read_byte = nx_nand_read_byte;
-    }
-
-    chip->cmdfunc = nx_nand_command;
-    chip->ecc.read_page_raw = nx_nand_read_page_raw;
-    chip->ecc.write_page_raw = nx_nand_write_page_raw;
-    chip->ecc.read_oob = nx_nand_read_oob;
-    chip->ecc.write_oob = nx_nand_write_oob;
-    chip->read_buf = nx_nand_read_buf;
-    chip->write_buf = nx_nand_write_buf;
-    chip->block_bad = nx_nand_block_bad;
+   /* Ioremap AHB buffer for interrupt flow control */
+   nx_nc->ahb_buf = devm_ioremap(&pdev->dev, NX_NAND_AHB_BUF, 
+      NX_NAND_AHB_BUF_MAX_SIZE);
+   if (!nx_nc->ahb_buf) {
+      goto out_free1;
+   }
+#endif
+
+   /* Store in dev structure */
+   dev_set_drvdata(&pdev->dev, nx_nc);
+
+   /* Store in HwAPI config */
+   gktmhwEfmc_Config[nx_nc->unitid].baseAddress = (uint32_t) nx_nc->ctrl_base;
+   gktmhwEfmc_Config[nx_nc->unitid].ahbMemAddress = (uint8_t *)nx_nc->ahb_buf;
+
+   /* Init wait queue */
+   init_waitqueue_head(&nx_nc->nand_queue);
+
+   /* Read the control configuration & store */
+   ret = tmhwEfmc_GetCapabilities(nx_nc->unitid, &pcaps);
+   nx_nc->aes = pcaps.supportAES;
+   nx_nc->slots = pcaps.maxDevices;
+   nx_nc->slotid = 0;
+   nx_nc->blk_size = 512; /* default block size */
+   nx_nc->lb_chip = 0;    /* initialise the lbchip flag to false */
+
+   /* Flash configuration -- REVISIT */
+   ret = tmhwEfmc_GetFlashConfig(nx_nc->unitid, nx_nc->slotid, &pconfig);
+#if defined (CONFIG_ARCH_KRONOS)
+   pModeCtrl.rb_n_bypass = TM_FALSE;
+   pModeCtrl.rd_stall = TM_TRUE;
+   ret = tmhwEfmc_SetModeCtrl(nx_nc->unitid, &pModeCtrl);
+   ret = tmhwEfmc_GetOobInfo(nx_nc->unitid, nx_nc->slotid, &pOobInfo);
+#endif
+
+   /* CE don;t care support */
+   nx_nc->cedontcare = pconfig.enableCENDontCare; 
+
+   mtd = &nx_nc->mtd;
+   mtd->owner = THIS_MODULE;
+   /* mtd->name = "nx_2017"; This has to come from the platform driver*/
+   mtd->name = pdev->name;
+   chip = &nx_nc->chip;
+   mtd->priv = chip;
+
+   /* Initialize hardware controller structure */
+   spin_lock_init(&nx_nc->nandctrl.lock);
+   init_waitqueue_head(&nx_nc->nandctrl.wq);
+   chip->controller = &nx_nc->nandctrl;
+
+   /* Store reference to the nx_nand structure */
+   chip->priv = nx_nc;
+
+   /* Chip Information */
+   chip->chip_delay = 0;
+   chip->options = NAND_NO_AUTOINCR | NAND_ALLOW_CLEAR_BBT |
+                     NAND_NO_SUBPAGE_WRITE;
+   chip->select_chip = nx_nand_select_chip;
+   chip->dev_ready = nx_nand_dev_ready;
+
+   if (pconfig.dataWidth) {
+      chip->options |= NAND_BUSWIDTH_16;
+      chip->read_byte = nx_nand_read_byte16;
+   } else {
+      chip->read_byte = nx_nand_read_byte;
+   }
+
+   chip->cmdfunc = nx_nand_command;
+   chip->read_buf = nx_nand_read_buf;
+   chip->write_buf = nx_nand_write_buf;
+   chip->block_bad = nx_nand_block_bad;
+
+   /* Allocate temp driver buffer for ONFI PARAM page read */
+   nx_nc->dmabuf = dmam_alloc_coherent(&pdev->dev,
+                                       1024, 
+                                       &nx_nc->dmabuf_phy, 
+                                       GFP_DMA | GFP_KERNEL);
+   if(!nx_nc->dmabuf) {
+      printk(KERN_ERR "nx_nand: DMA buf alloc \r\n");
+      ret = -ENOMEM;
+      goto out_free1;
+   }
+
+   /* Call chip identify function */
+   if(nand_scan_ident(mtd, 1, NULL)) {
+      printk(KERN_ERR "nx_nand: NAND scan ident \r\n");  
+      ret = -ENXIO;
+      goto out_free1;
+   }
+
+   /* Free temp driver buffer */
+   dmam_free_coherent(&pdev->dev,
+      1024,
+      nx_nc->dmabuf,
+      nx_nc->dmabuf_phy);
+
+#if defined (CONFIG_ARCH_KRONOS)
+   memset(&FlashConfig, 0, sizeof(FlashConfig));
+
+   FlashConfig.dataWidth = pconfig.dataWidth; /* REVISIT */
+   FlashConfig.enableCENDontCare = pconfig.enableCENDontCare;
+   FlashConfig.enableWrProtect = pconfig.enableWrProtect;
+   switch (mtd->writesize >> 9) {
+      case 1:
+         FlashConfig.pageSize = tmhwEfmc_512Byte;
+         FlashConfig.subpageSize = tmhwEfmc_SubPage512Byte;
+         break;
+      case 2:
+         FlashConfig.pageSize = tmhwEfmc_1024Byte;
+         FlashConfig.subpageSize = tmhwEfmc_SubPage1024Byte;
+         break;
+      case 4:
+         FlashConfig.pageSize = tmhwEfmc_2048Byte;
+         FlashConfig.subpageSize = tmhwEfmc_SubPage1024Byte;
+         break;
+      case 8:
+         FlashConfig.pageSize = tmhwEfmc_4096Byte;
+         FlashConfig.subpageSize = tmhwEfmc_SubPage1024Byte;
+         break;
+      case 16:
+         FlashConfig.pageSize = tmhwEfmc_8192Byte;
+         FlashConfig.subpageSize = tmhwEfmc_SubPage1024Byte;
+         break;
+      default:
+         BUG();
+   }
+   FlashConfig.oobSize =  mtd->oobsize;
+   FlashConfig.eccLevel = 4; /* REVISIT */
+   FlashConfig.erasedPageThres = FlashConfig.eccLevel/2;
+   memset(&FlashConfig.devTiming, 0xF, sizeof(FlashConfig.devTiming));
+
+   tmhwEfmc_SetFlashConfig(nx_nc->unitid,nx_nc->slotid, &FlashConfig);
+
+   nx_nc->blk_size = FlashConfig.subpageSize;
+#endif
+
+   /* Calculate number of 512 or 1024 byte blocks in a page */
+   nx_nc->num_blks = mtd->writesize/nx_nc->blk_size;
+
+#if defined (CONFIG_ARCH_APOLLO)
+   /* Allocate ECC status array */
+   nx_nc->ecc_status = kzalloc(sizeof(int) * nx_nc->num_blks, GFP_KERNEL);
+   if(!nx_nc->ecc_status) {
+      printk(KERN_ERR "nx_nand: ECC status alloc \r\n");
+      ret = -ENOMEM;
+      goto out_free1;
+   }
+#endif
+
+   /* Allocate internal driver buffer */
+   nx_nc->dmabuf = dmam_alloc_coherent(&pdev->dev,
+   mtd->writesize + mtd->oobsize, 
+   &nx_nc->dmabuf_phy, GFP_DMA | GFP_KERNEL);
+   if(!nx_nc->dmabuf) {
+      printk(KERN_ERR "nx_nand: DMA buf alloc \r\n");
+      ret = -ENOMEM;
+      goto out_free1;
+   }
+
+   if(mtd->writesize > 512) {
+      chip->cmdfunc = nx_nand_command_lp;
+      nx_nc->lb_chip = 1;
+   }
+
+   chip->options |= NAND_ALLOW_CLEAR_BBT | NAND_NO_SUBPAGE_WRITE | 
+                     NAND_USE_FLASH_BBT;
+
+   chip->ecc.read_page_raw = nx_nand_read_page_raw;
+   chip->ecc.write_page_raw = nx_nand_write_page_raw;
+   chip->ecc.read_oob = nx_nand_read_oob;
+   chip->ecc.write_oob = nx_nand_write_oob;
 
 #ifdef CONFIG_MTD_NX_NAND_HWECC
-    nx_nc->hwecc = true;
-    chip->ecc.read_page = nx_nand_read_page;
-    chip->ecc.write_page = nx_nand_write_page;
-    chip->ecc.mode = NAND_ECC_HW_SYNDROME;
-    chip->ecc.calculate = nx_nand_calculate_ecc;
-    chip->ecc.correct = nx_nand_correct_data;
-    chip->ecc.hwctl = nx_nand_hwctl;
-    chip->ecc.size = 512;
-    chip->ecc.bytes = 12;
-    chip->bbt_td = &nx_bbt_main;  
-    chip->bbt_md = &nx_bbt_mirror;
+   nx_nc->hwecc = true;
+   chip->ecc.read_page = nx_nand_read_page;
+   chip->ecc.write_page = nx_nand_write_page;
+   chip->ecc.mode = NAND_ECC_HW_SYNDROME;
+   chip->ecc.calculate = nx_nand_calculate_ecc;
+   chip->ecc.correct = nx_nand_correct_data;
+   chip->ecc.hwctl = nx_nand_hwctl;
+   chip->ecc.size = nx_nc->blk_size;
+#if defined (CONFIG_ARCH_KRONOS)
+   /* formula to calculate no. of parity bytes for a given ecc level */
+   chip->ecc.bytes = pOobInfo.parity_bytes; 
+#else
+   chip->ecc.bytes = 12;
+#endif
+   chip->bbt_td = &nx_bbt_main;
+   chip->bbt_md = &nx_bbt_mirror;
 #endif
 
 #ifdef CONFIG_MTD_NX_NAND_SWECC
-    nx_nc->hwecc = false;
-    chip->ecc.mode = NAND_ECC_SOFT;
+   nx_nc->hwecc = false;
+   chip->ecc.mode = NAND_ECC_SOFT;
 #endif
 
 #ifdef CONFIG_MTD_NX_NAND_NONEECC
-    chip->ecc.read_page = nx_nand_read_page_raw;
-    chip->ecc.write_page = nx_nand_write_page_raw;
-    nx_nc->hwecc = false;
-    chip->ecc.mode = NAND_ECC_NONE;
-#endif
-
-    /* Allocate temp driver buffer for ONFI PARAM page read */
-    nx_nc->dmabuf = dmam_alloc_coherent(&pdev->dev,
-            8*NX_NAND_BLK_SIZE, 
-            &nx_nc->dmabuf_phy, GFP_DMA | GFP_KERNEL);
-    if(!nx_nc->dmabuf) {
-        printk(KERN_ERR "nx_nand: DMA buf alloc \r\n");
-        ret = -ENOMEM;
-        goto out_free1;
-    }
-
-    /* Call chip identify function */
-    if(nand_scan_ident(mtd, 1, NULL)) {
-        printk(KERN_ERR "nx_nand: NAND scan ident \r\n");  
-        ret = -ENXIO;
-        goto out_free1;
-    }
-
-    /* Free temp driver buffer */
-    dmam_free_coherent(&pdev->dev,
-            8*NX_NAND_BLK_SIZE,
-            nx_nc->dmabuf,
-            nx_nc->dmabuf_phy);
-
-    /* Calculate number of 512byte blocks in a page */
-    nx_nc->num_blks = mtd->writesize >> 9;
-
-    /* Allocate ECC status array */
-    nx_nc->ecc_status = kzalloc(sizeof(int) * nx_nc->num_blks, GFP_KERNEL);
-    if(!nx_nc->ecc_status) {
-        printk(KERN_ERR "nx_nand: ECC status alloc \r\n");
-        ret = -ENOMEM;
-        goto out_free1;
-    }
-
-    /* Allocate internal driver buffer */
-    nx_nc->dmabuf = dmam_alloc_coherent(&pdev->dev,
-            mtd->writesize + mtd->oobsize, 
-            &nx_nc->dmabuf_phy, GFP_DMA | GFP_KERNEL);
-    if(!nx_nc->dmabuf) {
-        printk(KERN_ERR "nx_nand: DMA buf alloc \r\n");
-        ret = -ENOMEM;
-        goto out_free1;
-    }
-
-    if(mtd->writesize > 512) {
-        chip->cmdfunc = nx_nand_command_lp;
-        nx_nc->lb_chip = 1;
-    }
-
-    chip->options |= NAND_ALLOW_CLEAR_BBT | NAND_NO_SUBPAGE_WRITE | NAND_USE_FLASH_BBT ;
+   chip->ecc.read_page = nx_nand_read_page_raw;
+   chip->ecc.write_page = nx_nand_write_page_raw;
+   nx_nc->hwecc = false;
+   chip->ecc.mode = NAND_ECC_NONE;
+#endif
 
 #ifdef CONFIG_MTD_NX_NAND_HWECC
-    switch (mtd->oobsize) {
-        case 16:
-            chip->ecc.layout = &nx_nand_oob_16;
-            break;
-        case 64:
-            chip->ecc.layout = &nx_nand_oob_64;
-            break;
-        case 128:
-            chip->ecc.layout = &nx_nand_oob_128;
-            break;
-        default:
-            printk(KERN_WARNING "No oob scheme defined for "
-                    "oobsize %d\n", mtd->oobsize);
-            BUG();
-    }
-#endif   
-
-    if(nand_scan_tail(mtd)) {
-        printk(KERN_ERR "nx_nand: NAND scan tail \r\n");   
-        ret = -ENXIO;
-        goto out_free1;
-    }
+#ifdef CONFIG_ARCH_APOLLO
+   switch (mtd->oobsize) {
+      case 16:
+         chip->ecc.layout = &nx_nand_oob_16;
+         break;
+      case 64:
+         chip->ecc.layout = &nx_nand_oob_64;
+         break;
+      case 128:
+         chip->ecc.layout = &nx_nand_oob_128;
+         break;
+      default:
+         printk(KERN_WARNING "No oob scheme defined for "
+            "oobsize %d\n", mtd->oobsize);
+         BUG();
+   }
+#else
+   nx_nand_oob.eccbytes = (pOobInfo.parity_bytes)*(nx_nc->num_blks);
 
-    mtd->repartition = nx_nand_repartition;
+   nx_nand_oob.oobfree[0].offset = 0;
+   nx_nand_oob.oobfree[0].length = (nx_nc->blk_size - (pOobInfo.parity_bytes));
 
-#ifdef CONFIG_MTD_PERF_MEAS
-    mtd->perf_meas = mtd_perf_meas;
+   chip->ecc.layout = &nx_nand_oob;
+#endif
 #endif
 
-    /* Scan for the partitions */
-    nx_nand_scan_partitions(mtd);
+   if(nand_scan_tail(mtd)) {
+      printk(KERN_ERR "nx_nand: NAND scan tail \r\n");
+      ret = -ENXIO;
+      goto out_free1;
+   }
 
-    return 0;
+   mtd->repartition = nx_nand_repartition;
+
+   /* Scan for the partitions */
+   nx_nand_scan_partitions(mtd);
+
+   return 0;
 
 out_free1:  
-    kfree(nx_nc);
+   kfree(nx_nc);
 
-    return ret;
+   return ret;
 }
 
 /**
@@ -2421,65 +2383,61 @@ out_free1:  
  */
 static int nx_nand_remove(struct platform_device *pdev)
 {
-    struct nx_nand_ctrl *nc = dev_get_drvdata(&pdev->dev);
+struct nx_nand_ctrl *nc = dev_get_drvdata(&pdev->dev);
 
-    /* Release resources */
-    nand_release(&nc->mtd);
+   /* Release resources */
+   nand_release(&nc->mtd);
 
-    /* Free DMA buf */
-    kfree(nc);
+   /* Free DMA buf */
+   kfree(nc);
 
-    return 0;
+   return 0;
 }
 
 #ifdef CONFIG_PM
-
 static int nx_nand_suspend(struct platform_device *pdev, pm_message_t state)
 {
-    struct nx_nand_ctrl *nc = dev_get_drvdata(&pdev->dev);
-    int ret = 0;
-    unsigned long val;
-
-    if (nc)
-    { 
-        if(nc->mtd.suspend)
-            ret = nc->mtd.suspend(&nc->mtd);
-
-        /* Put the controller (IP2017) into power down mode */
-        if(!ret)
-        {
-            val = readl((nc->ctrl_base + NX_NAND_POWER_DOWN_CFG_OFFSET));
-
-            val &= ~NX_NAND_POWER_DOWN_MASK;
-            val |= (NX_NAND_POWER_DOWN_ENABLE & NX_NAND_POWER_DOWN_MASK);
-
-            writel(val, (nc->ctrl_base + NX_NAND_POWER_DOWN_CFG_OFFSET));
-        }
-    }
+   struct nx_nand_ctrl *nc = dev_get_drvdata(&pdev->dev);
+   int ret = 0;
+   unsigned long val;
+
+   if (nc) { 
+      if(nc->mtd.suspend)
+         ret = nc->mtd.suspend(&nc->mtd);
+
+      /* Put the controller (IP2017) into power down mode */
+      if(!ret) {
+         val = readl((nc->ctrl_base + NX_NAND_POWER_DOWN_CFG_OFFSET));
+
+         val &= ~NX_NAND_POWER_DOWN_MASK;
+         val |= (NX_NAND_POWER_DOWN_ENABLE & NX_NAND_POWER_DOWN_MASK);
+
+         writel(val, (nc->ctrl_base + NX_NAND_POWER_DOWN_CFG_OFFSET));
+      }
+   }
 
-    return ret;
+   return ret;
 }
 
 static int nx_nand_resume(struct platform_device *pdev)
 {
-    struct nx_nand_ctrl *nc = dev_get_drvdata(&pdev->dev);
-    unsigned long val;
+   struct nx_nand_ctrl *nc = dev_get_drvdata(&pdev->dev);
+   unsigned long val;
 
-    if (nc)
-    {
-        /* Bring the controller out of power down mode */
-        val = readl((nc->ctrl_base + NX_NAND_POWER_DOWN_CFG_OFFSET));
+   if (nc) {
+      /* Bring the controller out of power down mode */
+      val = readl((nc->ctrl_base + NX_NAND_POWER_DOWN_CFG_OFFSET));
 
-        val &= ~NX_NAND_POWER_DOWN_MASK;
-        val |= (NX_NAND_POWER_DOWN_DISABLE & NX_NAND_POWER_DOWN_MASK);
+      val &= ~NX_NAND_POWER_DOWN_MASK;
+      val |= (NX_NAND_POWER_DOWN_DISABLE & NX_NAND_POWER_DOWN_MASK);
 
-        writel(val, (nc->ctrl_base + NX_NAND_POWER_DOWN_CFG_OFFSET));
+      writel(val, (nc->ctrl_base + NX_NAND_POWER_DOWN_CFG_OFFSET));
 
-        if (nc->mtd.resume)
-            nc->mtd.resume(&nc->mtd);
-    }
+      if (nc->mtd.resume)
+         nc->mtd.resume(&nc->mtd);
+   }
 
-    return 0;
+   return 0;
 }
 #else
 
@@ -2489,17 +2447,17 @@ static int nx_nand_resume(struct platfor
 #endif
 
 /**
- * NAND device registration
- */
+* NAND device registration
+*/
 static struct platform_driver nx_nand_driver = {
-    .probe      = nx_nand_probe,
-    .remove     = nx_nand_remove,
-    .suspend    = nx_nand_suspend,
-    .resume     = nx_nand_resume,
-    .driver     = {
-        .name = "nx_2017",
-        .owner   = THIS_MODULE,
-    },
+   .probe      = nx_nand_probe,
+   .remove     = nx_nand_remove,
+   .suspend    = nx_nand_suspend,
+   .resume     = nx_nand_resume,
+   .driver     = {
+      .name = "nx_2017",
+      .owner   = THIS_MODULE,
+   },
 };
 
 /**
@@ -2509,7 +2467,7 @@ static struct platform_driver nx_nand_dr
  */
 static int __init nx_nand_init(void)
 {
-    return platform_driver_register(&nx_nand_driver);
+   return platform_driver_register(&nx_nand_driver);
 }
 module_init(nx_nand_init);
 
@@ -2521,7 +2479,7 @@ module_init(nx_nand_init);
  */
 static void __exit nx_nand_exit(void)
 {
-    platform_driver_unregister(&nx_nand_driver);
+   platform_driver_unregister(&nx_nand_driver);
 }
 module_exit(nx_nand_exit);
 #endif
diff -Naurp linux-2.6.34_orig/drivers/mtd/nand/nx_nand/nx_nand.h linux-2.6.34/drivers/mtd/nand/nx_nand/nx_nand.h
--- linux-2.6.34_orig/drivers/mtd/nand/nx_nand/nx_nand.h	2011-05-12 17:15:58.517049000 +0530
+++ linux-2.6.34/drivers/mtd/nand/nx_nand/nx_nand.h	2011-05-12 18:24:21.097026000 +0530
@@ -19,11 +19,12 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
  * Revision history
- * Version  	Author           Date          Remarks		
- * 0.0.1		Bangaragiri G			20080318		Draft-Initial version
- * 0.1.0		Bangaragiri G			20080804		Proposal-After self review
- * 0.2.0		Bangaragiri G			20080925		Proposal-After including review comments
- * 1.0.0		Bangaragiri G			20090305		Accepted-After testing on TV550M0 board
+ * Version     Author           Date          Remarks    
+ * 0.0.1    Bangaragiri G        20080318    Draft-Initial version
+ * 0.1.0    Bangaragiri G        20080804    Proposal-After self review
+ * 0.2.0    Bangaragiri G        20080925    Proposal-After including review comments
+ * 1.0.0    Bangaragiri G        20090305    Accepted-After testing on TV550M0 board
+ * 2.0.0    Deven Balani         20110515    Supported Kronos NAND controller
  */
 
 #ifndef _NX_NAND_H
@@ -35,101 +36,120 @@
 #include <linux/mtd/nand.h>
 #include <linux/mtd/partitions.h>
 
-#if defined(CONFIG_MTD_NX_NAND_DMAC) && defined(CONFIG_ARCH_APOLLO)
-	#define NX_NAND_AHB_BUF     (0x40000000) /* DMAC Flow conttrol */
+#if defined(CONFIG_MTD_NX_NAND_DMAC) && (defined(CONFIG_ARCH_APOLLO) || defined(CONFIG_ARCH_KRONOS))
+#define NX_NAND_AHB_BUF     (0x40000000) /* DMAC Flow conttrol */
 #elif defined(CONFIG_MTD_NX_NAND_DMAC) && !defined(CONFIG_ARCH_APOLLO)
-	#define NX_NAND_AHB_BUF 	(0x00000000) /* DMAC Flow conttrol */
+#define NX_NAND_AHB_BUF    (0x00000000) /* DMAC Flow conttrol */
 #else
-	#define NX_NAND_AHB_BUF 	(NX_NAND_AHB_INTFC_BUF) /* Interrupt Flow control */
+#define NX_NAND_AHB_BUF    (NX_NAND_AHB_INTFC_BUF) /* Interrupt Flow control */
 #endif
 
 /**
 * NAND control structure
 */
 struct nx_nand_ctrl {
-  struct mtd_info       mtd;    	    /* MTD information structure */
-  struct nand_chip      chip;     	  /* NAND chip structure */
-	struct nand_hw_control	nandctrl;		/* NAND control lock */
-  uint8_t               *dmabuf;    	/* DMA buffer */
-	dma_addr_t            dmabuf_phy;   /* DMA buffer PHY address */
-  int                   slots;      	/* # of chips */
-  int                   slotid;     	/* current chip number */
-  uint32_t              slotbase;   	/* Chip start address */
-  int                   unitid;       /* Current unit ID of controller */
-  int                   cur_col;    	/* Current column address */
-  int                   cur_page;   	/* Current page address */
-  int                   cur_cmd;   	/* Current page address */
-  int                   lb_chip;   	  /* Large Block chip flag */
-  void __iomem          *ctrl_base; 	/* Controller base address */
-  void __iomem          *ahb_buf;   	/* Controller base address */
-  struct mtd_partition  *partinfo;  	/* partition info structure */
-  bool                  aes;        	/* AES decryption support */
-  bool		              hwecc;     	/* Use HW ECC */
-  uint32_t              aes_key[4]; 	/* AES 128 bit key */
-	uint32_t              aes_val[4]; 	/* AES initial 128 bit value */
-  int		                num_blks;   	/* # of 512 bytes blocks per page */ 
-  int		                blk_index;  	/* Block index */
-  int                   *ecc_status;	/* ECC status array */
-  bool                  done;       	/* Read, write, erase done flag */  
-	wait_queue_head_t   	nand_queue;		/* NAND queue */
-  int                   offset;				/* Offset in inetrnal driver buffer */
-	bool									cedontcare;		/* CE dont care support */
+   struct mtd_info      mtd;           /* MTD information structure        */
+   struct nand_chip     chip;          /* NAND chip structure              */
+   struct nand_hw_control  nandctrl;   /* NAND control lock                */
+   uint8_t              *dmabuf;       /* DMA buffer                       */
+   dma_addr_t           dmabuf_phy;    /* DMA buffer PHY address           */
+   int                  slots;         /* # of chips                       */
+   int                  slotid;        /* current chip number              */
+   uint32_t             slotbase;      /* Chip start address               */
+   int                  unitid;        /* Current unit ID of controller    */
+   int                  cur_col;       /* Current column address           */
+   int                  cur_page;      /* Current page address             */
+   int                  cur_cmd;       /* Current page address             */
+   int                  lb_chip;       /* Large Block chip flag            */
+   void __iomem         *ctrl_base;    /* Controller base address          */
+   void __iomem         *ahb_buf;      /* Controller base address          */
+   struct mtd_partition *partinfo;     /* partition info structure         */
+   bool                 aes;           /* AES decryption support           */
+   bool                 hwecc;         /* Use HW ECC                       */
+   uint32_t             aes_key[4];    /* AES 128 bit key                  */
+   uint32_t             aes_val[4];    /* AES initial 128 bit value        */
+   int                  blk_size;      /* Block size                       */
+   int                  num_blks;      /* # of blocks per page             */
+   int                  blk_index;     /* Block index                      */
+   int                  *ecc_status;   /* ECC status array                 */
+   bool                 done;          /* Read, write, erase done flag     */
+   wait_queue_head_t    nand_queue;    /* NAND queue                       */
+   int                  offset;        /* Offset in inetrnal driver buffer */
+   bool                 cedontcare;    /* CE dont care support             */
+   tmhwEfmc_PageRWStatusFifo_t page_rw_status_fifo;
 };
 
 /* Max Data buffer size */
-#define NX_NAND_BLK_SIZE          (512)
+#if defined (CONFIG_ARCH_KRONOS)
+#define NX_NAND_BLK_SIZE   (1024)
+#else 
+#define NX_NAND_BLK_SIZE   (512)
+#endif
 
 /* Max OOB buffer size */
-#define NX_NAND_MAX_OOB_SIZE      (128)
+#define NX_NAND_MAX_OOB_SIZE  (128)
 
 /* Maximum AHB buffer size */
-#define NX_NAND_AHB_BUF_MAX_SIZE  (NX_NAND_BLK_SIZE+NX_NAND_MAX_OOB_SIZE)
+#define NX_NAND_AHB_BUF_MAX_SIZE (NX_NAND_BLK_SIZE+NX_NAND_MAX_OOB_SIZE)
 
 /* NAND CONTROLLER register definitions */
-#define NX_NAND_INT_ENA_OFFSET    (0xFE4)
+#define NX_NAND_INT_ENA_OFFSET   (0xFE4)
 
-#define NX_NAND_INT_READY_START   (20)
+#define NX_NAND_INT_READY_START  (20)
 
 /* Interrupt status bits */
-#define NX_NAND_INT_OOB_READ      (1<<0)
-#define NX_NAND_INT_OOB_WRITE     (1<<1)
-#define NX_NAND_INT_BLK_READ      (1<<2)
-#define NX_NAND_INT_BLK_WRITE     (1<<3)
-#define NX_NAND_INT_ENC           (1<<4)
-#define NX_NAND_INT_DEC           (1<<5)
-#define NX_NAND_INT_DEC_0_ERR     (1<<6)
-#define NX_NAND_INT_DEC_1_ERR     (1<<7)
-#define NX_NAND_INT_DEC_2_ERR     (1<<8)
-#define NX_NAND_INT_DEC_3_ERR     (1<<9)
-#define NX_NAND_INT_DEC_4_ERR     (1<<10)
-#define NX_NAND_INT_DEC_5_ERR     (1<<11)
-#define NX_NAND_INT_DEC_UNCOR     (1<<12)
-#define NX_NAND_INT_AES_DEC       (1<<13)
-#define NX_NAND_INT_SEQ_READ      (1<<14)
-#define NX_NAND_INT_SEQ_WRITE     (1<<15)
-#define NX_NAND_INT_BUSY1         (1<<16)
-#define NX_NAND_INT_BUSY2         (1<<17)
-#define NX_NAND_INT_BUSY3         (1<<18)
-#define NX_NAND_INT_BUSY4         (1<<19)
-#define NX_NAND_INT_READY1        (1<<20)
-#define NX_NAND_INT_READY2        (1<<21)
-#define NX_NAND_INT_READY3        (1<<22)
-#define NX_NAND_INT_READY4        (1<<23)
+#define NX_NAND_INT_OOB_READ                 (1<<0)
+#define NX_NAND_INT_OOB_WRITE                (1<<1)
+#define NX_NAND_INT_BLK_READ                 (1<<2)
+#define NX_NAND_INT_BLK_WRITE                (1<<3)
+#define NX_NAND_INT_ENC                      (1<<4)
+#define NX_NAND_INT_DEC                      (1<<5)
+#define NX_NAND_INT_DEC_0_ERR                (1<<6)
+#if defined(CONFIG_ARCH_APOLLO)
+#define NX_NAND_INT_DEC_1_ERR                (1<<7)
+#define NX_NAND_INT_DEC_2_ERR                (1<<8)
+#define NX_NAND_INT_DEC_3_ERR                (1<<9)
+#define NX_NAND_INT_DEC_4_ERR                (1<<10)
+#define NX_NAND_INT_DEC_5_ERR                (1<<11)
+#define NX_NAND_INT_DEC_UNCOR                (1<<12)
+#define NX_NAND_INT_AES_DEC                  (1<<13)
+#else /* CONFIG_ARCH_KRONOS */
+#define NX_NAND_INT_DEC_ERR_CORR             (1<<7)
+#define NX_NAND_INT_PAGE_READ_STS_FIFO_FULL  (1<<9)
+#define NX_NAND_INT_PAGE_WRITE_STS_FIFO_FULL (1<<10)
+#define NX_NAND_INT_CMD_ADR_FIFO_EMPTY       (1<<11)
+#define NX_NAND_INT_SUBPAGE_UNCOR            (1<<12)
+#endif
+#define NX_NAND_INT_SEQ_READ                 (1<<14)
+#define NX_NAND_INT_SEQ_WRITE                (1<<15)
+#define NX_NAND_INT_BUSY1                    (1<<16)
+#define NX_NAND_INT_BUSY2                    (1<<17)
+#define NX_NAND_INT_BUSY3                    (1<<18)
+#define NX_NAND_INT_BUSY4                    (1<<19)
+#define NX_NAND_INT_READY1                   (1<<20)
+#define NX_NAND_INT_READY2                   (1<<21)
+#define NX_NAND_INT_READY3                   (1<<22)
+#define NX_NAND_INT_READY4                   (1<<23)
 
 /* Position of address */
-#define NX_NAND_SP_ADDR_MASK      (0xFF)
-#define NX_NAND_SP_ADDR_MASK1     (0x03)
+#define NX_NAND_SP_ADDR_MASK  (0xFF)
+#define NX_NAND_SP_ADDR_MASK1 (0x03)
 
-#define NX_NAND_SP_ADDR1_POS      (0)
-#define NX_NAND_SP_ADDR2_POS      (9)
-#define NX_NAND_SP_ADDR3_POS      (17)
-#define NX_NAND_SP_ADDR4_POS      (29)
+#define NX_NAND_SP_ADDR1_POS  (0)
+#define NX_NAND_SP_ADDR2_POS  (9)
+#define NX_NAND_SP_ADDR3_POS  (17)
+#define NX_NAND_SP_ADDR4_POS  (29)
 
 /* Cmd FIFO bit information */
-#define NX_NAND_CMD_FIFO_CE_START  (19)
-#define NX_NAND_CMD_FIFO_ADDR_CYC  (0x0)
-#define NX_NAND_CMD_FIFO_CMD_CYC   (0x1)
-#define NX_NAND_CMD_FIFO_POST_CMD  (0x2)
+#define NX_NAND_CMD_FIFO_CE_START   (19)
+#define NX_NAND_CMD_FIFO_ADDR_CYC   (0x0)
+#define NX_NAND_CMD_FIFO_CMD_CYC    (0x1)
+#define NX_NAND_CMD_FIFO_POST_CMD   (0x2)
+
+#define NX_NAND_POWER_DOWN_CFG_OFFSET  (0xFF4)
+#define NX_NAND_POWER_DOWN_MASK        (0x00000001)
+#define NX_NAND_POWER_DOWN_ENABLE      (1UL<<0)
+#define NX_NAND_POWER_DOWN_DISABLE     (0UL<<0)
 
 #endif /* __KERNEL__ */
 #endif /* _NX_NAND_H */
diff -Naurp linux-2.6.34_orig/drivers/mtd/nand/nx_nand/tmhwEfmc/inc/tmhwEfmc.h linux-2.6.34/drivers/mtd/nand/nx_nand/tmhwEfmc/inc/tmhwEfmc.h
--- linux-2.6.34_orig/drivers/mtd/nand/nx_nand/tmhwEfmc/inc/tmhwEfmc.h	2011-05-12 17:15:58.529048000 +0530
+++ linux-2.6.34/drivers/mtd/nand/nx_nand/tmhwEfmc/inc/tmhwEfmc.h	2011-05-13 11:33:25.441386000 +0530
@@ -33,6 +33,7 @@
  * \1.0      Mahadev Cholachagudda     2006-06-06           Draft
  * \1.1      Mahadev Cholachagudda     2007-03-06           Changed the name of the component to tmhwEfmc from tmhwEfmc2070
  *                                                          Also changed to be inline with v1.21 of IP_2017 data sheet
+ * \2.0      Deven Balani              2011-05-15           Supported Kronos NAND Controller
  */
 
 #ifndef TMHWEFMC_H
@@ -189,11 +190,27 @@ typedef enum tmhwEfmc_DataWidth
 typedef enum tmhwEfmc_PageSize
 /*! This enum specifies the page size of the corresponding NAND flash device connected to the EFMC controller */
 {
-  tmhwEfmc_512Byte = 0x00,  /*!< Page size = 512 bytes */
-  tmhwEfmc_2048Byte = 0x10, /*!< Page size = 2048 bytes */
-  tmhwEfmc_4096Byte = 0x20  /*!< Page size = 4096 bytes */
+#if defined (CONFIG_ARCH_KRONOS)
+tmhwEfmc_512Byte = 0x0,  /*!< Page size = 512 bytes */
+tmhwEfmc_1024Byte = 0x1,  /*!< Page size = 1024 bytes */
+tmhwEfmc_2048Byte = 0x2, /*!< Page size = 2048 bytes */
+tmhwEfmc_4096Byte = 0x3, /*!< Page size = 4096 bytes */
+tmhwEfmc_8192Byte = 0x4  /*!< Page size = 8192 bytes */
+#else
+tmhwEfmc_512Byte = 0x0,  /*!< Page size = 512 bytes */
+tmhwEfmc_2048Byte = 0x1, /*!< Page size = 2048 bytes */
+tmhwEfmc_4096Byte = 0x2, /*!< Page size = 4096 bytes */
+#endif
 } tmhwEfmc_PageSize_t, *ptmhwEfmc_PageSize_t;
 
+typedef enum tmhwEfmc_SubPageSize
+/*! This enum specifies the sub page size of the corresponding NAND flash device connected to the EFMC controller */
+{
+  tmhwEfmc_SubPage512Byte = 0x0,  /*!< sub page size = 512 bytes */
+  tmhwEfmc_SubPage1024Byte = 0x1, /*!< sub page size = 1024 bytes */
+} tmhwEfmc_SubPageSize_t, *ptmhwEfmc_SubPageSize_t;
+
+
 typedef enum tmhwEfmc_RdyDelay
 /*! This enum defines the data read delay timing in AXI/AHB clock cycles */
 {
@@ -230,12 +247,26 @@ typedef struct tmhwEfmc_ReadBusySignal
 typedef struct tmhwEfmc_CmdAddr
 /*! This structure contains the command/address and the corresponding data to be put onto the IO lines for the flash devices connected to the EFMC controller */
 {
+  /* -- Kronos specific definitions starts -- */
+  Bool                 immediate;      /* 0-Wait until RB# is 1 (default), 1-Don't care */
+  Bool                 includeOOB;     /* 0-OOB block not included (default), 1-OOB block included */
+  Bool                 includeECC;     /* 0-HW ECC disabled (default), 1-enabled */
+  Bool                 page_transfer;  /* 0-Page xfer (default), 1-Not a Page transfer */
+  Bool                 direction;      /* 0-Read (default), 1-Write */
+  /* -- Kronos specific definitions ends -- */
+
   tmhwEfmc_ChipEn_t    deviceNum;  /*!< The value of CEn lines during command/address/read-write cycles */
-  Bool                     lastCycle;  /*!< The specified command/address is the last on the sequence. When TRUE, nand flash controller will start sending all the commands and/or address present in the FIFO to the nand flash device */
+  Bool                 lastCycle;  /*!< The specified command/address is the last on the sequence. When TRUE, nand flash controller will start sending all the commands and/or address present in the FIFO to the nand flash device */
   tmhwEfmc_CycleType_t cycleType;  /*!< Address/command/PostWrite command cycle type */
-  UInt16                   data;       /*!< data on the IO lines during address/command cycle */
+  UInt16               data;       /*!< data on the IO lines during address/command cycle */
 }tmhwEfmc_CmdAddr_t, *ptmhwEfmc_CmdAddr_t;
 
+typedef struct tmhwEfmc_SetModeCtrl
+{
+  Bool                 rb_n_bypass;
+  Bool                 rd_stall;
+} tmhwEfmc_ModeCtrl_t, *ptmhwEfmc_ModeCtrl_t;
+
 typedef struct tmhwEfmc_PageConfig
 /*! this structure contains the page related read/write configuration for the flash device */
 {
@@ -272,6 +303,10 @@ typedef struct tmhwEfmc_TimingConfig
 typedef struct tmhwEfmc_FlashConfig
 /*! This structure specifies the flash configuration for the correspondign flash device connected to the EFMC controller */
 {
+  UInt8                    erasedPageThres;   /* threshold for the erased-page detector */
+  UInt8                    eccLevel;          /* number of bits that can be corrected by the ECC engine */
+  UInt16                   oobSize;           /* number of bytes available in the OOB area of one page */
+  tmhwEfmc_SubPageSize_t   subpageSize;       /* 0:512 bytes,1:1024 bytes */
   tmhwEfmc_PageSize_t      pageSize;          /*!< Page size of the NAND flash device. */
   tmhwEfmc_EnableDisable_t enableWrProtect;   /*!< Data write protection enabled/disabled */
   tmhwEfmc_EnableDisable_t enableCENDontCare; /*!< defines whether the nand flash device supports "CEn don.t care". The "CEn don.t care" feature allows another memory controller like e.g. the IP_2016 to interrupt an ongoing sequential read/write. */
@@ -279,6 +314,58 @@ typedef struct tmhwEfmc_FlashConfig
   tmhwEfmc_TimingConfig_t  devTiming;         /*!< timing parameters for the NAND flash device */
 } tmhwEfmc_FlashConfig_t, *ptmhwEfmc_FlashConfig_t;
 
+typedef struct tmhwEfmc_OobInfo
+/*! This structure specifies the flash oob partition info for the correspondign flash device connected to the EFMC controller */
+{
+   UInt16   extended_oob;
+   UInt8    unprotected_bytes;
+   UInt8    parity_bytes;
+   UInt8    protected_oob_min;
+} tmhwEfmc_OobInfo_t, *ptmhwEfmc_OobInfo_t;
+
+typedef struct tmhwEfmc_PageRdStatus
+/*! This structure specifies the page read status for the correspondign flash device connected to the EFMC controller */
+{
+   UInt16   tag;
+   Bool     erased;
+   Bool     ecc_off;
+   Bool     uncorrectable;
+   Bool     corrected;
+   Bool     error_free;
+   UInt8    num_errors;
+} tmhwEfmc_PageRdStatus_t, *ptmhwEfmc_PageRdStatus_t;
+
+typedef struct tmhwEfmc_PageWrStatus
+/*! This structure specifies the page read status for the correspondign flash device connected to the EFMC controller */
+{
+   UInt16   tag;
+} tmhwEfmc_PageWrStatus_t, *ptmhwEfmc_PageWrStatus_t;
+
+#define MAX_PAGE_WR_STATUS_FIFO_DEPTH 8
+#define MAX_PAGE_RD_STATUS_FIFO_DEPTH 16
+
+typedef struct tmhwEfmc_PageRWStatusFifo
+/*! This structure specifies the page read status fifo for the correspondign flash device connected to the EFMC controller */
+{
+   UInt8                   PageRdStatusLevel;
+   UInt8                   PageWrStatusLevel;
+   tmhwEfmc_PageRdStatus_t PageRdStatus[MAX_PAGE_RD_STATUS_FIFO_DEPTH];
+   tmhwEfmc_PageWrStatus_t PageWrStatus[MAX_PAGE_WR_STATUS_FIFO_DEPTH];
+} tmhwEfmc_PageRWStatusFifo_t, *ptmhwEfmc_PageRWStatusFifo_t;
+
+typedef enum tmhwEfmc_StatusFifoMode
+{
+   tmhwEfmc_StatusFifoMode_Normal      = 0x0,
+   tmhwEfmc_StatusFifoMode_Protected   = 0x1,
+} tmhwEfmc_StatusFifoMode_t, *ptmhwEfmc_StatusFifoMode_t;
+
+typedef struct tmhwEfmc_PageRWStatusFifoMode
+/*! This structure specifies the page read status for the correspondign flash device connected to the EFMC controller */
+{
+   tmhwEfmc_StatusFifoMode_t  status_fifo_mode;
+   Bool                       status_fifo_pop;
+} tmhwEfmc_PageRWStatusFifoMode_t, *ptmhwEfmc_PageRWStatusFifoMode_t;
+
 /*! \} */ /* addtogroup Basic */
 
 
@@ -491,7 +578,6 @@ tmhwEfmc_WriteCmdAddr(
     const tmhwEfmc_CmdAddr_t *         pCmdAddr
 );
 
-
 /*!\fn tmErrorCode_t tmhwEfmc_InitPageOp( tmUnitSelect_t efmcUnitID, const tmhwEfmc_PageConfig_t * pPageOper);
 *     This function configures the page read/write operation for the relevant NAND flash device.
 *     Note: This API should be called before relevant command/address/post-commands sequence put into the FIFO. Please refer to the use
@@ -503,7 +589,13 @@ tmhwEfmc_WriteCmdAddr(
 tmErrorCode_t
 tmhwEfmc_InitPageOp(
     tmUnitSelect_t                  efmcUnitID,
-    const tmhwEfmc_PageConfig_t *      pPageOper
+    const tmhwEfmc_PageConfig_t *   pPageOper
+);
+
+tmErrorCode_t
+tmhwEfmc_SetModeCtrl(
+    tmUnitSelect_t               efmcUnitID,
+    const tmhwEfmc_ModeCtrl_t    *pModeCtrl
 );
 
 
@@ -522,6 +614,21 @@ tmhwEfmc_SetFlashConfig(
     const tmhwEfmc_FlashConfig_t *     pFlashConfig
 );
 
+tmErrorCode_t
+tmhwEfmc_GetOobInfo (
+    tmUnitSelect_t               efmcUnitID,
+    tmhwEfmc_DeviceNumber_t      deviceNum,
+    tmhwEfmc_OobInfo_t           *pOobInfo);
+
+tmErrorCode_t
+tmhwEfmc_GetPageRWStatusFifo (
+    tmUnitSelect_t               efmcUnitID,
+    tmhwEfmc_PageRWStatusFifo_t *pPageRWStatusFifo);
+
+tmErrorCode_t
+tmhwEfmc_SetPageRWStatusFifoMode (
+    tmUnitSelect_t                  efmcUnitID,
+    tmhwEfmc_PageRWStatusFifoMode_t *pPageRWStatusFifoCfg);
 
 /*!\fn tmErrorCode_t tmhwEfmc_ReadSingleData( tmUnitSelect_t efmcUnitID, pUInt16 pDataRead);
 *     This function reads a single 16-bit data from the relevant NAND flash device.
diff -Naurp linux-2.6.34_orig/drivers/mtd/nand/nx_nand/tmhwEfmc/src/tmhwEfmc.c linux-2.6.34/drivers/mtd/nand/nx_nand/tmhwEfmc/src/tmhwEfmc.c
--- linux-2.6.34_orig/drivers/mtd/nand/nx_nand/tmhwEfmc/src/tmhwEfmc.c	2011-05-12 17:16:01.231818000 +0530
+++ linux-2.6.34/drivers/mtd/nand/nx_nand/tmhwEfmc/src/tmhwEfmc.c	2011-05-12 19:49:14.473897000 +0530
@@ -23,6 +23,7 @@
  * \1.0      Mahadev Cholachagudda     2006-06-07           Draft
  * \1.1      Mahadev Cholachagudda     2007-03-06           Changed the name of the component to tmhwEfmc from tmhwEfmc2070
  *                                                          Also changed to be inline with v1.21 of IP_2017 data sheet
+ * \2.0      Deven Balani              2011-05-15           Supported Kronos NAND Controller
  *---------------------------------------------------------------------------
  */
 
@@ -52,6 +53,10 @@
 /*-----------------------------------------------------------------------------
 * Global data
 *-----------------------------------------------------------------------------*/
+#if defined (CONFIG_ARCH_KRONOS)
+/* Kronos specific - Cmd, Addr, Page config structure */
+static tmhwEfmc_CmdAddr_t Cmd_Addr_Fifo_Cfg;
+#endif
 
 /*------------------------------------------------------------------------------
 * Defines
@@ -85,18 +90,59 @@ tmhwEfmc_Init(
 tmErrorCode_t
 tmhwEfmc_WriteCmdAddr(
     tmUnitSelect_t                  efmcUnitID,
-    const tmhwEfmc_CmdAddr_t *         pCmdAddr
+    const tmhwEfmc_CmdAddr_t *      pCmdAddr
 )
 {
-  UInt32              regs   = 0 ;
-  UInt32                         regVal        = 0 ;
+  UInt32              regs    = 0 ;
+  UInt32              regVal  = 0 ;
   
   regs = (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_CMD_ADDR_FIFO_OFFSET );
+
+#if defined (CONFIG_ARCH_KRONOS)
+  /* -- Kronos specific definitions starts -- */
+  if (tmhwEfmc_CmdCycle == pCmdAddr->cycleType)
+  {
+    if ((/*NAND_CMD_RESET*/0xff==pCmdAddr->data) || 
+        (/*NAND_CMD_STATUS*/0x70== pCmdAddr->data))
+    {
+      Cmd_Addr_Fifo_Cfg.immediate = TM_TRUE;
+    }
+  }
+  if( TM_TRUE == Cmd_Addr_Fifo_Cfg.immediate )
+  {
+    regVal |= (UInt32) TMVH_EFMC_CMD_ADDR_FIFO_IMMEDIATE_MSK ;
+  }
+  if( TM_TRUE == Cmd_Addr_Fifo_Cfg.includeOOB )
+  {
+    /* OOB block included */
+    regVal |= (UInt32) TMVH_EFMC_CMD_ADDR_FIFO_OOB_MSK ;
+  }
+  if( TM_TRUE == Cmd_Addr_Fifo_Cfg.includeECC )
+  {
+    /* ECC block included */
+    regVal |= (UInt32) TMVH_EFMC_CMD_ADDR_FIFO_ECC_MSK ;
+  }
+  if( TM_TRUE == Cmd_Addr_Fifo_Cfg.page_transfer )
+  {
+     /* Transfer page */
+    regVal |= (UInt32) TMVH_EFMC_CMD_ADDR_FIFO_PAGE_XFER_MSK;
+  }
+  if( TM_TRUE == Cmd_Addr_Fifo_Cfg.direction )
+  {
+    /* Write page */
+    regVal |= (UInt32) TMVH_EFMC_CMD_ADDR_FIFO_DIR_MSK;
+  }
+  /* -- Kronos specific definitions ends -- */
+#endif
+
   regVal |= (UInt32) (pCmdAddr->deviceNum) ;
-  
+
   if( TM_TRUE == pCmdAddr->lastCycle )
   {
     regVal |= (UInt32) TMVH_EFMC_CMD_ADDR_FIFO_LAST_CYCLE_MSK ;
+#if defined (CONFIG_ARCH_KRONOS)
+    memset(&Cmd_Addr_Fifo_Cfg, 0, sizeof(Cmd_Addr_Fifo_Cfg));
+#endif
   }
   
   regVal |= (UInt32) (pCmdAddr->cycleType) ;
@@ -120,9 +166,10 @@ tmhwEfmc_InitPageOp(
     const tmhwEfmc_PageConfig_t *      pPageOper
 )
 {
+#if defined (CONFIG_ARCH_APOLLO)
   UInt32              regs  = 0 ;
-  UInt32                         regVal    = 0 ;
-  
+  UInt32              regVal    = 0 ;
+
   regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_PAGE_RW_OFFSET );
   /* Just write the values directly into the register */
   if( TM_TRUE == pPageOper->includeOOB  )
@@ -140,9 +187,76 @@ tmhwEfmc_InitPageOp(
   regVal |= (UInt32) (pPageOper->operType) ;
 
   TMVH_GEN_WRITE( regs, regVal );
+#else /* CONFIG_ARCH_KRONOS */
+  /* Write the values into the global cmd_addr_fifo structure */
+  if( TM_TRUE == pPageOper->includeOOB  )
+  {
+    Cmd_Addr_Fifo_Cfg.includeOOB = TM_TRUE;
+  }
+  if( TM_TRUE == pPageOper->includeECC )
+  {
+    Cmd_Addr_Fifo_Cfg.includeECC = TM_TRUE;
+  }
+  if (tmhwEfmc_PageRead == pPageOper->operType)
+  {
+    Cmd_Addr_Fifo_Cfg.page_transfer = TM_TRUE;
+    Cmd_Addr_Fifo_Cfg.direction     = TM_FALSE;
+  }
+  else if (tmhwEfmc_PageWrite == pPageOper->operType)
+  {
+     Cmd_Addr_Fifo_Cfg.page_transfer   = TM_TRUE;
+     Cmd_Addr_Fifo_Cfg.direction       = TM_TRUE;
+  }
+  else
+  {
+     Cmd_Addr_Fifo_Cfg.page_transfer   = TM_FALSE;
+     Cmd_Addr_Fifo_Cfg.direction       = TM_FALSE;
+  }
+#endif
   return TM_OK;
 }
 
+tmErrorCode_t
+tmhwEfmc_SetModeCtrl(
+   tmUnitSelect_t             efmcUnitID,
+   const tmhwEfmc_ModeCtrl_t *pModeCtrl
+   )
+{
+   UInt32   regs     = 0 ;
+   UInt32   regVal   = 0 ;
+
+   regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + 
+      TMVH_EFMC_MODE_CTRL_OFFSET );
+
+   /* Just write the values directly into the register */
+
+   if( TM_TRUE == pModeCtrl->rb_n_bypass )
+   {
+      regVal |= (UInt32) (TMVH_EFMC_MODE_CTRL_RBN_BYPASS_MSK);
+   }
+   else
+   {
+      regVal &= (UInt32) ~(TMVH_EFMC_MODE_CTRL_RBN_BYPASS_MSK);
+   }
+   if( TM_TRUE == pModeCtrl->rd_stall )
+   {
+      regVal |= (UInt32) (TMVH_EFMC_MODE_CTRL_RD_STALL_MSK);
+   }
+   else
+   {
+      regVal &= (UInt32) ~(TMVH_EFMC_MODE_CTRL_RD_STALL_MSK);
+   }
+   TMVH_GEN_WRITE( regs, regVal );
+
+   /* enable normal fifo operation i.e. reading from the FIFO increments 
+    * the FIFO pointer as a side effect. */
+   regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + 
+      TMVH_EFMC_STATUS_FIFO_MODE_OFFSET );
+   regVal = (UInt32) (tmhwEfmc_StatusFifoMode_Normal);
+   TMVH_GEN_WRITE( regs, regVal );
+
+   return TM_OK;
+}
 
 /*!\fn tmErrorCode_t tmhwEfmc_SetFlashConfig( tmUnitSelect_t efmcUnitID, tmhwEfmc_DeviceNumber_t deviceNum, const tmhwEfmc_FlashConfig_t * pFlashConfig);
 *     This function configures the given NAND flash device for timing parameters, data width and page size and also for write-protect of NAND flash device.
@@ -154,62 +268,203 @@ tmhwEfmc_InitPageOp(
 */
 tmErrorCode_t
 tmhwEfmc_SetFlashConfig(
-    tmUnitSelect_t                  efmcUnitID,
-    tmhwEfmc_DeviceNumber_t                           deviceNum,
-    const tmhwEfmc_FlashConfig_t *     pFlashConfig
+   tmUnitSelect_t                efmcUnitID,
+   tmhwEfmc_DeviceNumber_t       deviceNum,
+   const tmhwEfmc_FlashConfig_t *pFlashConfig
+)
+{
+   UInt32   regs     = 0 ;
+   UInt32   regVal   = 0 ;
+
+   regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_DEV_TYPE0_OFFSET +
+      ( deviceNum * TMVH_EFMC_DEV_TYPE0_DIFF ) );
+
+   /* Just write the values directly into the register */
+   regVal = (UInt32) (pFlashConfig->dataWidth) ;
+   if( tmhwEfmc_Enable == pFlashConfig->enableCENDontCare )
+   {
+      regVal |= (UInt32) (TMVH_EFMC_DEV_TYPE0_CEN_DONT_MSK);
+   }
+   if( tmhwEfmc_Enable == pFlashConfig->enableWrProtect )
+   {
+      regVal |= (UInt32) (TMVH_EFMC_DEV_TYPE0_WP_MSK);
+   }
+   regVal |= (UInt32) (pFlashConfig->pageSize) ;
+
+#if defined (CONFIG_ARCH_KRONOS)
+   /* -- Kronos specific definitions starts -- */
+   regVal |=  ((UInt32)(pFlashConfig->subpageSize) << 
+      TMVH_EFMC_DEV_TYPE0_SUB_PAGE_SIZE_POS);
+
+   regVal |=  ((UInt32)(pFlashConfig->oobSize) << 
+      TMVH_EFMC_DEV_TYPE0_OOB_SIZE_POS);
+
+   regVal |=  ((UInt32)(pFlashConfig->eccLevel) << 
+      TMVH_EFMC_DEV_TYPE0_ECC_LEVEL_POS);
+
+   regVal |=  ((UInt32)(pFlashConfig->erasedPageThres) << 
+      TMVH_EFMC_DEV_TYPE0_ERASED_PAGE_THRES_POS);
+#endif
+
+   /* -- Kronos specific definitions ends -- */
+   TMVH_GEN_WRITE( regs, regVal );
+
+   /* configure the timing0 register */
+   regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_DEV_TIMING0_OFFSET +
+      ( deviceNum * TMVH_EFMC_DEV_TIMING0_DIFF ) );
+   regVal = (UInt32) (pFlashConfig->devTiming.tWaitForRdy & TMVH_EFMC_DEV_TIMING0_TRR_MSK);
+
+   /* please note that, 0x00 meaning 16 cycles, so when masking, if given is 16,then it will turn to be 0x00 which is correct */
+   regVal |= ((((UInt32)(pFlashConfig->devTiming.tAleHold)) << TMVH_EFMC_DEV_TIMING0_TALH_POS ) & TMVH_EFMC_DEV_TIMING0_TALH_MSK );
+   regVal |= ((((UInt32)(pFlashConfig->devTiming.tAleSetup)) << TMVH_EFMC_DEV_TIMING0_TALS_POS ) & TMVH_EFMC_DEV_TIMING0_TALS_MSK );
+   regVal |= ((((UInt32)(pFlashConfig->devTiming.tCleHold)) << TMVH_EFMC_DEV_TIMING0_TCLH_POS ) & TMVH_EFMC_DEV_TIMING0_TCLH_MSK );
+   regVal |= ((((UInt32)(pFlashConfig->devTiming.tCleSetup)) << TMVH_EFMC_DEV_TIMING0_TCLS_POS ) & TMVH_EFMC_DEV_TIMING0_TCLS_MSK );
+   regVal |= ((((UInt32)(pFlashConfig->devTiming.tCenHold))<< TMVH_EFMC_DEV_TIMING0_TCPH_POS ) & TMVH_EFMC_DEV_TIMING0_TCPH_MSK );
+   regVal |= ((((UInt32)(pFlashConfig->devTiming.tCenSetup)) << TMVH_EFMC_DEV_TIMING0_TCPS_POS ) & TMVH_EFMC_DEV_TIMING0_TCPS_MSK );
+
+   TMVH_GEN_WRITE( regs, regVal );
+
+   /* configure the timing1 register */
+   regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_DEV_TIMING1_OFFSET +
+      ( deviceNum * TMVH_EFMC_DEV_TIMING1_DIFF ) );
+
+   regVal = (UInt32) (pFlashConfig->devTiming.tRenHigh & TMVH_EFMC_DEV_TIMING1_TRH_MSK );
+   regVal |= (UInt32) (pFlashConfig->devTiming.tRdDelay);
+   /* please note that, 0x00 meaning 16 cycles, so when masking, if given is 16,then it will turn to be 0x00 which is correct */
+   regVal |= ((((UInt32)(pFlashConfig->devTiming.tWaitForBusy)) << TMVH_EFMC_DEV_TIMING1_TWB_POS ) & TMVH_EFMC_DEV_TIMING1_TWB_MSK );
+   regVal |= ((((UInt32)(pFlashConfig->devTiming.tWenWidth)) << TMVH_EFMC_DEV_TIMING1_TWP_POS ) & TMVH_EFMC_DEV_TIMING1_TWP_MSK );
+   regVal |= ((((UInt32)(pFlashConfig->devTiming.tWenHigh)) << TMVH_EFMC_DEV_TIMING1_TWH_POS ) & TMVH_EFMC_DEV_TIMING1_TWH_MSK );
+   regVal |= ((((UInt32)(pFlashConfig->devTiming.tRenWidth)) << TMVH_EFMC_DEV_TIMING1_TRP_POS ) & TMVH_EFMC_DEV_TIMING1_TRP_MSK );
+
+   TMVH_GEN_WRITE( regs, regVal );
+   return TM_OK;
+}
+
+tmErrorCode_t
+tmhwEfmc_GetOobInfo (
+    tmUnitSelect_t            efmcUnitID,
+    tmhwEfmc_DeviceNumber_t   deviceNum,
+    tmhwEfmc_OobInfo_t       *pOobInfo
 )
 {
-  UInt32              regs  = 0 ;
-  UInt32                         regVal    = 0 ;
+   UInt32   regs     = 0 ;
+   UInt32   regVal   = 0 ;
 
-  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_DEV_TYPE0_OFFSET +
-                                   ( deviceNum * TMVH_EFMC_DEV_TYPE0_DIFF ) );
+   regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + 
+      TMVH_EFMC_OOB_PARTITION_N_OFFSET + ( deviceNum * TMVH_EFMC_DEV_TYPE0_DIFF ) );
+   TMVH_GEN_READ( regs, regVal );
 
-  /* Just write the values directly into the register */
-  regVal = (UInt32) (pFlashConfig->dataWidth) ;
-  if( tmhwEfmc_Enable == pFlashConfig->enableCENDontCare )
-  {
-    regVal |= (UInt32) (TMVH_EFMC_DEV_TYPE0_CEN_DONT_MSK);
-  }
-  if( tmhwEfmc_Enable == pFlashConfig->enableWrProtect )
-  {
-    regVal |= (UInt32) (TMVH_EFMC_DEV_TYPE0_WP_MSK);
-  }
-  regVal |= (UInt32) (pFlashConfig->pageSize) ;
+   pOobInfo->extended_oob = 
+      (UInt16) ((regVal & TMVH_EFMC_OOB_PARTITION_N_EXTENDED_OOB_MSK)
+         >> TMVH_EFMC_OOB_PARTITION_N_EXTENDED_OOB_POS);
 
-  TMVH_GEN_WRITE( regs, regVal );
+   pOobInfo->unprotected_bytes = 
+      (UInt8) ((regVal & TMVH_EFMC_OOB_PARTITION_N_UNPROTECTED_BYTES_MSK)
+         >> TMVH_EFMC_OOB_PARTITION_N_UNPROTECTED_BYTES_POS);
 
-  /* configure the timing0 register */
-  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_DEV_TIMING0_OFFSET +
-                                   ( deviceNum * TMVH_EFMC_DEV_TIMING0_DIFF ) );
-  regVal = (UInt32) (pFlashConfig->devTiming.tWaitForRdy & TMVH_EFMC_DEV_TIMING0_TRR_MSK);
-
-  /* please note that, 0x00 meaning 16 cycles, so when masking, if given is 16,then it will turn to be 0x00 which is correct */
-  regVal |= ((((UInt32)(pFlashConfig->devTiming.tAleHold)) << TMVH_EFMC_DEV_TIMING0_TALH_POS ) & TMVH_EFMC_DEV_TIMING0_TALH_MSK );
-  regVal |= ((((UInt32)(pFlashConfig->devTiming.tAleSetup)) << TMVH_EFMC_DEV_TIMING0_TALS_POS ) & TMVH_EFMC_DEV_TIMING0_TALS_MSK );
-  regVal |= ((((UInt32)(pFlashConfig->devTiming.tCleHold)) << TMVH_EFMC_DEV_TIMING0_TCLH_POS ) & TMVH_EFMC_DEV_TIMING0_TCLH_MSK );
-  regVal |= ((((UInt32)(pFlashConfig->devTiming.tCleSetup)) << TMVH_EFMC_DEV_TIMING0_TCLS_POS ) & TMVH_EFMC_DEV_TIMING0_TCLS_MSK );
-  regVal |= ((((UInt32)(pFlashConfig->devTiming.tCenHold))<< TMVH_EFMC_DEV_TIMING0_TCPH_POS ) & TMVH_EFMC_DEV_TIMING0_TCPH_MSK );
-  regVal |= ((((UInt32)(pFlashConfig->devTiming.tCenSetup)) << TMVH_EFMC_DEV_TIMING0_TCPS_POS ) & TMVH_EFMC_DEV_TIMING0_TCPS_MSK );
+   pOobInfo->parity_bytes = 
+      (UInt8) ((regVal & TMVH_EFMC_OOB_PARTITION_N_PARITY_BYTES_MSK)
+         >> TMVH_EFMC_OOB_PARTITION_N_PARITY_BYTES_POS);
 
-  TMVH_GEN_WRITE( regs, regVal );
+   pOobInfo->protected_oob_min = 
+      (UInt8) ((regVal & TMVH_EFMC_OOB_PARTITION_N_PROTECTED_OOB_MIN_MSK)
+         >> TMVH_EFMC_OOB_PARTITION_N_PROTECTED_OOB_MIN_POS);
 
-  /* configure the timing1 register */
-  regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + TMVH_EFMC_DEV_TIMING1_OFFSET +
-                                   ( deviceNum * TMVH_EFMC_DEV_TIMING1_DIFF ) );
-  
-  regVal = (UInt32) (pFlashConfig->devTiming.tRenHigh & TMVH_EFMC_DEV_TIMING1_TRH_MSK );
-  regVal |= (UInt32) (pFlashConfig->devTiming.tRdDelay);
-  /* please note that, 0x00 meaning 16 cycles, so when masking, if given is 16,then it will turn to be 0x00 which is correct */
-  regVal |= ((((UInt32)(pFlashConfig->devTiming.tWaitForBusy)) << TMVH_EFMC_DEV_TIMING1_TWB_POS ) & TMVH_EFMC_DEV_TIMING1_TWB_MSK );
-  regVal |= ((((UInt32)(pFlashConfig->devTiming.tWenWidth)) << TMVH_EFMC_DEV_TIMING1_TWP_POS ) & TMVH_EFMC_DEV_TIMING1_TWP_MSK );
-  regVal |= ((((UInt32)(pFlashConfig->devTiming.tWenHigh)) << TMVH_EFMC_DEV_TIMING1_TWH_POS ) & TMVH_EFMC_DEV_TIMING1_TWH_MSK );
-  regVal |= ((((UInt32)(pFlashConfig->devTiming.tRenWidth)) << TMVH_EFMC_DEV_TIMING1_TRP_POS ) & TMVH_EFMC_DEV_TIMING1_TRP_MSK );
-  
-  TMVH_GEN_WRITE( regs, regVal );
   return TM_OK;
 }
 
+tmErrorCode_t
+tmhwEfmc_GetPageRWStatusFifo (
+    tmUnitSelect_t               efmcUnitID,
+    tmhwEfmc_PageRWStatusFifo_t *pPageRWStatusFifo
+)
+{
+   UInt32   regs     = 0;
+   UInt32   regVal   = 0;
+   UInt32   i        = 0;
+
+   regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + 
+      TMVH_EFMC_FIFO_STATUS_OFFSET );
+   TMVH_GEN_READ( regs, regVal );
+
+   pPageRWStatusFifo->PageRdStatusLevel =  
+      ((regVal & TMVH_EFMC_FIFO_PAGE_RD_STATUS_LEVEL_MSK)
+         >> TMVH_EFMC_FIFO_PAGE_RD_STATUS_LEVEL_POS);
+
+   pPageRWStatusFifo->PageWrStatusLevel = 
+      ((regVal & TMVH_EFMC_FIFO_PAGE_WR_STATUS_LEVEL_MSK)
+         >> TMVH_EFMC_FIFO_PAGE_WR_STATUS_LEVEL_POS);
+
+   for (i = 0; i < pPageRWStatusFifo->PageRdStatusLevel; i++)
+   {
+      regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + 
+         TMVH_EFMC_PAGE_RD_STATUS_FIFO_OFFSET );
+      TMVH_GEN_READ( regs, regVal );
+
+      pPageRWStatusFifo->PageRdStatus[i].tag             = 
+         ((regVal & TMVH_EFMC_PAGE_RD_STATUS_FIFO_TAG_MSK)
+            >> TMVH_EFMC_PAGE_RD_STATUS_FIFO_TAG_POS);
+
+      pPageRWStatusFifo->PageRdStatus[i].erased          = 
+         ((regVal & TMVH_EFMC_PAGE_RD_STATUS_FIFO_ERASED_MSK)
+            >> TMVH_EFMC_PAGE_RD_STATUS_FIFO_ERASED_POS);
+
+      pPageRWStatusFifo->PageRdStatus[i].ecc_off         = 
+         ((regVal & TMVH_EFMC_PAGE_RD_STATUS_FIFO_ECC_OFF_MSK)
+            >> TMVH_EFMC_PAGE_RD_STATUS_FIFO_ECC_OFF_POS);
+
+      pPageRWStatusFifo->PageRdStatus[i].uncorrectable   = 
+         ((regVal & TMVH_EFMC_PAGE_RD_STATUS_FIFO_UNCORRECTABLE_MSK)
+            >> TMVH_EFMC_PAGE_RD_STATUS_FIFO_UNCORRECTABLE_POS);
+
+      pPageRWStatusFifo->PageRdStatus[i].corrected       = 
+         ((regVal & TMVH_EFMC_PAGE_RD_STATUS_FIFO_CORRECTED_MSK)
+            >> TMVH_EFMC_PAGE_RD_STATUS_FIFO_CORRECTED_POS);
+
+      pPageRWStatusFifo->PageRdStatus[i].error_free      = 
+         ((regVal & TMVH_EFMC_PAGE_RD_STATUS_FIFO_ERROR_FREE_MSK)
+            >> TMVH_EFMC_PAGE_RD_STATUS_FIFO_ERROR_FREE_POS);
+
+      pPageRWStatusFifo->PageRdStatus[i].num_errors      =
+         ((regVal & TMVH_EFMC_PAGE_RD_STATUS_FIFO_NUM_ERROR_MSK)
+            >> TMVH_EFMC_PAGE_RD_STATUS_FIFO_NUM_ERROR_POS);
+   }
+
+   for (i = 0; i < pPageRWStatusFifo->PageWrStatusLevel; i++)
+   {
+      regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + 
+         TMVH_EFMC_PAGE_WR_STATUS_FIFO_OFFSET );
+      TMVH_GEN_READ( regs, regVal );
+
+      pPageRWStatusFifo->PageWrStatus[i].tag      =
+         ((regVal & TMVH_EFMC_PAGE_WR_STATUS_FIFO_TAG_MSK)
+            >> TMVH_EFMC_PAGE_WR_STATUS_FIFO_TAG_POS);
+   }
+
+   return TM_OK;
+}
+
+tmErrorCode_t
+tmhwEfmc_SetPageRWStatusFifoMode (
+    tmUnitSelect_t                  efmcUnitID,
+    tmhwEfmc_PageRWStatusFifoMode_t  *pPageRWStatusFifoMode
+)
+{
+   UInt32   regs     = 0;
+   UInt32   regVal   = 0;
+
+   regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + 
+      TMVH_EFMC_STATUS_FIFO_MODE_OFFSET );
+   regVal = (UInt32) (pPageRWStatusFifoMode->status_fifo_mode);
+   TMVH_GEN_WRITE( regs, regVal );
+
+   regs =  (UInt32) ( TMHW_EFMC_GET_BASE( efmcUnitID) + 
+      TMVH_EFMC_STATUS_FIFO_POP_OFFSET );
+   regVal = (UInt32) (pPageRWStatusFifoMode->status_fifo_pop);
+   TMVH_GEN_WRITE( regs, regVal );
+
+   return TM_OK;
+}
 
 /*!\fn tmErrorCode_t tmhwEfmc_ReadSingleData( tmUnitSelect_t efmcUnitID, pUInt16 pDataRead);
 *     This function reads a single 16-bit data from the relevant NAND flash device.
@@ -529,7 +784,6 @@ tmhwEfmc_GetBusyStatus(
   return TM_OK;
 }
 
-
 #if (TMFL_EFMCSD_DMA || TMFL_SD_ALL)
 /*! \addtogroup DmaSupport
  *  \{
diff -Naurp linux-2.6.34_orig/drivers/mtd/nand/nx_nand/tmhwEfmc/src/tmhwEfmc_Vhip.h linux-2.6.34/drivers/mtd/nand/nx_nand/tmhwEfmc/src/tmhwEfmc_Vhip.h
--- linux-2.6.34_orig/drivers/mtd/nand/nx_nand/tmhwEfmc/src/tmhwEfmc_Vhip.h	2011-05-12 17:16:01.234804000 +0530
+++ linux-2.6.34/drivers/mtd/nand/nx_nand/tmhwEfmc/src/tmhwEfmc_Vhip.h	2011-05-12 19:50:00.607095000 +0530
@@ -23,6 +23,7 @@
  * \1.0      Mahadev Cholachagudda     2006-06-07           Draft
  * \1.1      Mahadev Cholachagudda     2007-03-06           Changed the name of the component to tmhwEfmc from tmhwEfmc2070
  *                                                          Also changed to be inline with v1.21 of IP_2017 data sheet
+ * \2.0      Deven Balani              2011-05-15           Supported Kronos NAND Controller
  */
 /*----------------------------------------------------------------------------*/
 
@@ -65,43 +66,58 @@ extern "C"
  * Register offsets from base address
  */
 /**---------------------------------------------------------------------------*/
-#define TMVH_EFMC_CMD_ADDR_FIFO_OFFSET          (0x000) /**< EFMC Nand Flash Command / Address FIFO register */
-#define TMVH_EFMC_PAGE_RW_OFFSET                (0x004) /**< EFMC Nand Flash Page Read/Write register */
-#define TMVH_EFMC_NAND_STATUS_OFFSET            (0x008) /** Nand Flash Status registers */
-#define TMVH_EFMC_DMA_CTRL_OFFSET               (0x00C) /** DMA Control Register */
-#define TMVH_EFMC_EBI_CTRL_OFFSET               (0x010) /**<  EBI Pin-Sharing Control Register*/
-#define TMVH_EFMC_AHB_LATENCY_OFFSET            (0x014) /**< AX/AHB Latency Register */
-#define TMVH_EFMC_APB_LATENCY_OFFSET            (0x018) /**<  APB Latency Register*/
-#define TMVH_EFMC_APB_ERROR_GEN_OFFSET          (0x01C) /**<  APB Error Register */
-#define TMVH_EFMC_AES_KEY1_OFFSET               (0x020) /**< AES Key Register(1st 32bit) */
-#define TMVH_EFMC_AES_KEY2_OFFSET               (0x024) /**< AES Key Register(2nd 32bit) */
-#define TMVH_EFMC_AES_KEY3_OFFSET               (0x028) /**< AES Key Register (3rd 32bit) */
-#define TMVH_EFMC_AES_KEY4_OFFSET               (0x02C) /**< AES Key Register (4th 32bit) */
-#define TMVH_EFMC_AES_IV1_OFFSET                (0x030) /**<  AES Initial Value Register (1st 32bit)*/
-#define TMVH_EFMC_AES_IV2_OFFSET                (0x034) /**< AES Initial Value Register (2nd32bit) */
-#define TMVH_EFMC_AES_IV3_OFFSET                (0x038) /**< AES Initial Value Register (3rd 32bit) */
-#define TMVH_EFMC_AES_IV4_OFFSET                (0x03C) /**< AES Initial Value Register (4th 32bit) */
-#define TMVH_EFMC_AES_STATUS_OFFSET             (0x040) /**< AES Status Register */
-#define TMVH_EFMC_SINGLE_READ_OFFSET            (0x044) /**<  Nand Flash SInge Read Register*/
-#define TMVH_EFMC_SINGLE_WRITE_OFFSET           (0x048) /**< Nand Flash SInge Write Register */
-#define TMVH_EFMC_DEV_TYPE0_OFFSET              (0x04C) /**<  Nand Flash Device Type Register for CEn[n]*/
-#define TMVH_EFMC_DEV_TYPE0_DIFF                (0x00C) /**  */
-#define TMVH_EFMC_DEV_TIMING0_OFFSET            (0x050) /**<Nand Flash Device Timing Register #0 for CEn[n]  */
-#define TMVH_EFMC_DEV_TIMING0_DIFF              (0x00C) /**  */
-#define TMVH_EFMC_DEV_TIMING1_OFFSET            (0x054) /**< Nand Flash Device Timing Register #1 for CEn[n] */
-#define TMVH_EFMC_DEV_TIMING1_DIFF              (0x00C) /**  */
-#define TMVH_EFMC_MOD_CONFIG_OFFSET             (0xFD4) /**< Module Configuration Register */
-#define TMVH_EFMC_INT_CLR_ENABLE_OFFSET         (0xFD8) /** Interrupt Clear Enable Register */
-#define TMVH_EFMC_INT_SET_ENABLE_OFFSET         (0xFDC) /** Interrupt Set Enable Register */
-#define TMVH_EFMC_INT_STATUS_OFFSET             (0xFE0) /** Interrupt Status Register */
-#define TMVH_EFMC_INT_ENABLE_OFFSET             (0xFE4) /** Interrupt Enable Register */
-#define TMVH_EFMC_INT_CLR_STATUS_OFFSET         (0xFE8) /** Interrupt Clear Status Set Register */
-#define TMVH_EFMC_INT_SET_STATUS_OFFSET         (0xFEC) /** Interrupt Set Status Set Register */
-#define TMVH_EFMC_SWRESET_OFFSET                (0xFF0) /**< Software reset register */
-#define TMVH_EFMC_POWER_DOWN_OFFSET             (0xFF4) /**< Power down register */
-#define TMVH_EFMC_EXT_MODID_OFFSET              (0xFF8) /**< Dynamic memory write recovery time register */
-#define TMVH_EFMC_MODID_OFFSET                  (0xFFC) /**< Dynamic memory write recovery time register */
+#define TMVH_EFMC_CMD_ADDR_FIFO_OFFSET          (0x000) /* EFMC Nand Flash Command / Address FIFO register */
 
+#define TMVH_EFMC_PAGE_RW_OFFSET                (0x004) /* (Apollo) EFMC Nand Flash Page Read/Write register */
+#define TMVH_EFMC_MODE_CTRL_OFFSET              (0x004) /* (Kronos) Determines the page read operation mode */
+
+#define TMVH_EFMC_NAND_STATUS_OFFSET            (0x008) /* Nand Flash Status registers */
+#define TMVH_EFMC_DMA_CTRL_OFFSET               (0x00C) /* DMA Control Register */
+#define TMVH_EFMC_EBI_CTRL_OFFSET               (0x010) /* EBI Pin-Sharing Control Register*/
+
+#define TMVH_EFMC_AHB_LATENCY_OFFSET            (0x014) /* (Reserved) AX/AHB Latency Register */
+#define TMVH_EFMC_APB_LATENCY_OFFSET            (0x018) /* (Reserved) APB Latency Register*/
+#define TMVH_EFMC_APB_ERROR_GEN_OFFSET          (0x01C) /* (Reserved) APB Error Register */
+#define TMVH_EFMC_AES_KEY1_OFFSET               (0x020) /* (Reserved) AES Key Register(1st 32bit) */
+#define TMVH_EFMC_AES_KEY2_OFFSET               (0x024) /* (Reserved) AES Key Register(2nd 32bit) */
+#define TMVH_EFMC_AES_KEY3_OFFSET               (0x028) /* (Reserved) AES Key Register (3rd 32bit) */
+#define TMVH_EFMC_AES_KEY4_OFFSET               (0x02C) /* (Reserved) AES Key Register (4th 32bit) */
+#define TMVH_EFMC_AES_IV1_OFFSET                (0x030) /* (Reserved) AES Initial Value Register (1st 32bit)*/
+#define TMVH_EFMC_AES_IV2_OFFSET                (0x034) /* (Reserved) AES Initial Value Register (2nd32bit) */
+#define TMVH_EFMC_AES_IV3_OFFSET                (0x038) /* (Reserved) AES Initial Value Register (3rd 32bit) */
+#define TMVH_EFMC_AES_IV4_OFFSET                (0x03C) /* (Reserved) AES Initial Value Register (4th 32bit) */
+#define TMVH_EFMC_AES_STATUS_OFFSET             (0x040) /* (Reserved) AES Status Register */
+
+#define TMVH_EFMC_SINGLE_READ_OFFSET            (0x044) /* Nand Flash SInge Read Register*/
+#define TMVH_EFMC_SINGLE_WRITE_OFFSET           (0x048) /* Nand Flash SInge Write Register */
+#define TMVH_EFMC_DEV_TYPE0_OFFSET              (0x04C) /* Nand Flash Device Type Register for CEn[n]*/
+#define TMVH_EFMC_DEV_TYPE0_DIFF                (0x00C) /* */
+#define TMVH_EFMC_DEV_TIMING0_OFFSET            (0x050) /* Nand Flash Device Timing Register #0 for CEn[n]  */
+#define TMVH_EFMC_DEV_TIMING0_DIFF              (0x00C) /* */
+#define TMVH_EFMC_DEV_TIMING1_OFFSET            (0x054) /* Nand Flash Device Timing Register #1 for CEn[n] */
+#define TMVH_EFMC_DEV_TIMING1_DIFF              (0x00C) /* */
+
+#define TMVH_EFMC_OOB_PARTITION_N_OFFSET        (0x07C) /* (Kronos) OOB Partitioning Register */
+#define TMVH_EFMC_PAGE_RD_STATUS_FIFO_OFFSET    (0x080) /* (Kronos) Page read status fifo Register*/
+#define TMVH_EFMC_PAGE_WR_STATUS_FIFO_OFFSET    (0x084) /* (Kronos) Page write status fifo Register */
+#define TMVH_EFMC_PAGE_TAG_OFFSET               (0x088) /* (Kronos) Page Tag Register */
+#define TMVH_EFMC_FIFO_STATUS_OFFSET            (0x08C) /* (Kronos) FIFO Status Register*/
+#define TMVH_EFMC_STATUS_FIFO_POP_OFFSET        (0x090) /* (Kronos) PAGE RD/WR STATUS status fifo pop Register */
+#define TMVH_EFMC_STATUS_FIFO_MODE_OFFSET       (0x094) /* (Kronos) FIFO mode selection Register */
+#define TMVH_EFMC_CMD_ADDR_FIFO_DATA_OFFSET     (0x098) /* (Kronos) Command address fifo contents register */
+#define TMVH_EFMC_CMD_ADDR_FIFO_DATA_DIFF       (0x004) /* (Kronos) */
+
+#define TMVH_EFMC_MOD_CONFIG_OFFSET             (0xFD4) /* Module Configuration Register */
+#define TMVH_EFMC_INT_CLR_ENABLE_OFFSET         (0xFD8) /* Interrupt Clear Enable Register */
+#define TMVH_EFMC_INT_SET_ENABLE_OFFSET         (0xFDC) /* Interrupt Set Enable Register */
+#define TMVH_EFMC_INT_STATUS_OFFSET             (0xFE0) /* Interrupt Status Register */
+#define TMVH_EFMC_INT_ENABLE_OFFSET             (0xFE4) /* Interrupt Enable Register */
+#define TMVH_EFMC_INT_CLR_STATUS_OFFSET         (0xFE8) /* Interrupt Clear Status Set Register */
+#define TMVH_EFMC_INT_SET_STATUS_OFFSET         (0xFEC) /* Interrupt Set Status Set Register */
+#define TMVH_EFMC_SWRESET_OFFSET                (0xFF0) /* Software reset register */
+#define TMVH_EFMC_POWER_DOWN_OFFSET             (0xFF4) /* Power down register */
+#define TMVH_EFMC_EXT_MODID_OFFSET              (0xFF8) /* Dynamic memory write recovery time register */
+#define TMVH_EFMC_MODID_OFFSET                  (0xFFC) /* Dynamic memory write recovery time register */
 
 #define TMVH_EFMC_MAX_AHB_MAIN_MEM_SIZE         (0x200)
 
@@ -112,9 +128,26 @@ extern "C"
 /**---------------------------------------------------------------------------*/
 
 /**
- * CMD_ADDR_FIFO register
+ * (Apollo, Kronos) CMD_ADDR_FIFO register
  */
-#define TMVH_EFMC_CMD_ADDR_FIFO_CEN_MSK         (0x00180000)
+/* -- Kronos specific definitions starts -- */
+#define TMVH_EFMC_CMD_ADDR_FIFO_IMMEDIATE_MSK   (0x04000000)
+#define TMVH_EFMC_CMD_ADDR_FIFO_IMMEDIATE_POS   (26)
+
+#define TMVH_EFMC_CMD_ADDR_FIFO_OOB_MSK         (0x02000000)
+#define TMVH_EFMC_CMD_ADDR_FIFO_OOB_POS         (25)
+
+#define TMVH_EFMC_CMD_ADDR_FIFO_ECC_MSK         (0x01000000)
+#define TMVH_EFMC_CMD_ADDR_FIFO_ECC_POS         (24)
+
+#define TMVH_EFMC_CMD_ADDR_FIFO_PAGE_XFER_MSK   (0x00800000)
+#define TMVH_EFMC_CMD_ADDR_FIFO_PAGE_XFER_POS   (23)
+
+#define TMVH_EFMC_CMD_ADDR_FIFO_DIR_MSK         (0x00400000)
+#define TMVH_EFMC_CMD_ADDR_FIFO_DIR_POS         (22)
+/* -- Kronos specific definitions ends -- */
+
+#define TMVH_EFMC_CMD_ADDR_FIFO_CEN_MSK         (0x00380000)
 #define TMVH_EFMC_CMD_ADDR_FIFO_CEN_POS         (19)
 
 #define TMVH_EFMC_CMD_ADDR_FIFO_LAST_CYCLE_MSK  (0x00040000)
@@ -126,305 +159,381 @@ extern "C"
 #define TMVH_EFMC_CMD_ADDR_FIFO_IO_MSK          (0x0000FFFF)
 #define TMVH_EFMC_CMD_ADDR_FIFO_IO_POS          (0)
 
-
 /**
- * PAGE_RW register
+ * (Kronos) MODE_CTRL register
  */
-#define TMVH_EFMC_PAGE_RW_OOB_MSK          (0x00000010)
-#define TMVH_EFMC_PAGE_RW_OOB_POS          (4)
-
-#define TMVH_EFMC_PAGE_RW_AES_MSK          (0x00000008)
-#define TMVH_EFMC_PAGE_RW_AES_POS          (3)
-
-#define TMVH_EFMC_PAGE_RW_ECC_MSK          (0x00000004)
-#define TMVH_EFMC_PAGE_RW_ECC_POS          (2)
-
-#define TMVH_EFMC_PAGE_RW_WRITE_PAGE_MSK   (0x00000002)
-#define TMVH_EFMC_PAGE_RW_WRITE_PAGE_POS   (1)
-
-#define TMVH_EFMC_PAGE_RW_READ_PAGE_MSK    (0x00000001)
-#define TMVH_EFMC_PAGE_RW_READ_PAGE_POS    (0)
+#define TMVH_EFMC_MODE_CTRL_RBN_BYPASS_MSK      (0x00000002)
+#define TMVH_EFMC_MODE_CTRL_RBN_BYPASS_POS      (1)
 
+#define TMVH_EFMC_MODE_CTRL_RD_STALL_MSK        (0x00000001)
+#define TMVH_EFMC_MODE_CTRL_RD_STALL_POS        (0)
 
 /**
- * NAND_STATUS register
+ * (Apollo) PAGE_RW register
  */
-#define TMVH_EFMC_NAND_STATUS_RBN_RISE_MSK (0x00000F00)
-#define TMVH_EFMC_NAND_STATUS_RBN_RISE_POS (8)
+#define TMVH_EFMC_PAGE_RW_OOB_MSK               (0x00000010)
+#define TMVH_EFMC_PAGE_RW_OOB_POS               (4)
+
+#define TMVH_EFMC_PAGE_RW_AES_MSK               (0x00000008)
+#define TMVH_EFMC_PAGE_RW_AES_POS               (3)
 
-#define TMVH_EFMC_NAND_STATUS_RBN_FALL_MSK (0x000000F0)
-#define TMVH_EFMC_NAND_STATUS_RBN_FALL_POS (4)
+#define TMVH_EFMC_PAGE_RW_ECC_MSK               (0x00000004)
+#define TMVH_EFMC_PAGE_RW_ECC_POS               (2)
 
-#define TMVH_EFMC_NAND_STATUS_RBN_MSK      (0x0000000F)
-#define TMVH_EFMC_NAND_STATUS_RBN_POS      (0)
+#define TMVH_EFMC_PAGE_RW_WRITE_PAGE_MSK        (0x00000002)
+#define TMVH_EFMC_PAGE_RW_WRITE_PAGE_POS        (1)
 
+#define TMVH_EFMC_PAGE_RW_READ_PAGE_MSK         (0x00000001)
+#define TMVH_EFMC_PAGE_RW_READ_PAGE_POS         (0)
 
 /**
- * DMA_CTRL register
+ * (Apollo, Kronos) NAND_STATUS register
  */
-#define TMVH_EFMC_DMA_CTRL_MEM_2_DMA_MSK   (0x00000002)
-#define TMVH_EFMC_DMA_CTRL_MEM_2_DMA_POS   (1)
+#define TMVH_EFMC_NAND_STATUS_RBN_RISE_MSK      (0x00000F00)
+#define TMVH_EFMC_NAND_STATUS_RBN_RISE_POS      (8)
 
-#define TMVH_EFMC_DMA_CTRL_DMA_2_MEM_MSK   (0x00000001)
-#define TMVH_EFMC_DMA_CTRL_DMA_2_MEM_POS   (0)
+#define TMVH_EFMC_NAND_STATUS_RBN_FALL_MSK      (0x000000F0)
+#define TMVH_EFMC_NAND_STATUS_RBN_FALL_POS      (4)
 
+#define TMVH_EFMC_NAND_STATUS_RBN_MSK           (0x0000000F)
+#define TMVH_EFMC_NAND_STATUS_RBN_POS           (0)
 
 /**
- * EBI_CTRL register
+ * (Apollo, Kronos) DMA_CTRL register
  */
-#define TMVH_EFMC_EBI_CTRL_TIMEOUT_MSK     (0x000003FC)
-#define TMVH_EFMC_EBI_CTRL_TIMEOUT_POS     (2)
-
-#define TMVH_EFMC_EBI_CTRL_MODE_MSK        (0x00000002)
-#define TMVH_EFMC_EBI_CTRL_MODE_POS        (1)
-
-#define TMVH_EFMC_EBI_CTRL_DEF_REQ_MSK     (0x00000001)
-#define TMVH_EFMC_EBI_CTRL_DEF_REQ_POS     (0)
+#define TMVH_EFMC_DMA_CTRL_MEM_2_DMA_MSK        (0x00000002)
+#define TMVH_EFMC_DMA_CTRL_MEM_2_DMA_POS        (1)
 
+#define TMVH_EFMC_DMA_CTRL_DMA_2_MEM_MSK        (0x00000001)
+#define TMVH_EFMC_DMA_CTRL_DMA_2_MEM_POS        (0)
 
 /**
- * AHB_LATENCY register
+ * (Apollo, Kronos) EBI_CTRL register
  */
-#define TMVH_EFMC_AHB_LATENCY_CMD_MSK      (0x00000002)
-#define TMVH_EFMC_AHB_LATENCY_CMD_POS      (1)
+#define TMVH_EFMC_EBI_CTRL_TIMEOUT_MSK          (0x000003FC)
+#define TMVH_EFMC_EBI_CTRL_TIMEOUT_POS          (2)
 
-#define TMVH_EFMC_AHB_LATENCY_RD_DATA_MSK  (0x00000001)
-#define TMVH_EFMC_AHB_LATENCY_RD_DATA_POS  (0)
+#define TMVH_EFMC_EBI_CTRL_MODE_MSK             (0x00000002)
+#define TMVH_EFMC_EBI_CTRL_MODE_POS             (1)
 
+#define TMVH_EFMC_EBI_CTRL_DEF_REQ_MSK          (0x00000001)
+#define TMVH_EFMC_EBI_CTRL_DEF_REQ_POS          (0)
 
 /**
- * APB_LATENCY register
+ * (Reserved) AHB_LATENCY register
  */
-#define TMVH_EFMC_APB_LATENCY_WS_MSK       (0x00000001)
-#define TMVH_EFMC_APB_LATENCY_WS_POS       (0)
+#define TMVH_EFMC_AHB_LATENCY_CMD_MSK           (0x00000002)
+#define TMVH_EFMC_AHB_LATENCY_CMD_POS           (1)
 
+#define TMVH_EFMC_AHB_LATENCY_RD_DATA_MSK       (0x00000001)
+#define TMVH_EFMC_AHB_LATENCY_RD_DATA_POS       (0)
 
 /**
- * APB_ERROR_GEN register
+ * (Reserved) APB_LATENCY register
  */
-#define TMVH_EFMC_APB_ERROR_GEN_WR_MSK     (0x00000002)
-#define TMVH_EFMC_APB_ERROR_GEN_WR_POS     (1)
-
-#define TMVH_EFMC_APB_ERROR_GEN_RD_MSK     (0x00000001)
-#define TMVH_EFMC_APB_ERROR_GEN_RD_POS     (0)
-
+#define TMVH_EFMC_APB_LATENCY_WS_MSK            (0x00000001)
+#define TMVH_EFMC_APB_LATENCY_WS_POS            (0)
 
 /**
- * AES_KEY1 register
+ * (Reserved) APB_ERROR_GEN register
  */
-#define TMVH_EFMC_AES_KEY1_AES_KEY_MSK     (0xFFFFFFFFU)
-#define TMVH_EFMC_AES_KEY1_AES_KEY_POS     (0)
+#define TMVH_EFMC_APB_ERROR_GEN_WR_MSK          (0x00000002)
+#define TMVH_EFMC_APB_ERROR_GEN_WR_POS          (1)
 
+#define TMVH_EFMC_APB_ERROR_GEN_RD_MSK          (0x00000001)
+#define TMVH_EFMC_APB_ERROR_GEN_RD_POS          (0)
 
 /**
- * AES_KEY2 register
+ * (Reserved) AES_KEY1 register
  */
-#define TMVH_EFMC_AES_KEY2_AES_KEY_MSK     (0xFFFFFFFFU)
-#define TMVH_EFMC_AES_KEY2_AES_KEY_POS     (0)
+#define TMVH_EFMC_AES_KEY1_AES_KEY_MSK          (0xFFFFFFFFU)
+#define TMVH_EFMC_AES_KEY1_AES_KEY_POS          (0)
 
 /**
- * AES_KEY3 register
+ * (Reserved) AES_KEY2 register
  */
-#define TMVH_EFMC_AES_KEY3_AES_KEY_MSK     (0xFFFFFFFFU)
-#define TMVH_EFMC_AES_KEY3_AES_KEY_POS     (0)
+#define TMVH_EFMC_AES_KEY2_AES_KEY_MSK          (0xFFFFFFFFU)
+#define TMVH_EFMC_AES_KEY2_AES_KEY_POS          (0)
 
 /**
- * AES_KEY4 register
+ * (Reserved) AES_KEY3 register
  */
-#define TMVH_EFMC_AES_KEY4_AES_KEY_MSK     (0xFFFFFFFFU)
-#define TMVH_EFMC_AES_KEY4_AES_KEY_POS     (0)
-
+#define TMVH_EFMC_AES_KEY3_AES_KEY_MSK          (0xFFFFFFFFU)
+#define TMVH_EFMC_AES_KEY3_AES_KEY_POS          (0)
 
 /**
- * AES_IV1 register
+ * (Reserved) AES_KEY4 register
  */
-#define TMVH_EFMC_AES_IV1_AES_IV_MSK       (0xFFFFFFFFU)
-#define TMVH_EFMC_AES_IV1_AES_IV_POS       (0)
+#define TMVH_EFMC_AES_KEY4_AES_KEY_MSK          (0xFFFFFFFFU)
+#define TMVH_EFMC_AES_KEY4_AES_KEY_POS          (0)
 
 /**
- * AES_IV2 register
+ * (Reserved) AES_IV1 register
  */
-#define TMVH_EFMC_AES_IV2_AES_IV_MSK       (0xFFFFFFFFU)
-#define TMVH_EFMC_AES_IV2_AES_IV_POS       (0)
+#define TMVH_EFMC_AES_IV1_AES_IV_MSK            (0xFFFFFFFFU)
+#define TMVH_EFMC_AES_IV1_AES_IV_POS            (0)
 
 /**
- * AES_IV3 register
+ * (Reserved) AES_IV2 register
  */
-#define TMVH_EFMC_AES_IV3_AES_IV_MSK       (0xFFFFFFFFU)
-#define TMVH_EFMC_AES_IV3_AES_IV_POS       (0)
+#define TMVH_EFMC_AES_IV2_AES_IV_MSK            (0xFFFFFFFFU)
+#define TMVH_EFMC_AES_IV2_AES_IV_POS            (0)
 
 /**
- * AES_IV4 register
+ * (Reserved) AES_IV3 register
  */
-#define TMVH_EFMC_AES_IV4_AES_IV_MSK       (0xFFFFFFFFU)
-#define TMVH_EFMC_AES_IV4_AES_IV_POS       (0)
-
+#define TMVH_EFMC_AES_IV3_AES_IV_MSK            (0xFFFFFFFFU)
+#define TMVH_EFMC_AES_IV3_AES_IV_POS            (0)
 
 /**
- * AES_STATUS register
+ * (Reserved) AES_IV4 register
  */
-#define TMVH_EFMC_AES_STATUS_ACCEPT_KEY_MSK (0x00000002)
-#define TMVH_EFMC_AES_STATUS_ACCEPT_KEY_POS (1)
+#define TMVH_EFMC_AES_IV4_AES_IV_MSK            (0xFFFFFFFFU)
+#define TMVH_EFMC_AES_IV4_AES_IV_POS            (0)
 
-#define TMVH_EFMC_AES_STATUS_ACCEPT_IN_MSK (0x00000001)
-#define TMVH_EFMC_AES_STATUS_ACCEPT_IN_POS (0)
+/**
+ * (Reserved) AES_STATUS register
+ */
+#define TMVH_EFMC_AES_STATUS_ACCEPT_KEY_MSK     (0x00000002)
+#define TMVH_EFMC_AES_STATUS_ACCEPT_KEY_POS     (1)
 
+#define TMVH_EFMC_AES_STATUS_ACCEPT_IN_MSK      (0x00000001)
+#define TMVH_EFMC_AES_STATUS_ACCEPT_IN_POS      (0)
 
 /**
- * SINGLE_READ register
+ * (Apollo, Kronos) SINGLE_READ register
  */
-#define TMVH_EFMC_SINGLE_READ_DATA_MSK    (0x0000FFFF)
-#define TMVH_EFMC_SINGLE_READ_DATA_POS    (0)
+#define TMVH_EFMC_SINGLE_READ_DATA_MSK          (0x0000FFFF)
+#define TMVH_EFMC_SINGLE_READ_DATA_POS          (0)
 
 /**
- * SINGLE_WRITE register
+ * (Apollo, Kronos) SINGLE_WRITE register
  */
-#define TMVH_EFMC_SINGLE_WRITE_DATA_MSK   (0x0000FFFF)
-#define TMVH_EFMC_SINGLE_WRITE_DATA_POS   (0)
+#define TMVH_EFMC_SINGLE_WRITE_DATA_MSK         (0x0000FFFF)
+#define TMVH_EFMC_SINGLE_WRITE_DATA_POS         (0)
 
 /**
- * DEV_TYPE0 register
+ * (Apollo, Kronos) DEV_TYPE0 register
  */
-#define TMVH_EFMC_DEV_TYPE0_PAGE_SIZE_MSK  (0x00000070)
-#define TMVH_EFMC_DEV_TYPE0_PAGE_SIZE_POS  (4)
+/* -- Kronos specific definitions starts -- */
+#define TMVH_EFMC_DEV_TYPE0_ERASED_PAGE_THRES_MSK  (0xFC000000)
+#define TMVH_EFMC_DEV_TYPE0_ERASED_PAGE_THRES_POS  (26)
+
+#define TMVH_EFMC_DEV_TYPE0_ECC_LEVEL_MSK       (0x03F00000)
+#define TMVH_EFMC_DEV_TYPE0_ECC_LEVEL_POS       (20)
+
+#define TMVH_EFMC_DEV_TYPE0_OOB_SIZE_MSK        (0x000FFF00)
+#define TMVH_EFMC_DEV_TYPE0_OOB_SIZE_POS        (8)
 
-#define TMVH_EFMC_DEV_TYPE0_WP_MSK         (0x00000008)
-#define TMVH_EFMC_DEV_TYPE0_WP_POS         (3)
+#define TMVH_EFMC_DEV_TYPE0_SUB_PAGE_SIZE_MSK   (0x00000080)
+#define TMVH_EFMC_DEV_TYPE0_SUB_PAGE_SIZE_POS   (7)
+/* -- Kronos specific definitions ends -- */
 
-#define TMVH_EFMC_DEV_TYPE0_CEN_DONT_MSK   (0x00000004)
-#define TMVH_EFMC_DEV_TYPE0_CEN_DONT_POS   (2)
+#define TMVH_EFMC_DEV_TYPE0_PAGE_SIZE_MSK       (0x00000070)
+#define TMVH_EFMC_DEV_TYPE0_PAGE_SIZE_POS       (4)
 
-#define TMVH_EFMC_DEV_TYPE0_DATA_WIDTH_MSK (0x00000003)
-#define TMVH_EFMC_DEV_TYPE0_DATA_WIDTH_POS (0)
+#define TMVH_EFMC_DEV_TYPE0_WP_MSK              (0x00000008)
+#define TMVH_EFMC_DEV_TYPE0_WP_POS              (3)
 
+#define TMVH_EFMC_DEV_TYPE0_CEN_DONT_MSK        (0x00000004)
+#define TMVH_EFMC_DEV_TYPE0_CEN_DONT_POS        (2)
+
+#define TMVH_EFMC_DEV_TYPE0_DATA_WIDTH_MSK      (0x00000003)
+#define TMVH_EFMC_DEV_TYPE0_DATA_WIDTH_POS      (0)
 
 /**
- * DEV_TIMING0 register
+ * (Apollo, Kronos) DEV_TIMING0 register
  */
-#define TMVH_EFMC_DEV_TIMING0_TCPS_MSK     (0x0F000000)
-#define TMVH_EFMC_DEV_TIMING0_TCPS_POS     (24)
-
-#define TMVH_EFMC_DEV_TIMING0_TCPH_MSK     (0x00F00000)
-#define TMVH_EFMC_DEV_TIMING0_TCPH_POS     (20)
+#define TMVH_EFMC_DEV_TIMING0_TCPS_MSK          (0x0F000000)
+#define TMVH_EFMC_DEV_TIMING0_TCPS_POS          (24)
 
-#define TMVH_EFMC_DEV_TIMING0_TCLS_MSK     (0x000F0000)
-#define TMVH_EFMC_DEV_TIMING0_TCLS_POS     (16)
+#define TMVH_EFMC_DEV_TIMING0_TCPH_MSK          (0x00F00000)
+#define TMVH_EFMC_DEV_TIMING0_TCPH_POS          (20)
 
-#define TMVH_EFMC_DEV_TIMING0_TCLH_MSK     (0x0000F000)
-#define TMVH_EFMC_DEV_TIMING0_TCLH_POS     (12)
+#define TMVH_EFMC_DEV_TIMING0_TCLS_MSK          (0x000F0000)
+#define TMVH_EFMC_DEV_TIMING0_TCLS_POS          (16)
 
-#define TMVH_EFMC_DEV_TIMING0_TALS_MSK     (0x00000F00)
-#define TMVH_EFMC_DEV_TIMING0_TALS_POS     (8)
+#define TMVH_EFMC_DEV_TIMING0_TCLH_MSK          (0x0000F000)
+#define TMVH_EFMC_DEV_TIMING0_TCLH_POS          (12)
 
-#define TMVH_EFMC_DEV_TIMING0_TALH_MSK     (0x000000F0)
-#define TMVH_EFMC_DEV_TIMING0_TALH_POS     (4)
+#define TMVH_EFMC_DEV_TIMING0_TALS_MSK          (0x00000F00)
+#define TMVH_EFMC_DEV_TIMING0_TALS_POS          (8)
 
-#define TMVH_EFMC_DEV_TIMING0_TRR_MSK      (0x0000000F)
-#define TMVH_EFMC_DEV_TIMING0_TRR_POS      (0)
-#define TMVH_EFMC_DEV_TIMING0_MAX_CYCLES   (16)
+#define TMVH_EFMC_DEV_TIMING0_TALH_MSK          (0x000000F0)
+#define TMVH_EFMC_DEV_TIMING0_TALH_POS          (4)
 
+#define TMVH_EFMC_DEV_TIMING0_TRR_MSK           (0x0000000F)
+#define TMVH_EFMC_DEV_TIMING0_TRR_POS           (0)
+#define TMVH_EFMC_DEV_TIMING0_MAX_CYCLES        (16)
 
 /**
- * DEV_TIMING1 register
+ * (Apollo, Kronos) DEV_TIMING1 register
  */
-#define TMVH_EFMC_DEV_TIMING1_TDRD_MSK (0x03C00000)
-#define TMVH_EFMC_DEV_TIMING1_TDRD_POS (22)
-
-#define TMVH_EFMC_DEV_TIMING1_TWB_MSK  (0x003F0000)
-#define TMVH_EFMC_DEV_TIMING1_TWB_POS  (16)
-#define TMVH_EFMC_DEV_TIMING1_TWB_MAX_CYCLES (64)
+#define TMVH_EFMC_DEV_TIMING1_TDRD_MSK          (0x03C00000)
+#define TMVH_EFMC_DEV_TIMING1_TDRD_POS          (22)
 
-#define TMVH_EFMC_DEV_TIMING1_TWP_MSK  (0x0000F000)
-#define TMVH_EFMC_DEV_TIMING1_TWP_POS  (12)
+#define TMVH_EFMC_DEV_TIMING1_TWB_MSK           (0x003F0000)
+#define TMVH_EFMC_DEV_TIMING1_TWB_POS           (16)
+#define TMVH_EFMC_DEV_TIMING1_TWB_MAX_CYCLES    (64)
 
-#define TMVH_EFMC_DEV_TIMING1_TWH_MSK  (0x00000F00)
-#define TMVH_EFMC_DEV_TIMING1_TWH_POS  (8)
+#define TMVH_EFMC_DEV_TIMING1_TWP_MSK           (0x0000F000)
+#define TMVH_EFMC_DEV_TIMING1_TWP_POS           (12)
 
-#define TMVH_EFMC_DEV_TIMING1_TRP_MSK  (0x000000F0)
-#define TMVH_EFMC_DEV_TIMING1_TRP_POS  (4)
+#define TMVH_EFMC_DEV_TIMING1_TWH_MSK           (0x00000F00)
+#define TMVH_EFMC_DEV_TIMING1_TWH_POS           (8)
 
-#define TMVH_EFMC_DEV_TIMING1_TRH_MSK  (0x0000000F)
-#define TMVH_EFMC_DEV_TIMING1_TRH_POS  (0)
-#define TMVH_EFMC_DEV_TIMING1_MAX_CYCLES   (16)
+#define TMVH_EFMC_DEV_TIMING1_TRP_MSK           (0x000000F0)
+#define TMVH_EFMC_DEV_TIMING1_TRP_POS           (4)
 
+#define TMVH_EFMC_DEV_TIMING1_TRH_MSK           (0x0000000F)
+#define TMVH_EFMC_DEV_TIMING1_TRH_POS           (0)
+#define TMVH_EFMC_DEV_TIMING1_MAX_CYCLES        (16)
 
 /**
- * MOD_CONFIG register
+ * (Kronos) OOB_PARTITION_N register
  */
+#define TMVH_EFMC_OOB_PARTITION_N_EXTENDED_OOB_MSK       (0xFFFF0000)
+#define TMVH_EFMC_OOB_PARTITION_N_EXTENDED_OOB_POS       (16)
 
-#define TMVH_EFMC_MOD_CONFIG_APB_LAT_MSK          (0x00000400)
-#define TMVH_EFMC_MOD_CONFIG_APB_LAT_POS          (10)
+#define TMVH_EFMC_OOB_PARTITION_N_UNPROTECTED_BYTES_MSK  (0x0000C000)
+#define TMVH_EFMC_OOB_PARTITION_N_UNPROTECTED_BYTES_POS  (14)
 
-#define TMVH_EFMC_MOD_CONFIG_APB_ERR_MSK          (0x00000200)
-#define TMVH_EFMC_MOD_CONFIG_APB_ERR_POS          (9)
+#define TMVH_EFMC_OOB_PARTITION_N_PARITY_BYTES_MSK       (0x00003F00)
+#define TMVH_EFMC_OOB_PARTITION_N_PARITY_BYTES_POS       (8)
 
-#define TMVH_EFMC_MOD_CONFIG_DATA_BUS_TYPE_MSK    (0x00000180)
-#define TMVH_EFMC_MOD_CONFIG_DATA_BUS_TYPE_POS    (7)
+#define TMVH_EFMC_OOB_PARTITION_N_PROTECTED_OOB_MIN_MSK  (0x000000FF)
+#define TMVH_EFMC_OOB_PARTITION_N_PROTECTED_OOB_MIN_POS  (0)
 
-#define TMVH_EFMC_MOD_CONFIG_DATA_BUS_LAT_MSK     (0x00000040)
-#define TMVH_EFMC_MOD_CONFIG_DATA_BUS_LAT_POS     (6)
+/**
+ * (Kronos) PAGE_RD_STATUS_FIFO register
+ */
+#define TMVH_EFMC_PAGE_RD_STATUS_FIFO_TAG_MSK            (0xFFFF0000)
+#define TMVH_EFMC_PAGE_RD_STATUS_FIFO_TAG_POS            (16)
 
-#define TMVH_EFMC_MOD_CONFIG_AES_MSK              (0x00000020)
-#define TMVH_EFMC_MOD_CONFIG_AES_POS              (5)
+#define TMVH_EFMC_PAGE_RD_STATUS_FIFO_ERASED_MSK         (0x00000400)
+#define TMVH_EFMC_PAGE_RD_STATUS_FIFO_ERASED_POS         (10)
 
-#define TMVH_EFMC_MOD_CONFIG_EBI_PIN_MSK          (0x00000010)
-#define TMVH_EFMC_MOD_CONFIG_EBI_PIN_POS          (4)
+#define TMVH_EFMC_PAGE_RD_STATUS_FIFO_ECC_OFF_MSK        (0x00000200)
+#define TMVH_EFMC_PAGE_RD_STATUS_FIFO_ECC_OFF_POS        (9)
 
-#define TMVH_EFMC_MOD_CONFIG_BOOT_NAND_MSK        (0x00000008)
-#define TMVH_EFMC_MOD_CONFIG_BOOT_NAND_POS        (3)
+#define TMVH_EFMC_PAGE_RD_STATUS_FIFO_UNCORRECTABLE_MSK  (0x00000100)
+#define TMVH_EFMC_PAGE_RD_STATUS_FIFO_UNCORRECTABLE_POS  (8)
 
-#define TMVH_EFMC_MOD_CONFIG_RST_SYNC_MSK         (0x00000004)
-#define TMVH_EFMC_MOD_CONFIG_RST_SYNC_POS         (2)
+#define TMVH_EFMC_PAGE_RD_STATUS_FIFO_CORRECTED_MSK      (0x00000080)
+#define TMVH_EFMC_PAGE_RD_STATUS_FIFO_CORRECTED_POS      (7)
 
-#define TMVH_EFMC_MOD_CONFIG_NUM_DEV_MSK          (0x00000003)
-#define TMVH_EFMC_MOD_CONFIG_NUM_DEV_POS          (0)
+#define TMVH_EFMC_PAGE_RD_STATUS_FIFO_ERROR_FREE_MSK     (0x00000040)
+#define TMVH_EFMC_PAGE_RD_STATUS_FIFO_ERROR_FREE_POS     (6)
 
+#define TMVH_EFMC_PAGE_RD_STATUS_FIFO_NUM_ERROR_MSK      (0x0000003F)
+#define TMVH_EFMC_PAGE_RD_STATUS_FIFO_NUM_ERROR_POS      (0)
 
 /**
- * INT registers
+ * (Kronos) PAGE_WR_STATUS_FIFO register
  */
+#define TMVH_EFMC_PAGE_WR_STATUS_FIFO_TAG_MSK            (0xFFFF0000)
+#define TMVH_EFMC_PAGE_WR_STATUS_FIFO_TAG_POS            (16)
 
-#define TMVH_EFMC_INT_MSK                      (0x00FFFFFF)
-#define TMVH_EFMC_INT_POS                      (0)
+/**
+ * (Kronos) PAGE_TAG register
+ */
+#define TMVH_EFMC_PAGE_TAG_TAG_MSK              (0x000000FF)
+#define TMVH_EFMC_PAGE_TAG_TAG_POS              (0)
 
+/**
+ * (Kronos) FIFO_STATUS register
+ */
+#define TMVH_EFMC_FIFO_PAGE_RD_STATUS_LEVEL_MSK (0x0000FF00)
+#define TMVH_EFMC_FIFO_PAGE_RD_STATUS_LEVEL_POS (8)
+#define TMVH_EFMC_FIFO_PAGE_WR_STATUS_LEVEL_MSK (0x00FF0000)
+#define TMVH_EFMC_FIFO_PAGE_WR_STATUS_LEVEL_POS (16)
 
 /**
- * SWRESET registers
+ * (Kronos) STATUS_FIFO_POP register
  */
+#define TMVH_EFMC_STATUS_FIFO_POP_MSK (0x00000001)
+#define TMVH_EFMC_STATUS_FIFO_POP_POS (0)
 
-#define TMVH_EFMC_SWRESET_SW_RESET_MSK         (0x00000001)
-#define TMVH_EFMC_SWRESET_SW_RESET_POS         (0)
+/**
+ * (Kronos) STATUS_FIFO_MODE register
+ */
+#define TMVH_EFMC_STATUS_FIFO_MODE_MSK (0x00000001)
+#define TMVH_EFMC_STATUS_FIFO_MODE_POS (0)
 
+/**
+ * (Kronos) CMD_ADDR_FIFO register
+ */
+#define TMVH_EFMC_CMD_ADDR_FIFO_MSK (0xFFFFFFFF)
+#define TMVH_EFMC_CMD_ADDR_FIFO_POS (0)
 
 /**
- * POWER_DOWN registers
+ * (Apollo, Kronos) MOD_CONFIG register
  */
+#define TMVH_EFMC_MOD_CONFIG_APB_LAT_MSK        (0x00000400)
+#define TMVH_EFMC_MOD_CONFIG_APB_LAT_POS        (10)
+
+#define TMVH_EFMC_MOD_CONFIG_APB_ERR_MSK        (0x00000200)
+#define TMVH_EFMC_MOD_CONFIG_APB_ERR_POS        (9)
+
+#define TMVH_EFMC_MOD_CONFIG_DATA_BUS_TYPE_MSK  (0x00000180)
+#define TMVH_EFMC_MOD_CONFIG_DATA_BUS_TYPE_POS  (7)
 
-#define TMVH_EFMC_POWER_DOWN_TIMEOUT_MSK       (0x0001FFFE)
-#define TMVH_EFMC_POWER_DOWN_TIMEOUT_POS       (1)
+#define TMVH_EFMC_MOD_CONFIG_DATA_BUS_LAT_MSK   (0x00000040)
+#define TMVH_EFMC_MOD_CONFIG_DATA_BUS_LAT_POS   (6)
 
-#define TMVH_EFMC_POWER_DOWN_POWER_DOWN_MSK    (0x00000001)
-#define TMVH_EFMC_POWER_DOWN_POWER_DOWN_POS    (0)
+#define TMVH_EFMC_MOD_CONFIG_AES_MSK            (0x00000020)
+#define TMVH_EFMC_MOD_CONFIG_AES_POS            (5)
 
+#define TMVH_EFMC_MOD_CONFIG_EBI_PIN_MSK        (0x00000010)
+#define TMVH_EFMC_MOD_CONFIG_EBI_PIN_POS        (4)
+
+#define TMVH_EFMC_MOD_CONFIG_BOOT_NAND_MSK      (0x00000008)
+#define TMVH_EFMC_MOD_CONFIG_BOOT_NAND_POS      (3)
+
+#define TMVH_EFMC_MOD_CONFIG_RST_SYNC_MSK       (0x00000004)
+#define TMVH_EFMC_MOD_CONFIG_RST_SYNC_POS       (2)
+
+#define TMVH_EFMC_MOD_CONFIG_NUM_DEV_MSK        (0x00000003)
+#define TMVH_EFMC_MOD_CONFIG_NUM_DEV_POS        (0)
+
+/**
+ * (Apollo, Kronos) INT registers
+ */
+#define TMVH_EFMC_INT_MSK                       (0x00FFFFFF)
+#define TMVH_EFMC_INT_POS                       (0)
 
 /**
- * MODID register
+ * (Apollo, Kronos) SWRESET registers
  */
-#define TMVH_EFMC_MODID_MODID_MSK           (0xFFFF0000U)
-#define TMVH_EFMC_MODID_MODID_POS           (16)
+#define TMVH_EFMC_SWRESET_SW_RESET_MSK          (0x00000001)
+#define TMVH_EFMC_SWRESET_SW_RESET_POS          (0)
 
-#define TMVH_EFMC_MODID_MAJOR_VER_MSK       (0x0000F000)
-#define TMVH_EFMC_MODID_MAJOR_VER_POS       (12)
+/**
+ * (Apollo, Kronos) POWER_DOWN registers
+ */
+#define TMVH_EFMC_POWER_DOWN_TIMEOUT_MSK        (0x0001FFFE)
+#define TMVH_EFMC_POWER_DOWN_TIMEOUT_POS        (1)
+
+#define TMVH_EFMC_POWER_DOWN_POWER_DOWN_MSK     (0x00000001)
+#define TMVH_EFMC_POWER_DOWN_POWER_DOWN_POS     (0)
+
+/**
+ * (Apollo, Kronos) MODID register
+ */
+#define TMVH_EFMC_MODID_MODID_MSK               (0xFFFF0000U)
+#define TMVH_EFMC_MODID_MODID_POS               (16)
 
-#define TMVH_EFMC_MODID_MINOR_VER_MSK       (0x00000F00)
-#define TMVH_EFMC_MODID_MINOR_VER_POS       (8)
+#define TMVH_EFMC_MODID_MAJOR_VER_MSK           (0x0000F000)
+#define TMVH_EFMC_MODID_MAJOR_VER_POS           (12)
 
-#define TMVH_EFMC_MODID_APERTURE_MSK        (0x000000FF)
-#define TMVH_EFMC_MODID_APERTURE_POS        (0)
+#define TMVH_EFMC_MODID_MINOR_VER_MSK           (0x00000F00)
+#define TMVH_EFMC_MODID_MINOR_VER_POS           (8)
 
+#define TMVH_EFMC_MODID_APERTURE_MSK            (0x000000FF)
+#define TMVH_EFMC_MODID_APERTURE_POS            (0)
 
 /**
- * EXT_MODID register
+ * (Reserved) EXT_MODID register
  */
 #define TMVH_EFMC_EXT_MODID_MODID_MSK           (0xFFFF0000U)
 #define TMVH_EFMC_EXT_MODID_MODID_POS           (16)
