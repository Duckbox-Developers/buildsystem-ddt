diff -Naurp linux-2.6.34.org/arch/arm/include/asm/hardware/ip9028.h linux-2.6.34/arch/arm/include/asm/hardware/ip9028.h
--- linux-2.6.34.org/arch/arm/include/asm/hardware/ip9028.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/arch/arm/include/asm/hardware/ip9028.h	2010-09-21 16:31:59.000000000 -0500
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#ifndef __ASM_ARM_ARCH_HARDWARE_IP9028_H
+#define __ASM_ARM_ARCH_HARDWARE_IP9028_H
+
+
+/* --------------------------------------------------------------------------
+ *  Register offsets from base address
+*  -------------------------------------------------------------------------*/
+
+#define PNX8XXX_USB_IP9028_EHCI_OFFSET		0x100
+#define PNX8XXX_USB_IP9028_USB_MODE_OFFSET	0x1A8
+#define PNX8XXX_USB_IP9028_USB_MODE_HOST	0x00000003
+
+#define PNX8XXX_USB_IP9028_USB_SBUSCFG_VAL	0x6
+#define PNX8XXX_USB_IP9028_USB_SBUSCFG_OFFSET	0x90
+
+/* defines PNX8XXX_USB_IP9028_... -> IP9028_... */
+#ifdef ABOVE_HAS_TO_BE_MIGRATE_TO_THIS_IN_EHCI_IP9028_C
+#define IP9028_USB_EHCI_OFFSET		0x100
+#define IP9028_USB_MODE_OFFSET		0x1A8
+#define IP9028_USB_MODE_HOST		0x00000003
+#endif
+
+#endif
diff -Naurp linux-2.6.34.org/drivers/usb/core/hcd.h linux-2.6.34/drivers/usb/core/hcd.h
--- linux-2.6.34.org/drivers/usb/core/hcd.h	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/usb/core/hcd.h	2010-09-21 16:31:59.000000000 -0500
@@ -84,6 +84,15 @@ struct usb_hcd {
 	struct work_struct	wakeup_work;	/* for remote wakeup */
 #endif
 
+	#ifdef CONFIG_USB_OTG
+/*
+	 * OTG controllers and transceivers need software interaction;
+	 * other external transceivers should be software-transparent
+	 */
+	struct otg_transceiver	*transceiver;
+	/* void (*start_hnp)(struct ehci_hcd *ehci,struct usb_hcd		*hcd); */
+	void (*start_hnp)(struct usb_hcd		*hcd);
+     #endif
 	/*
 	 * hardware info/state
 	 */
diff -Naurp linux-2.6.34.org/drivers/usb/core/hub.c linux-2.6.34/drivers/usb/core/hub.c
--- linux-2.6.34.org/drivers/usb/core/hub.c	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/usb/core/hub.c	2010-09-21 16:31:59.000000000 -0500
@@ -31,6 +31,16 @@
 #include "hcd.h"
 #include "hub.h"
 
+
+#ifdef CONFIG_IP9028_OTG
+#include <linux/proc_fs.h>
+struct task_struct  *hnp_thread;
+static struct semaphore	hnp_sema;	
+unsigned int  Init_HNP =0,hnp_initiator=0;
+int just_once =0;
+
+#endif
+
 /* if we are in debug mode, always announce new devices */
 #ifdef DEBUG
 #ifndef CONFIG_USB_ANNOUNCE_NEW_DEVICES
@@ -1636,6 +1646,131 @@ static inline void announce_device(struc
 #include "otg_whitelist.h"
 #endif
 
+
+#ifdef CONFIG_IP9028_OTG
+
+     
+
+	static int hnp_main_thread(void * _udev)
+	{
+        	struct usb_device *udev  = _udev;
+		int err = 0;
+		struct usb_bus			*bus = udev->bus;
+
+		for (;;) 
+		{
+			printk("hnp_main_thread: Before down_interruptible on hnp_sema\n");
+			while  (down_interruptible(&hnp_sema));			
+			
+			/* Intiate HNP */
+			
+
+			if (udev->bus->b_hnp_enable || udev->bus->is_b_host) {
+
+
+			if(Init_HNP)
+			{
+				err = usb_control_msg(udev,
+					usb_sndctrlpipe(udev, 0),
+					USB_REQ_SET_FEATURE, 0,
+					bus->b_hnp_enable
+						? USB_DEVICE_B_HNP_ENABLE
+						: USB_DEVICE_A_ALT_HNP_SUPPORT,
+					0, NULL, 0, USB_CTRL_SET_TIMEOUT);
+				if (err < 0) {
+					/* OTG MESSAGE: report errors here,
+					 * customize to match your product.
+					 */
+					dev_info(&udev->dev,
+						"can't set HNP mode; %d\n",
+						err);
+					 bus->b_hnp_enable = 0; 
+				}
+
+				 Init_HNP =0;
+
+			}
+
+		/*	printk(" Call the HNP  Port Suspend ****=%x \n",udev);	*/
+			err = usb_port_suspend(udev,PMSG_SUSPEND);
+			if (err < 0)
+				dev_dbg(&udev->dev, "HNP fail, %d\n", err);
+		}
+	
+
+		}
+	
+
+	return 0;
+
+}
+
+
+
+
+	int proc_usb_otg_start_hnp(char *buffer,char **buffer_location,off_t offset,
+                             int buffer_length, int *eof, void *data)
+	{
+
+		printk(KERN_INFO "proc_usb_otg_start_hnp \n");
+		Init_HNP = 1;
+		hnp_initiator =1;
+		up(&hnp_sema);
+
+	 	return 0;
+
+	}
+
+	int proc_usb_otg_start_hnp_1(char *buffer,char **buffer_location,off_t offset,
+                             int buffer_length, int *eof, void *data)
+	{
+
+	 	return 0;
+
+	}
+	
+	void usb_otg_hnp_create_proc_entry(void)
+	{
+	    static struct proc_dir_entry *gadget_proc_file /* ,proc_root */;
+
+	    gadget_proc_file = create_proc_entry("usb_otg_start_hnp", 0644, NULL);
+	    if (gadget_proc_file == NULL) {
+	            /*  remove_proc_entry("usb_otg_start_hnp", &gadget_proc_file); */
+	             printk(KERN_ALERT "Error: Could not initialize /proc/%s\n","usb_otg_start_srp");
+	             return;
+	    }
+	    gadget_proc_file->read_proc = proc_usb_otg_start_hnp;
+	    /* gadget_proc_file->owner = THIS_MODULE; */
+	    gadget_proc_file->mode = S_IFREG | S_IRUGO;
+	    gadget_proc_file->uid = 0;
+	    gadget_proc_file->gid = 0;
+	    gadget_proc_file->size = 100;
+
+	    gadget_proc_file = create_proc_entry("usb_otg_start_hnp_1", 0644, NULL);
+	    if (gadget_proc_file == NULL) {
+	   /*          remove_proc_entry("usb_otg_start_hnp_1", &gadget_proc_file); */
+	             printk(KERN_ALERT "Error: Could not initialize /proc/%s\n","usb_otg_start_hnp_1");
+	             return;
+	    }
+	    gadget_proc_file->read_proc = proc_usb_otg_start_hnp_1;
+	 /*   gadget_proc_file->owner = THIS_MODULE; */
+	    gadget_proc_file->mode = S_IFREG | S_IRUGO;
+	    gadget_proc_file->uid = 0;
+	    gadget_proc_file->gid = 0;
+	    gadget_proc_file->size = 100;
+
+
+
+	}
+
+	EXPORT_SYMBOL(proc_usb_otg_start_hnp);
+	EXPORT_SYMBOL(proc_usb_otg_start_hnp_1);
+	EXPORT_SYMBOL(usb_otg_hnp_create_proc_entry);
+
+
+#endif
+
+
 /**
  * usb_enumerate_device_otg - FIXME (usbcore-internal)
  * @udev: newly addressed device (in ADDRESS state)
@@ -1672,7 +1807,34 @@ static int usb_enumerate_device_otg(stru
 
 				/* enable HNP before suspend, it's simpler */
 				if (port1 == bus->otg_port)
+					{
+#ifdef CONFIG_IP9028_OTG
+
+
+					if(!just_once)
+					{
+						usb_otg_hnp_create_proc_entry();
+	
+						hnp_thread = kthread_create(hnp_main_thread, udev, "hnp_thread");	
+						if (IS_ERR(hnp_thread))
+						{	
+							printk("Unable to start the hnp_main_thread\n");		
+							return PTR_ERR(hnp_thread);	
+						}
+
+						wake_up_process(hnp_thread);
+						init_MUTEX_LOCKED(&(hnp_sema));
+
+						just_once=1;
+					}
+
+#endif
 					bus->b_hnp_enable = 1;
+
+					}
+#ifdef CONFIG_IP9028_OTG
+		if(Init_HNP)
+			{
 				err = usb_control_msg(udev,
 					usb_sndctrlpipe(udev, 0),
 					USB_REQ_SET_FEATURE, 0,
@@ -1689,6 +1851,9 @@ static int usb_enumerate_device_otg(stru
 						err);
 					bus->b_hnp_enable = 0;
 				}
+				
+			}
+#endif	
 			}
 		}
 	}
diff -Naurp linux-2.6.34.org/drivers/usb/core/hub.h linux-2.6.34/drivers/usb/core/hub.h
--- linux-2.6.34.org/drivers/usb/core/hub.h	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/usb/core/hub.h	2010-09-21 16:31:59.000000000 -0500
@@ -59,6 +59,32 @@
 #define USB_PORT_FEAT_TEST              21
 #define USB_PORT_FEAT_INDICATOR         22
 #define USB_PORT_FEAT_C_PORT_L1         23
+/*
+ * Hub Port Test Mode Selector Codes
+ * See USB 2.0 spec Table 11-24
+ */
+#define USB_PORT_TEST_J			0x01
+#define USB_PORT_TEST_K			0x02
+#define USB_PORT_TEST_SE0_NAK		0x03
+#define USB_PORT_TEST_PACKET		0x04
+#define USB_PORT_TEST_FORCE_ENABLE	0x05
+/*
+ * This is used for the Hi-Speed Host Electrical Tests
+ * on the root hub. See USB 2.0 spec 7.1.20 and the
+ * Embedded High-speed Host Electrical Test Procedure.
+ */
+#define USB_PORT_TEST_SINGLE_STEP_SET_FEATURE 0x00
+/*
+* Product IDs used to trigger USB Hi-Speed Host Electrical Tests * on the root hub. See USB 2.0 spec 7.1.20 and the * Embedded High-speed Host Electrical Test Procedure. */
+#define EHSET_TEST_SE0_NAK			0x0101
+#define EHSET_TEST_J				0x0102
+#define EHSET_TEST_K				0x0103
+#define EHSET_TEST_PACKET			0x0104
+/* Note that the FORCE ENABLE test is no longer used in the EHSET spec. */
+#define EHSET_TEST_FORCE_ENABLE			0x0105
+#define EHSET_HS_HOST_PORT_SUSPEND_RESUME	0x0106
+#define EHSET_SINGLE_STEP_GET_DEV_DESC		0x0107
+#define EHSET_SINGLE_STEP_SET_FEATURE		0x0108
 
 /*
  * Hub Status and Hub Change results
diff -Naurp linux-2.6.34.org/drivers/usb/core/Kconfig linux-2.6.34/drivers/usb/core/Kconfig
--- linux-2.6.34.org/drivers/usb/core/Kconfig	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/usb/core/Kconfig	2010-09-21 16:31:59.000000000 -0500
@@ -112,6 +112,21 @@ config USB_OTG
 	depends on USB_SUSPEND
 	default n
 
+config USB_EHSET
+	bool "Embedded High-speed Host Electrical Test Support"
+	depends on USB
+	help
+	  This option is only used if you are developing firmware for
+	  an embedded device with a Hi-speed USB Host or OTG port.
+	  If you say Y here, software support for the Embedded
+	  High-speed Host Electrical Tests will be added to the USB
+	  Host stack. This is one of the tests performed during
+	  High-speed USB Host certification testing.
+	  Please note that the USB Host Controller Driver must also
+	  support this option. For an example of how to add support
+	  for this to a USB Host Controller Driver see the EHCI driver.
+	  If you are at all unsure then say N here.
+
 
 config USB_OTG_WHITELIST
 	bool "Rely on OTG Targeted Peripherals List"
diff -Naurp linux-2.6.34.org/drivers/usb/core/otg_whitelist.h linux-2.6.34/drivers/usb/core/otg_whitelist.h
--- linux-2.6.34.org/drivers/usb/core/otg_whitelist.h	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/usb/core/otg_whitelist.h	2010-09-21 16:31:59.000000000 -0500
@@ -31,6 +31,14 @@ static struct usb_device_id whitelist_ta
 { USB_DEVICE_INFO(7, 1, 3) },
 #endif
 
+#ifdef CONFIG_IP9028_OTG
+
+/* Linux-USB file storage gadget */
+{ USB_DEVICE(0x0525, 0xa4a5), },
+
+
+#endif
+
 #ifdef	CONFIG_USB_NET_CDCETHER
 /* Linux-USB CDC Ethernet gadget */
 { USB_DEVICE(0x0525, 0xa4a1), },
diff -Naurp linux-2.6.34.org/drivers/usb/gadget/config.c linux-2.6.34/drivers/usb/gadget/config.c
--- linux-2.6.34.org/drivers/usb/gadget/config.c	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/usb/gadget/config.c	2010-09-21 16:31:59.000000000 -0500
@@ -88,7 +88,8 @@ int usb_gadget_config_buf(
 	const struct usb_config_descriptor	*config,
 	void					*buf,
 	unsigned				length,
-	const struct usb_descriptor_header	**desc
+	const struct usb_descriptor_header	**desc,
+	u8 speed
 )
 {
 	struct usb_config_descriptor		*cp = buf;
@@ -113,6 +114,14 @@ int usb_gadget_config_buf(
 	cp->bDescriptorType = USB_DT_CONFIG;
 	cp->wTotalLength = cpu_to_le16(len);
 	cp->bmAttributes |= USB_CONFIG_ATT_ONE;
+/* Other speed config doesn't have proper speed value set it properly for full speed , this can be done at udc driver too*/
+	if(speed == USB_SPEED_FULL)
+	{
+		*( (u8*)buf + 25) = 0x40;
+		*( (u8*)buf + 26) = 0x00;
+		*( (u8*)buf + 32) = 0x40;
+		*( (u8*)buf + 33) = 0x00;
+	}
 	return len;
 }
 
diff -Naurp linux-2.6.34.org/drivers/usb/gadget/epautoconf.c linux-2.6.34/drivers/usb/gadget/epautoconf.c
--- linux-2.6.34.org/drivers/usb/gadget/epautoconf.c	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/usb/gadget/epautoconf.c	2010-09-21 16:31:59.000000000 -0500
@@ -180,8 +180,13 @@ ep_matches (
 		int size = ep->maxpacket;
 
 		/* min() doesn't work on bitfields with gcc-3.5 */
+#if 0 // USB_UDC_CHECK
 		if (size > 64)
 			size = 64;
+#else
+		if (size > 512)
+			size = 512;
+#endif
 		desc->wMaxPacketSize = cpu_to_le16(size);
 	}
 	return 1;
@@ -283,7 +288,13 @@ struct usb_ep * __init usb_ep_autoconfig
 		if (ep && ep_matches (gadget, ep, desc))
 			return ep;
 #endif
-	}
+	}else {						
+		printk("==== usb_ep_autoconfig.... \n");
+		ep = find_ep (gadget, "ep1-bulk");
+		if (ep && ep_matches (gadget, ep, desc))
+			return ep;
+
+		}
 
 	/* Second, look at endpoints until an unclaimed one looks usable */
 	list_for_each_entry (ep, &gadget->ep_list, ep_list) {
diff -Naurp linux-2.6.34.org/drivers/usb/gadget/file_storage.c linux-2.6.34/drivers/usb/gadget/file_storage.c
--- linux-2.6.34.org/drivers/usb/gadget/file_storage.c	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/usb/gadget/file_storage.c	2010-09-21 16:31:59.000000000 -0500
@@ -602,7 +602,7 @@ static int populate_config_buf(struct us
 	if (!gadget_is_otg(gadget))
 		function++;
 
-	len = usb_gadget_config_buf(&config_desc, buf, EP0_BUFSIZE, function);
+	len = usb_gadget_config_buf(&config_desc, buf, EP0_BUFSIZE, function,speed);
 	((struct usb_config_descriptor *) buf)->bDescriptorType = type;
 	return len;
 }
diff -Naurp linux-2.6.34.org/drivers/usb/gadget/fsl_usb2_udc.h linux-2.6.34/drivers/usb/gadget/fsl_usb2_udc.h
--- linux-2.6.34.org/drivers/usb/gadget/fsl_usb2_udc.h	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/usb/gadget/fsl_usb2_udc.h	2010-09-21 16:31:59.000000000 -0500
@@ -32,7 +32,9 @@ struct usb_dr_device {
 	u8 res5[4];
 	u32 burstsize;		/* Master Interface Data Burst Size Register */
 	u32 txttfilltuning;	/* Transmit FIFO Tuning Controls Register */
-	u8 res6[24];
+	u8 res6[16];		// USB_UDC_CHECK
+	u32 endptnak;
+	u32 endptnaken;	
 	u32 configflag;		/* Configure Flag Register */
 	u32 portsc1;		/* Port 1 Status and Control Register */
 	u8 res7[28];
@@ -247,6 +249,7 @@ struct usb_sys_interface {
 /* otgsc Register Bit Masks */
 #define  OTGSC_CTRL_VUSB_DISCHARGE            0x00000001
 #define  OTGSC_CTRL_VUSB_CHARGE               0x00000002
+#define  OTGSC_CTRL_OTG_HAAR               0x00000004
 #define  OTGSC_CTRL_OTG_TERM                  0x00000008
 #define  OTGSC_CTRL_DATA_PULSING              0x00000010
 #define  OTGSC_STS_USB_ID                     0x00000100
diff -Naurp linux-2.6.34.org/drivers/usb/gadget/gadget_chips.h linux-2.6.34/drivers/usb/gadget/gadget_chips.h
--- linux-2.6.34.org/drivers/usb/gadget/gadget_chips.h	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/usb/gadget/gadget_chips.h	2010-09-21 16:31:59.000000000 -0500
@@ -12,6 +12,7 @@
  * yet pushed in the 2.6 mainline tree.
  */
 
+#include <mach/usbudc.h>
 #ifndef __GADGET_CHIPS_H
 #define __GADGET_CHIPS_H
 
@@ -120,6 +121,24 @@
 #define gadget_is_fsl_qe(g)	0
 #endif
 
+
+#ifdef CONFIG_USB_GADGET_IP9028
+
+	#ifdef FSL_PORT
+	//#define gadget_is_ip9028(g)	!strcmp("ip9028_otg_usb", (g)->name)		// Use FSL PORT..., Device mode
+	#define gadget_is_ip9028(g)	!strcmp("ip9028_udc_udc", (g)->name)		// Use FSL PORT..., OTG mode
+	#endif
+	#ifdef NOCONA_PORT
+	#define gadget_is_ip9028(g)	!strcmp("ci13xxx_udc_udc", (g)->name)		// Use CI PORT... Must to have 14-char name
+	#endif
+	#ifdef CI_PORT
+	#define gadget_is_ip9028(g)	!strcmp("ci13xxx_udc", (g)->name)
+	#endif
+	
+#else
+#define gadget_is_ip9028(g)	0
+#endif
+
 #ifdef CONFIG_USB_GADGET_CI13XXX
 #define gadget_is_ci13xxx(g)	(!strcmp("ci13xxx_udc", (g)->name))
 #else
diff -Naurp linux-2.6.34.org/drivers/usb/gadget/ip9028_udc.c linux-2.6.34/drivers/usb/gadget/ip9028_udc.c
--- linux-2.6.34.org/drivers/usb/gadget/ip9028_udc.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/drivers/usb/gadget/ip9028_udc.c	2010-09-21 19:35:36.000000000 -0500
@@ -0,0 +1,2831 @@
+/*
+ * Copyright (C) 2004-2007 Freescale Semicondutor, Inc. All rights reserved.
+ *
+ * Author: Li Yang <leoli@freescale.com>
+ *         Jiang Bo <tanya.jiang@freescale.com>
+ *
+ * Description:
+ * Freescale high-speed USB SOC DR module device controller driver.
+ * This can be found on MPC8349E/MPC8313E cpus.
+ * The driver is previously named as mpc_udc.  Based on bare board
+ * code from Dave Liu and Shlomi Gridish.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#undef VERBOSE
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+#include <linux/mm.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include <linux/usb/otg.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/dmapool.h>
+
+#include <asm/byteorder.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/unaligned.h>
+#include <asm/dma.h>
+
+#include <mach/usbudc.h>
+#include "fsl_usb2_udc.h"
+
+#define	DRIVER_DESC	"NXP IP9028 High-Speed USB SOC Device Controller driver == Avalon USB_UDC_CHECK"
+#define	DRIVER_AUTHOR	"Li Yang/Jiang Bo"
+#define	DRIVER_VERSION	"Apr 20, 2007"
+
+#define	DMA_ADDR_INVALID	(~(dma_addr_t)0)
+
+static const char driver_name[] = "ip9028_udc_udc";	// USB_UDC_CHECK: same as in gadget_chips.h #define gadget_is_ip9028
+static const char driver_desc[] = DRIVER_DESC;
+
+static struct usb_dr_device *dr_regs;
+static struct usb_sys_interface *usb_sys_regs;
+
+
+extern unsigned int  Is_A_host ;
+
+
+/* it is initialized in probe()  */
+static struct fsl_udc *udc_controller = NULL;
+
+static const struct usb_endpoint_descriptor
+fsl_ep0_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	0,
+	.bmAttributes =		USB_ENDPOINT_XFER_CONTROL,
+	.wMaxPacketSize =	USB_MAX_CTRL_PAYLOAD,
+};
+
+static void fsl_ep_fifo_flush(struct usb_ep *_ep);
+struct timeval  fsl_time;
+
+#ifdef CONFIG_PPC32
+#define fsl_readl(addr)		in_le32(addr)
+#define fsl_writel(val32, addr) out_le32(addr, val32)
+#else
+#define fsl_readl(addr)		readl(addr)
+#define fsl_writel(val32, addr) writel(val32, addr)
+#endif
+
+/********************************************************************
+ *	Internal Used Function
+********************************************************************/
+/*-----------------------------------------------------------------
+ * done() - retire a request; caller blocked irqs
+ * @status : request status to be set, only works when
+ *	request is still in progress.
+ *--------------------------------------------------------------*/
+static void done(struct fsl_ep *ep, struct fsl_req *req, int status)
+{
+	struct fsl_udc *udc = NULL;
+	unsigned char stopped = ep->stopped;
+	struct ep_td_struct *curr_td, *next_td;
+	int j;
+
+	udc = (struct fsl_udc *)ep->udc;
+	/* Removed the req from fsl_ep->queue */
+	list_del_init(&req->queue);
+
+	/* req.status should be set as -EINPROGRESS in ep_queue() */
+	if (req->req.status == -EINPROGRESS)
+		req->req.status = status;
+	else
+		status = req->req.status;
+
+	/* Free dtd for the request */
+	next_td = req->head;
+	for (j = 0; j < req->dtd_count; j++) {
+		curr_td = next_td;
+		if (j != req->dtd_count - 1) {
+			next_td = curr_td->next_td_virt;
+		}
+		dma_pool_free(udc->td_pool, curr_td, curr_td->td_dma);
+	}
+
+	if (req->mapped) {
+		dma_unmap_single(ep->udc->gadget.dev.parent,
+			req->req.dma, req->req.length,
+			ep_is_in(ep)
+				? DMA_TO_DEVICE
+				: DMA_FROM_DEVICE);
+		req->req.dma = DMA_ADDR_INVALID;
+		req->mapped = 0;
+	} else
+		dma_sync_single_for_cpu(ep->udc->gadget.dev.parent,
+			req->req.dma, req->req.length,
+			ep_is_in(ep)
+				? DMA_TO_DEVICE
+				: DMA_FROM_DEVICE);
+
+	if (status && (status != -ESHUTDOWN))
+		VDBG("complete %s req %p stat %d len %u/%u",
+			ep->ep.name, &req->req, status,
+			req->req.actual, req->req.length);
+
+	ep->stopped = 1;
+
+	spin_unlock(&ep->udc->lock);
+	/* complete() is from gadget layer,
+	 * eg fsg->bulk_in_complete() */
+	if (req->req.complete)
+		req->req.complete(&ep->ep, &req->req);
+
+	spin_lock(&ep->udc->lock);
+	ep->stopped = stopped;
+}
+
+/*-----------------------------------------------------------------
+ * nuke(): delete all requests related to this ep
+ * called with spinlock held
+ *--------------------------------------------------------------*/
+static void nuke(struct fsl_ep *ep, int status)
+{
+	ep->stopped = 1;
+
+	/* Flush fifo */
+	fsl_ep_fifo_flush(&ep->ep);
+
+	/* Whether this eq has request linked */
+	while (!list_empty(&ep->queue)) {
+		struct fsl_req *req = NULL;
+
+		req = list_entry(ep->queue.next, struct fsl_req, queue);
+		done(ep, req, status);
+	}
+}
+
+/*------------------------------------------------------------------
+	Internal Hardware related function
+ ------------------------------------------------------------------*/
+
+static int dr_controller_setup(struct fsl_udc *udc)
+{
+	unsigned int tmp = 0, ctrl = 0;
+	unsigned long timeout;
+#define FSL_UDC_RESET_TIMEOUT 1000
+
+	/* Stop and reset the usb controller */
+	tmp = fsl_readl(&dr_regs->usbcmd);
+	tmp &= ~USB_CMD_RUN_STOP;
+	fsl_writel(tmp, &dr_regs->usbcmd);
+
+	tmp = fsl_readl(&dr_regs->usbcmd);
+	tmp |= USB_CMD_CTRL_RESET;
+	fsl_writel(tmp, &dr_regs->usbcmd);
+
+	/* Wait for reset to complete */
+	timeout = jiffies + FSL_UDC_RESET_TIMEOUT;
+	while (fsl_readl(&dr_regs->usbcmd) & USB_CMD_CTRL_RESET) {
+		if (time_after(jiffies, timeout)) {
+			ERR("udc reset timeout!\n");
+			return -ETIMEDOUT;
+		}
+		cpu_relax();
+	}
+
+	/* Set the controller as device mode */
+	tmp = fsl_readl(&dr_regs->usbmode);
+	tmp |= USB_MODE_CTRL_MODE_DEVICE;
+	/* Disable Setup Lockout */
+	tmp |= USB_MODE_SETUP_LOCK_OFF;
+	fsl_writel(tmp, &dr_regs->usbmode);
+
+	/* Clear the setup status */
+	fsl_writel(0, &dr_regs->usbsts);
+
+	tmp = udc->ep_qh_dma;
+	tmp &= USB_EP_LIST_ADDRESS_MASK;
+	fsl_writel(tmp, &dr_regs->endpointlistaddr);
+
+	VDBG("vir[qh_base] is %p phy[qh_base] is 0x%8x reg is 0x%8x",
+		udc->ep_qh, (int)tmp,
+		fsl_readl(&dr_regs->endpointlistaddr));
+
+	/* Config control enable i/o output, cpu endian register */
+	ctrl = readl(&usb_sys_regs->control);
+	ctrl |= USB_CTRL_IOENB;
+	writel(ctrl, &usb_sys_regs->control);
+
+#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
+	/* Turn on cache snooping hardware, since some PowerPC platforms
+	 * wholly rely on hardware to deal with cache coherent. */
+
+	/* Setup Snooping for all the 4GB space */
+	tmp = SNOOP_SIZE_2GB;	/* starts from 0x0, size 2G */
+	__raw_writel(tmp, &usb_sys_regs->snoop1);
+	tmp |= 0x80000000;	/* starts from 0x8000000, size 2G */
+	__raw_writel(tmp, &usb_sys_regs->snoop2);
+#endif
+
+	// USB_UDC_CHECK, enable the ENDPOINT NAK for EP0, EP1
+	tmp = 0x00030003;	// bit0: EP0RX, bit1: EP1RX, bit16:EP0TX, bit17:EP1TX
+	fsl_writel(tmp, &dr_regs->endptnak);
+	fsl_writel(tmp, &dr_regs->endptnaken);
+
+	return 0;
+}
+
+/* Enable DR irq and set controller to run state */
+static void dr_controller_run(struct fsl_udc *udc)
+{
+	u32 temp;
+
+	/* Enable DR irq reg */
+	temp = USB_INTR_INT_EN | USB_INTR_ERR_INT_EN
+		| USB_INTR_PTC_DETECT_EN | USB_INTR_RESET_EN
+		| USB_INTR_DEVICE_SUSPEND | USB_INTR_SYS_ERR_EN;
+
+	fsl_writel(temp, &dr_regs->usbintr);
+
+	/* Clear stopped bit */
+	udc->stopped = 0;
+
+	/* Set the controller as device mode */
+	temp = fsl_readl(&dr_regs->usbmode);
+	temp |= USB_MODE_CTRL_MODE_DEVICE;
+	fsl_writel(temp, &dr_regs->usbmode);
+
+
+	/* Set controller to Run */
+	temp = fsl_readl(&dr_regs->usbcmd);
+	temp |= USB_CMD_RUN_STOP;
+	fsl_writel(temp, &dr_regs->usbcmd);
+
+	return;
+}
+
+static int reset_queues(struct fsl_udc *udc);
+static void ep0_setup(struct fsl_udc *udc);
+
+void dr_controller_run_otg_1(struct fsl_udc *udc)
+{
+	u32 temp, ctrl = 0;
+	unsigned long timeout;
+#define FSL_UDC_RESET_TIMEOUT 1000
+	
+	/* Clear stopped bit */
+	udc->stopped = 0;
+
+	/* Reset the OTG core  */
+	temp = fsl_readl(&dr_regs->usbcmd);
+	temp |= USB_CMD_CTRL_RESET;
+	fsl_writel(temp, &dr_regs->usbcmd);
+
+	/* Wait for reset to complete */
+	timeout = jiffies + FSL_UDC_RESET_TIMEOUT;
+	while (fsl_readl(&dr_regs->usbcmd) & USB_CMD_CTRL_RESET) {
+		if (time_after(jiffies, timeout)) {
+			ERR("udc reset timeout!\n");
+			return ;
+		}
+		cpu_relax();
+	}
+
+	/* Set the controller as device mode */
+	temp = fsl_readl(&dr_regs->usbmode);
+	temp |= USB_MODE_CTRL_MODE_DEVICE;
+	fsl_writel(temp, &dr_regs->usbmode);
+
+	temp = fsl_readl(&dr_regs->usbmode);
+	printk(KERN_DEBUG" dr_controller_run_otg_1 mode  = %x \n",temp);
+
+	/* Disable Setup Lockout */
+	temp |= USB_MODE_SETUP_LOCK_OFF;
+	fsl_writel(temp, &dr_regs->usbmode);
+	/* Clear the setup status */
+	fsl_writel(0, &dr_regs->usbsts);
+	temp = udc->ep_qh_dma;
+	temp &= USB_EP_LIST_ADDRESS_MASK;
+	fsl_writel(temp, &dr_regs->endpointlistaddr);
+	VDBG("vir[qh_base] is %p phy[qh_base] is 0x%8x reg is 0x%8x",
+		udc->ep_qh, (int)tmp,
+		fsl_readl(&dr_regs->endpointlistaddr));
+	/* Config control enable i/o output, cpu endian register */
+	ctrl = readl(&usb_sys_regs->control);
+	ctrl |= USB_CTRL_IOENB;
+	writel(ctrl, &usb_sys_regs->control);
+#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
+	/* Turn on cache snooping hardware, since some PowerPC platforms
+	 * wholly rely on hardware to deal with cache coherent. */
+	/* Setup Snooping for all the 4GB space */
+	temp = SNOOP_SIZE_2GB;	/* starts from 0x0, size 2G */
+	__raw_writel(temp, &usb_sys_regs->snoop1);
+	temp |= 0x80000000;	/* starts from 0x8000000, size 2G */
+	__raw_writel(temp, &usb_sys_regs->snoop2);
+#endif
+	// USB_UDC_CHECK, enable the ENDPOINT NAK for EP0, EP1
+	temp = 0x00030003;	// bit0: EP0RX, bit1: EP1RX, bit16:EP0TX, bit17:EP1TX
+	fsl_writel(temp, &dr_regs->endptnak);
+	fsl_writel(temp, &dr_regs->endptnaken);
+	/* Reset all internal used Queues */
+		ep0_setup(udc);
+	temp = fsl_readl(&dr_regs->usbintr);
+	/* Enable DR irq reg */
+	temp = USB_INTR_INT_EN | USB_INTR_ERR_INT_EN
+	| USB_INTR_PTC_DETECT_EN | USB_INTR_RESET_EN
+	| USB_INTR_DEVICE_SUSPEND | USB_INTR_SYS_ERR_EN;
+	fsl_writel(temp, &dr_regs->usbintr);
+	
+	/* Set controller to Run */
+	temp = fsl_readl(&dr_regs->usbcmd);
+	temp |= USB_CMD_RUN_STOP;
+	fsl_writel(temp, &dr_regs->usbcmd);
+
+	return;
+}
+		
+void dr_controller_run_otg(struct fsl_udc *udc)
+{
+	dr_controller_run_otg_1(udc);
+}
+
+void dr_controller_run_otg_wr(void)
+{
+	dr_controller_run_otg(udc_controller);
+}
+
+void dr_controller_run_otg_wr_1(void)
+{
+	dr_controller_run_otg_1(udc_controller);
+}
+
+static void dr_controller_stop(struct fsl_udc *udc)
+{
+	unsigned int tmp;
+
+	/* disable all INTR */
+	fsl_writel(0, &dr_regs->usbintr);
+
+	/* Set stopped bit for isr */
+	udc->stopped = 1;
+
+	/* disable IO output */
+/*	usb_sys_regs->control = 0; */
+
+	/* set controller to Stop */
+	tmp = fsl_readl(&dr_regs->usbcmd);
+	tmp &= ~USB_CMD_RUN_STOP;
+	fsl_writel(tmp, &dr_regs->usbcmd);
+
+	return;
+}
+
+static void dr_ep_setup(unsigned char ep_num, unsigned char dir,
+			unsigned char ep_type)
+{
+	unsigned int tmp_epctrl = 0;
+
+	tmp_epctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);
+	if (dir) {
+		if (ep_num)
+			tmp_epctrl |= EPCTRL_TX_DATA_TOGGLE_RST;
+		tmp_epctrl |= EPCTRL_TX_ENABLE;
+		tmp_epctrl |= ((unsigned int)(ep_type)
+				<< EPCTRL_TX_EP_TYPE_SHIFT);
+	} else {
+		if (ep_num)
+			tmp_epctrl |= EPCTRL_RX_DATA_TOGGLE_RST;
+		tmp_epctrl |= EPCTRL_RX_ENABLE;
+		tmp_epctrl |= ((unsigned int)(ep_type)
+				<< EPCTRL_RX_EP_TYPE_SHIFT);
+	}
+
+	fsl_writel(tmp_epctrl, &dr_regs->endptctrl[ep_num]);
+}
+
+static void
+dr_ep_change_stall(unsigned char ep_num, unsigned char dir, int value)
+{
+	u32 tmp_epctrl = 0;
+
+	tmp_epctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);
+
+	if (value) {
+		/* set the stall bit */
+		if (dir)
+			tmp_epctrl |= EPCTRL_TX_EP_STALL;
+		else
+			tmp_epctrl |= EPCTRL_RX_EP_STALL;
+	} else {
+		/* clear the stall bit and reset data toggle */
+		if (dir) {
+			tmp_epctrl &= ~EPCTRL_TX_EP_STALL;
+			tmp_epctrl |= EPCTRL_TX_DATA_TOGGLE_RST;
+		} else {
+			tmp_epctrl &= ~EPCTRL_RX_EP_STALL;
+			tmp_epctrl |= EPCTRL_RX_DATA_TOGGLE_RST;
+		}
+	}
+	fsl_writel(tmp_epctrl, &dr_regs->endptctrl[ep_num]);
+}
+
+/* Get stall status of a specific ep
+   Return: 0: not stalled; 1:stalled */
+static int dr_ep_get_stall(unsigned char ep_num, unsigned char dir)
+{
+	u32 epctrl;
+
+	epctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);
+	if (dir)
+		return (epctrl & EPCTRL_TX_EP_STALL) ? 1 : 0;
+	else
+		return (epctrl & EPCTRL_RX_EP_STALL) ? 1 : 0;
+}
+
+/********************************************************************
+	Internal Structure Build up functions
+********************************************************************/
+
+/*------------------------------------------------------------------
+* struct_ep_qh_setup(): set the Endpoint Capabilites field of QH
+ * @zlt: Zero Length Termination Select (1: disable; 0: enable)
+ * @mult: Mult field
+ ------------------------------------------------------------------*/
+static void struct_ep_qh_setup(struct fsl_udc *udc, unsigned char ep_num,
+		unsigned char dir, unsigned char ep_type,
+		unsigned int max_pkt_len,
+		unsigned int zlt, unsigned char mult)
+{
+	struct ep_queue_head *p_QH = &udc->ep_qh[2 * ep_num + dir];
+	unsigned int tmp = 0;
+
+	/* set the Endpoint Capabilites in QH */
+	switch (ep_type) {
+	case USB_ENDPOINT_XFER_CONTROL:
+		/* Interrupt On Setup (IOS). for control ep  */
+		tmp = (max_pkt_len << EP_QUEUE_HEAD_MAX_PKT_LEN_POS)
+			| EP_QUEUE_HEAD_IOS;
+		break;
+	case USB_ENDPOINT_XFER_ISOC:
+		tmp = (max_pkt_len << EP_QUEUE_HEAD_MAX_PKT_LEN_POS)
+			| (mult << EP_QUEUE_HEAD_MULT_POS);
+		break;
+	case USB_ENDPOINT_XFER_BULK:
+	case USB_ENDPOINT_XFER_INT:
+		tmp = max_pkt_len << EP_QUEUE_HEAD_MAX_PKT_LEN_POS;
+		break;
+	default:
+		VDBG("error ep type is %d", ep_type);
+		return;
+	}
+	if (zlt)
+		tmp |= EP_QUEUE_HEAD_ZLT_SEL;
+
+	p_QH->max_pkt_length = cpu_to_le32(tmp);
+	p_QH->next_dtd_ptr = 1;
+	p_QH->size_ioc_int_sts = 0;
+
+	return;
+}
+
+/* Setup qh structure and ep register for ep0. */
+static void ep0_setup(struct fsl_udc *udc)
+{
+	/* the intialization of an ep includes: fields in QH, Regs,
+	 * fsl_ep struct */
+	struct_ep_qh_setup(udc, 0, USB_RECV, USB_ENDPOINT_XFER_CONTROL,
+			USB_MAX_CTRL_PAYLOAD, 0, 0);
+	struct_ep_qh_setup(udc, 0, USB_SEND, USB_ENDPOINT_XFER_CONTROL,
+			USB_MAX_CTRL_PAYLOAD, 0, 0);
+	dr_ep_setup(0, USB_RECV, USB_ENDPOINT_XFER_CONTROL);
+	dr_ep_setup(0, USB_SEND, USB_ENDPOINT_XFER_CONTROL);
+
+	return;
+
+}
+
+/***********************************************************************
+		Endpoint Management Functions
+***********************************************************************/
+
+/*-------------------------------------------------------------------------
+ * when configurations are set, or when interface settings change
+ * for example the do_set_interface() in gadget layer,
+ * the driver will enable or disable the relevant endpoints
+ * ep0 doesn't use this routine. It is always enabled.
+-------------------------------------------------------------------------*/
+static int fsl_ep_enable(struct usb_ep *_ep,
+		const struct usb_endpoint_descriptor *desc)
+{
+	struct fsl_udc *udc = NULL;
+	struct fsl_ep *ep = NULL;
+	unsigned short max = 0;
+	unsigned char mult = 0, zlt;
+	int retval = -EINVAL;
+	unsigned long flags = 0;
+
+	ep = container_of(_ep, struct fsl_ep, ep);
+
+	/* catch various bogus parameters */
+	if (!_ep || !desc || ep->desc
+			|| (desc->bDescriptorType != USB_DT_ENDPOINT))
+		return -EINVAL;
+
+	udc = ep->udc;
+
+	if (!udc->driver || (udc->gadget.speed == USB_SPEED_UNKNOWN))
+		return -ESHUTDOWN;
+
+	max = le16_to_cpu(desc->wMaxPacketSize);
+
+	/* Disable automatic zlp generation.  Driver is reponsible to indicate
+	 * explicitly through req->req.zero.  This is needed to enable multi-td
+	 * request. */
+	zlt = 1;
+
+	/* Assume the max packet size from gadget is always correct */
+	switch (desc->bmAttributes & 0x03) {
+	case USB_ENDPOINT_XFER_CONTROL:
+	case USB_ENDPOINT_XFER_BULK:
+	case USB_ENDPOINT_XFER_INT:
+		/* mult = 0.  Execute N Transactions as demonstrated by
+		 * the USB variable length packet protocol where N is
+		 * computed using the Maximum Packet Length (dQH) and
+		 * the Total Bytes field (dTD) */
+		mult = 0;
+		break;
+	case USB_ENDPOINT_XFER_ISOC:
+		/* Calculate transactions needed for high bandwidth iso */
+		mult = (unsigned char)(1 + ((max >> 11) & 0x03));
+		max = max & 0x7ff;	/* bit 0~10 */
+		/* 3 transactions at most */
+		if (mult > 3)
+			goto en_done;
+		break;
+	default:
+		goto en_done;
+	}
+
+	spin_lock_irqsave(&udc->lock, flags);
+	ep->ep.maxpacket = max;
+	ep->desc = desc;
+	ep->stopped = 0;
+
+	/* Controller related setup */
+	/* Init EPx Queue Head (Ep Capabilites field in QH
+	 * according to max, zlt, mult) */
+	struct_ep_qh_setup(udc, (unsigned char) ep_index(ep),
+			(unsigned char) ((desc->bEndpointAddress & USB_DIR_IN)
+					?  USB_SEND : USB_RECV),
+			(unsigned char) (desc->bmAttributes
+					& USB_ENDPOINT_XFERTYPE_MASK),
+			max, zlt, mult);
+
+	/* Init endpoint ctrl register */
+	dr_ep_setup((unsigned char) ep_index(ep),
+			(unsigned char) ((desc->bEndpointAddress & USB_DIR_IN)
+					? USB_SEND : USB_RECV),
+			(unsigned char) (desc->bmAttributes
+					& USB_ENDPOINT_XFERTYPE_MASK));
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+	retval = 0;
+
+	VDBG("enabled %s (ep%d%s) maxpacket %d",ep->ep.name,
+			ep->desc->bEndpointAddress & 0x0f,
+			(desc->bEndpointAddress & USB_DIR_IN)
+				? "in" : "out", max);
+en_done:
+	return retval;
+}
+
+/*---------------------------------------------------------------------
+ * @ep : the ep being unconfigured. May not be ep0
+ * Any pending and uncomplete req will complete with status (-ESHUTDOWN)
+*---------------------------------------------------------------------*/
+static int fsl_ep_disable(struct usb_ep *_ep)
+{
+	struct fsl_udc *udc = NULL;
+	struct fsl_ep *ep = NULL;
+	unsigned long flags = 0;
+	u32 epctrl;
+	int ep_num;
+
+	ep = container_of(_ep, struct fsl_ep, ep);
+	if (!_ep || !ep->desc) {
+		VDBG("%s not enabled", _ep ? ep->ep.name : NULL);
+		return -EINVAL;
+	}
+
+	/* disable ep on controller */
+	ep_num = ep_index(ep);
+	epctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);
+	if (ep_is_in(ep))
+		epctrl &= ~EPCTRL_TX_ENABLE;
+	else
+		epctrl &= ~EPCTRL_RX_ENABLE;
+	fsl_writel(epctrl, &dr_regs->endptctrl[ep_num]);
+
+	udc = (struct fsl_udc *)ep->udc;
+	spin_lock_irqsave(&udc->lock, flags);
+
+	/* nuke all pending requests (does flush) */
+	nuke(ep, -ESHUTDOWN);
+
+	ep->desc = NULL;
+	ep->stopped = 1;
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	VDBG("disabled %s OK", _ep->name);
+	return 0;
+}
+
+/*---------------------------------------------------------------------
+ * allocate a request object used by this endpoint
+ * the main operation is to insert the req->queue to the eq->queue
+ * Returns the request, or null if one could not be allocated
+*---------------------------------------------------------------------*/
+static struct usb_request *
+fsl_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)
+{
+	struct fsl_req *req = NULL;
+
+	req = kzalloc(sizeof *req, gfp_flags);
+	if (!req)
+		return NULL;
+
+	req->req.dma = DMA_ADDR_INVALID;
+	INIT_LIST_HEAD(&req->queue);
+
+	return &req->req;
+}
+
+static void fsl_free_request(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct fsl_req *req = NULL;
+
+	req = container_of(_req, struct fsl_req, req);
+
+	if (_req)
+		kfree(req);
+}
+
+/*-------------------------------------------------------------------------*/
+static void fsl_queue_td(struct fsl_ep *ep, struct fsl_req *req)
+{
+	int i = ep_index(ep) * 2 + ep_is_in(ep);
+	u32 temp, bitmask, tmp_stat;
+	struct ep_queue_head *dQH = &ep->udc->ep_qh[i];
+
+	
+
+	bitmask = ep_is_in(ep)
+		? (1 << (ep_index(ep) + 16))
+		: (1 << (ep_index(ep)));
+
+	/* check if the pipe is empty */
+	if (!(list_empty(&ep->queue))) {
+		/* Add td to the end */
+		struct fsl_req *lastreq;
+		lastreq = list_entry(ep->queue.prev, struct fsl_req, queue);
+		lastreq->tail->next_td_ptr =
+			cpu_to_le32(req->head->td_dma & DTD_ADDR_MASK);
+		/* Read prime bit, if 1 goto done */
+		if (fsl_readl(&dr_regs->endpointprime) & bitmask)
+			goto out;
+
+		do {
+			/* Set ATDTW bit in USBCMD */
+			temp = fsl_readl(&dr_regs->usbcmd);
+			fsl_writel(temp | USB_CMD_ATDTW, &dr_regs->usbcmd);
+
+			/* Read correct status bit */
+			tmp_stat = fsl_readl(&dr_regs->endptstatus) & bitmask;
+
+		} while (!(fsl_readl(&dr_regs->usbcmd) & USB_CMD_ATDTW));
+
+		/* Write ATDTW bit to 0 */
+		temp = fsl_readl(&dr_regs->usbcmd);
+		fsl_writel(temp & ~USB_CMD_ATDTW, &dr_regs->usbcmd);
+
+		if (tmp_stat)
+			goto out;
+	}
+
+	/* Write dQH next pointer and terminate bit to 0 */
+	temp = req->head->td_dma & EP_QUEUE_HEAD_NEXT_POINTER_MASK;
+	dQH->next_dtd_ptr = cpu_to_le32(temp);
+
+	/* Clear active and halt bit */
+	temp = cpu_to_le32(~(EP_QUEUE_HEAD_STATUS_ACTIVE
+			| EP_QUEUE_HEAD_STATUS_HALT));
+	dQH->size_ioc_int_sts &= temp;
+
+	/* Ensure that updates to the QH will occure before priming. */
+	wmb();
+
+	/* Prime endpoint by writing 1 to ENDPTPRIME */
+	temp = ep_is_in(ep)
+		? (1 << (ep_index(ep) + 16))
+		: (1 << (ep_index(ep)));
+	fsl_writel(temp, &dr_regs->endpointprime);
+out:
+	return;
+}
+
+/* Fill in the dTD structure
+ * @req: request that the transfer belongs to
+ * @length: return actually data length of the dTD
+ * @dma: return dma address of the dTD
+ * @is_last: return flag if it is the last dTD of the request
+ * return: pointer to the built dTD */
+static struct ep_td_struct *fsl_build_dtd(struct fsl_req *req, unsigned *length,
+		dma_addr_t *dma, int *is_last)
+{
+	u32 swap_temp;
+	struct ep_td_struct *dtd;
+
+	/* how big will this transfer be? */
+	*length = min(req->req.length - req->req.actual,
+			(unsigned)EP_MAX_LENGTH_TRANSFER);
+
+	dtd = dma_pool_alloc(udc_controller->td_pool, GFP_KERNEL, dma);
+	if (dtd == NULL)
+		return dtd;
+
+	dtd->td_dma = *dma;
+	/* Clear reserved field */
+	swap_temp = cpu_to_le32(dtd->size_ioc_sts);
+	swap_temp &= ~DTD_RESERVED_FIELDS;
+	dtd->size_ioc_sts = cpu_to_le32(swap_temp);
+
+	/* Init all of buffer page pointers */
+	swap_temp = (u32) (req->req.dma + req->req.actual);
+	dtd->buff_ptr0 = cpu_to_le32(swap_temp);
+	dtd->buff_ptr1 = cpu_to_le32(swap_temp + 0x1000);
+	dtd->buff_ptr2 = cpu_to_le32(swap_temp + 0x2000);
+	dtd->buff_ptr3 = cpu_to_le32(swap_temp + 0x3000);
+	dtd->buff_ptr4 = cpu_to_le32(swap_temp + 0x4000);
+
+	req->req.actual += *length;
+
+	/* zlp is needed if req->req.zero is set */
+	if (req->req.zero) {
+		if (*length == 0 || (*length % req->ep->ep.maxpacket) != 0)
+			*is_last = 1;
+		else
+			*is_last = 0;
+	} else if (req->req.length == req->req.actual)
+		*is_last = 1;
+	else
+		*is_last = 0;
+
+	if ((*is_last) == 0)
+		VDBG("multi-dtd request!");
+	/* Fill in the transfer size; set active bit */
+	swap_temp = ((*length << DTD_LENGTH_BIT_POS) | DTD_STATUS_ACTIVE);
+
+	/* Enable interrupt for the last dtd of a request */
+	if (*is_last && !req->req.no_interrupt)
+		swap_temp |= DTD_IOC;
+
+	dtd->size_ioc_sts = cpu_to_le32(swap_temp);
+
+	wmb();
+
+	VDBG("length = %d address= 0x%x", *length, (int)*dma);
+
+	return dtd;
+}
+
+/* Generate dtd chain for a request */
+static int fsl_req_to_dtd(struct fsl_req *req)
+{
+	unsigned	count;
+	int		is_last;
+	int		is_first =1;
+	struct ep_td_struct	*last_dtd = NULL, *dtd;
+	dma_addr_t dma;
+
+	do {
+		dtd = fsl_build_dtd(req, &count, &dma, &is_last);
+		if (dtd == NULL)
+			return -ENOMEM;
+
+		if (is_first) {
+			is_first = 0;
+			req->head = dtd;
+		} else {
+			last_dtd->next_td_ptr = cpu_to_le32(dma);
+			last_dtd->next_td_virt = dtd;
+		}
+		last_dtd = dtd;
+
+		req->dtd_count++;
+	} while (!is_last);
+
+	dtd->next_td_ptr = cpu_to_le32(DTD_NEXT_TERMINATE);
+
+	req->tail = dtd;
+
+	return 0;
+}
+
+/* queues (submits) an I/O request to an endpoint */
+static int
+fsl_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
+{
+	struct fsl_ep *ep = container_of(_ep, struct fsl_ep, ep);
+	struct fsl_req *req = container_of(_req, struct fsl_req, req);
+	struct fsl_udc *udc;
+	unsigned long flags;
+	int is_iso = 0;
+
+	/* catch various bogus parameters */
+	if (!_req || !req->req.complete || !req->req.buf
+			|| !list_empty(&req->queue)) {
+		VDBG("%s, bad params", __func__);
+		return -EINVAL;
+	}
+	if (unlikely(!_ep || !ep->desc)) {
+		VDBG("%s, bad ep", __func__);
+		return -EINVAL;
+	}
+	if (ep->desc->bmAttributes == USB_ENDPOINT_XFER_ISOC) {
+		if (req->req.length > ep->ep.maxpacket)
+			return -EMSGSIZE;
+		is_iso = 1;
+	}
+
+	udc = ep->udc;
+	if (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN)
+		return -ESHUTDOWN;
+
+	req->ep = ep;
+
+	/* map virtual address to hardware */
+	if (req->req.dma == DMA_ADDR_INVALID) {
+		req->req.dma = dma_map_single(ep->udc->gadget.dev.parent,
+					req->req.buf,
+					req->req.length, ep_is_in(ep)
+						? DMA_TO_DEVICE
+						: DMA_FROM_DEVICE);
+		req->mapped = 1;
+	} else {
+		dma_sync_single_for_device(ep->udc->gadget.dev.parent,
+					req->req.dma, req->req.length,
+					ep_is_in(ep)
+						? DMA_TO_DEVICE
+						: DMA_FROM_DEVICE);
+		req->mapped = 0;
+	}
+
+	req->req.status = -EINPROGRESS;
+	req->req.actual = 0;
+	req->dtd_count = 0;
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	/* build dtds and push them to device queue */
+	if (!fsl_req_to_dtd(req)) {
+		fsl_queue_td(ep, req);
+	} else {
+		spin_unlock_irqrestore(&udc->lock, flags);
+		return -ENOMEM;
+	}
+
+	/* Update ep0 state */
+	if ((ep_index(ep) == 0))
+		udc->ep0_state = DATA_STATE_XMIT;
+
+	/* irq handler advances the queue */
+	if (req != NULL)
+		list_add_tail(&req->queue, &ep->queue);
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return 0;
+}
+
+/* dequeues (cancels, unlinks) an I/O request from an endpoint */
+static int fsl_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct fsl_ep *ep = container_of(_ep, struct fsl_ep, ep);
+	struct fsl_req *req;
+	unsigned long flags;
+	int ep_num, stopped, ret = 0;
+	u32 epctrl;
+
+	if (!_ep || !_req)
+		return -EINVAL;
+
+	spin_lock_irqsave(&ep->udc->lock, flags);
+	stopped = ep->stopped;
+
+	/* Stop the ep before we deal with the queue */
+	ep->stopped = 1;
+	ep_num = ep_index(ep);
+	epctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);
+	if (ep_is_in(ep))
+		epctrl &= ~EPCTRL_TX_ENABLE;
+	else
+		epctrl &= ~EPCTRL_RX_ENABLE;
+	fsl_writel(epctrl, &dr_regs->endptctrl[ep_num]);
+
+	/* make sure it's actually queued on this endpoint */
+	list_for_each_entry(req, &ep->queue, queue) {
+		if (&req->req == _req)
+			break;
+	}
+	if (&req->req != _req) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* The request is in progress, or completed but not dequeued */
+	if (ep->queue.next == &req->queue) {
+		_req->status = -ECONNRESET;
+		fsl_ep_fifo_flush(_ep);	/* flush current transfer */
+
+		/* The request isn't the last request in this ep queue */
+		if (req->queue.next != &ep->queue) {
+			struct ep_queue_head *qh;
+			struct fsl_req *next_req;
+
+			qh = ep->qh;
+			next_req = list_entry(req->queue.next, struct fsl_req,
+					queue);
+
+			/* Point the QH to the first TD of next request */
+			fsl_writel((u32) next_req->head, &qh->curr_dtd_ptr);
+		}
+
+		/* The request hasn't been processed, patch up the TD chain */
+	} else {
+		struct fsl_req *prev_req;
+
+		prev_req = list_entry(req->queue.prev, struct fsl_req, queue);
+		fsl_writel(fsl_readl(&req->tail->next_td_ptr),
+				&prev_req->tail->next_td_ptr);
+
+	}
+
+	done(ep, req, -ECONNRESET);
+
+	/* Enable EP */
+out:	epctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);
+	if (ep_is_in(ep))
+		epctrl |= EPCTRL_TX_ENABLE;
+	else
+		epctrl |= EPCTRL_RX_ENABLE;
+	fsl_writel(epctrl, &dr_regs->endptctrl[ep_num]);
+	ep->stopped = stopped;
+
+	spin_unlock_irqrestore(&ep->udc->lock, flags);
+	return ret;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/*-----------------------------------------------------------------
+ * modify the endpoint halt feature
+ * @ep: the non-isochronous endpoint being stalled
+ * @value: 1--set halt  0--clear halt
+ * Returns zero, or a negative error code.
+*----------------------------------------------------------------*/
+static int fsl_ep_set_halt(struct usb_ep *_ep, int value)
+{
+	struct fsl_ep *ep = NULL;
+	unsigned long flags = 0;
+	int status = -EOPNOTSUPP;	/* operation not supported */
+	unsigned char ep_dir = 0, ep_num = 0;
+	struct fsl_udc *udc = NULL;
+
+	ep = container_of(_ep, struct fsl_ep, ep);
+	udc = ep->udc;
+	if (!_ep || !ep->desc) {
+		status = -EINVAL;
+		goto out;
+	}
+
+	if (ep->desc->bmAttributes == USB_ENDPOINT_XFER_ISOC) {
+		status = -EOPNOTSUPP;
+		goto out;
+	}
+
+	/* Attempt to halt IN ep will fail if any transfer requests
+	 * are still queue */
+	if (value && ep_is_in(ep) && !list_empty(&ep->queue)) {
+		status = -EAGAIN;
+		goto out;
+	}
+
+	status = 0;
+	ep_dir = ep_is_in(ep) ? USB_SEND : USB_RECV;
+	ep_num = (unsigned char)(ep_index(ep));
+	spin_lock_irqsave(&ep->udc->lock, flags);
+	dr_ep_change_stall(ep_num, ep_dir, value);
+	spin_unlock_irqrestore(&ep->udc->lock, flags);
+
+	if (ep_index(ep) == 0) {
+		udc->ep0_state = WAIT_FOR_SETUP;
+		udc->ep0_dir = 0;
+	}
+out:
+	VDBG(" %s %s halt stat %d", ep->ep.name,
+			value ?  "set" : "clear", status);
+
+	return status;
+}
+
+static void fsl_ep_fifo_flush(struct usb_ep *_ep)
+{
+	struct fsl_ep *ep;
+	int ep_num, ep_dir;
+	u32 bits;
+	unsigned long timeout;
+#define FSL_UDC_FLUSH_TIMEOUT 1000
+
+	if (!_ep) {
+		return;
+	} else {
+		ep = container_of(_ep, struct fsl_ep, ep);
+		if (!ep->desc)
+			return;
+	}
+	ep_num = ep_index(ep);
+	ep_dir = ep_is_in(ep) ? USB_SEND : USB_RECV;
+
+	if (ep_num == 0)
+		bits = (1 << 16) | 1;
+	else if (ep_dir == USB_SEND)
+		bits = 1 << (16 + ep_num);
+	else
+		bits = 1 << ep_num;
+
+	timeout = jiffies + FSL_UDC_FLUSH_TIMEOUT;
+	do {
+		fsl_writel(bits, &dr_regs->endptflush);
+
+		/* Wait until flush complete */
+		while (fsl_readl(&dr_regs->endptflush)) {
+			if (time_after(jiffies, timeout)) {
+				ERR("ep flush timeout\n");
+				return;
+			}
+			cpu_relax();
+		}
+		/* See if we need to flush again */
+	} while (fsl_readl(&dr_regs->endptstatus) & bits);
+}
+
+static struct usb_ep_ops fsl_ep_ops = {
+	.enable = fsl_ep_enable,
+	.disable = fsl_ep_disable,
+
+	.alloc_request = fsl_alloc_request,
+	.free_request = fsl_free_request,
+
+	.queue = fsl_ep_queue,
+	.dequeue = fsl_ep_dequeue,
+
+	.set_halt = fsl_ep_set_halt,
+	.fifo_flush = fsl_ep_fifo_flush,	/* flush fifo */
+};
+
+/*-------------------------------------------------------------------------
+		Gadget Driver Layer Operations
+-------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------
+ * Get the current frame number (from DR frame_index Reg )
+ *----------------------------------------------------------------------*/
+static int fsl_get_frame(struct usb_gadget *gadget)
+{
+	return (int)(fsl_readl(&dr_regs->frindex) & USB_FRINDEX_MASKS);
+}
+
+/*-----------------------------------------------------------------------
+ * Tries to wake up the host connected to this gadget
+ -----------------------------------------------------------------------*/
+static int fsl_wakeup(struct usb_gadget *gadget)
+{
+	struct fsl_udc *udc = container_of(gadget, struct fsl_udc, gadget);
+	u32 portsc;
+
+	/* Remote wakeup feature not enabled by host */
+	if (!udc->remote_wakeup)
+		return -ENOTSUPP;
+
+	portsc = fsl_readl(&dr_regs->portsc1);
+	/* not suspended? */
+	if (!(portsc & PORTSCX_PORT_SUSPEND))
+		return 0;
+	/* trigger force resume */
+	portsc |= PORTSCX_PORT_FORCE_RESUME;
+	fsl_writel(portsc, &dr_regs->portsc1);
+	return 0;
+}
+
+static int can_pullup(struct fsl_udc *udc)
+{
+	return udc->driver && udc->softconnect && udc->vbus_active;
+}
+
+/* Notify controller that VBUS is powered, Called by whatever
+   detects VBUS sessions */
+static int fsl_vbus_session(struct usb_gadget *gadget, int is_active)
+{
+	struct fsl_udc	*udc;
+	unsigned long	flags;
+
+	udc = container_of(gadget, struct fsl_udc, gadget);
+	spin_lock_irqsave(&udc->lock, flags);
+	VDBG("VBUS %s", is_active ? "on" : "off");
+	udc->vbus_active = (is_active != 0);
+	if (can_pullup(udc))
+		fsl_writel((fsl_readl(&dr_regs->usbcmd) | USB_CMD_RUN_STOP),
+				&dr_regs->usbcmd);
+	else
+		fsl_writel((fsl_readl(&dr_regs->usbcmd) & ~USB_CMD_RUN_STOP),
+				&dr_regs->usbcmd);
+	spin_unlock_irqrestore(&udc->lock, flags);
+	return 0;
+}
+
+/* constrain controller's VBUS power usage
+ * This call is used by gadget drivers during SET_CONFIGURATION calls,
+ * reporting how much power the device may consume.  For example, this
+ * could affect how quickly batteries are recharged.
+ *
+ * Returns zero on success, else negative errno.
+ */
+static int fsl_vbus_draw(struct usb_gadget *gadget, unsigned mA)
+{
+	struct fsl_udc *udc;
+
+	udc = container_of(gadget, struct fsl_udc, gadget);
+	if (udc->transceiver)
+		return otg_set_power(udc->transceiver, mA);
+	return -ENOTSUPP;
+}
+
+/* Change Data+ pullup status
+ * this func is used by usb_gadget_connect/disconnet
+ */
+static int fsl_pullup(struct usb_gadget *gadget, int is_on)
+{
+	struct fsl_udc *udc;
+
+	udc = container_of(gadget, struct fsl_udc, gadget);
+	udc->softconnect = (is_on != 0);
+	if (can_pullup(udc))
+		fsl_writel((fsl_readl(&dr_regs->usbcmd) | USB_CMD_RUN_STOP),
+				&dr_regs->usbcmd);
+	else
+		fsl_writel((fsl_readl(&dr_regs->usbcmd) & ~USB_CMD_RUN_STOP),
+				&dr_regs->usbcmd);
+
+	return 0;
+}
+
+/* defined in gadget.h */
+static struct usb_gadget_ops fsl_gadget_ops = {
+	.get_frame = fsl_get_frame,
+	.wakeup = fsl_wakeup,
+/*	.set_selfpowered = fsl_set_selfpowered,	*/ /* Always selfpowered */
+	.vbus_session = fsl_vbus_session,
+	.vbus_draw = fsl_vbus_draw,
+	.pullup = fsl_pullup,
+};
+
+/* Set protocol stall on ep0, protocol stall will automatically be cleared
+   on new transaction */
+static void ep0stall(struct fsl_udc *udc)
+{
+	u32 tmp;
+
+	/* must set tx and rx to stall at the same time */
+	tmp = fsl_readl(&dr_regs->endptctrl[0]);
+	tmp |= EPCTRL_TX_EP_STALL | EPCTRL_RX_EP_STALL;
+	fsl_writel(tmp, &dr_regs->endptctrl[0]);
+	udc->ep0_state = WAIT_FOR_SETUP;
+	udc->ep0_dir = 0;
+}
+
+/* Prime a status phase for ep0 */
+static int ep0_prime_status(struct fsl_udc *udc, int direction)
+{
+	struct fsl_req *req = udc->status_req;
+	struct fsl_ep *ep;
+
+	if (direction == EP_DIR_IN)
+		udc->ep0_dir = USB_DIR_IN;
+	else
+		udc->ep0_dir = USB_DIR_OUT;
+
+	ep = &udc->eps[0];
+	udc->ep0_state = WAIT_FOR_OUT_STATUS;
+
+	req->ep = ep;
+	req->req.length = 0;
+	req->req.status = -EINPROGRESS;
+	req->req.actual = 0;
+	req->req.complete = NULL;
+	req->dtd_count = 0;
+
+	if (fsl_req_to_dtd(req) == 0)
+		fsl_queue_td(ep, req);
+	else
+		return -ENOMEM;
+
+	list_add_tail(&req->queue, &ep->queue);
+
+	return 0;
+}
+
+static void udc_reset_ep_queue(struct fsl_udc *udc, u8 pipe)
+{
+	struct fsl_ep *ep = get_ep_by_pipe(udc, pipe);
+
+	if (ep->name)
+		nuke(ep, -ESHUTDOWN);
+}
+
+/*
+ * ch9 Set address
+ */
+static void ch9setaddress(struct fsl_udc *udc, u16 value, u16 index, u16 length)
+{
+	/* Save the new address to device struct */
+	udc->device_address = (u8) value;
+	/* Update usb state */
+	udc->usb_state = USB_STATE_ADDRESS;
+	/* Status phase */
+	if (ep0_prime_status(udc, EP_DIR_IN))
+		ep0stall(udc);
+}
+
+/*
+ * ch9 Get status
+ */
+static void ch9getstatus(struct fsl_udc *udc, u8 request_type, u16 value,
+		u16 index, u16 length)
+{
+	u16 tmp = 0;		/* Status, cpu endian */
+	struct fsl_req *req;
+	struct fsl_ep *ep;
+
+	ep = &udc->eps[0];
+
+	if ((request_type & USB_RECIP_MASK) == USB_RECIP_DEVICE) {
+		/* Get device status */
+		tmp = 1 << USB_DEVICE_SELF_POWERED;
+		tmp |= udc->remote_wakeup << USB_DEVICE_REMOTE_WAKEUP;
+	} else if ((request_type & USB_RECIP_MASK) == USB_RECIP_INTERFACE) {
+		/* Get interface status */
+		/* We don't have interface information in udc driver */
+		tmp = 0;
+	} else if ((request_type & USB_RECIP_MASK) == USB_RECIP_ENDPOINT) {
+		/* Get endpoint status */
+		struct fsl_ep *target_ep;
+
+		target_ep = get_ep_by_pipe(udc, get_pipe_by_windex(index));
+
+		/* stall if endpoint doesn't exist */
+		if (!target_ep->desc)
+			goto stall;
+		tmp = dr_ep_get_stall(ep_index(target_ep), ep_is_in(target_ep))
+				<< USB_ENDPOINT_HALT;
+	}
+
+	udc->ep0_dir = USB_DIR_IN;
+	/* Borrow the per device status_req */
+	req = udc->status_req;
+	/* Fill in the reqest structure */
+	*((u16 *) req->req.buf) = cpu_to_le16(tmp);
+	req->ep = ep;
+	req->req.length = 2;
+	req->req.status = -EINPROGRESS;
+	req->req.actual = 0;
+	req->req.complete = NULL;
+	req->dtd_count = 0;
+	req->req.dma = dma_map_single(ep->udc->gadget.dev.parent,
+					req->req.buf,
+					req->req.length, ep_is_in(ep)
+						? DMA_TO_DEVICE
+						: DMA_FROM_DEVICE);
+	req->mapped = 1;
+
+	/* prime the data phase */
+	if ((fsl_req_to_dtd(req) == 0))
+		fsl_queue_td(ep, req);
+	else			/* no mem */
+		goto stall;
+
+	list_add_tail(&req->queue, &ep->queue);
+	udc->ep0_state = DATA_STATE_XMIT;
+	return;
+stall:
+	ep0stall(udc);
+}
+
+static void setup_received_irq(struct fsl_udc *udc,
+		struct usb_ctrlrequest *setup)
+{
+	u16 wValue = le16_to_cpu(setup->wValue);
+	u16 wIndex = le16_to_cpu(setup->wIndex);
+	u16 wLength = le16_to_cpu(setup->wLength);
+	u32 portsc;
+
+	udc_reset_ep_queue(udc, 0);
+
+	/* We process some stardard setup requests here */
+	switch (setup->bRequest) {
+	case USB_REQ_GET_STATUS:
+		/* Data+Status phase from udc */
+		if ((setup->bRequestType & (USB_DIR_IN | USB_TYPE_MASK))
+					!= (USB_DIR_IN | USB_TYPE_STANDARD))
+			break;
+		ch9getstatus(udc, setup->bRequestType, wValue, wIndex, wLength);
+		return;
+
+	case USB_REQ_SET_ADDRESS:
+		/* Status phase from udc */
+		if (setup->bRequestType != (USB_DIR_OUT | USB_TYPE_STANDARD
+						| USB_RECIP_DEVICE))
+			break;
+		ch9setaddress(udc, wValue, wIndex, wLength);
+		return;
+
+	case USB_REQ_CLEAR_FEATURE:
+	case USB_REQ_SET_FEATURE:
+		/* Status phase from udc */
+	{
+		int rc = -EOPNOTSUPP;
+
+		if ((setup->bRequestType & (USB_RECIP_MASK | USB_TYPE_MASK))
+				== (USB_RECIP_ENDPOINT | USB_TYPE_STANDARD)) {
+			int pipe = get_pipe_by_windex(wIndex);
+			struct fsl_ep *ep;
+
+			if (wValue != 0 || wLength != 0 || pipe > udc->max_ep)
+				break;
+			ep = get_ep_by_pipe(udc, pipe);
+
+			spin_unlock(&udc->lock);
+			rc = fsl_ep_set_halt(&ep->ep,
+					(setup->bRequest == USB_REQ_SET_FEATURE)
+						? 1 : 0);
+			spin_lock(&udc->lock);
+
+		} else if ((setup->bRequestType & (USB_RECIP_MASK
+				| USB_TYPE_MASK)) == (USB_RECIP_DEVICE
+				| USB_TYPE_STANDARD)) {
+			/* Note: The driver has not include OTG support yet.
+			 * This will be set when OTG support is added */
+			
+			if(wValue == 0x2)
+			{
+				if (ep0_prime_status(udc, EP_DIR_IN))
+					ep0stall(udc);
+						
+				portsc = fsl_readl(&dr_regs->portsc1);
+
+				switch(wIndex)
+				{
+
+					case  0x100:
+				 		portsc |= PORTSCX_PTC_JSTATE;
+						break;
+
+					case 0x200:
+						portsc |= PORTSCX_PTC_KSTATE;
+						break;
+						 
+					case 0x300:
+						portsc |= PORTSCX_PTC_SEQNAK;
+						break;
+
+					case 0x400:
+						portsc |= PORTSCX_PTC_PACKET;
+						break;
+
+					default:
+						break;
+				}
+				fsl_writel(portsc, &dr_regs->portsc1);
+
+				return;
+			}
+
+			if (!gadget_is_otg(&udc->gadget))
+				break;
+			else if (setup->bRequest == USB_DEVICE_B_HNP_ENABLE)
+				udc->gadget.b_hnp_enable = 1;
+			else if (setup->bRequest == USB_DEVICE_A_HNP_SUPPORT)
+				udc->gadget.a_hnp_support = 1;
+			else if (setup->bRequest ==
+					USB_DEVICE_A_ALT_HNP_SUPPORT)
+				udc->gadget.a_alt_hnp_support = 1;
+			else
+				break;
+			rc = 0;
+		} else
+			break;
+
+		if (rc == 0) {
+			if (ep0_prime_status(udc, EP_DIR_IN))
+				ep0stall(udc);
+		}
+		return;
+	}
+
+	default:
+		break;
+	}
+
+	/* Requests handled by gadget */
+	if (wLength) {
+		/* Data phase from gadget, status phase from udc */
+		udc->ep0_dir = (setup->bRequestType & USB_DIR_IN)
+				?  USB_DIR_IN : USB_DIR_OUT;
+		spin_unlock(&udc->lock);
+		if (udc->driver->setup(&udc->gadget,
+				&udc->local_setup_buff) < 0)
+			ep0stall(udc);
+		spin_lock(&udc->lock);
+		udc->ep0_state = (setup->bRequestType & USB_DIR_IN)
+				?  DATA_STATE_XMIT : DATA_STATE_RECV;
+	} else {
+		/* No data phase, IN status from gadget */
+		udc->ep0_dir = USB_DIR_IN;
+		spin_unlock(&udc->lock);
+		if (udc->driver->setup(&udc->gadget,
+				&udc->local_setup_buff) < 0)
+			ep0stall(udc);
+		spin_lock(&udc->lock);
+		udc->ep0_state = WAIT_FOR_OUT_STATUS;
+	}
+}
+
+/* Process request for Data or Status phase of ep0
+ * prime status phase if needed */
+static void ep0_req_complete(struct fsl_udc *udc, struct fsl_ep *ep0,
+		struct fsl_req *req)
+{
+	if (udc->usb_state == USB_STATE_ADDRESS) {
+		/* Set the new address */
+		u32 new_address = (u32) udc->device_address;
+		fsl_writel(new_address << USB_DEVICE_ADDRESS_BIT_POS,
+				&dr_regs->deviceaddr);
+	}
+
+	done(ep0, req, 0);
+
+	switch (udc->ep0_state) {
+	case DATA_STATE_XMIT:
+		/* receive status phase */
+		if (ep0_prime_status(udc, EP_DIR_OUT))
+			ep0stall(udc);
+		break;
+	case DATA_STATE_RECV:
+		/* send status phase */
+		if (ep0_prime_status(udc, EP_DIR_IN))
+			ep0stall(udc);
+		break;
+	case WAIT_FOR_OUT_STATUS:
+		udc->ep0_state = WAIT_FOR_SETUP;
+		break;
+	case WAIT_FOR_SETUP:
+		ERR("Unexpect ep0 packets\n");
+		break;
+	default:
+		ep0stall(udc);
+		break;
+	}
+}
+
+/* Tripwire mechanism to ensure a setup packet payload is extracted without
+ * being corrupted by another incoming setup packet */
+static void tripwire_handler(struct fsl_udc *udc, u8 ep_num, u8 *buffer_ptr)
+{
+	u32 temp;
+	struct ep_queue_head *qh;
+
+	qh = &udc->ep_qh[ep_num * 2 + EP_DIR_OUT];
+
+	/* Clear bit in ENDPTSETUPSTAT */
+	temp = fsl_readl(&dr_regs->endptsetupstat);
+	fsl_writel(temp | (1 << ep_num), &dr_regs->endptsetupstat);
+
+	/* while a hazard exists when setup package arrives */
+	do {
+		/* Set Setup Tripwire */
+		temp = fsl_readl(&dr_regs->usbcmd);
+		fsl_writel(temp | USB_CMD_SUTW, &dr_regs->usbcmd);
+
+		/* Copy the setup packet to local buffer */
+		memcpy(buffer_ptr, (u8 *) qh->setup_buffer, 8);
+	} while (!(fsl_readl(&dr_regs->usbcmd) & USB_CMD_SUTW));
+
+	/* Clear Setup Tripwire */
+	temp = fsl_readl(&dr_regs->usbcmd);
+	fsl_writel(temp & ~USB_CMD_SUTW, &dr_regs->usbcmd);
+}
+
+/* process-ep_req(): free the completed Tds for this req */
+static int process_ep_req(struct fsl_udc *udc, int pipe,
+		struct fsl_req *curr_req)
+{
+	struct ep_td_struct *curr_td;
+	int	td_complete, actual, remaining_length, j, tmp;
+	int	status = 0;
+	int	errors = 0;
+	struct  ep_queue_head *curr_qh = &udc->ep_qh[pipe];
+	int direction = pipe % 2;
+
+	curr_td = curr_req->head;
+	td_complete = 0;
+	actual = curr_req->req.length;
+
+	for (j = 0; j < curr_req->dtd_count; j++) {
+		remaining_length = (le32_to_cpu(curr_td->size_ioc_sts)
+					& DTD_PACKET_SIZE)
+				>> DTD_LENGTH_BIT_POS;
+		actual -= remaining_length;
+
+		if ((errors = le32_to_cpu(curr_td->size_ioc_sts) &
+						DTD_ERROR_MASK)) {
+			if (errors & DTD_STATUS_HALTED) {
+				ERR("dTD error %08x QH=%d\n", errors, pipe);
+				/* Clear the errors and Halt condition */
+				tmp = le32_to_cpu(curr_qh->size_ioc_int_sts);
+				tmp &= ~errors;
+				curr_qh->size_ioc_int_sts = cpu_to_le32(tmp);
+				status = -EPIPE;
+				/* FIXME: continue with next queued TD? */
+
+				break;
+			}
+			if (errors & DTD_STATUS_DATA_BUFF_ERR) {
+				VDBG("Transfer overflow");
+				status = -EPROTO;
+				break;
+			} else if (errors & DTD_STATUS_TRANSACTION_ERR) {
+				VDBG("ISO error");
+				status = -EILSEQ;
+				break;
+			} else
+				ERR("Unknown error has occured (0x%x)!\n",
+					errors);
+
+		} else if (le32_to_cpu(curr_td->size_ioc_sts)
+				& DTD_STATUS_ACTIVE) {
+			VDBG("Request not complete");
+			status = REQ_UNCOMPLETE;
+			return status;
+		} else if (remaining_length) {
+			if (direction) {
+				VDBG("Transmit dTD remaining length not zero");
+				status = -EPROTO;
+				break;
+			} else {
+				td_complete++;
+				break;
+			}
+		} else {
+			td_complete++;
+			VDBG("dTD transmitted successful");
+		}
+
+		if (j != curr_req->dtd_count - 1)
+			curr_td = (struct ep_td_struct *)curr_td->next_td_virt;
+	}
+
+	if (status)
+		return status;
+
+	curr_req->req.actual = actual;
+
+	return 0;
+}
+
+/* Process a DTD completion interrupt */
+static void dtd_complete_irq(struct fsl_udc *udc)
+{
+	u32 bit_pos;
+	int i, ep_num, direction, bit_mask, status;
+	struct fsl_ep *curr_ep;
+	struct fsl_req *curr_req, *temp_req;
+
+	/* Clear the bits in the register */
+	bit_pos = fsl_readl(&dr_regs->endptcomplete);
+	fsl_writel(bit_pos, &dr_regs->endptcomplete);
+
+	if (!bit_pos)
+		return;
+
+	for (i = 0; i < udc->max_ep * 2; i++) {
+		ep_num = i >> 1;
+		direction = i % 2;
+
+		bit_mask = 1 << (ep_num + 16 * direction);
+
+		if (!(bit_pos & bit_mask))
+			continue;
+
+		curr_ep = get_ep_by_pipe(udc, i);
+
+		/* If the ep is configured */
+		if (curr_ep->name == NULL) {
+			WARNING("Invalid EP?");
+			continue;
+		}
+
+		/* process the req queue until an uncomplete request */
+		list_for_each_entry_safe(curr_req, temp_req, &curr_ep->queue,
+				queue) {
+			status = process_ep_req(udc, i, curr_req);
+
+			VDBG("status of process_ep_req= %d, ep = %d",
+					status, ep_num);
+			if (status == REQ_UNCOMPLETE)
+				break;
+			/* write back status to req */
+			curr_req->req.status = status;
+
+			if (ep_num == 0) {
+				ep0_req_complete(udc, curr_ep, curr_req);
+				break;
+			} else
+				done(curr_ep, curr_req, status);
+		}
+	}
+}
+
+/* Process a port Error interrupt */
+static void port_error(struct fsl_udc *udc)
+{
+	/* clear the error state */	
+}
+
+/* Process a port change interrupt */
+static void port_change_irq(struct fsl_udc *udc)
+{
+	u32 speed;
+
+	/* Bus resetting is finished */
+	if (!(fsl_readl(&dr_regs->portsc1) & PORTSCX_PORT_RESET)) {
+		/* Get the speed */
+		speed = (fsl_readl(&dr_regs->portsc1)
+				& PORTSCX_PORT_SPEED_MASK);
+		switch (speed) {
+		case PORTSCX_PORT_SPEED_HIGH:
+			udc->gadget.speed = USB_SPEED_HIGH;
+			break;
+		case PORTSCX_PORT_SPEED_FULL:
+			udc->gadget.speed = USB_SPEED_FULL;
+			break;
+		case PORTSCX_PORT_SPEED_LOW:
+			udc->gadget.speed = USB_SPEED_LOW;
+			break;
+		default:
+			udc->gadget.speed = USB_SPEED_UNKNOWN;
+			break;
+		}
+	}
+
+	/* Update USB state */
+	if (!udc->resume_state)
+		udc->usb_state = USB_STATE_DEFAULT;
+}
+
+#ifdef CONFIG_IP9028_OTG	
+extern struct work_struct	*wq_host_probe_g;
+extern unsigned int hnp_initiator;
+extern unsigned int Is_HNP_Event;
+
+static void dr_controller_b_host(struct fsl_udc *udc)
+{
+	unsigned int tmp;
+
+	/* set controller to Stop */
+	tmp = fsl_readl(&dr_regs->usbcmd);
+	tmp &= ~USB_CMD_RUN_STOP;
+	fsl_writel(tmp, &dr_regs->usbcmd);
+
+	tmp = fsl_readl(&dr_regs->usbcmd);
+	tmp |= USB_CMD_CTRL_RESET;
+	fsl_writel(tmp, &dr_regs->usbcmd);
+
+	tmp = fsl_readl(&dr_regs->usbmode);
+	tmp |= USB_MODE_CTRL_MODE_HOST;
+	fsl_writel(tmp, &dr_regs->usbmode);
+
+
+	tmp = fsl_readl(&dr_regs->otgsc);
+	tmp |= OTGSC_CTRL_OTG_TERM;
+	fsl_writel(tmp, &dr_regs->otgsc);
+	
+	tmp = fsl_readl(&dr_regs->otgsc);
+	tmp |= OTGSC_CTRL_OTG_HAAR;
+	fsl_writel(tmp, &dr_regs->otgsc);
+
+	/* Set stopped bit for isr */	
+	udc->stopped = 1;
+
+	Is_HNP_Event =1 ;
+	
+	schedule_work(wq_host_probe_g);
+
+	return;
+}
+#endif
+
+/* Process suspend interrupt */
+static void suspend_irq(struct fsl_udc *udc)
+{
+	unsigned int tmp;
+
+	udc->resume_state = udc->usb_state;
+	udc->usb_state = USB_STATE_SUSPENDED;
+
+#ifdef CONFIG_IP9028_OTG	
+
+	tmp = fsl_readl(&dr_regs->otgsc);
+	printk(KERN_DEBUG "suspend_irq udc->gadget.b_hnp_enable =%d otgsc =%x \n",udc->gadget.b_hnp_enable,tmp);
+
+	if(udc->gadget.b_hnp_enable == 1)
+	{
+
+		udc->gadget.b_hnp_enable = 0; /* HNP is handled */
+
+		if( hnp_initiator)
+		{
+		 	hnp_initiator=0;
+			printk(KERN_DEBUG "suspend_irq DO NOTHING AS IT IS HNP INTIATOR \n");
+			/* DO NOTHING */
+		}else
+		{
+			//Ready the b-device for  Host role
+			printk(KERN_DEBUG "suspend_irq  b_host role udc->gadget.b_hnp_enable = %d \n",udc->gadget.b_hnp_enable);
+			//usb_gadget_unregister_driver(udc->driver);
+			dr_controller_b_host(udc_controller);
+
+		}
+		
+	}	
+
+	if(hnp_initiator)
+	{
+		hnp_initiator=0;
+		udc->gadget.b_hnp_enable = 0; /* HNP is handled */
+	}
+	
+#endif	
+
+
+	/* report suspend to the driver, serial.c does not support this */
+	if (udc->driver->suspend)
+		udc->driver->suspend(&udc->gadget);
+}
+
+static void bus_resume(struct fsl_udc *udc)
+{
+	udc->usb_state = udc->resume_state;
+	udc->resume_state = 0;
+
+	/* report resume to the driver, serial.c does not support this */
+	if (udc->driver->resume)
+		udc->driver->resume(&udc->gadget);
+}
+
+/* Clear up all ep queues */
+static int reset_queues(struct fsl_udc *udc)
+{
+	u8 pipe;
+
+	for (pipe = 0; pipe < udc->max_pipes; pipe++)
+		udc_reset_ep_queue(udc, pipe);
+
+	/* report disconnect; the driver is already quiesced */
+	spin_unlock(&udc->lock);
+	udc->driver->disconnect(&udc->gadget);
+	spin_lock(&udc->lock);
+
+	return 0;
+}
+
+/* Process reset interrupt */
+static void reset_irq(struct fsl_udc *udc)
+{
+	u32 temp;
+	unsigned long timeout;
+
+	/* Clear the device address */
+	temp = fsl_readl(&dr_regs->deviceaddr);
+	fsl_writel(temp & ~USB_DEVICE_ADDRESS_MASK, &dr_regs->deviceaddr);
+
+	udc->device_address = 0;
+
+	/* Clear usb state */
+	udc->resume_state = 0;
+	udc->ep0_dir = 0;
+	udc->ep0_state = WAIT_FOR_SETUP;
+	udc->remote_wakeup = 0;	/* default to 0 on reset */
+	udc->gadget.b_hnp_enable = 0;
+	udc->gadget.a_hnp_support = 0;
+	udc->gadget.a_alt_hnp_support = 0;
+
+	/* Clear all the setup token semaphores */
+	temp = fsl_readl(&dr_regs->endptsetupstat);
+	fsl_writel(temp, &dr_regs->endptsetupstat);
+
+	/* Clear all the endpoint complete status bits */
+	temp = fsl_readl(&dr_regs->endptcomplete);
+	fsl_writel(temp, &dr_regs->endptcomplete);
+
+	timeout = jiffies + 100;
+	while (fsl_readl(&dr_regs->endpointprime)) {
+		/* Wait until all endptprime bits cleared */
+		if (time_after(jiffies, timeout)) {
+			ERR("Timeout for reset\n");
+			break;
+		}
+		cpu_relax();
+	}
+
+	/* Write 1s to the flush register */
+	fsl_writel(0xffffffff, &dr_regs->endptflush);
+
+	if (fsl_readl(&dr_regs->portsc1) & PORTSCX_PORT_RESET) {
+		VDBG("Bus reset");
+		/* Reset all the queues, include XD, dTD, EP queue
+		 * head and TR Queue */
+	/*	reset_queues(udc);     */
+		udc->usb_state = USB_STATE_DEFAULT;
+	} else {
+		VDBG("Controller reset");
+		/* initialize usb hw reg except for regs for EP, not
+		 * touch usbintr reg */
+		dr_controller_setup(udc);
+
+		/* Reset all internal used Queues */
+		reset_queues(udc);
+
+		ep0_setup(udc);
+
+		/* Enable DR IRQ reg, Set Run bit, change udc state */
+		dr_controller_run(udc);
+		udc->usb_state = USB_STATE_ATTACHED;
+	}
+}
+
+#define IP9028_OTGSC_INT_IDIS     0x00010000
+#define IP9028_OTGSC_INT_AVVIS   0x00020000
+#define IP9028_OTGSC_INT_ASVIS   0x00040000
+#define IP9028_OTGSC_INT_BSVIS   0x00080000
+#define IP9028_OTGSC_INT_BSEIS   0x00100000
+#define IP9028_OTGSC_INT_1mIS    0x00200000
+#define IP9028_OTGSC_INT_DPIS    0x00400000
+
+extern unsigned int Is_B_Device;
+
+/* return value 0 indicates non OTG interrupt, 1 indicates it an OTG interrupt */
+
+int Is_Otg_Intr(struct fsl_udc *udc)
+{
+	unsigned int tmp, flag=0;
+
+	tmp = fsl_readl(&dr_regs->otgsc);
+
+	if( (tmp & IP9028_OTGSC_INT_IDIS)  ==  IP9028_OTGSC_INT_IDIS )
+	{
+		flag=1;
+		printk(KERN_DEBUG" IDIS interrupt is not expected at this STATE \n");
+	}
+	if( (tmp & IP9028_OTGSC_INT_AVVIS)  ==  IP9028_OTGSC_INT_AVVIS )
+		flag=1;
+
+	if( (tmp & IP9028_OTGSC_INT_ASVIS)  ==  IP9028_OTGSC_INT_ASVIS )
+	{
+		flag=1;
+		
+	}
+
+	if( (tmp & IP9028_OTGSC_INT_BSVIS)  ==  IP9028_OTGSC_INT_BSVIS )
+	{
+		flag=1;
+		
+	}
+	if( (tmp & IP9028_OTGSC_INT_BSEIS)  ==  IP9028_OTGSC_INT_BSEIS )
+	{
+		flag=1;
+
+	}
+	
+	if( (tmp & IP9028_OTGSC_INT_DPIS)  ==  IP9028_OTGSC_INT_DPIS )
+		flag=1;
+
+	if(flag)
+	{
+	   Is_B_Device = 0;	
+	   printk(KERN_DEBUG"  Is_Otg_Intr  is OTG INTERRUPT  Is_B_Device =%d tmp=%x   \n",Is_B_Device,tmp);
+	  
+	}
+
+	return flag;
+	
+}
+
+/*
+ * USB device controller interrupt handler
+ */
+static irqreturn_t fsl_udc_irq(int irq, void *_udc)
+{
+	struct fsl_udc *udc = _udc;
+	u32 irq_src;
+	irqreturn_t status = IRQ_NONE;
+	unsigned long flags;
+
+	if(Is_Otg_Intr(udc))
+		return IRQ_NONE;
+
+	if(Is_A_host)
+	{
+		udc->stopped = 1;
+	}
+
+	/* Disable ISR for OTG host mode */
+	if (udc->stopped)
+		return IRQ_NONE;
+	spin_lock_irqsave(&udc->lock, flags);
+	irq_src = fsl_readl(&dr_regs->usbsts) & fsl_readl(&dr_regs->usbintr);
+	/* Clear notification bits */
+	fsl_writel(irq_src, &dr_regs->usbsts);
+
+	/* VDBG("irq_src [0x%8x]", irq_src); */
+
+	/* Need to resume? */
+	if (udc->usb_state == USB_STATE_SUSPENDED)
+		if ((fsl_readl(&dr_regs->portsc1) & PORTSCX_PORT_SUSPEND) == 0)
+			bus_resume(udc);
+
+	/* USB Interrupt */
+	if (irq_src & USB_STS_INT) {
+		VDBG("Packet int");
+		/* Setup package, we only support ep0 as control ep */
+		if (fsl_readl(&dr_regs->endptsetupstat) & EP_SETUP_STATUS_EP0) {
+			tripwire_handler(udc, 0,
+					(u8 *) (&udc->local_setup_buff));
+			setup_received_irq(udc, &udc->local_setup_buff);
+			status = IRQ_HANDLED;
+		}
+
+		/* completion of dtd */
+		if (fsl_readl(&dr_regs->endptcomplete)) {
+			dtd_complete_irq(udc);
+			status = IRQ_HANDLED;
+		}
+	}
+
+	/* SOF (for ISO transfer) */
+	if (irq_src & USB_STS_SOF) {
+		status = IRQ_HANDLED;
+	}
+
+	/* Port Change */
+	if (irq_src & USB_STS_PORT_CHANGE) {
+		port_change_irq(udc);
+		status = IRQ_HANDLED;
+	}
+
+	/* Reset Received */
+	if (irq_src & USB_STS_RESET) {
+		reset_irq(udc);
+		status = IRQ_HANDLED;
+	}
+
+	/* Sleep Enable (Suspend) */
+	if (irq_src & USB_STS_SUSPEND) {
+		suspend_irq(udc);
+		status = IRQ_HANDLED;
+	}
+
+	if (irq_src & (USB_STS_ERR | USB_STS_SYS_ERR)) {
+		port_error(udc);
+		VDBG("Error IRQ %x", irq_src);
+	}
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+	return status;
+}
+
+/*----------------------------------------------------------------*
+ * Hook to gadget drivers
+ * Called by initialization code of gadget drivers
+*----------------------------------------------------------------*/
+int usb_gadget_register_driver(struct usb_gadget_driver *driver)
+{
+	int retval = -ENODEV;
+	unsigned long flags = 0;
+
+	if (!udc_controller)
+		return -ENODEV;
+
+	if (!driver || (driver->speed != USB_SPEED_FULL
+				&& driver->speed != USB_SPEED_HIGH)
+			|| !driver->bind || !driver->disconnect
+			|| !driver->setup)
+		return -EINVAL;
+
+	if (udc_controller->driver)
+		return -EBUSY;
+
+	/* lock is needed but whether should use this lock or another */
+	spin_lock_irqsave(&udc_controller->lock, flags);
+
+	driver->driver.bus = NULL;
+	/* hook up the driver */
+	udc_controller->driver = driver;
+	udc_controller->gadget.dev.driver = &driver->driver;
+	spin_unlock_irqrestore(&udc_controller->lock, flags);
+
+	/* bind udc driver to gadget driver */
+	retval = driver->bind(&udc_controller->gadget);
+	if (retval) {
+		VDBG("bind to %s --> %d", driver->driver.name, retval);
+		udc_controller->gadget.dev.driver = NULL;
+		udc_controller->driver = NULL;
+		goto out;
+	}
+
+	/* Enable DR IRQ reg and Set usbcmd reg  Run bit */
+	if(!Is_A_host)
+	{
+		printk("usb_gadget_register_driver: Run the udc controller only if it is B_device or A_device \n");
+		dr_controller_run(udc_controller);
+	}
+
+	udc_controller->usb_state = USB_STATE_ATTACHED;
+	udc_controller->ep0_state = WAIT_FOR_SETUP;
+	udc_controller->ep0_dir = 0;
+	printk(KERN_INFO "%s: bind to driver %s\n",
+			udc_controller->gadget.name, driver->driver.name);
+
+out:
+	if (retval)
+		printk(KERN_WARNING "gadget driver register failed %d\n",
+		       retval);
+	return retval;
+}
+EXPORT_SYMBOL(usb_gadget_register_driver);
+
+/* Disconnect from gadget driver */
+int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
+{
+	struct fsl_ep *loop_ep;
+	unsigned long flags;
+
+	if (!udc_controller)
+		return -ENODEV;
+
+	if (!driver || driver != udc_controller->driver || !driver->unbind)
+		return -EINVAL;
+
+	if (udc_controller->transceiver)
+		otg_set_peripheral(udc_controller->transceiver, NULL);
+
+	/* stop DR, disable intr */
+	dr_controller_stop(udc_controller);
+
+	/* in fact, no needed */
+	udc_controller->usb_state = USB_STATE_ATTACHED;
+	udc_controller->ep0_state = WAIT_FOR_SETUP;
+	udc_controller->ep0_dir = 0;
+
+	/* stand operation */
+	spin_lock_irqsave(&udc_controller->lock, flags);
+	udc_controller->gadget.speed = USB_SPEED_UNKNOWN;
+	nuke(&udc_controller->eps[0], -ESHUTDOWN);
+	list_for_each_entry(loop_ep, &udc_controller->gadget.ep_list,
+			ep.ep_list)
+		nuke(loop_ep, -ESHUTDOWN);
+	spin_unlock_irqrestore(&udc_controller->lock, flags);
+
+	/* report disconnect; the controller is already quiesced */
+	driver->disconnect(&udc_controller->gadget);
+
+	/* unbind gadget and unhook driver. */
+	driver->unbind(&udc_controller->gadget);
+	udc_controller->gadget.dev.driver = NULL;
+	udc_controller->driver = NULL;
+
+	printk(KERN_WARNING "unregistered gadget driver '%s'\n",
+	       driver->driver.name);
+	return 0;
+}
+EXPORT_SYMBOL(usb_gadget_unregister_driver);
+
+/*-------------------------------------------------------------------------
+		PROC File System Support
+-------------------------------------------------------------------------*/
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
+
+#include <linux/seq_file.h>
+
+static const char proc_filename[] = "driver/fsl_usb2_udc";
+
+static int fsl_proc_read(char *page, char **start, off_t off, int count,
+		int *eof, void *_dev)
+{
+	char *buf = page;
+	char *next = buf;
+	unsigned size = count;
+	unsigned long flags;
+	int t, i;
+	u32 tmp_reg;
+	struct fsl_ep *ep = NULL;
+	struct fsl_req *req;
+
+	struct fsl_udc *udc = udc_controller;
+	if (off != 0)
+		return 0;
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	/* ------basic driver information ---- */
+	t = scnprintf(next, size,
+			DRIVER_DESC "\n"
+			"%s version: %s\n"
+			"Gadget driver: %s\n\n",
+			driver_name, DRIVER_VERSION,
+			udc->driver ? udc->driver->driver.name : "(none)");
+	size -= t;
+	next += t;
+
+	/* ------ DR Registers ----- */
+	tmp_reg = fsl_readl(&dr_regs->usbcmd);
+	t = scnprintf(next, size,
+			"USBCMD reg:\n"
+			"SetupTW: %d\n"
+			"Run/Stop: %s\n\n",
+			(tmp_reg & USB_CMD_SUTW) ? 1 : 0,
+			(tmp_reg & USB_CMD_RUN_STOP) ? "Run" : "Stop");
+	size -= t;
+	next += t;
+
+	tmp_reg = fsl_readl(&dr_regs->usbsts);
+	t = scnprintf(next, size,
+			"USB Status Reg:\n"
+			"Dr Suspend: %d Reset Received: %d System Error: %s "
+			"USB Error Interrupt: %s\n\n",
+			(tmp_reg & USB_STS_SUSPEND) ? 1 : 0,
+			(tmp_reg & USB_STS_RESET) ? 1 : 0,
+			(tmp_reg & USB_STS_SYS_ERR) ? "Err" : "Normal",
+			(tmp_reg & USB_STS_ERR) ? "Err detected" : "No err");
+	size -= t;
+	next += t;
+
+	tmp_reg = fsl_readl(&dr_regs->usbintr);
+	t = scnprintf(next, size,
+			"USB Intrrupt Enable Reg:\n"
+			"Sleep Enable: %d SOF Received Enable: %d "
+			"Reset Enable: %d\n"
+			"System Error Enable: %d "
+			"Port Change Dectected Enable: %d\n"
+			"USB Error Intr Enable: %d USB Intr Enable: %d\n\n",
+			(tmp_reg & USB_INTR_DEVICE_SUSPEND) ? 1 : 0,
+			(tmp_reg & USB_INTR_SOF_EN) ? 1 : 0,
+			(tmp_reg & USB_INTR_RESET_EN) ? 1 : 0,
+			(tmp_reg & USB_INTR_SYS_ERR_EN) ? 1 : 0,
+			(tmp_reg & USB_INTR_PTC_DETECT_EN) ? 1 : 0,
+			(tmp_reg & USB_INTR_ERR_INT_EN) ? 1 : 0,
+			(tmp_reg & USB_INTR_INT_EN) ? 1 : 0);
+	size -= t;
+	next += t;
+
+	tmp_reg = fsl_readl(&dr_regs->frindex);
+	t = scnprintf(next, size,
+			"USB Frame Index Reg: Frame Number is 0x%x\n\n",
+			(tmp_reg & USB_FRINDEX_MASKS));
+	size -= t;
+	next += t;
+
+	tmp_reg = fsl_readl(&dr_regs->deviceaddr);
+	t = scnprintf(next, size,
+			"USB Device Address Reg: Device Addr is 0x%x\n\n",
+			(tmp_reg & USB_DEVICE_ADDRESS_MASK));
+	size -= t;
+	next += t;
+
+	tmp_reg = fsl_readl(&dr_regs->endpointlistaddr);
+	t = scnprintf(next, size,
+			"USB Endpoint List Address Reg: "
+			"Device Addr is 0x%x\n\n",
+			(tmp_reg & USB_EP_LIST_ADDRESS_MASK));
+	size -= t;
+	next += t;
+
+	tmp_reg = fsl_readl(&dr_regs->portsc1);
+	t = scnprintf(next, size,
+		"USB Port Status&Control Reg:\n"
+		"Port Transceiver Type : %s Port Speed: %s\n"
+		"PHY Low Power Suspend: %s Port Reset: %s "
+		"Port Suspend Mode: %s\n"
+		"Over-current Change: %s "
+		"Port Enable/Disable Change: %s\n"
+		"Port Enabled/Disabled: %s "
+		"Current Connect Status: %s\n\n", ( {
+			char *s;
+			switch (tmp_reg & PORTSCX_PTS_FSLS) {
+			case PORTSCX_PTS_UTMI:
+				s = "UTMI"; break;
+			case PORTSCX_PTS_ULPI:
+				s = "ULPI "; break;
+			case PORTSCX_PTS_FSLS:
+				s = "FS/LS Serial"; break;
+			default:
+				s = "None"; break;
+			}
+			s;} ), ( {
+			char *s;
+			switch (tmp_reg & PORTSCX_PORT_SPEED_UNDEF) {
+			case PORTSCX_PORT_SPEED_FULL:
+				s = "Full Speed"; break;
+			case PORTSCX_PORT_SPEED_LOW:
+				s = "Low Speed"; break;
+			case PORTSCX_PORT_SPEED_HIGH:
+				s = "High Speed"; break;
+			default:
+				s = "Undefined"; break;
+			}
+			s;
+		} ),
+		(tmp_reg & PORTSCX_PHY_LOW_POWER_SPD) ?
+		"Normal PHY mode" : "Low power mode",
+		(tmp_reg & PORTSCX_PORT_RESET) ? "In Reset" :
+		"Not in Reset",
+		(tmp_reg & PORTSCX_PORT_SUSPEND) ? "In " : "Not in",
+		(tmp_reg & PORTSCX_OVER_CURRENT_CHG) ? "Dected" :
+		"No",
+		(tmp_reg & PORTSCX_PORT_EN_DIS_CHANGE) ? "Disable" :
+		"Not change",
+		(tmp_reg & PORTSCX_PORT_ENABLE) ? "Enable" :
+		"Not correct",
+		(tmp_reg & PORTSCX_CURRENT_CONNECT_STATUS) ?
+		"Attached" : "Not-Att");
+	size -= t;
+	next += t;
+
+	tmp_reg = fsl_readl(&dr_regs->usbmode);
+	t = scnprintf(next, size,
+			"USB Mode Reg: Controller Mode is: %s\n\n", ( {
+				char *s;
+				switch (tmp_reg & USB_MODE_CTRL_MODE_HOST) {
+				case USB_MODE_CTRL_MODE_IDLE:
+					s = "Idle"; break;
+				case USB_MODE_CTRL_MODE_DEVICE:
+					s = "Device Controller"; break;
+				case USB_MODE_CTRL_MODE_HOST:
+					s = "Host Controller"; break;
+				default:
+					s = "None"; break;
+				}
+				s;
+			} ));
+	size -= t;
+	next += t;
+
+	tmp_reg = fsl_readl(&dr_regs->endptsetupstat);
+	t = scnprintf(next, size,
+			"Endpoint Setup Status Reg: SETUP on ep 0x%x\n\n",
+			(tmp_reg & EP_SETUP_STATUS_MASK));
+	size -= t;
+	next += t;
+
+	for (i = 0; i < udc->max_ep / 2; i++) {
+		tmp_reg = fsl_readl(&dr_regs->endptctrl[i]);
+		t = scnprintf(next, size, "EP Ctrl Reg [0x%x]: = [0x%x]\n",
+				i, tmp_reg);
+		size -= t;
+		next += t;
+	}
+	tmp_reg = fsl_readl(&dr_regs->endpointprime);
+	t = scnprintf(next, size, "EP Prime Reg = [0x%x]\n\n", tmp_reg);
+	size -= t;
+	next += t;
+
+	tmp_reg = usb_sys_regs->snoop1;
+	t = scnprintf(next, size, "Snoop1 Reg : = [0x%x]\n\n", tmp_reg);
+	size -= t;
+	next += t;
+
+	tmp_reg = usb_sys_regs->control;
+	t = scnprintf(next, size, "General Control Reg : = [0x%x]\n\n",
+			tmp_reg);
+	size -= t;
+	next += t;
+
+	/* ------fsl_udc, fsl_ep, fsl_request structure information ----- */
+	ep = &udc->eps[0];
+	t = scnprintf(next, size, "For %s Maxpkt is 0x%x index is 0x%x\n",
+			ep->ep.name, ep_maxpacket(ep), ep_index(ep));
+	size -= t;
+	next += t;
+
+	if (list_empty(&ep->queue)) {
+		t = scnprintf(next, size, "its req queue is empty\n\n");
+		size -= t;
+		next += t;
+	} else {
+		list_for_each_entry(req, &ep->queue, queue) {
+			t = scnprintf(next, size,
+				"req %p actual 0x%x length 0x%x buf %p\n",
+				&req->req, req->req.actual,
+				req->req.length, req->req.buf);
+			size -= t;
+			next += t;
+		}
+	}
+	/* other gadget->eplist ep */
+	list_for_each_entry(ep, &udc->gadget.ep_list, ep.ep_list) {
+		if (ep->desc) {
+			t = scnprintf(next, size,
+					"\nFor %s Maxpkt is 0x%x "
+					"index is 0x%x\n",
+					ep->ep.name, ep_maxpacket(ep),
+					ep_index(ep));
+			size -= t;
+			next += t;
+
+			if (list_empty(&ep->queue)) {
+				t = scnprintf(next, size,
+						"its req queue is empty\n\n");
+				size -= t;
+				next += t;
+			} else {
+				list_for_each_entry(req, &ep->queue, queue) {
+					t = scnprintf(next, size,
+						"req %p actual 0x%x length "
+						"0x%x  buf %p\n",
+						&req->req, req->req.actual,
+						req->req.length, req->req.buf);
+					size -= t;
+					next += t;
+					}	/* end for each_entry of ep req */
+				}	/* end for else */
+			}	/* end for if(ep->queue) */
+		}		/* end (ep->desc) */
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	*eof = 1;
+	return count - size;
+}
+
+#define create_proc_file()	create_proc_read_entry(proc_filename, \
+				0, NULL, fsl_proc_read, NULL)
+
+#define remove_proc_file()	remove_proc_entry(proc_filename, NULL)
+
+#else				/* !CONFIG_USB_GADGET_DEBUG_FILES */
+
+#define create_proc_file()	do {} while (0)
+#define remove_proc_file()	do {} while (0)
+
+#endif				/* CONFIG_USB_GADGET_DEBUG_FILES */
+
+/*-------------------------------------------------------------------------*/
+
+/* Release udc structures */
+static void fsl_udc_release(struct device *dev)
+{
+	complete(udc_controller->done);
+	dma_free_coherent(dev->parent, udc_controller->ep_qh_size,
+			udc_controller->ep_qh, udc_controller->ep_qh_dma);
+	kfree(udc_controller);
+}
+
+/******************************************************************
+	Internal structure setup functions
+*******************************************************************/
+/*------------------------------------------------------------------
+ * init resource for globle controller
+ * Return the udc handle on success or NULL on failure
+ ------------------------------------------------------------------*/
+static int __init struct_udc_setup(struct fsl_udc *udc,
+		struct device *dev)
+{
+	size_t size;
+
+	udc->eps = kzalloc(sizeof(struct fsl_ep) * udc->max_ep, GFP_KERNEL);
+	if (!udc->eps) {
+		ERR("malloc fsl_ep failed\n");
+		return -1;
+	}
+
+	/* initialized QHs, take care of alignment */
+	size = udc->max_ep * sizeof(struct ep_queue_head);
+	if (size < QH_ALIGNMENT)
+		size = QH_ALIGNMENT;
+	else if ((size % QH_ALIGNMENT) != 0) {
+		size += QH_ALIGNMENT + 1;
+		size &= ~(QH_ALIGNMENT - 1);
+	}
+	udc->ep_qh = dma_alloc_coherent(dev, size,
+					&udc->ep_qh_dma, GFP_KERNEL);
+	if (!udc->ep_qh) {
+		ERR("malloc QHs for udc failed\n");
+		kfree(udc->eps);
+		return -1;
+	}
+
+	udc->ep_qh_size = size;
+
+	/* Initialize ep0 status request structure */
+	/* FIXME: fsl_alloc_request() ignores ep argument */
+	udc->status_req = container_of(fsl_alloc_request(NULL, GFP_KERNEL),
+			struct fsl_req, req);
+	/* allocate a small amount of memory to get valid address */
+	udc->status_req->req.buf = kmalloc(8, GFP_KERNEL);
+	udc->status_req->req.dma = virt_to_phys(udc->status_req->req.buf);
+
+	udc->resume_state = USB_STATE_NOTATTACHED;
+	udc->usb_state = USB_STATE_POWERED;
+	udc->ep0_dir = 0;
+	udc->remote_wakeup = 0;	/* default to 0 on reset */
+
+	return 0;
+}
+
+/*----------------------------------------------------------------
+ * Setup the fsl_ep struct for eps
+ * Link fsl_ep->ep to gadget->ep_list
+ * ep0out is not used so do nothing here
+ * ep0in should be taken care
+ *--------------------------------------------------------------*/
+static int __init struct_ep_setup(struct fsl_udc *udc, unsigned char index,
+		char *name, int link)
+{
+	struct fsl_ep *ep = &udc->eps[index];
+
+	ep->udc = udc;
+	strcpy(ep->name, name);
+	ep->ep.name = ep->name;
+
+	ep->ep.ops = &fsl_ep_ops;
+	ep->stopped = 0;
+
+	/* for ep0: maxP defined in desc
+	 * for other eps, maxP is set by epautoconfig() called by gadget layer
+	 */
+	ep->ep.maxpacket = (unsigned short) ~0;
+
+	/* the queue lists any req for this ep */
+	INIT_LIST_HEAD(&ep->queue);
+
+	/* gagdet.ep_list used for ep_autoconfig so no ep0 */
+	if (link)
+		list_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);
+	ep->gadget = &udc->gadget;
+	ep->qh = &udc->ep_qh[index];
+
+	return 0;
+}
+
+/* Driver probe function : CALLED BY OTG MODULE (WHEN DEVICE MODE IS SELECTED WITH OTG OPTION)
+ * all intialization operations implemented here except enabling usb_intr reg
+ * board setup should have been done in the platform code
+ */
+int __init fsl_otg_udc_probe(struct device *dev /*struct platform_device * pdev*/, void *regs, int irq)
+{
+	int ret = -ENODEV;
+	unsigned int i;
+	u32 dccparams;
+
+	udc_controller = kzalloc(sizeof(struct fsl_udc), GFP_KERNEL);
+	if (udc_controller == NULL) {
+		ERR("malloc udc failed\n");
+		return -ENOMEM;
+	}
+
+	spin_lock_init(&udc_controller->lock);
+	udc_controller->stopped = 1;
+
+	dr_regs = regs;
+	if (!dr_regs) {
+		return -ENOMEM;
+	}
+
+	usb_sys_regs = (struct usb_sys_interface *)
+			((u32)dr_regs + USB_DR_SYS_OFFSET);
+
+	/* Read Device Controller Capability Parameters register */
+	dccparams = fsl_readl(&dr_regs->dccparams);
+	if (!(dccparams & DCCPARAMS_DC)) {
+		ERR("This SOC doesn't support device role\n");
+		ret = -ENODEV;
+		goto err_iounmap;
+	}
+	/* Get max device endpoints */
+	/* DEN is bidirectional ep number, max_ep doubles the number */
+	udc_controller->max_ep = (dccparams & DCCPARAMS_DEN_MASK) * 2;
+
+	udc_controller->irq = irq;
+	if (!udc_controller->irq) {
+		ret = -ENODEV;
+		goto err_iounmap;
+	}
+
+	ret = request_irq(udc_controller->irq, fsl_udc_irq, IRQF_SHARED,
+			driver_name, udc_controller);
+	if (ret != 0) {
+		ERR("cannot request irq %d err %d\n",
+				udc_controller->irq, ret);
+		goto err_iounmap;
+	}
+
+	/* Initialize the udc structure including QH member and other member */
+	if (struct_udc_setup(udc_controller, dev)) {
+		ERR("Can't initialize udc data structure\n");
+		ret = -ENOMEM;
+		goto err_free_irq;
+	}
+
+	/* initialize usb hw reg except for regs for EP,
+	 * leave usbintr reg untouched */
+	dr_controller_setup(udc_controller);
+
+	/* Setup gadget structure */
+	udc_controller->gadget.ops = &fsl_gadget_ops;
+	udc_controller->gadget.is_dualspeed = 1;
+	udc_controller->gadget.ep0 = &udc_controller->eps[0].ep;
+	INIT_LIST_HEAD(&udc_controller->gadget.ep_list);
+	udc_controller->gadget.speed = USB_SPEED_UNKNOWN;
+	udc_controller->gadget.name = driver_name;
+#ifdef CONFIG_IP9028_OTG
+	printk(KERN_DEBUG "fsl_otg_udc_probe : gadget.is_otg is set \n");
+	udc_controller->gadget.is_otg = 1;
+#endif
+
+	/* Setup gadget.dev and register with kernel */
+	dev_set_name(&udc_controller->gadget.dev, "gadget");
+	udc_controller->gadget.dev.release = fsl_udc_release;
+	udc_controller->gadget.dev.parent = dev;
+	ret = device_register(&udc_controller->gadget.dev);
+	if (ret < 0)
+		goto err_free_irq;
+
+	/* setup QH and epctrl for ep0 */
+	ep0_setup(udc_controller);
+
+	/* setup udc->eps[] for ep0 */
+	struct_ep_setup(udc_controller, 0, "ep0", 0);
+	/* for ep0: the desc defined here;
+	 * for other eps, gadget layer called ep_enable with defined desc
+	 */
+	udc_controller->eps[0].desc = &fsl_ep0_desc;
+	udc_controller->eps[0].ep.maxpacket = USB_MAX_CTRL_PAYLOAD;
+
+	/* setup the udc->eps[] for non-control endpoints and link
+	 * to gadget.ep_list */
+	for (i = 1; i < (int)(udc_controller->max_ep / 2); i++) {
+		char name[14];
+
+		sprintf(name, "ep%dout", i);
+		struct_ep_setup(udc_controller, i * 2, name, 1);
+		sprintf(name, "ep%din", i);
+		struct_ep_setup(udc_controller, i * 2 + 1, name, 1);
+	}
+
+	/* use dma_pool for TD management */
+	udc_controller->td_pool = dma_pool_create("udc_td", dev,
+			sizeof(struct ep_td_struct),
+			DTD_ALIGNMENT, UDC_DMA_BOUNDARY);
+	if (udc_controller->td_pool == NULL) {
+		ret = -ENOMEM;
+		goto err_unregister;
+	}
+	create_proc_file();
+	return 0;
+
+err_unregister:
+	device_unregister(&udc_controller->gadget.dev);
+err_free_irq:
+	free_irq(udc_controller->irq, udc_controller);
+err_iounmap:
+	iounmap(dr_regs);
+/*err_kfree:*/
+	kfree(udc_controller);
+	udc_controller = NULL;
+
+	printk(KERN_DEBUG "fsl_otg_udc_probe ........ end, error code=%d\n", ret);
+	return ret;
+}
+
+
+/* Driver removal function
+ * Free resources and finish pending transactions
+ */
+int __exit fsl_otg_udc_remove(void)
+{
+	DECLARE_COMPLETION(done);
+
+	if (!udc_controller)
+		return -ENODEV;
+	udc_controller->done = &done;
+
+	/* DR has been stopped in usb_gadget_unregister_driver() */
+	remove_proc_file();
+
+	/* Free allocated memory */
+	kfree(udc_controller->status_req->req.buf);
+	kfree(udc_controller->status_req);
+	kfree(udc_controller->eps);
+
+	dma_pool_destroy(udc_controller->td_pool);
+	free_irq(udc_controller->irq, udc_controller);
+
+	device_unregister(&udc_controller->gadget.dev);
+	/* free udc --wait for the release() finished */
+	wait_for_completion(&done);
+
+	return 0;
+}
+
+/*-----------------------------------------------------------------
+ * Modify Power management attributes
+ * Used by OTG statemachine to disable gadget temporarily
+ -----------------------------------------------------------------*/
+int fsl_udc_otg_suspend(void)
+{
+	dr_controller_stop(udc_controller);
+	return 0;
+}
+
+/*-----------------------------------------------------------------
+ * Invoked on USB resume. May be called in_interrupt.
+ * Here we start the DR controller and enable the irq
+ *-----------------------------------------------------------------*/
+int fsl_udc_otg_resume(void)
+{
+	/* Enable DR irq reg and set controller Run */
+	if (udc_controller->stopped) {
+		dr_controller_setup(udc_controller);
+		dr_controller_run(udc_controller);
+	}
+	udc_controller->usb_state = USB_STATE_ATTACHED;
+	udc_controller->ep0_state = WAIT_FOR_SETUP;
+	udc_controller->ep0_dir = 0;
+	return 0;
+}
+
+/* Driver removal function
+ * Free resources and finish pending transactions
+ */
+static int __exit fsl_udc_remove(struct platform_device *pdev)
+{
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	DECLARE_COMPLETION(done);
+
+	if (!udc_controller)
+		return -ENODEV;
+	udc_controller->done = &done;
+
+	/* DR has been stopped in usb_gadget_unregister_driver() */
+	remove_proc_file();
+
+	/* Free allocated memory */
+	kfree(udc_controller->status_req->req.buf);
+	kfree(udc_controller->status_req);
+	kfree(udc_controller->eps);
+
+	dma_pool_destroy(udc_controller->td_pool);
+	free_irq(udc_controller->irq, udc_controller);
+	iounmap(dr_regs);
+	release_mem_region(res->start, res->end - res->start + 1);
+
+	device_unregister(&udc_controller->gadget.dev);
+	/* free udc --wait for the release() finished */
+	wait_for_completion(&done);
+
+	return 0;
+}
+
+#ifdef CONFIG_IP9028_OTG
+extern   int  ip9028_otg_usb_probe(struct platform_device *pdev);
+#endif
+
+/* Driver probe function : CALLED BY KERNEL (WHEN DEVICE MODE IS SELECTED WITHOUT OTG OPTION)
+ * all intialization operations implemented here except enabling usb_intr reg
+ * board setup should have been done in the platform code
+ */
+int __init fsl_udc_probe(struct platform_device * pdev)
+{
+	void __iomem *regs = NULL;
+	int retval;
+
+	if (!request_mem_region(pdev->resource[0].start, pdev->resource[0].end - 
+	    pdev->resource[0].start + 1, "ip9028_usb_udc")) {		// "ip9028_otg"
+		printk (KERN_ALERT "request_mem_region failed\n");
+		return -EBUSY;
+	}
+	regs = ioremap(pdev->resource[0].start, pdev->resource[0].end -
+				   pdev->resource[0].start + 1);
+	
+	if (!regs) {
+		printk (KERN_ALERT "fsl_udc_probe: ioremap failed\n");
+		return -ENOMEM;
+	}
+
+#ifdef CONFIG_IP9028_OTG
+	ip9028_otg_usb_probe(pdev);
+#endif
+
+	retval = fsl_otg_udc_probe(&pdev->dev, regs, pdev->resource[1].start);
+	return retval;
+
+// gadget_remove:
+	fsl_udc_remove(pdev);
+// iounmap:
+	iounmap(regs);
+	return retval;
+}
+
+/*-----------------------------------------------------------------
+ * Modify Power management attributes
+ * Used by OTG statemachine to disable gadget temporarily
+ -----------------------------------------------------------------*/
+static int fsl_udc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	dr_controller_stop(udc_controller);
+	return 0;
+}
+
+/*-----------------------------------------------------------------
+ * Invoked on USB resume. May be called in_interrupt.
+ * Here we start the DR controller and enable the irq
+ *-----------------------------------------------------------------*/
+static int fsl_udc_resume(struct platform_device *pdev)
+{
+	/* Enable DR irq reg and set controller Run */
+	if (udc_controller->stopped) {
+		dr_controller_setup(udc_controller);
+		dr_controller_run(udc_controller);
+	}
+	udc_controller->usb_state = USB_STATE_ATTACHED;
+	udc_controller->ep0_state = WAIT_FOR_SETUP;
+	udc_controller->ep0_dir = 0;
+	return 0;
+}
+
+/*-------------------------------------------------------------------------
+	Register entry point for the peripheral controller driver
+--------------------------------------------------------------------------*/
+
+
+static struct platform_driver ip9028_udc_driver = {
+	.probe		= fsl_udc_probe,
+	.remove		=  __exit_p(fsl_udc_remove),
+	.suspend 	= fsl_udc_suspend,
+	.resume		= fsl_udc_resume,
+	.driver  = {
+		.name = (char *)driver_name,
+		.owner = THIS_MODULE,
+		.bus = &platform_bus_type
+	},
+};
+
+static int __init udc_init(void)
+{
+	int i;
+	
+	i = platform_driver_register(&ip9028_udc_driver);	
+	return i;
+}
+
+module_init(udc_init);
+
+static void __exit udc_exit(void)
+{
+	platform_driver_unregister(&ip9028_udc_driver);
+}
+
+module_exit(udc_exit);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:ip9028-udc");
diff -Naurp linux-2.6.34.org/drivers/usb/gadget/Kconfig linux-2.6.34/drivers/usb/gadget/Kconfig
--- linux-2.6.34.org/drivers/usb/gadget/Kconfig	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/usb/gadget/Kconfig	2010-09-21 16:31:59.000000000 -0500
@@ -252,6 +252,23 @@ config USB_PXA25X_SMALL
 	default y if USB_ETH
 	default y if USB_G_SERIAL
 
+
+
+config USB_GADGET_IP9028
+	boolean "IP9028 USB device controller"
+	depends on USB_EHCI_IP9028
+	select USB_GADGET_SELECTED
+	select USB_OTG
+
+
+config USB_IP9028
+	tristate
+	depends on USB_GADGET_IP9028
+	default USB_GADGET
+	select USB_GADGET_SELECTED
+	select USB_GADGET_DUALSPEED
+
+
 config USB_GADGET_R8A66597
 	boolean "Renesas R8A66597 USB Peripheral Controller"
 	select USB_GADGET_DUALSPEED
diff -Naurp linux-2.6.34.org/drivers/usb/gadget/Makefile linux-2.6.34/drivers/usb/gadget/Makefile
--- linux-2.6.34.org/drivers/usb/gadget/Makefile	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/usb/gadget/Makefile	2010-09-21 16:31:59.000000000 -0500
@@ -28,6 +28,7 @@ obj-$(CONFIG_USB_FSL_QE)	+= fsl_qe_udc.o
 obj-$(CONFIG_USB_CI13XXX)	+= ci13xxx_udc.o
 obj-$(CONFIG_USB_S3C_HSOTG)	+= s3c-hsotg.o
 obj-$(CONFIG_USB_LANGWELL)	+= langwell_udc.o
+obj-$(CONFIG_USB_GADGET_IP9028)       += ip9028_udc.o
 
 #
 # USB gadget drivers
diff -Naurp linux-2.6.34.org/drivers/usb/host/ehci-hub.c linux-2.6.34/drivers/usb/host/ehci-hub.c
--- linux-2.6.34.org/drivers/usb/host/ehci-hub.c	2010-09-21 16:31:16.000000000 -0500
+++ linux-2.6.34/drivers/usb/host/ehci-hub.c	2010-09-21 16:31:59.000000000 -0500
@@ -908,6 +908,17 @@ static int ehci_hub_control (
 		temp &= ~PORT_RWC_BITS;
 		switch (wValue) {
 		case USB_PORT_FEAT_SUSPEND:
+
+#ifdef	CONFIG_USB_OTG
+			if (hcd->self.otg_port == (wIndex + 1)
+					&& hcd->self.b_hnp_enable)
+			{
+
+				/* printk("ehci-hub:  hcd=%x \n",hcd);  */
+				hcd->start_hnp(/*ehci,*/hcd);
+			}
+			else
+#endif
 			if (ehci->no_selective_suspend)
 				break;
 			if ((temp & PORT_PE) == 0
diff -Naurp linux-2.6.34.org/drivers/usb/host/ehci-ip9028.c linux-2.6.34/drivers/usb/host/ehci-ip9028.c
--- linux-2.6.34.org/drivers/usb/host/ehci-ip9028.c	2010-09-21 16:31:16.000000000 -0500
+++ linux-2.6.34/drivers/usb/host/ehci-ip9028.c	2010-09-21 17:04:06.000000000 -0500
@@ -71,7 +71,7 @@ int usb_ehci_ip9028_probe(const struct h
 
 
 	/* put USB OTG block into HOST mode */
-	__raw_writel(PNX8XXX_USB_IP9028_USB_MODE_HOST,
+	writel(PNX8XXX_USB_IP9028_USB_MODE_HOST,
 		hcd->regs + PNX8XXX_USB_IP9028_USB_MODE_OFFSET);
 
 	retval = usb_add_hcd(hcd, dev->resource[1].start,
@@ -129,7 +129,7 @@ int usb_ehci_ip9028_otg_host_setup(struc
 	ehci_reset(ehci);
 
 	/* put USB OTG block into HOST mode */
-	__raw_writel(PNX8XXX_USB_IP9028_USB_MODE_HOST,
+	writel(PNX8XXX_USB_IP9028_USB_MODE_HOST,
 		hcd->regs + PNX8XXX_USB_IP9028_USB_MODE_OFFSET);
 
 	ehci_port_power(ehci, 0);
@@ -145,7 +145,7 @@ static int usb_ehci_ip9028_setup(struct 
 	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
 	int		retval;
 
-	printk(" usb_ehci_ip9028_setup IN \n");
+	printk(KERN_DEBUG " usb_ehci_ip9028_setup IN \n");
 
 	/* EHCI registers start at offset 0x100 */
 	ehci->caps = hcd->regs + 0x100;
@@ -172,7 +172,7 @@ static int usb_ehci_ip9028_setup(struct 
 		return retval;
 
 
-	printk(" usb_ehci_ip9028_setup ehci_init \n");
+	printk(KERN_DEBUG " usb_ehci_ip9028_setup ehci_init \n");
 
 	hcd->has_tt = 1;
 
@@ -181,17 +181,17 @@ static int usb_ehci_ip9028_setup(struct 
 	ehci_reset(ehci);
 
 
-	printk(" usb_ehci_ip9028_setup ehci_reset \n");
+	printk(KERN_DEBUG " usb_ehci_ip9028_setup ehci_reset \n");
 
 	/* put USB OTG block into HOST mode */
-	__raw_writel(PNX8XXX_USB_IP9028_USB_MODE_HOST,
+	writel(PNX8XXX_USB_IP9028_USB_MODE_HOST,
 		hcd->regs + PNX8XXX_USB_IP9028_USB_MODE_OFFSET);
 
 
 
 	ehci_port_power(ehci, 0);
 
-	printk(" usb_ehci_ip9028_setup OUT \n");
+	printk(KERN_DEBUG " usb_ehci_ip9028_setup OUT \n");
 
 	return 0;
 }
diff -Naurp linux-2.6.34.org/drivers/usb/host/ehci-q.c linux-2.6.34/drivers/usb/host/ehci-q.c
--- linux-2.6.34.org/drivers/usb/host/ehci-q.c	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/usb/host/ehci-q.c	2010-09-21 16:38:23.000000000 -0500
@@ -1135,6 +1135,7 @@ submit_async (
 	if (unlikely(rc))
 		goto done;
 
+	rmb(); 
 	qh = qh_append_tds(ehci, urb, qtd_list, epnum, &urb->ep->hcpriv);
 	if (unlikely(qh == NULL)) {
 		usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
@@ -1147,6 +1148,7 @@ submit_async (
 	 */
 	if (likely (qh->qh_state == QH_STATE_IDLE))
 		qh_link_async(ehci, qh);
+	wmb();
  done:
 	spin_unlock_irqrestore (&ehci->lock, flags);
 	if (unlikely (qh == NULL))
diff -Naurp linux-2.6.34.org/drivers/usb/host/Kconfig linux-2.6.34/drivers/usb/host/Kconfig
--- linux-2.6.34.org/drivers/usb/host/Kconfig	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/usb/host/Kconfig	2010-09-21 16:31:59.000000000 -0500
@@ -98,6 +98,11 @@ config USB_EHCI_BIG_ENDIAN_DESC
 	depends on USB_EHCI_HCD && (440EPX || ARCH_IXP4XX || XPS_USB_HCD_XILINX)
 	default y
 
+config USB_EHCI_IP9028
+	bool "Support for NXP IP9028 on-chip EHCI USB controller"
+	depends on USB_EHCI_HCD && (SOC_PNX85500 || SOC_PNX8543 || SOC_PNX8400)
+	select USB_EHCI_ROOT_HUB_TT
+	
 config XPS_USB_HCD_XILINX
 	bool "Use Xilinx usb host EHCI controller core"
 	depends on USB_EHCI_HCD && (PPC32 || MICROBLAZE)
diff -Naurp linux-2.6.34.org/drivers/usb/Makefile linux-2.6.34/drivers/usb/Makefile
--- linux-2.6.34.org/drivers/usb/Makefile	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/drivers/usb/Makefile	2010-09-21 16:31:59.000000000 -0500
@@ -45,3 +45,4 @@ obj-y				+= early/
 
 obj-$(CONFIG_USB_ATM)		+= atm/
 obj-$(CONFIG_USB_SPEEDTOUCH)	+= atm/
+obj-$(CONFIG_USB_OTG)		+= otg/	
\ No newline at end of file
diff -Naurp linux-2.6.34.org/drivers/usb/otg/ip9028-otg.c linux-2.6.34/drivers/usb/otg/ip9028-otg.c
--- linux-2.6.34.org/drivers/usb/otg/ip9028-otg.c	2010-09-21 16:31:16.000000000 -0500
+++ linux-2.6.34/drivers/usb/otg/ip9028-otg.c	2010-09-21 16:31:59.000000000 -0500
@@ -43,7 +43,7 @@
 #define OTG_SRP_THREAD 1
 #define OTG_A_HOST_POWER_OFF_THREAD 1
 #define IDLE_DETECTNESS_TIMER 1
-#define IDLE_DETECTNESS_TIMER_VAL 3
+#define IDLE_DETECTNESS_TIMER_VAL 1
 #define USB_OTG_HNP_EN  1
 #define USB_OTG_HNP_A_DEVICE 1
 #define USB_OTG_HNP_B_HOST 1
@@ -57,9 +57,10 @@ static struct semaphore	srp_sema ,pwr_of
 //jun24 volatile int id_is_b=0; /* ID is b-device */
 unsigned int Is_A_host =0; /* OTG device has taken  A -Host role */
 volatile int  b_connect =0;
-int IsPowerOff =0,IsDeviceConnected=0;
+int IsPowerOff =0,IsDeviceConnected=0,Ismnt=0;
 volatile  unsigned int Is_B_Device=0;
 struct work_struct	 *wq_host_probe_g;
+volatile unsigned int Is_HNP_Event = 0;
 
 #ifdef IDLE_DETECTNESS_TIMER
 
@@ -133,11 +134,9 @@ static void a_device_idle_timer_fn(unsig
 		
 	unsigned int tmp,flag=0;
 
-	//printk(" Check for A-device idlenes for every 10s ****** \n");
-
-	
+		
 	tmp = readl (ip9028_otg->regs + IP9028_USBCMD);
-	//printk(" ASE-PSE tmp = %x \n",tmp);
+
 
 	if( (tmp &  0x10) == (0x10) )
 	{
@@ -155,6 +154,25 @@ static void a_device_idle_timer_fn(unsig
 		printk(KERN_DEBUG" **************USB BUS is IDLE **************\n");
 
 
+		tmp = readl (ip9028_otg->regs + IP9028_USBMOD);
+		if( (tmp & IP9028_USBMODE_MASK) == IP9028_USBMODE_DEVICE)
+		{
+			printk(KERN_DEBUG" **************USB BUS is IDLE  BUT IN DEVICE MODE **************\n");
+			mod_timer(&A_device_idle_timer, jiffies + (IDLE_DETECTNESS_TIMER_VAL * 100 * HZ));
+			return;
+		}
+
+		
+
+		if(Ismnt)
+		{
+
+			printk(KERN_DEBUG" **************USB BUS is IDLE  BUT MOUNTED **************\n");
+			mod_timer(&A_device_idle_timer, jiffies + (IDLE_DETECTNESS_TIMER_VAL * 100 * HZ));
+			return;
+
+		}
+		
 		tmp = readl (ip9028_otg->regs + IP9028_PRTSC);
 		
 		if (( tmp  & IP9028_PRTSC_CCS_MASK) == (IP9028_PRTSC_CCS_MASK) )
@@ -174,26 +192,10 @@ static void a_device_idle_timer_fn(unsig
 
 
 	}
-/*
-	if(!flag)
-	{
-		
-			
-		tmp = readl (ip9028_otg->regs + IP9028_PRTSC);
-		tmp = tmp & 0xFFFFEFFF;
-		writel (tmp, ip9028_otg->regs + IP9028_PRTSC);
 
-		tmp = readl (ip9028_otg->regs + IP9028_PRTSC);
-
-		printk( " a_device_idle_timer_fn : Turn off the port power  =%x \n",tmp);
-		
-	}
-*/
 	mod_timer(&A_device_idle_timer, jiffies + (IDLE_DETECTNESS_TIMER_VAL * 100 * HZ));
 
-	
-//	tmp = tmp | IP9028_PRTSC_PP;
-//	writel (tmp, ip9028_otg->regs + IP9028_PRTSC);
+
 
 
 	
@@ -227,11 +229,12 @@ void  start_hw_assit_hnp(struct ip9028_o
 }
 
 extern void dr_controller_run_otg_wr(void);
+extern void dr_controller_run_otg_wr_1(void);
 
 static int ip9028_otg_start_hnp(struct otg_transceiver *x)
 {
 	struct ip9028_otg_usb *ip9028_otg;
-	uint32_t tmp ,delay=100000/* ,retval*/;
+	uint32_t tmp ,delay=100000;
 
 	printk("  ip9028_otg_start_hnp 1\n");
 
@@ -248,7 +251,7 @@ static int ip9028_otg_start_hnp(struct o
 	tmp = readl (ip9028_otg->regs + IP9028_PRTSC);
 	printk("  ip9028_otg_start_hnp tmp=%x 2\n",tmp);
 
-	//usb_remove_hcd(ip9028_otg->hcd);
+	
 
 
 	Is_A_host = 0; //
@@ -258,17 +261,19 @@ static int ip9028_otg_start_hnp(struct o
 	for(;delay > 0 ;delay--);
 
 	printk( "ip9028_otg_start_hnp: roothub graceful disconnect\n");
-//	spin_lock_irq (&hcd_root_hub_lock);
+
 	ip9028_otg->hcd->rh_registered = 0;
-//	spin_unlock_irq (&hcd_root_hub_lock);
 
-	dr_controller_run_otg_wr();
 
 	
+	
+	dr_controller_run_otg_wr();
+
+
 	return 0;
 }
 
-static void start_hnp(/*struct ehci_hcd *ehci*,*/struct usb_hcd		*hcd)
+static void start_hnp(struct usb_hcd		*hcd)
 {
 	printk(" ip9028_otgc. : start_hnp \n");
 	otg_start_hnp(hcd->transceiver);
@@ -281,7 +286,7 @@ static void start_hnp(/*struct ehci_hcd 
 
 extern int ip9028_otg_register_peripheral(struct platform_device *peripheral_driver)
 {
-	//ip9028_otg->peripheral_driver = peripheral_driver;
+	
 
 	return 0;
 }
@@ -338,6 +343,17 @@ void ip9028_otg_wq_host_probe(struct wor
 	if (ip9028_otg->otg.gadget)
 		usb_gadget_vbus_disconnect(ip9028_otg->otg.gadget);
 
+	if(ip9028_otg->hcd)
+	{
+		printk(KERN_DEBUG" ip9028_otg_wq_host_probe: HCD is already created ,remove old and create new \n");
+
+		usb_remove_hcd(ip9028_otg->hcd);
+		usb_put_hcd(ip9028_otg->hcd);
+
+		ip9028_otg->hcd = NULL;
+
+	
+	}
 	
 	 ip9028_otg->hcd = usb_create_hcd(&ehci_ip9028_hc_driver/*&ehci_ip9028_otg_hc_driver*/,
 					 &ip9028_otg->usb_host,"ip9028_udc_udc"/* "ip9028_host"*/);
@@ -363,7 +379,7 @@ void ip9028_otg_wq_host_probe(struct wor
 
 #ifdef USB_OTG_HNP_A_DEVICE
 
-//jun24	id_is_b=0;
+
 	Is_A_host=1;
 
 #endif
@@ -376,15 +392,15 @@ void ip9028_otg_wq_host_probe(struct wor
 		
 		int	status = otg_set_host(ip9028_otg->hcd->transceiver,
 						&ip9028_otg->hcd->self);
-		/*  printk("  otg_set_host \nip9028_otg->hcd =%x ip9028_otg->hcd->transceiver =%x ",ip9028_otg->hcd,ip9028_otg->hcd->transceiver); */
+		
 			if (status) {
 				if (ip9028_otg->hcd->transceiver)
 					put_device(ip9028_otg->hcd->transceiver->dev);
-				/* return status; */
+				
 			
 		}
 		ip9028_otg->hcd->start_hnp = start_hnp;
-		/* printk(" ip9028_otg->hcd->transceiver->start_hnp = %x \n ",ip9028_otg->hcd->transceiver->start_hnp); */
+		
 
 
 	}
@@ -396,7 +412,7 @@ void ip9028_otg_wq_host_probe(struct wor
 	A_device_idle_timer.expires = jiffies + (IDLE_DETECTNESS_TIMER_VAL * 100 * HZ);
 	A_device_idle_timer.function =a_device_idle_timer_fn;
 	A_device_idle_timer.data = (unsigned long)ip9028_otg;
-/* 	setup_timer(&A_device_idle_timer, a_device_idle_timer_fn, (unsigned long)ip9028_otg);  */
+
 	add_timer(&A_device_idle_timer);
 	printk(" A_host_idle_detectness_timer added ****END \n");
 #endif	
@@ -410,8 +426,17 @@ void ip9028_otg_wq_host_remove(struct wo
 	struct ip9028_otg_usb *ip9028_otg = container_of((work), struct ip9028_otg_usb,
 							 wq_host_remove);
 
-	usb_remove_hcd(ip9028_otg->hcd);
-	usb_put_hcd(ip9028_otg->hcd);
+	if(ip9028_otg->hcd)
+	{
+		usb_remove_hcd(ip9028_otg->hcd);
+		usb_put_hcd(ip9028_otg->hcd);
+	}
+
+	
+		
+	ip9028_otg->hcd = NULL;
+
+	
 
 	if (ip9028_otg->otg.gadget)
 		usb_gadget_vbus_connect(ip9028_otg->otg.gadget);
@@ -434,27 +459,13 @@ static irqreturn_t ip9028_otg_usb_irq(in
 
 	otgsc = readl (ip9028_otg->regs + IP9028_OTGSC);
 
-	//printk(" ip9028_otg_usb_irq otgsc=%x   \n",otgsc);
 	
-#ifdef DEBUG_ON_TV550	/* enable this to hardwire ID pin to A (host) for TV550 debugging */
-	/* Although TV550 is Host-only support, the ID pin is floating, which 
-	 * results in USB ID 'B-status' (device) because of the internal
-	 * pull-up resistor. To test host functionality on TV550, we need to
-	 * fake as if the ID pin was connected correctly (i.e. to GND) */
-	otgsc = otgsc & ~0x100;
-	otgsc = otgsc | 0x400;
-#endif
 
 	if(Is_B_Device)
 		return IRQ_NONE;
 
-//	if(id_is_b)
-//	{
-//		return IRQ_NONE;
-//	}
 
-
-	/* Added senthil  */
+	
 	if(otgsc  &  IP9028_OTGSC_DPIS)
 	{
 		
@@ -467,6 +478,7 @@ static irqreturn_t ip9028_otg_usb_irq(in
 		{
 			printk(KERN_DEBUG"Is this   Poweroff event ?  DO Nothing \n");
 			IsPowerOff =0;
+			return IRQ_HANDLED;
 		}
 		else
 		{
@@ -485,16 +497,7 @@ static irqreturn_t ip9028_otg_usb_irq(in
 		
 	}	
 		
-/* JUNE 23rd
-	if( IP9028_OTGSC_ID  & otgsc)
-	{
-		id_is_b=1;
 
-		printk(" id_is_b is set to 1 \n");
-		return IRQ_NONE;
-		
-	}
-*/	
 
 	if( b_connect)
 	{
@@ -502,11 +505,11 @@ static irqreturn_t ip9028_otg_usb_irq(in
 		return IRQ_NONE;
 	}	
 
-//	printk (KERN_ALERT "ip9028_otg_usb_irq, otgsc = %08x, state = %d\n", otgsc, ip9028_otg->otg.state);
+
 
 	switch (ip9028_otg->otg.state) {
 	case OTG_STATE_UNDEFINED:
-		printk(" OTG_STATE_UNDEFINED \n");
+		printk(KERN_DEBUG" OTG_STATE_UNDEFINED \n");
 		writel ((otgsc & 0xFFFFFFFF) | IP9028_OTGSC_IDIE |IP9028_OTGSC_IDPU,
 	   		ip9028_otg->regs + IP9028_OTGSC);
 		if (otgsc & IP9028_OTGSC_ID) {
@@ -551,7 +554,7 @@ static irqreturn_t ip9028_otg_usb_irq(in
 		break;
 	case OTG_STATE_A_IDLE:
 
-		printk(KERN_DEBUG"  OTG_STATE_A_IDLE IN \n");
+		printk(KERN_DEBUG"  OTG_STATE_A_IDLE IN otgsc=%x  \n",otgsc);
 		if (otgsc & IP9028_OTGSC_ID) {
 			ip9028_otg->otg.state = OTG_STATE_B_IDLE;
 			if (otgsc & IP9028_OTGSC_IDIS) {
@@ -569,7 +572,7 @@ static irqreturn_t ip9028_otg_usb_irq(in
 				
 			}
 			schedule_work(&ip9028_otg->wq_host_probe); 
-			printk(KERN_DEBUG"  OTG_STATE_A_IDLE  \n");
+			printk(KERN_DEBUG"  OTG_STATE_A_IDLE  otgsc=%x \n",otgsc);
 
 
 			}
@@ -595,28 +598,78 @@ static irqreturn_t ip9028_otg_usb_irq(in
 				IP9028_OTGSC_AVVIE, ip9028_otg->regs + IP9028_OTGSC);
 			timeout = 10;
 			ip9028_otg->otg.state = OTG_STATE_A_WAIT_VRISE;
-			printk("  OTG_STATE_A_IDLE -> OTG_STATE_A_WAIT_VRISE\n");
+			printk("  OTG_STATE_A_IDLE -> OTG_STATE_A_WAIT_VRISE otgsc = %x \n",otgsc);
 			return retval;
 		}
 		break;
 	case OTG_STATE_B_IDLE:
+
+		printk(KERN_DEBUG"  OTG_STATE_B_IDLE otgsc = %x  IN \n",otgsc);
+
+
+		if ((otgsc & IP9028_OTGSC_ID) == ( IP9028_OTGSC_ID)) {
+
+			printk(KERN_DEBUG" B-plug is plugged , OTG has to  take as Device role \n");
+
+			schedule_work(&ip9028_otg->wq_host_remove);
+
+			dr_controller_run_otg_wr_1();
+
+			Is_B_Device = 1;
+			Is_A_host  = 0;
+
+		}
+
+		if( (otgsc &  IP9028_OTGSC_INT_ASVIS) == IP9028_OTGSC_INT_ASVIS )
+		{
+			if( (otgsc &  IP9028_OTGSC_INT_BSVIS) == IP9028_OTGSC_INT_BSVIS )	
+				{
+					writel ((otgsc   | IP9028_OTGSC_INT_BSVIS), ip9028_otg->regs + IP9028_OTGSC);
+					printk(KERN_DEBUG"  OTG_STATE_B_IDLE  cleared IP9028_OTGSC_INT_BSVIS  \n");
+				}
+
+				writel ((otgsc   | IP9028_OTGSC_INT_ASVIS), ip9028_otg->regs + IP9028_OTGSC);
+				printk(KERN_DEBUG"  OTG_STATE_B_IDLE  cleared IP9028_OTGSC_INT_ASVIS  \n");
+				return IRQ_HANDLED;
+			
+		}	
+		
+
+		if( (otgsc  & IP9028_OTGSC_INT_BSEIS)  ==  IP9028_OTGSC_INT_BSEIS )
+		{
+			writel ((otgsc   | IP9028_OTGSC_INT_BSEIS), ip9028_otg->regs + IP9028_OTGSC);
+			printk(KERN_DEBUG " *** END OF B-SESSION  OTG_STATE_B_IDLE cleared the BSEIS otgsc=%x   \n",otgsc);
+			return IRQ_HANDLED;
+		}
+
+
+		
+				
 		if (!(otgsc & IP9028_OTGSC_ID)) {
+
+			printk(KERN_DEBUG "  OTG_STATE_B_IDLE ->  OTG_STATE_A_IDLE \n");
 			ip9028_otg->otg.state = OTG_STATE_A_IDLE;
+
+						
 			if (otgsc & IP9028_OTGSC_IDIS) {
 				writel ((otgsc & 0xFF00FFFF) | IP9028_OTGSC_IDIS,
 				   	ip9028_otg->regs + IP9028_OTGSC);
-				return IRQ_HANDLED;
+				 /* return IRQ_HANDLED; */
 			}
+
+			/* enable port power */
+			tmp = readl (ip9028_otg->regs + IP9028_PRTSC);
+			tmp = tmp | IP9028_PRTSC_PP;
+			writel (tmp, ip9028_otg->regs + IP9028_PRTSC);
+			writel ((otgsc & 0x0000FFFF) | IP9028_OTGSC_IDIE | IP9028_OTGSC_1msE |
+				IP9028_OTGSC_AVVIE, ip9028_otg->regs + IP9028_OTGSC);
+			
+			return IRQ_HANDLED;
+			
 		}
 		break;
 	case OTG_STATE_A_WAIT_VRISE:
-		printk("  OTG_STATE_A_WAIT_VRISE \n"); 
-#ifdef DEBUG_ON_TV550 /* enable this for TV550 debugging! */
-				writel ((otgsc & 0x0000FFFF) | IP9028_OTGSC_IDIE | IP9028_OTGSC_1msE,
-				   	ip9028_otg->regs + IP9028_OTGSC);
-				ip9028_otg->otg.state = OTG_STATE_A_WAIT_BCON;
-				break;
-#endif
+		printk(KERN_DEBUG"  OTG_STATE_A_WAIT_VRISE \n"); 
 		if (otgsc & IP9028_OTGSC_IDIS) {
 			writel ((otgsc & 0xFF00FFFF) | IP9028_OTGSC_IDIS,
 			   	ip9028_otg->regs + IP9028_OTGSC);
@@ -660,13 +713,15 @@ static irqreturn_t ip9028_otg_usb_irq(in
 		}
 		break;
 	case OTG_STATE_A_WAIT_VFALL:
+
+		printk(KERN_DEBUG"  OTG_STATE_A_WAIT_VFALL \n"); 
 		if (otgsc & IP9028_OTGSC_1msS) {
 			writel ((otgsc & 0xFF00FFFF) | IP9028_OTGSC_1msS,
 			   	ip9028_otg->regs + IP9028_OTGSC);
 			if (timeout) {
 				timeout--;
 			} else {
-				writel ((otgsc & 0x0000FFFF) | IP9028_OTGSC_IDIE,
+				writel ((otgsc & 0xFF00FFFF) | IP9028_OTGSC_IDIE,
 			   		ip9028_otg->regs + IP9028_OTGSC);
 				if (otgsc & IP9028_OTGSC_ID) {
 					ip9028_otg->otg.state = OTG_STATE_A_IDLE;
@@ -679,34 +734,18 @@ static irqreturn_t ip9028_otg_usb_irq(in
 		break;
 	case OTG_STATE_A_WAIT_BCON:
 
-		//OTG_STATE_A_WAIT_BCON
 
-	//jun24	printk(" OTG_STATE_A_WAIT_BCON id_is_b =%d \n",id_is_b );
+		printk(KERN_DEBUG"  OTG_STATE_A_WAIT_BCON \n"); 
 
-		
-
-		
+			
 		if (otgsc & IP9028_OTGSC_1msS) {
 			writel ((otgsc & 0x0000FFFF) | IP9028_OTGSC_1msS | IP9028_OTGSC_IDIE,
 			   	ip9028_otg->regs + IP9028_OTGSC);
 			ip9028_otg->otg.state = OTG_STATE_A_HOST;
 
-			schedule_work(&ip9028_otg->wq_host_probe);  ////jun24 uncommented
-
-		/*	
-			if(!id_is_b)
-			{
-					schedule_work(&ip9028_otg->wq_host_probe);
-
-			}
-
-			if(id_is_b)
-			{
-				b_connect = 1;
-				printk(" OTG_STATE_A_WAIT_BCON  b_connect set to 1 \n");
-			}
-		*/	
+			schedule_work(&ip9028_otg->wq_host_probe);  
 
+		
 		    otgsc1= readl (ip9028_otg->regs + IP9028_OTGSC);
 		    writel (otgsc1 | IP9028_OTGSC_DPIE |IP9028_OTGSC_DPIS/*  | IP9028_OTGSC_IDIE  | IP9028_OTGSC_IDPU | IP9028_OTGSC_ASVIE | IP9028_OTGSC_BSVIE*/,
 			ip9028_otg->regs + IP9028_OTGSC);
@@ -715,12 +754,16 @@ static irqreturn_t ip9028_otg_usb_irq(in
 		}
 		/* intentional break-through */
 	case OTG_STATE_A_HOST:
+
+		printk(KERN_DEBUG"  OTG_STATE_A_HOST \n"); 
+
+		
 		if (otgsc & IP9028_OTGSC_IDIS) {
 			writel ((otgsc & 0xFF00FFFF) | IP9028_OTGSC_IDIS,
 			   	ip9028_otg->regs + IP9028_OTGSC);
 			if (otgsc & IP9028_OTGSC_ID) {
 				timeout = 10;
-				writel ((otgsc & 0x0000FFFF) | IP9028_OTGSC_1msE, 
+				writel ((otgsc & 0xFF00FFFF) /* | IP9028_OTGSC_1msE */| IP9028_OTGSC_IDIE |IP9028_OTGSC_ASVIE | IP9028_OTGSC_BSVIE| IP9028_OTGSC_BSEIE, 
 					ip9028_otg->regs + IP9028_OTGSC);
 				schedule_work(&ip9028_otg->wq_host_remove);
 				ip9028_otg->otg.state = OTG_STATE_A_WAIT_VFALL;
@@ -771,7 +814,7 @@ static struct platform_driver ip9028_otg
 
 static int pwr_off_main_thread(void *_pwr_off_otg)
 {
-//	struct fsg_dev		*fsg = fsg_;
+
         struct ip9028_otg_usb *ip9028_otg = _pwr_off_otg;
 	 unsigned int tmp;
 
@@ -814,7 +857,7 @@ static int pwr_off_main_thread(void *_pw
 
 static int srp_main_thread(void *_srp_otg)
 {
-//	struct fsg_dev		*fsg = fsg_;
+
         struct ip9028_otg_usb *ip9028_otg = _srp_otg;
 	 unsigned int tmp;
 
@@ -838,17 +881,6 @@ static int srp_main_thread(void *_srp_ot
 			tmp  |= (IP9028_OTGSC_OT |IP9028_OTGSC_DP |IP9028_OTGSC_HADP);
 			writel (tmp, ip9028_otg->regs + IP9028_OTGSC);
 			
-/*
-			tmp = readl (ip9028_otg->regs + IP9028_OTGSC);
-			tmp  |= IP9028_OTGSC_DP;
-			writel (tmp, ip9028_otg->regs + IP9028_OTGSC);
-			
-		
-			tmp = readl (ip9028_otg->regs + IP9028_OTGSC);
-			tmp  |= IP9028_OTGSC_HADP;
-			writel (tmp, ip9028_otg->regs + IP9028_OTGSC);
-*/
-
 			
 
 			printk("  SRP Intialization  done \n");
@@ -895,6 +927,31 @@ int proc_usb_otg_host_poweroff(char *buf
 		
 }
 
+int proc_usb_otg_host_mnt_set_unset(char *buffer,char **buffer_location,off_t offset,
+                             int buffer_length, int *eof, void *data)
+{
+
+		printk(KERN_INFO "proc_usb_otg_host_mnt_set_unset\n");
+
+		if(Ismnt)
+		{
+			printk(" USB DRIVE is mounted currently ,unset the mount status \n");
+			Ismnt=0;
+		}
+		else
+		{
+			printk(" USB DRIVE is unmounted currently ,set the mount status \n");
+			Ismnt=1;
+		}
+
+		
+
+		return 0;
+		
+}
+
+
+
 void usb_otg_create_proc_entry(void)
 {
     static struct proc_dir_entry *gadget_proc_file ;
@@ -902,30 +959,42 @@ void usb_otg_create_proc_entry(void)
 
     gadget_proc_file = create_proc_entry("usb_otg_start_srp", 0644, NULL);
     if (gadget_proc_file == NULL) {
-           //  remove_proc_entry("usb_gadget1", &gadget_proc_file);
+           
              printk(KERN_ALERT "Error: Could not initialize /proc/%s\n","usb_otg_start_srp");
              return;
     }
     gadget_proc_file->read_proc = proc_usb_otg_start_srp;
-    gadget_proc_file->owner = THIS_MODULE;
+    /* gadget_proc_file->owner = THIS_MODULE; */
     gadget_proc_file->mode = S_IFREG | S_IRUGO;
     gadget_proc_file->uid = 0;
     gadget_proc_file->gid = 0;
     gadget_proc_file->size = 100;
 
-    gadget_proc_file = create_proc_entry("proc_usb_otg_host_poweroff", 0644, NULL);
+    gadget_proc_file = create_proc_entry("usb_otg_host_poweroff", 0644, NULL);
     if (gadget_proc_file == NULL) {
-            // remove_proc_entry("usb_gadget2", &gadget_proc_file);
-             printk(KERN_ALERT "Error: Could not initialize /proc/%s\n","proc_usb_otg_host_poweroff");
+            
+             printk(KERN_ALERT "Error: Could not initialize /proc/%s\n","usb_otg_host_poweroff");
              return;
     }
     gadget_proc_file->read_proc = proc_usb_otg_host_poweroff;
-    gadget_proc_file->owner = THIS_MODULE;
+    /* gadget_proc_file->owner = THIS_MODULE; */
     gadget_proc_file->mode = S_IFREG | S_IRUGO;
     gadget_proc_file->uid = 0;
     gadget_proc_file->gid = 0;
     gadget_proc_file->size = 100;
 
+   gadget_proc_file = create_proc_entry("usb_otg_host_mnt_set_unset", 0644, NULL);
+    if (gadget_proc_file == NULL) {
+            
+             printk(KERN_ALERT "Error: Could not initialize /proc/%s\n","usb_otg_host_mnt_set_unset");
+             return;
+    }
+    gadget_proc_file->read_proc = proc_usb_otg_host_mnt_set_unset;
+    /* gadget_proc_file->owner = THIS_MODULE; */
+    gadget_proc_file->mode = S_IFREG | S_IRUGO;
+    gadget_proc_file->uid = 0;
+    gadget_proc_file->gid = 0;
+    gadget_proc_file->size = 100;
 
 
 }
@@ -935,7 +1004,7 @@ void usb_otg_create_proc_entry(void)
 
 
 
-/*static */ int __devinit ip9028_otg_usb_probe(struct platform_device *pdev)
+ int __devinit ip9028_otg_usb_probe(struct platform_device *pdev)
 {
 	struct ip9028_otg_usb	*ip9028_otg;
 	int			status, retval,err;
@@ -943,23 +1012,8 @@ void usb_otg_create_proc_entry(void)
 	
 
 
-	printk(" SENTHIL   ip9028_otg_usb_probe \n");
-
-/*	
-
-	if (pdev->resource[1].flags != IORESOURCE_IRQ) {
-		printk("resource[1] is not IORESOURCE_IRQ\n");
-		return -EINVAL;
-	}
-
-
+	printk(KERN_DEBUG"    ip9028_otg_usb_probe \n");
 
-	if (!request_mem_region(pdev->resource[0].start, pdev->resource[0].end - 
-	    pdev->resource[0].start + 1, "ip9028_otg")) {
-		printk (KERN_ALERT "request_mem_region failed\n");
-		return -EBUSY;
-	}
-*/
 	ip9028_otg = kzalloc(sizeof *ip9028_otg, GFP_KERNEL);
 	if (!ip9028_otg)
 		return -ENOMEM;
@@ -973,7 +1027,7 @@ void usb_otg_create_proc_entry(void)
 	}
 
 	ip9028_otg->dev			= &pdev->dev;
-	// USB_UDC_CHECK ip9028_otg->irq = platform_get_irq(pdev, 1);	// (pdev, 0);
+	
 	ip9028_otg->irq			= pdev->resource[1].start;
 	ip9028_otg->otg.dev		= ip9028_otg->dev;
 	ip9028_otg->otg.label		= "ip9028_otg";
@@ -982,7 +1036,7 @@ void usb_otg_create_proc_entry(void)
 	ip9028_otg->otg.set_suspend	= ip9028_otg_set_suspend;
 	ip9028_otg->otg.start_hnp =  ip9028_otg_start_hnp;
 	ip9028_otg->usb_host.dma_mask	= &ehci_dmamask;
-	ip9028_otg->usb_host.coherent_dma_mask = 0x1fffffff;
+	ip9028_otg->usb_host.coherent_dma_mask = 0xffffffff;
 	ip9028_otg->usb_peripheral.dma_mask = &ehci_dmamask;
 	ip9028_otg->usb_peripheral.coherent_dma_mask = 0x1fffffff;
 
@@ -991,7 +1045,7 @@ void usb_otg_create_proc_entry(void)
 
 	wq_host_probe_g = &ip9028_otg->wq_host_probe;
 
-	//INIT_WORK(&wq_host_probe_g, ip9028_otg_wq_host_probe);
+	
 	
 	
 
@@ -1021,30 +1075,7 @@ void usb_otg_create_proc_entry(void)
 	retval = device_register (&ip9028_otg->usb_peripheral);
 
 
-	// USB_UDC_CHECK: check for probe success/fail. incase fail, subsequent controller operations cause Kernel crash.
-//	#ifdef FSL_PORT
-	//retval = fsl_otg_udc_probe (pdev /*&ip9028_otg->usb_peripheral*/, ip9028_otg->regs,  ip9028_otg->irq);	// Use FSL PORT...
-//	 retval = fsl_otg_udc_probe (&ip9028_otg->usb_peripheral, ip9028_otg->regs, ip9028_otg->irq);
-//	printk("===== SENTHIL ******fsl_otg_udc_probe done: irq %d, iobase 0x%x\n", ip9028_otg->irq, pdev->resource[0].start);
-//	#else
-//	retval = cnxt_udc_probe(&udc_device0);	// Use NOCONA PORT...
-//	printk("===== SENTHIL ******cnxt_udc_probe done: irq %d, iobase 0x%x\n", ip9028_otg->irq, pdev->resource[0].start);
-//	#endif
-
-//	if (retval != 0) 
-//	{
-//		dev_dbg(&pdev->dev, "can't get IRQ %d, err %d\n",
-//			ip9028_otg->irq, retval);
-//		kfree(ip9028_otg);
-//		return retval;
-//	}
-	
-//	#ifdef FSL_PORT
-//	fsl_udc_otg_suspend ();		// Use FSL PORT...
-//	#else
-//	cnxt_udc_suspend();			// Use NOCONA PORT...
-//	#endif
-//*/	
+		
 	status = request_irq(ip9028_otg->irq, ip9028_otg_usb_irq,
 			IRQF_SHARED /* | IRQF_DISABLED */,
 			/* "ip9028_otg_usb"*/"ip9028_udc_udc", ip9028_otg);
@@ -1055,17 +1086,13 @@ void usb_otg_create_proc_entry(void)
 		return status;
 	}
 
-	//mode= readl (ip9028_otg->regs + IP9028_USBMODE);
-
-	//writel (mode |IP9028_USBMODE_IDLE_MASK ,
-	//ip9028_otg->regs + IP9028_USBMODE);
-
-	ip9028_otg->otg.state = OTG_STATE_UNDEFINED; //
-	/* ip9028_otg_usb_irq(ip9028_otg->irq, ip9028_otg);  */
+	
+	ip9028_otg->otg.state = OTG_STATE_UNDEFINED; 
+	
 
-	otgsc = readl (ip9028_otg->regs + IP9028_OTGSC);  //
+	otgsc = readl (ip9028_otg->regs + IP9028_OTGSC);  
 	writel ((otgsc & 0xFFFFFFFF) | IP9028_OTGSC_IDIE |IP9028_OTGSC_IDPU|IP9028_OTGSC_ASVIE  |IP9028_OTGSC_BSVIE | IP9028_OTGSC_AVVIE  | IP9028_OTGSC_BSEIE,
-	   		ip9028_otg->regs + IP9028_OTGSC); //
+	   		ip9028_otg->regs + IP9028_OTGSC); 
 	
 #ifdef OTG_PROC_IF
 	usb_otg_create_proc_entry();
@@ -1101,6 +1128,7 @@ void usb_otg_create_proc_entry(void)
 
 #endif
 
+	ip9028_otg->hcd = NULL;
 	
 	printk (KERN_INFO "Initialized IP9028 OTG USB module\n");
 	return 0;
@@ -1125,7 +1153,7 @@ static int __init ip9028_otg_usb_init(vo
 	return platform_driver_register(&ip9028_otg_usb_driver);
 }
 module_init(ip9028_otg_usb_init);	// USB_UDC_CHECK
-//USB_UDC_CHECK subsys_initcall(ip9028_otg_usb_init);
+
 
 static void __exit ip9028_otg_usb_exit(void)
 {
diff -Naurp linux-2.6.34.org/include/linux/usb/gadget.h linux-2.6.34/include/linux/usb/gadget.h
--- linux-2.6.34.org/include/linux/usb/gadget.h	2010-05-16 16:17:36.000000000 -0500
+++ linux-2.6.34/include/linux/usb/gadget.h	2010-09-21 16:31:59.000000000 -0500
@@ -864,7 +864,7 @@ int usb_descriptor_fillbuf(void *, unsig
 
 /* build config descriptor from single descriptor vector */
 int usb_gadget_config_buf(const struct usb_config_descriptor *config,
-	void *buf, unsigned buflen, const struct usb_descriptor_header **desc);
+	void *buf, unsigned buflen, const struct usb_descriptor_header **desc,u8 speed);
 
 /* copy a NULL-terminated vector of descriptors */
 struct usb_descriptor_header **usb_copy_descriptors(
diff -Naurp linux-2.6.34.org/include/linux/usb/ip9028-otg.h linux-2.6.34/include/linux/usb/ip9028-otg.h
--- linux-2.6.34.org/include/linux/usb/ip9028-otg.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.34/include/linux/usb/ip9028-otg.h	2010-09-21 16:31:59.000000000 -0500
@@ -0,0 +1,126 @@
+/**
+ * Copyright 2006, 2007 (C) NXP BV, All Rights Reserved
+ * Author: OKC <okc.helpdesk@nxp.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#ifndef __LINUX_USB_IP9028_OTG_H
+#define __LINUX_USB_IP9028_OTG_H
+
+#include <../drivers/usb/core/hcd.h>
+#include <mach/usbudc.h>
+
+extern const struct hc_driver ehci_ip9028_hc_driver  /* ehci_ip9028_otg_hc_driver */;
+int fsl_udc_otg_resume(void);
+#ifdef FSL_PORT
+extern int fsl_udc_otg_suspend(void);	// Use FSL PORT...
+//extern int __init fsl_otg_udc_probe(struct platform_device *pdev /*struct device *dev*/, void *regs, int irq);	// Use FSL PORT...
+extern int __init fsl_otg_udc_probe(struct device *dev, void *regs, int irq);	// Use FSL PORT...
+#else
+extern int cnxt_udc_suspend(void);		// Use NOCONA PORT...
+extern int __init cnxt_udc_probe(struct platform_device *pdev);	// Use NOCONA PORT...
+extern struct platform_device udc_device0;
+#endif
+int __exit fsl_otg_udc_remove(void);
+
+#define IP9028_PRTSC		0x184
+#define IP9028_USBCMD		0x140
+#define IP9028_USBMOD		0x1A8
+#define IP9028_USBCMD_PSE	(1 << 4)
+#define IP9028_USBCMD_ASE	(1 << 5)
+#define IP9028_PRTSC_PP		(1 << 12)
+#define IP9028_PRTSC_SUSP	(1 << 7)
+#define IP9028_PRTSC_CCS	(1 << 0)
+#define IP9028_OTGSC		0x1A4
+
+
+
+/* Added  missing register sets  START*/
+
+#define IP9028_OTGSC_VD	(1 <<  0)
+#define IP9028_OTGSC_VC	(1 <<  1)
+#define IP9028_OTGSC_HARA	(1 <<  2)
+#define IP9028_OTGSC_OT	(1 <<  3)
+#define IP9028_OTGSC_DP	(1 <<  4)
+#define IP9028_OTGSC_IDPU	(1 <<  5)
+#define IP9028_OTGSC_HADP	(1 <<  6)
+#define IP9028_OTGSC_HABA	(1 <<  7)
+
+/* Added  missing register sets  END*/
+
+
+
+#define IP9028_OTGSC_ID		(1 <<  8)
+#define IP9028_OTGSC_ASV	(1 << 10)
+#define IP9028_OTGSC_BSV	(1 << 11)
+#define IP9028_OTGSC_IDIS	(1 << 16)
+#define IP9028_OTGSC_AVV	(1 << 17)
+#define IP9028_OTGSC_IDIS	(1 << 16)
+#define IP9028_OTGSC_AVVIS	(1 << 17)
+#define IP9028_OTGSC_ASVIS	(1 << 18)
+#define IP9028_OTGSC_BSVIS	(1 << 19)
+#define IP9028_OTGSC_BSEIS	(1 << 20)
+#define IP9028_OTGSC_1msS	(1 << 21)
+
+/* Added  missing register sets */
+
+#define IP9028_OTGSC_DPIS	(1 << 22) 
+#define IP9028_OTGSC_IDIE	(1 << 24)
+#define IP9028_OTGSC_AVVIE	(1 << 25)
+#define IP9028_OTGSC_ASVIE	(1 << 26)
+#define IP9028_OTGSC_BSVIE	(1 << 27)
+#define IP9028_OTGSC_BSEIE	(1 << 28)
+#define IP9028_OTGSC_1msE	(1 << 29)
+#define IP9028_OTGSC_DPIE	(1 << 30)
+#define IP9028_USBMODE		0x1A8
+#define IP9028_USBMODE_IDLE	0x0
+#define IP9028_USBMODE_DEVICE	0x2
+#define IP9028_USBMODE_HOST	0x3
+#define IP9028_USBMODE_MASK	0x3
+
+/* Added   Interrupt Mask flag  */
+#define IP9028_OTGSC_INT_STS_MASK (0x005F0000)
+#define IP9028_USBMODE_IDLE_MASK 0xFFFFFFFC
+#define IP9028_PRTSC_PP_OFF_MASK 0xFFFFEFFF
+#define IP9028_PRTSC_CCS_MASK 0x00000001
+#define IP9028_OTGSC_INT_BSEIS 0x00100000
+#define IP9028_OTGSC_INT_ASVIS   0x00040000
+#define IP9028_OTGSC_INT_BSVIS   0x00080000
+
+
+
+struct ip9028_otg_usb {
+	struct otg_transceiver	otg;
+	struct device		*dev;
+
+
+	/* for vbus reporting with irqs disabled */
+	spinlock_t		lock;
+
+	int			irq;
+	void			*regs;
+	bool			irq_enabled;
+
+	struct work_struct	wq_host_probe;
+	struct work_struct	wq_host_remove;
+
+	struct platform_device	*pdev;
+	struct usb_hcd		*hcd;
+	struct device		usb_host;
+	struct device		usb_peripheral;
+	
+};
+
+#endif /* __LINUX_USB_IP9028_OTG_H */
