diff --git a/MAKEALL b/MAKEALL
index a02412b..0b7ffc6 100755
--- a/MAKEALL
+++ b/MAKEALL
@@ -655,6 +655,40 @@ LIST_blackfin="		\
 	bf561-ezkit	\
 "
 
+#########################################################################
+## SuperH SH4 Systems
+#########################################################################
+
+LIST_sh="		\
+	mb411		\
+	mb448		\
+	mb442_27	\
+	mb442_30	\
+	mb442_27_128	\
+	mb442_30_128	\
+	mb442se_27	\
+	mb442se_30	\
+	mb442se_27_128	\
+	mb442se_30_128	\
+	hms1		\
+	hms1_128	\
+	mb519		\
+	mb519se		\
+	cb101		\
+	cb101se		\
+"
+
+#########################################################################
+## STMicroelectronics ST200 Systems
+#########################################################################
+
+LIST_st200="		\
+	sti5301mb390	\
+	sti5301mb424	\
+	stm8010mboard	\
+	traviata	\
+"
+
 #-----------------------------------------------------------------------
 
 #----- for now, just run PPC by default -----
@@ -689,6 +723,8 @@ do
 	mips|mips_el| \
 	nios|nios2| \
 	ppc|5xx|5xxx|512x|8xx|8220|824x|8260|83xx|85xx|86xx|4xx|7xx|74xx| \
+	sh| \
+	st200| \
 	x86|I486|TSEC)
 			for target in `eval echo '$LIST_'${arg}`
 			do
diff --git a/Makefile b/Makefile
index 1ff80b5..d6a2ab6 100644
--- a/Makefile
+++ b/Makefile
@@ -152,6 +152,12 @@ endif
 ifeq ($(ARCH),avr32)
 CROSS_COMPILE = avr32-linux-
 endif
+ifeq ($(ARCH),sh)
+CROSS_COMPILE = sh4-linux-
+endif
+ifeq ($(ARCH),st200)
+CROSS_COMPILE = st231-linux-
+endif
 endif
 endif
 
@@ -2658,6 +2664,117 @@ bf561-ezkit_config:	unconfig
 atstk1002_config	:	unconfig
 	@$(MKCONFIG) $(@:_config=) avr32 at32ap atstk1000 atmel at32ap7000
 
+#========================================================================
+# SuperH
+#========================================================================
+#########################################################################
+## SuperH SH4
+#########################################################################
+
+mb411_config :		unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_SH_STB7100 1" >>include/config.h
+	@echo "#define CONFIG_SH_MB411   1" >>include/config.h
+	@./mkconfig -a mb411 sh sh mb411 "" stb7100
+
+mb442_27_config \
+mb442_30_config \
+mb442_27_128_config \
+mb442_30_128_config \
+mb442se_27_config \
+mb442se_30_config \
+mb442se_27_128_config \
+mb442se_30_128_config : 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_SH_STB7100   1" >>include/config.h
+	@echo "#define CONFIG_SH_MB442     1" >>include/config.h
+	$(if $(findstring 27,$@), \
+	@echo "#define INPUT_CLOCK_RATE    27" >>include/config.h)
+	$(if $(findstring 30,$@), \
+	@echo "#define INPUT_CLOCK_RATE    30" >>include/config.h)
+	$(if $(findstring 128,$@), \
+	@echo "#define CONFIG_SH_MB442_128 1" >>include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x83F00000" >$(obj)board/mb442/config.tmp)
+	@./mkconfig -a mb442 sh sh mb442 "" stb7100
+
+mb448_config :		unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_SH_STB7100   1" >>include/config.h
+	@echo "#define CONFIG_SH_MB448     1" >>include/config.h
+	@echo "#define INPUT_CLOCK_RATE    27" >>include/config.h
+	@./mkconfig -a mb448 sh sh mb448 "" stb7100
+
+hms1_config \
+hms1_128_config :		unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_SH_STB7100   1" >>include/config.h
+	@echo "#define CONFIG_SH_HMS1      1" >>include/config.h
+	$(if $(findstring 128,$@), \
+	@echo "#define CONFIG_SH_HMS1_128  1" >>include/config.h)
+	@./mkconfig -a hms1 sh sh hms1 "" stb7100
+
+mb519_config \
+mb519se_config :		unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_SH_STX7200   1" >>include/config.h
+	@echo "#define CONFIG_SH_MB519     1" >>include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/mb519/config.tmp)
+	@./mkconfig -a mb519 sh sh mb519 "" stx7200
+
+cb101_config \
+cb101se_config :		unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_SH_STX7200   1" >>include/config.h
+	@echo "#define CONFIG_SH_CB101     1" >>include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/cb101/config.tmp)
+	@./mkconfig -a cb101 sh sh cb101 "" stx7200
+
+
+#========================================================================
+# STMicroelectronics ST200
+#========================================================================
+#########################################################################
+## STMicroelectronics ST231
+#########################################################################
+
+sti5301mb390_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_STM_MB390   1" >>include/config.h
+	@echo "#define CONFIG_STM_STI5301 1" >>include/config.h
+	@echo "#define CONFIG_STM_ST231   1" >>include/config.h
+	@./mkconfig -a sti5301mb390 st200 st231 sti5301mb390 "" sti5301
+
+sti5301mb424_config		: 	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_STM_MB424   1" >>include/config.h
+	@echo "#define CONFIG_STM_STI5301 1" >>include/config.h
+	@echo "#define CONFIG_STM_ST231   1" >>include/config.h
+	@./mkconfig -a sti5301mb424 st200 st231 sti5301mb424 "" sti5301
+
+stm8010mboard_config		:	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_STM_STM8010_MBOARD   1" >>include/config.h
+	@echo "#define CONFIG_STM_STM8010 1" >>include/config.h
+	@echo "#define CONFIG_STM_ST231   1" >>include/config.h
+	@./mkconfig -a stm8010mboard st200 st231 stm8010mboard "" stm8010
+
+traviata_config		:	unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_STM_TRAVIATA   1" >>include/config.h
+	@echo "#define CONFIG_STM_STM8010 1" >>include/config.h
+	@echo "#define CONFIG_STM_ST231   1" >>include/config.h
+	@./mkconfig -a traviata st200 st231 traviata "" stm8010
+
+
 #########################################################################
 #########################################################################
 #########################################################################
diff --git a/README b/README
index 3dad5fc..cb683cf 100644
--- a/README
+++ b/README
@@ -152,6 +152,8 @@ Directory Hierarchy:
   - pxa		Files specific to Intel XScale PXA CPUs
   - s3c44b0	Files specific to Samsung S3C44B0 CPUs
   - sa1100	Files specific to Intel StrongARM SA1100 CPUs
+  - sh          Files specific to SuperH (SH) CPUs
+  - st231       Files specific to STMicroelectronics ST200 series CPUs
 - disk		Code for disk drive partition handling
 - doc		Documentation (don't expect too much)
 - drivers	Commonly used device drivers
@@ -166,6 +168,8 @@ Directory Hierarchy:
 - lib_mips	Files generic to MIPS	 architecture
 - lib_nios	Files generic to NIOS	 architecture
 - lib_ppc	Files generic to PowerPC architecture
+- lib_sh	Files generic to SuperH  architecture
+- lib_st200	Files generic to ST200   architecture
 - libfdt 	Library files to support flattened device trees
 - net		Networking code
 - post		Power On Self Test
diff --git a/board/cb101/Makefile b/board/cb101/Makefile
new file mode 100644
index 0000000..ff0f69a
--- /dev/null
+++ b/board/cb101/Makefile
@@ -0,0 +1,44 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+AOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o sconsole.o nand.o
+
+OBJS	= $(COBJS) $(AOBJS)
+
+$(LIB):	.depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/cb101/cb101.c b/board/cb101/cb101.c
new file mode 100644
index 0000000..7c8a90f
--- /dev/null
+++ b/board/cb101/cb101.c
@@ -0,0 +1,184 @@
+/*
+ * (C) Copyright 2007 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Martin Lesniak <martin.lesniak@st.com> - added cb101 support
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stx7200reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+void stx7200_reset(void);
+
+void flashWriteEnable(void)
+{
+	/*  Enable vpp for writing to flash */
+}
+
+void flashWriteDisable(void)
+{
+	/*  Disable vpp for writing to flash */
+}
+
+
+#define PIO_BASE  0xfd020000
+
+
+static void configPIO(void)
+{
+	/*  Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
+	SET_PIO_ASC(PIO_PORT(5), 4, 3, 5, 6);  /* UART3 - AS1 */
+
+
+	SET_PIO_PIN(PIO_PORT(4), 7, STPIO_OUT);
+	STPIO_SET_PIN(PIO_PORT(4), 7, 1);
+	udelay(1);
+	STPIO_SET_PIN(PIO_PORT(4), 7, 0);
+	udelay(1);
+	STPIO_SET_PIN(PIO_PORT(4), 7, 1);
+
+#if defined(CONFIG_CMD_NAND)
+	/*  Setup PIO for NAND FLASH devices: Ready/Not_Busy */
+	SET_PIO_PIN(PIO_PORT(2), 7, STPIO_IN);
+#endif	/* CONFIG_CMD_NAND */
+}
+
+
+#if defined(CONFIG_CMD_NAND)
+static void nand_emi_init(void)
+{
+	/* setup the EMI configuration for the 2 banks
+	 * containing NAND flash devices. */
+
+	/* NAND FLASH in EMI Bank #1 (128MB) */
+	*ST40_EMI_BANK1_EMICONFIGDATA0 = 0x04100e99;
+	*ST40_EMI_BANK1_EMICONFIGDATA1 = 0x04000200;
+	*ST40_EMI_BANK1_EMICONFIGDATA2 = 0x04000200;
+	*ST40_EMI_BANK1_EMICONFIGDATA3 = 0x00000000;
+
+	/* NAND FLASH in EMI Bank #2 (1GB) */
+	*ST40_EMI_BANK2_EMICONFIGDATA0 = 0x04100e99;
+	*ST40_EMI_BANK2_EMICONFIGDATA1 = 0x04000200;
+	*ST40_EMI_BANK2_EMICONFIGDATA2 = 0x04000200;
+	*ST40_EMI_BANK2_EMICONFIGDATA3 = 0x00000000;
+}
+#endif	/* CONFIG_CMD_NAND */
+
+
+int board_init(void)
+{
+	unsigned long sysconf;
+
+	/* Serial port set up */
+	/* Route UART2&3 or SCI inputs instead of DVP to pins: conf_pad_dvp = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG40;
+	sysconf &= ~(1<<16);
+	*STX7200_SYSCONF_SYS_CFG40 = sysconf;
+
+	/* Route UART2&3/SCI outputs instead of DVP to pins: conf_pad_pio[1]=0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<25);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* No idea, more routing: conf_pad_pio[0] = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<24);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART2 (inputs and outputs) instead of SCI to pins: ssc2_mux_sel = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<2);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* conf_pad_pio[4] = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<28);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART3 (inputs and outputs) instead of SCI to pins: ssc3_mux_sel = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* conf_pad_clkobs = 1 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf |= (1<<14);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* I2C and USB related routing */
+	/* bit4: ssc4_mux_sel = 0 (treat SSC4 as I2C) */
+	/* bit26: conf_pad_pio[2] = 0 route USB etc instead of DVO */
+	/* bit27: conf_pad_pio[3] = 0 DVO output selection (probably ignored) */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~((1<<27)|(1<<26)|(1<<4));
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Enable SOFT_JTAG mode.
+	 * Taken from OS21, but is this correct?
+	 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG33;
+	sysconf |= (1<<6);
+	sysconf &= ~((1<<0)|(1<<1)|(1<<2)|(1<<3));
+	*STX7200_SYSCONF_SYS_CFG33 = sysconf;
+
+	/* Route Ethernet pins to output */
+	/* bit26-16: conf_pad_eth(10:0) */
+	sysconf = *STX7200_SYSCONF_SYS_CFG41;
+	/* MII0: conf_pad_eth(0) = 0 (ethernet) */
+	sysconf &= ~(1<<16);
+	/* MII1: conf_pad_eth(2) = 0, (3)=0, (4)=0, (9)=0, (10)=0 (ethernet)
+	 * MII1: conf_pad_eth(6) = 0 (MII1TXD[0] = output) */
+	sysconf &= ~( (1<<(16+2)) | (1<<(16+3)) | (1<<(16+4)) | (1<<(16+6)) |
+		      (1<<(16+9)) | (1<<(16+10)));
+	*STX7200_SYSCONF_SYS_CFG41 = sysconf;
+
+#if defined(CONFIG_CMD_NAND)
+	nand_emi_init();
+#endif	/* CONFIG_CMD_NAND */
+
+	configPIO();
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: cb101"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	return 0;
+}
+
+int do_reset (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	stx7200_reset();
+	/*NOTREACHED*/ return (0);
+}
+
diff --git a/board/cb101/config.mk b/board/cb101/config.mk
new file mode 100644
index 0000000..cf00d78
--- /dev/null
+++ b/board/cb101/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB519 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x8FF00000	29-bit mode (Traditional Mode)
+#	0x87F00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 127MB in P1 (cachable)
+TEXT_BASE = 0x8FF00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/cb101/init-cb101.S b/board/cb101/init-cb101.S
new file mode 100644
index 0000000..c088092
--- /dev/null
+++ b/board/cb101/init-cb101.S
@@ -0,0 +1,387 @@
+
+#include "asm/stx7200reg.h"
+#include "../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb519.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+
+.balign 32
+
+
+__memory_setup_table:
+
+  /* ----- STx7200 Clocks ----- */
+
+  /* Set CLOCKGENA PLL0 into BYPASS... */
+  OR_LONG(STX7200_CLOCKGENA_PLL0_CFG, 0x00100000)
+
+  /* Power down CLOCKGENA PLL0... */
+  OR_LONG(STX7200_CLOCKGENA_POWER_CFG, 0x00000001)
+
+  /* Configure CLOCKGENA PLL0... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x03 | (0x23 << 8) | (0x00 << 16))
+
+  /* Enable CLOCKGENA PLL0... */
+  UPDATE_LONG(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffe, 0)
+
+  /* Wait for CLOCKGENA PLL0 to lock... */
+  WHILE_NE(STX7200_CLOCKGENA_PLL0_CFG, 0x80000000, 0x80000000)
+
+  /* Clear CLOCKGENA PLL0 from BYPASS... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+
+  /* Set CLOCKGENA PLL1 into BYPASS... */
+  OR_LONG(STX7200_CLOCKGENA_PLL1_CFG, 0x00100000)
+
+  /* Power down CLOCKGENA PLL1... */
+  OR_LONG(STX7200_CLOCKGENA_POWER_CFG, 0x00000002)
+
+  /* Configure CLOCKGENA PLL1... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x01 | (0x0f << 8))
+
+  /* Enable CLOCKGENA PLL1... */
+  UPDATE_LONG(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffd, 0)
+
+  /* Wait for CLOCKGENA PLL1 to lock... */
+  WHILE_NE(STX7200_CLOCKGENA_PLL1_CFG, 0x80000000,  0x80000000)
+
+  /* Clear CLOCKGENA PLL1 from BYPASS... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL1_CFG, 0xffefffff, 0)
+
+  /* Set CLOCKGENA PLL2 into BYPASS... */
+  OR_LONG(STX7200_CLOCKGENA_PLL2_CFG, 0x00100000)
+
+  /* Power down CLOCKGENA PLL2... */
+  OR_LONG(STX7200_CLOCKGENA_POWER_CFG, 0x00000004)
+
+  /* Configure CLOCKGENA PLL2... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL2_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
+
+  /* Enable CLOCKGENA PLL2... */
+  UPDATE_LONG(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffb, 0)
+
+  /* Wait for CLOCKGENA PLL2 to lock... */
+  WHILE_NE(STX7200_CLOCKGENA_PLL2_CFG, 0x80000000,  0x80000000)
+
+  /* Clear CLOCKGENA PLL2 from BYPASS... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL2_CFG, 0xffefffff, 0)
+
+  /* Set CLOCKGENB PLL0 into BYPASS... */
+  OR_LONG(STX7200_CLOCKGENB_PLL0_CFG, 0x00100000)
+
+  /* Power down CLOCKGENB PLL0... */
+  OR_LONG(STX7200_CLOCKGENB_POWER_CFG, 0x00008000)
+
+  /* Configure CLOCKGENB PLL0... */
+  UPDATE_LONG(STX7200_CLOCKGENB_PLL0_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
+
+  /* Enable CLOCKGENB PLL0... */
+  UPDATE_LONG(STX7200_CLOCKGENB_POWER_CFG, 0xffff7fff, 0)
+
+  /* Wait for CLOCKGENB PLL0 to lock... */
+  WHILE_NE(STX7200_CLOCKGENB_PLL0_CFG, 0x80000000, 0x80000000)
+
+  /* Clear CLOCKGENB PLL0 from BYPASS... */
+  UPDATE_LONG(STX7200_CLOCKGENB_PLL0_CFG, 0xffefffff, 0)
+
+  /* Power down PLL... */
+  OR_LONG(STX7200_SYSCONF_SYS_CFG11, 0x00001000)
+
+  /* Configure PLL... */
+  /* Set LMI clock to 666MHz */
+  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x05 << 9) | (0x6f << 1))
+  /* On PCB rev A, we have a limitation on LMI1: Reset LMI clock to 400MHz */
+  IF(0xa5020000, 0x000000ff, 0x0000000a, UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x28 << 1)))
+
+  /* Enable CLOCKGENA PLL1... */
+  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xffffefff, 0)
+
+  /* Wait for CLOCKGENA PLL1 to lock... (polarity inverted on lock bit) */
+  WHILE_NE(STX7200_SYSCONF_SYS_STA03, 0x00000001, 0)
+
+  /* ----- STx7200 Sysconf ----- */
+
+  /* Exit from reset */
+  OR_LONG(STX7200_SYSCONF_SYS_CFG11, 0x00000001)
+  OR_LONG(STX7200_SYSCONF_SYS_CFG15, 0x00000001)
+
+  /* Check both DLL on LMI0 are locked */
+  WHILE_NE(STX7200_SYSCONF_SYS_STA03, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
+
+  /* Check both DLL on LMI1 are locked */
+  WHILE_NE(STX7200_SYSCONF_SYS_STA05, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
+
+  /* Adjust proga, progb, zoutproga, and receiver mode for LMI0 */
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG12, 0xa2007801 | (0x0 << 1) | (0x7 << 4) | (0x7 << 7) | (0x0 << 10))
+
+  /* Adjust proga, progb, zoutproga, and receiver mode for LMI1 */
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG16, 0xa2007801 | (0x0 << 1) | (0x7 << 4) | (0x7 << 7) | (0x0 << 10))
+
+  /* Enable AutoPrecharge */
+  OR_LONG(STX7200_SYSCONF_SYS_CFG38, 0x00030000)
+  OR_LONG(STX7200_SYSCONF_SYS_CFG39, 0x00030000)
+
+  /* Force DLL1 and DLL2 commands of LMI0 */
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG13, 0x00000002)
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG14, 0x00000002)
+
+  /* Force DLL1 and DLL2 commands of LMI1 */
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG17, 0x00000002)
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG18, 0x00000002)
+
+  /* ----- STx7200 EMI configuration ----- */
+
+  POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000005)
+
+  /* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
+  POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+  POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
+  POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x0000000c)
+  POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
+  POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x00000014)
+
+  /* Bank #0 - NOR FLASH (32MB) at address 0x00000000 -> 0x01ffffff */
+  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x04320691)
+  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x8F122300)
+  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x8F122300)
+  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+
+  /* Bank #1 - NAND FLASH (128MB), at address 0x02000000 -> 0x02FFFFFF */
+#if 0
+  /* this code has been moved to nand_emi_init() in board/cb101/cb101.c */
+  POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA0, 0x04100e99);
+  POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA1, 0x04000200);
+  POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA2, 0x04000200);
+  POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000);
+#endif
+
+  /* Bank #2 - NAND FLASH (1GB), at address 0x03000000 -> 0x03FFFFFF */
+#if 0
+  /* this code has been moved to nand_emi_init() in board/cb101/cb101.c */
+  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 0x04100e99);
+  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 0x04000200);
+  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 0x04000200);
+  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000);
+#endif
+
+  /* Bank #3 - unused, at address 0x04000000 -> 0x04FFFFFF */
+
+  /* Bank #4 - unused, at address 0x05000000 -> 0x05FFFFFF */
+
+  /* Program other EMI registers */
+  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+
+  /* ----- STx7200 LMI0 configuration ----- */
+
+  /* "Refresh Interval" is set equal to 0xA28=2600 => 2600*3ns=7.8us */
+/*POKE_LONG(ST40_LMI_MIM_0(0), 0x0a28015b)*/ /* OLD */
+  POKE_LONG(ST40_LMI_MIM_0(0), 0x0a28035b)
+/*POKE_LONG(ST40_LMI_MIM_1(0), 0xffff1010)*/ /* OLD */
+  POKE_LONG(ST40_LMI_MIM_1(0), 0x000000b0)
+
+  POKE_LONG(ST40_LMI_STR_0(0), 0xcb2cab5b)
+  POKE_LONG(ST40_LMI_STR_1(0), 0x000002d6)
+
+  /* lmi base address 0x08000000 + 128Mbytes 13x10 */
+  POKE_LONG(ST40_LMI_SDRA0_0(0), 0x10000a00)
+
+  /* lmi base address 0x08000000 + 128Mbytes 13x10 */
+  POKE_LONG(ST40_LMI_SDRA1_0(0), 0x10000a00)
+
+  /* Enable clock with NOP command */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020023)
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+
+  /* Precharge all */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020022)
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+
+  /* Issue EMRS2 */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000800)
+
+  /* Issue EMRS3 */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000c00)
+
+  /* Issue EMRS1 to enable DLL */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000400)
+
+  /* Issue MRS with DLL reset(0), CAS 5(0), Write recovery 6(0), Sequentiel(0), Burst lengh 8 */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00002353)
+
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+
+  /* Precharge all */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020022)
+  /* 2 CBR (auto refresh) */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020024)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020024)
+
+  /* Issue MRS with CAS 5(0), Write recovery 6(0), Sequentiel(0), Burst lengh 8 */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00002253)
+
+  /* Issue EMRS1 for OCD calibration default */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x000007c4)
+
+  /* Issue EMRS1 for OCD calibration exit */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000444)
+
+  /* Enable auto refresh */
+  POKE_LONG(ST40_LMI_MIM_0(0), 0x0a28035b)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+
+  POKE_LONG(ST40_LMI_GCC_0(0), 0x00382003)
+
+  /* ----- STx7200 LMI1 configuration ----- */
+
+  /* "Refresh Interval" is set equal to 0xA28=0d2600 => 2600*3ns=7.8us */
+  POKE_LONG(ST40_LMI_MIM_0(1), 0x0a28015b)
+  POKE_LONG(ST40_LMI_MIM_1(1), 0x000000b0)
+
+  POKE_LONG(ST40_LMI_STR_0(1), 0xcb2cab5b)
+  POKE_LONG(ST40_LMI_STR_1(1), 0x000002d6)
+
+  /* lmi base address 0x18000000 + 64Mbytes 13x10 (all 128MBytes are not visible in 29bits mode) */
+  POKE_LONG(ST40_LMI_SDRA0_0(1), 0x1c000a00)
+
+  /* lmi base address 0x18000000 + 64Mbytes 13x10 (all 128MBytes are not visible in 29bits mode) */
+  POKE_LONG(ST40_LMI_SDRA1_0(1), 0x1c000a00)
+
+  /* Enable clock with NOP command */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020023)
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+
+  /* Precharge all */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020022)
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+
+  /* Issue EMRS2 */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000800)
+
+  /* Issue EMRS3 */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000c00)
+
+  /* Issue EMRS1 to enable DLL */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000400)
+
+  /* Issue MRS with DLL reset(1), CAS 5(1), Write recovery 6(1), Sequentiel(1), Burst lengh 8 */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00002353)
+
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+
+  /* Precharge all */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020022)
+  /* 2 CBR (auto refresh) */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020024)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020024)
+
+  /* Issue MRS with CAS 5(1), Write recovery 6(1), Sequentiel(1), Burst lengh 8 */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00002253)
+
+  /* Issue EMRS1 for OCD calibration default */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x000007c4)
+
+  /* Issue EMRS1 for OCD calibration exit */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000444)
+
+  /* Enable auto refresh */
+  POKE_LONG(ST40_LMI_MIM_0(1), 0x0a28035b)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+
+  POKE_LONG(ST40_LMI_GCC_0(1), 0x00382003)
+
+#ifdef CONFIG_SH_SE_MODE
+  /*
+   * Note that we also manually need to move the LMI0 and LMI1 base addresses to
+   * their 32-bit SE mode locations as defined in the datasheet and change the
+   * 'upper bound addresses' (in row attribute registers) for the LMIs.
+   */
+  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+  POKE_LONG(ST40_LMI_SDRA0_0(0), 0x48000a00)
+  POKE_LONG(ST40_LMI_SDRA1_0(0), 0x48000a00)
+  POKE_LONG(ST40_LMI_SDRA0_0(1), 0x88000a00)
+  POKE_LONG(ST40_LMI_SDRA1_0(1), 0x88000a00)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/cb101/nand.c b/board/cb101/nand.c
new file mode 100644
index 0000000..697a901
--- /dev/null
+++ b/board/cb101/nand.c
@@ -0,0 +1,107 @@
+/*
+ * (C) Copyright 2006 DENX Software Engineering
+ * (C) Copyright 2008 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+
+#if defined(CONFIG_CMD_NAND)
+
+#include <nand.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stx7200reg.h>
+
+#define PIO_BASE  0xfd020000
+
+
+/*
+ * hardware specific access to control-lines
+ *	CL -> Emi_Addr(17)
+ *	AL -> Emi_Addr(18)
+ *	nCE is handled by EMI (not s/w controlable)
+ */
+static void cb101_hwcontrol(struct mtd_info *mtdinfo, int cmd)
+{
+	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
+
+	switch(cmd) {
+
+	case NAND_CTL_SETCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 17));
+		break;
+
+	case NAND_CTL_CLRCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 17));
+		break;
+
+	case NAND_CTL_SETALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 18));
+		break;
+
+	case NAND_CTL_CLRALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 18));
+		break;
+	}
+}
+
+
+/*
+ * hardware specific access to the Ready/not_Busy signal.
+ * Signal is routed through GPIO port#2, pin #7.
+ */
+static int cb101_device_ready(struct mtd_info *mtd)
+{
+	int ret = STPIO_GET_PIN(2,7);
+	return ret;
+}
+
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+extern int board_nand_init(struct nand_chip *nand)
+{
+	nand->hwcontrol = cb101_hwcontrol;
+	nand->dev_ready = cb101_device_ready;
+	nand->eccmode = NAND_ECC_SOFT;
+	nand->chip_delay = 25;
+	nand->options = NAND_NO_AUTOINCR;
+	return 0;
+}
+#endif	/* CONFIG_CMD_NAND */
+
diff --git a/board/cb101/sconsole.c b/board/cb101/sconsole.c
new file mode 100644
index 0000000..af92525
--- /dev/null
+++ b/board/cb101/sconsole.c
@@ -0,0 +1,129 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+
+#include "sconsole.h"
+
+#if 0
+void (*sconsole_putc) (char) = 0;
+void (*sconsole_puts) (const char *) = 0;
+int (*sconsole_getc) (void) = 0;
+int (*sconsole_tstc) (void) = 0;
+void (*sconsole_setbrg) (void) = 0;
+#endif
+
+#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
+int serial_init (void)
+{
+	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+	sb->pos = 0;
+	sb->size = 0;
+	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
+
+	return (0);
+}
+
+void serial_putc (char c)
+{
+	if (sconsole_putc) {
+		(*sconsole_putc) (c);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		if (c) {
+			sb->data[sb->pos++] = c;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+void serial_puts (const char *s)
+{
+	if (sconsole_puts) {
+		(*sconsole_puts) (s);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		while (*s) {
+			sb->data[sb->pos++] = *s++;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+int serial_getc (void)
+{
+	if (sconsole_getc) {
+		return (*sconsole_getc) ();
+	} else {
+		return 0;
+	}
+}
+
+int serial_tstc (void)
+{
+	if (sconsole_tstc) {
+		return (*sconsole_tstc) ();
+	} else {
+		return 0;
+	}
+}
+
+void serial_setbrg (void)
+{
+	if (sconsole_setbrg) {
+		(*sconsole_setbrg) ();
+	}
+}
+
+void sconsole_flush (void)
+{
+	if (sconsole_putc) {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+		unsigned int end = sb->pos < sb->size
+			? sb->pos + sb->max_size - sb->size
+			: sb->pos - sb->size;
+
+		while (sb->size) {
+			(*sconsole_putc) (sb->data[end++]);
+			if (end == sb->max_size) {
+				end = 0;
+			}
+			sb->size--;
+		}
+	}
+}
+#endif
diff --git a/board/cb101/sconsole.h b/board/cb101/sconsole.h
new file mode 100644
index 0000000..1666f21
--- /dev/null
+++ b/board/cb101/sconsole.h
@@ -0,0 +1,47 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SCONSOLE_H_
+#define _SCONSOLE_H_
+
+#include <config.h>
+
+typedef struct sconsole_buffer_s
+{
+	unsigned long size;
+	unsigned long max_size;
+	unsigned long pos;
+	char data[1];
+} sconsole_buffer_t;
+
+#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
+
+extern void (*sconsole_putc) (char);
+extern void (*sconsole_puts) (const char *);
+extern int (*sconsole_getc) (void);
+extern int (*sconsole_tstc) (void);
+extern void (*sconsole_setbrg) (void);
+
+extern void sconsole_flush (void);
+
+#endif
diff --git a/board/cb101/u-boot.lds b/board/cb101/u-boot.lds
new file mode 100644
index 0000000..3a1e91b
--- /dev/null
+++ b/board/cb101/u-boot.lds
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2007 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(sh4)
+ENTRY(_start)
+
+SECTIONS
+{
+	.text ALIGN(0x4):
+	{
+		__text_start = .;
+		cpu/sh/start.o (.text)
+		*(.text)
+		__text_end = .;
+	}
+
+	.rodata ALIGN(0x4):
+	{
+		__rodata_start = .;
+		*(.rodata)
+		__rodata_end = .;
+	}
+
+	.data ALIGN(0x4):
+	{
+		__data_start = .;
+		*(.data)
+		__data_end = .;
+	}
+
+	.u_boot_cmd ALIGN(0x4):
+	{
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	_uboot_end_data = .;
+
+	.bss ALIGN(0x4):
+	{
+		__bss_start = .;
+		*(.bss)
+		__bss_end = .;
+	}
+	_uboot_end = .;
+}
diff --git a/board/hms1/Makefile b/board/hms1/Makefile
new file mode 100644
index 0000000..c2c83a3
--- /dev/null
+++ b/board/hms1/Makefile
@@ -0,0 +1,44 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+AOBJS	= init-hms1.o
+
+COBJS	= $(BOARD).o sconsole.o
+
+OBJS	= $(COBJS) $(AOBJS)
+
+$(LIB):	.depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/hms1/config.mk b/board/hms1/config.mk
new file mode 100644
index 0000000..aff8d30
--- /dev/null
+++ b/board/hms1/config.mk
@@ -0,0 +1,30 @@
+#
+# (C) Copyright 2005
+# Andy Sturges (andy.sturges@st.com)
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# HMS1 board
+#
+
+# Installs at SDRAM BASE  + 31M in cache region
+TEXT_BASE = 0x86F00000
+PLATFORM_LDFLAGS +=
diff --git a/board/hms1/hms1.c b/board/hms1/hms1.c
new file mode 100644
index 0000000..654a4a6
--- /dev/null
+++ b/board/hms1/hms1.c
@@ -0,0 +1,173 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stb7100reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+#if defined CFG_JFFS_CUSTOM_PART
+#include <jffs2/jffs2.h>
+#endif
+
+void stb7100_reset(void);
+void stb7100_clocks(void);
+
+#define EPLD_ATAPI *(volatile unsigned char *)(0xa3900000)
+
+#define LED *(volatile unsigned char *)(0xa2000000 + 0x00100010)
+
+void flashWriteEnable(void)
+{
+}
+
+void flashWriteDisable(void)
+{
+}
+
+#define PIO_BASE  0xb8024000
+
+static void configPIO(void)
+{
+  SET_PIO_ASC(PIO_BASE, 3, 2, 4, 5);
+}
+
+#if defined(CONFIG_CMD_IDE)
+
+#ifdef CONFIG_SH_STB7100_IDE
+static void stb7100mboard_init_ide(void)
+{
+  EPLD_ATAPI = 1; /* Enable ATAPI mode of EMI */
+}
+#endif
+
+#ifdef CONFIG_SH_STB7100_SATA
+extern void stb7100_sata_init(void);
+#endif
+
+#endif
+
+int board_init(void)
+{
+	unsigned long sysconf;
+	/* Route UART2 instead of SCI to PIO4 */
+	/* Set ssc2_mux_sel = 0 */
+	sysconf = *STB7100_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
+
+	configPIO();
+
+#if defined(CONFIG_CMD_IDE)
+#ifdef CONFIG_SH_STB7100_IDE
+	stb7100mboard_init_ide();
+#endif
+#ifdef CONFIG_SH_STB7100_SATA
+	stb7100_sata_init();
+#endif
+#endif
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: HMS1"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	LED = 1;
+
+	return 0;
+}
+
+int do_reset (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	stb7100_reset();
+	 /*NOTREACHED*/ return (0);
+}
+
+#if defined CFG_JFFS_CUSTOM_PART
+
+/*
+ * jffs2_part_info - get information about a JFFS2 partition
+ *
+ * @part_num: number of the partition you want to get info about
+ * @return:   struct part_info* in case of success, 0 if failure
+ *
+ * Reads env variable jff2part for partition info
+ *
+ */
+
+static struct part_info part;
+static int current_part = -1;
+
+struct part_info* jffs2_part_info(int part_num) {
+	void *jffs2_priv_saved = part.jffs2_priv;
+
+	printf("jffs2_part_info: part_num=%i\n",part_num);
+
+	if (current_part == part_num)
+		return &part;
+
+	/* u-boot partition                                                 */
+	if(part_num==0){
+		ulong offset, size=0;
+		char *f;
+
+		if ((f=getenv("jffs2part"))) {
+			char *p;
+			offset = simple_strtoul(f, &p, 16);
+			size   = simple_strtoul(p+1, NULL, 16);
+		}
+
+		if (size) {
+			memset(&part, 0, sizeof(part));
+
+			part.offset=offset;
+			part.size=size;
+
+			/* Mark the struct as ready */
+			current_part = part_num;
+
+			printf("part.offset = 0x%08x\n",(unsigned int)part.offset);
+			printf("part.size   = 0x%08x\n",(unsigned int)part.size);
+		}
+	}
+
+	if (current_part == part_num) {
+/*QQQ-HACK:	part.usr_priv = &current_part;	*/
+		part.jffs2_priv = jffs2_priv_saved;
+		return &part;
+	}
+
+	printf("jffs2_part_info: end of partition table\n");
+	return 0;
+}
+#endif
diff --git a/board/hms1/init-hms1.S b/board/hms1/init-hms1.S
new file mode 100644
index 0000000..62781db
--- /dev/null
+++ b/board/hms1/init-hms1.S
@@ -0,0 +1,221 @@
+
+#include "asm/stb7100reg.h"
+#include "../../cpu/sh/init_ram.S"
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * CLOCKGENA setup PLL0
+	 */
+
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00100000)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff7ffff, 0)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x06 | (0x3b << 8) | (0x0 << 16))
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL0_STATUS, 0x00000001, 0x00000001)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+
+	/*
+	 * CLOCKGENA setup PLL1
+	 */
+
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000002)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff7ffff, 0)
+#if CONFIG_SH_STB7100_V1_1
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0x85 << 8) | (0x0 << 16))
+#else
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x09 | (0x80 << 8) | (0x1 << 16)) /* 384MHz */
+	IF_DEVID(STB7100_CUT3) /* 400MHz */
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+	ENDIF
+	IF_DEVID(STB7109_CUT2) /* 400MHz */
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+	ENDIF
+	IF_DEVID(STB7109_CUT3) /* 400MHz */
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+	ENDIF
+#endif
+	OR_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL1_STATUS, 0x00000001, 0x00000001)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000000)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+
+	/*
+	 * SYSCONF setup
+	 */
+	IF_DEVID(STB7109_CUT1)
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x0807fec0)
+	ELSE
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x0d7fd4ea)
+	  WHILE_NE(STB7100_SYSCONF_SYS_STA12, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	ENDIF
+	WHILE_NE(STB7100_SYSCONF_SYS_STA13, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG12, 0x4000000f | (0xf << 12) | (0xf << 23))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG13, 0x4000000f | (0xf << 12) | (0xf << 23))
+
+#ifdef  CONFIG_SH_STB7100_V1_1
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x5a << 20))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0xa9 << 20))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x5a << 20))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0xa9 << 20))
+#else
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x50 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0x40 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x50 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0x40 << 20))
+	ENDIF
+#endif
+	/*
+	 * LMI SYS setup
+	 */
+#ifdef CONFIG_SH_STB7100_V1_1
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a0247)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010000)
+#else
+	/*POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a0247)*/
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x861a0247)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010022)
+#endif
+	POKE_LONG(ST40_LMI_STR(SYS), 0x35b06455)
+
+#if CONFIG_SH_HMS1_128
+	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x0c001a00)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x0c001a00)
+#else
+	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x08001900)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x08001900)
+#endif
+
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000133)
+
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000000)
+
+#if CONFIG_SH_HMS1_128
+	POKE_LONG(SH4_CCN_CCR, 0x8000090d)
+#endif
+
+	/*
+	 * LMI VID setup
+	 */
+#ifdef CONFIG_SH_STB7100_V1_1
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a0247)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010000)
+#else
+	/*POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a0247)*/
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x861a0247)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010022)
+#endif
+	POKE_LONG(ST40_LMI_STR(VID), 0x35b06455)
+	POKE_LONG(ST40_LMI_SDRA0(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SDRA1(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000000)
+
+	/*
+	 * EMI setup
+	 */
+	POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000005)
+	POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000004)
+	POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x00000008)
+	POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x0000000a)
+	POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x0000000c)
+	/* FLASH */
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+	/* STEM Module */
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA0, 0x041086f1)
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA1, 0x93001111)
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA2, 0x91001111)
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000)
+#if 0
+	/* DVBCI */
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+#endif
+	/* ATAPI */
+#if defined(CONFIG_SH_STB7100_V1_1)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00021791)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x08004141)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x08004141)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
+#else
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00200791)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x0c006700)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x0c006700)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
+#endif
+
+#if 0
+	/* EPLD & LAN91C111 */
+
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA0, 0x042086f1)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA1, 0x88112111)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA2, 0x88112211)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)
+#endif
+
+	/* Program other EMI registers */
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7100_CUT2)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+	ENDIF
+	IF_DEVID(STB7100_CUT3)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+	ENDIF
+	IF_DEVID(STB7109_CUT1)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7109_CUT2)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7109_CUT3)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/hms1/sconsole.c b/board/hms1/sconsole.c
new file mode 100644
index 0000000..af92525
--- /dev/null
+++ b/board/hms1/sconsole.c
@@ -0,0 +1,129 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+
+#include "sconsole.h"
+
+#if 0
+void (*sconsole_putc) (char) = 0;
+void (*sconsole_puts) (const char *) = 0;
+int (*sconsole_getc) (void) = 0;
+int (*sconsole_tstc) (void) = 0;
+void (*sconsole_setbrg) (void) = 0;
+#endif
+
+#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
+int serial_init (void)
+{
+	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+	sb->pos = 0;
+	sb->size = 0;
+	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
+
+	return (0);
+}
+
+void serial_putc (char c)
+{
+	if (sconsole_putc) {
+		(*sconsole_putc) (c);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		if (c) {
+			sb->data[sb->pos++] = c;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+void serial_puts (const char *s)
+{
+	if (sconsole_puts) {
+		(*sconsole_puts) (s);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		while (*s) {
+			sb->data[sb->pos++] = *s++;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+int serial_getc (void)
+{
+	if (sconsole_getc) {
+		return (*sconsole_getc) ();
+	} else {
+		return 0;
+	}
+}
+
+int serial_tstc (void)
+{
+	if (sconsole_tstc) {
+		return (*sconsole_tstc) ();
+	} else {
+		return 0;
+	}
+}
+
+void serial_setbrg (void)
+{
+	if (sconsole_setbrg) {
+		(*sconsole_setbrg) ();
+	}
+}
+
+void sconsole_flush (void)
+{
+	if (sconsole_putc) {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+		unsigned int end = sb->pos < sb->size
+			? sb->pos + sb->max_size - sb->size
+			: sb->pos - sb->size;
+
+		while (sb->size) {
+			(*sconsole_putc) (sb->data[end++]);
+			if (end == sb->max_size) {
+				end = 0;
+			}
+			sb->size--;
+		}
+	}
+}
+#endif
diff --git a/board/hms1/sconsole.h b/board/hms1/sconsole.h
new file mode 100644
index 0000000..1666f21
--- /dev/null
+++ b/board/hms1/sconsole.h
@@ -0,0 +1,47 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SCONSOLE_H_
+#define _SCONSOLE_H_
+
+#include <config.h>
+
+typedef struct sconsole_buffer_s
+{
+	unsigned long size;
+	unsigned long max_size;
+	unsigned long pos;
+	char data[1];
+} sconsole_buffer_t;
+
+#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
+
+extern void (*sconsole_putc) (char);
+extern void (*sconsole_puts) (const char *);
+extern int (*sconsole_getc) (void);
+extern int (*sconsole_tstc) (void);
+extern void (*sconsole_setbrg) (void);
+
+extern void sconsole_flush (void);
+
+#endif
diff --git a/board/hms1/u-boot.lds b/board/hms1/u-boot.lds
new file mode 100644
index 0000000..246c526
--- /dev/null
+++ b/board/hms1/u-boot.lds
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(sh4)
+ENTRY(_start)
+
+SECTIONS
+{
+	.text ALIGN(0x4):
+	{
+		__text_start = .;
+		cpu/sh/start.o (.text)
+		*(.text)
+		__text_end = .;
+	}
+
+	.rodata ALIGN(0x4):
+	{
+		__rodata_start = .;
+		*(.rodata)
+		__rodata_end = .;
+	}
+
+	.data ALIGN(0x4):
+	{
+		__data_start = .;
+		*(.data)
+		__data_end = .;
+	}
+
+	.u_boot_cmd ALIGN(0x4):
+	{
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	_uboot_end_data = .;
+
+	.bss ALIGN(0x4):
+	{
+		__bss_start = .;
+		*(.bss)
+		__bss_end = .;
+	}
+	_uboot_end = .;
+}
diff --git a/board/mb411/Makefile b/board/mb411/Makefile
new file mode 100644
index 0000000..b06feaa
--- /dev/null
+++ b/board/mb411/Makefile
@@ -0,0 +1,44 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+AOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o sconsole.o
+
+OBJS	= $(COBJS) $(AOBJS)
+
+$(LIB):	.depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/mb411/config.mk b/board/mb411/config.mk
new file mode 100644
index 0000000..5f44ec6
--- /dev/null
+++ b/board/mb411/config.mk
@@ -0,0 +1,30 @@
+#
+# (C) Copyright 2005
+# Andy Sturges (andy.sturges@st.com)
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB411 (STb7100 Mboard) board
+#
+
+# Installs at SDRAM BASE  + 31M in cache region
+TEXT_BASE = 0x85F00000
+PLATFORM_LDFLAGS +=
diff --git a/board/mb411/init-mb411.S b/board/mb411/init-mb411.S
new file mode 100644
index 0000000..7969ddd
--- /dev/null
+++ b/board/mb411/init-mb411.S
@@ -0,0 +1,206 @@
+
+#include "asm/stb7100reg.h"
+#include "../../cpu/sh/init_ram.S"
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * CLOCKGENA setup PLL0
+	 */
+
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00100000)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff7ffff, 0)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x06 | (0x3b << 8) | (0x0 << 16))
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL0_STATUS, 0x00000001, 0x00000001)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+
+	/*
+	 * CLOCKGENA setup PLL1
+	 */
+
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000002)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff7ffff, 0)
+#if CONFIG_SH_STB7100_V1_1
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0x85 << 8) | (0x0 << 16))
+#else
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x09 | (0x80 << 8) | (0x1 << 16)) /* 384MHz */
+	IF_DEVID(STB7100_CUT3) /* 400MHz */
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+	ENDIF
+	IF_DEVID(STB7109_CUT2) /* 400MHz */
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+	ENDIF
+	IF_DEVID(STB7109_CUT3) /* 400MHz */
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+	ENDIF
+#endif
+	OR_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL1_STATUS, 0x00000001, 0x00000001)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000000)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+
+	/*
+	 * SYSCONF setup
+	 */
+	IF_DEVID(STB7109_CUT1)
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x0807fec0)
+	ELSE
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x080780c0)
+	  WHILE_NE(STB7100_SYSCONF_SYS_STA12, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	ENDIF
+	WHILE_NE(STB7100_SYSCONF_SYS_STA13, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG12, 0x4000000f | (0xf << 12) | (0xf << 23))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG13, 0x4000000f | (0xf << 12) | (0xf << 23))
+
+#ifdef  CONFIG_SH_STB7100_V1_1
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x5a << 20))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0xa9 << 20))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x5a << 20))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0xa9 << 20))
+#else
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x50 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0x40 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x50 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0x40 << 20))
+	ENDIF
+#endif
+	/*
+	 * LMI SYS setup
+	 */
+#ifdef CONFIG_SH_STB7100_V1_1
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a0247)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010000)
+#else
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a0247)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010022)
+#endif
+	POKE_LONG(ST40_LMI_STR(SYS), 0x35b06455)
+
+	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x08001900)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x08001900)
+
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000133)
+
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000000)
+
+	/*
+	 * LMI VID setup
+	 */
+#ifdef CONFIG_SH_STB7100_V1_1
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a0247)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010000)
+#else
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a0247)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010022)
+#endif
+	POKE_LONG(ST40_LMI_STR(VID), 0x35b06455)
+	POKE_LONG(ST40_LMI_SDRA0(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SDRA1(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000000)
+
+	/*
+	 * EMI setup
+	 */
+	POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000005)
+	POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000004)
+	POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x00000008)
+	POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x0000000a)
+	POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x0000000c)
+	/* FLASH */
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+	/* STEM Module */
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA0, 0x041086f1)
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA1, 0x0e024400)
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA2, 0x0e024400)
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000)
+	/* DVBCI */
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+	/* ATAPI */
+#if defined(CONFIG_SH_STB7100_V1_1)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00021791)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x08004141)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x08004141)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
+#else
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00021791)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x0c006700)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x0c006700)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
+#endif
+
+	/* EPLD & LAN91C111 */
+
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA0, 0x042086f1)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA1, 0x88112111)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA2, 0x88112211)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)
+
+	/* Program other EMI registers */
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7100_CUT2)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+	ENDIF
+	IF_DEVID(STB7100_CUT3)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+	ENDIF
+	IF_DEVID(STB7109_CUT1)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7109_CUT2)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7109_CUT3)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/mb411/mb411.c b/board/mb411/mb411.c
new file mode 100644
index 0000000..c6a38e4
--- /dev/null
+++ b/board/mb411/mb411.c
@@ -0,0 +1,180 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stb7100reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+#if defined CFG_JFFS_CUSTOM_PART
+#include <jffs2/jffs2.h>
+#endif
+
+void stb7100_reset(void);
+void stb7100_clocks(void);
+
+#define EPLD_FLASH *(volatile unsigned char *)(0xa3400000)
+#define EPLD_ATAPI *(volatile unsigned char *)(0xa3900000)
+
+#define LED *(volatile unsigned char *)(0xa2000000 + 0x00100010)
+
+void flashWriteEnable(void)
+{
+  /*  Enable vpp for writing to flash */
+  EPLD_FLASH = 3;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+
+void flashWriteDisable(void)
+{
+  /*  Disable vpp for writing to flash */
+  EPLD_FLASH = 2;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+
+#define PIO_BASE  0xb8020000
+
+static void configPIO(void)
+{
+  /*  Setup PIO of ASC device */
+  SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
+  SET_PIO_ASC(PIO_PORT(5), 0, 1, 2, 3);  /* UART3 - AS1 */
+}
+
+#if defined(CONFIG_CMD_IDE)
+
+#ifdef CONFIG_SH_STB7100_IDE
+static void stb7100mboard_init_ide(void)
+{
+  EPLD_ATAPI = 1; /* Enable ATAPI mode of EMI */
+}
+#endif
+
+#ifdef CONFIG_SH_STB7100_SATA
+extern void stb7100_sata_init(void);
+#endif
+
+#endif
+
+int board_init(void)
+{
+	unsigned long sysconf;
+	/* Route UART2 instead of SCI to PIO4 */
+	/* Set ssc2_mux_sel = 0 */
+	sysconf = *STB7100_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
+
+	configPIO();
+
+#if defined(CONFIG_CMD_IDE)
+#ifdef CONFIG_SH_STB7100_IDE
+	stb7100mboard_init_ide();
+#endif
+#ifdef CONFIG_SH_STB7100_SATA
+	stb7100_sata_init();
+#endif
+#endif
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STb7100-Mboard (MB411)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	LED = 1;
+
+	return 0;
+}
+
+int do_reset (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	stb7100_reset();
+	 /*NOTREACHED*/ return (0);
+}
+
+#if defined CFG_JFFS_CUSTOM_PART
+
+/*
+ * jffs2_part_info - get information about a JFFS2 partition
+ *
+ * @part_num: number of the partition you want to get info about
+ * @return:   struct part_info* in case of success, 0 if failure
+ *
+ * Reads env variable jff2part for partition info
+ *
+ */
+
+static struct part_info part;
+static int current_part = -1;
+
+struct part_info* jffs2_part_info(int part_num) {
+	void *jffs2_priv_saved = part.jffs2_priv;
+
+	printf("jffs2_part_info: part_num=%i\n",part_num);
+
+	if (current_part == part_num)
+		return &part;
+
+	/* u-boot partition                                                 */
+	if(part_num==0){
+		ulong offset, size=0;
+		char *f;
+
+		if ((f=getenv("jffs2part"))) {
+			char *p;
+			offset = simple_strtoul(f, &p, 16);
+			size   = simple_strtoul(p+1, NULL, 16);
+		}
+
+		if (size) {
+			memset(&part, 0, sizeof(part));
+
+			part.offset=offset;
+			part.size=size;
+
+			/* Mark the struct as ready */
+			current_part = part_num;
+
+			printf("part.offset = 0x%08x\n",(unsigned int)part.offset);
+			printf("part.size   = 0x%08x\n",(unsigned int)part.size);
+		}
+	}
+
+	if (current_part == part_num) {
+/*QQQ-HACK:	part.usr_priv = &current_part;	*/
+		part.jffs2_priv = jffs2_priv_saved;
+		return &part;
+	}
+
+	printf("jffs2_part_info: end of partition table\n");
+	return 0;
+}
+#endif
diff --git a/board/mb411/sconsole.c b/board/mb411/sconsole.c
new file mode 100644
index 0000000..af92525
--- /dev/null
+++ b/board/mb411/sconsole.c
@@ -0,0 +1,129 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+
+#include "sconsole.h"
+
+#if 0
+void (*sconsole_putc) (char) = 0;
+void (*sconsole_puts) (const char *) = 0;
+int (*sconsole_getc) (void) = 0;
+int (*sconsole_tstc) (void) = 0;
+void (*sconsole_setbrg) (void) = 0;
+#endif
+
+#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
+int serial_init (void)
+{
+	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+	sb->pos = 0;
+	sb->size = 0;
+	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
+
+	return (0);
+}
+
+void serial_putc (char c)
+{
+	if (sconsole_putc) {
+		(*sconsole_putc) (c);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		if (c) {
+			sb->data[sb->pos++] = c;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+void serial_puts (const char *s)
+{
+	if (sconsole_puts) {
+		(*sconsole_puts) (s);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		while (*s) {
+			sb->data[sb->pos++] = *s++;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+int serial_getc (void)
+{
+	if (sconsole_getc) {
+		return (*sconsole_getc) ();
+	} else {
+		return 0;
+	}
+}
+
+int serial_tstc (void)
+{
+	if (sconsole_tstc) {
+		return (*sconsole_tstc) ();
+	} else {
+		return 0;
+	}
+}
+
+void serial_setbrg (void)
+{
+	if (sconsole_setbrg) {
+		(*sconsole_setbrg) ();
+	}
+}
+
+void sconsole_flush (void)
+{
+	if (sconsole_putc) {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+		unsigned int end = sb->pos < sb->size
+			? sb->pos + sb->max_size - sb->size
+			: sb->pos - sb->size;
+
+		while (sb->size) {
+			(*sconsole_putc) (sb->data[end++]);
+			if (end == sb->max_size) {
+				end = 0;
+			}
+			sb->size--;
+		}
+	}
+}
+#endif
diff --git a/board/mb411/sconsole.h b/board/mb411/sconsole.h
new file mode 100644
index 0000000..1666f21
--- /dev/null
+++ b/board/mb411/sconsole.h
@@ -0,0 +1,47 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SCONSOLE_H_
+#define _SCONSOLE_H_
+
+#include <config.h>
+
+typedef struct sconsole_buffer_s
+{
+	unsigned long size;
+	unsigned long max_size;
+	unsigned long pos;
+	char data[1];
+} sconsole_buffer_t;
+
+#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
+
+extern void (*sconsole_putc) (char);
+extern void (*sconsole_puts) (const char *);
+extern int (*sconsole_getc) (void);
+extern int (*sconsole_tstc) (void);
+extern void (*sconsole_setbrg) (void);
+
+extern void sconsole_flush (void);
+
+#endif
diff --git a/board/mb411/u-boot.lds b/board/mb411/u-boot.lds
new file mode 100644
index 0000000..246c526
--- /dev/null
+++ b/board/mb411/u-boot.lds
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(sh4)
+ENTRY(_start)
+
+SECTIONS
+{
+	.text ALIGN(0x4):
+	{
+		__text_start = .;
+		cpu/sh/start.o (.text)
+		*(.text)
+		__text_end = .;
+	}
+
+	.rodata ALIGN(0x4):
+	{
+		__rodata_start = .;
+		*(.rodata)
+		__rodata_end = .;
+	}
+
+	.data ALIGN(0x4):
+	{
+		__data_start = .;
+		*(.data)
+		__data_end = .;
+	}
+
+	.u_boot_cmd ALIGN(0x4):
+	{
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	_uboot_end_data = .;
+
+	.bss ALIGN(0x4):
+	{
+		__bss_start = .;
+		*(.bss)
+		__bss_end = .;
+	}
+	_uboot_end = .;
+}
diff --git a/board/mb442/Makefile b/board/mb442/Makefile
new file mode 100644
index 0000000..b06feaa
--- /dev/null
+++ b/board/mb442/Makefile
@@ -0,0 +1,44 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+AOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o sconsole.o
+
+OBJS	= $(COBJS) $(AOBJS)
+
+$(LIB):	.depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/mb442/config.mk b/board/mb442/config.mk
new file mode 100644
index 0000000..4e73ed4
--- /dev/null
+++ b/board/mb442/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2005
+# Andy Sturges (andy.sturges@st.com)
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB442 (STb7100REF or Coco) board
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x87F00000	29-bit mode (Traditional Mode)
+#	0x83F00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at SDRAM BASE  + 63M in P1 (cachable)
+TEXT_BASE = 0x87F00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/mb442/init-mb442.S b/board/mb442/init-mb442.S
new file mode 100644
index 0000000..043a6e9
--- /dev/null
+++ b/board/mb442/init-mb442.S
@@ -0,0 +1,227 @@
+
+#include "asm/stb7100reg.h"
+#include "../../cpu/sh/init_ram.S"
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * CLOCKGENA setup PLL0
+	 */
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00100000)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff7ffff, 0)
+#if (INPUT_CLOCK_RATE == 30)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x14 | (0xb1 << 8) | (0x0 << 16))
+#else
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x06 | (0x3b << 8) | (0x0 << 16))
+#endif
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL0_STATUS, 0x00000001, 0x00000001)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	/*
+	 * CLOCKGENA setup PLL1
+	 */
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000002)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff7ffff, 0)
+	IF_DEVID(STB7100_CUT1) /* 266 MHz */
+#if (INPUT_CLOCK_RATE == 30)
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1e | (0x85 << 8) | (0x0 << 16))
+#else
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0x85 << 8) | (0x0 << 16))
+#endif
+	ELSE
+#if (INPUT_CLOCK_RATE == 30)   /* 384 MHz */
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x0a | (0x80 << 8) | (0x1 << 16))
+#else
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x09 | (0x80 << 8) | (0x1 << 16))
+#endif
+	ENDIF
+	IF_DEVID(STB7100_CUT3) /* 400MHz */
+#if (INPUT_CLOCK_RATE == 30)
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1e | (0xc8 << 8) | (0x0 << 16))
+#else
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+#endif
+	ENDIF
+	IF_DEVID(STB7109_CUT2) /* 400MHz */
+#if (INPUT_CLOCK_RATE == 30)
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1e | (0xc8 << 8) | (0x0 << 16))
+#else
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+#endif
+	ENDIF
+	IF_DEVID(STB7109_CUT3) /* 400MHz */
+#if (INPUT_CLOCK_RATE == 30)
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1e | (0xc8 << 8) | (0x0 << 16))
+#else
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+#endif
+	ENDIF
+	OR_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL1_STATUS, 0x00000001, 0x00000001)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000000)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	/*
+	 * SYSCONF setup
+	 */
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x0d7fd4ea)
+
+	WHILE_NE(STB7100_SYSCONF_SYS_STA12, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	WHILE_NE(STB7100_SYSCONF_SYS_STA13, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG12, 0x4000000f | (0xf << 12) | (0xf << 23))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG13, 0x4000000f | (0xf << 12) | (0xf << 23))
+
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x5a << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0xa9 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x5a << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0xa9 << 20))
+	ENDIF
+
+	/*
+	 * LMI SYS setup
+	 */
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x861a025f)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010022)
+
+	POKE_LONG(ST40_LMI_STR(SYS), 0x35b06455)
+
+#if CONFIG_SH_MB442_128
+	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x0c001a00)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x0c001a00)
+#else
+	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x08001900)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x08001900)
+#endif
+
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000000)
+
+	/*
+	 * LMI VID setup
+	 */
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x861a025f)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010022)
+
+	POKE_LONG(ST40_LMI_STR(VID), 0x35b06455)
+	POKE_LONG(ST40_LMI_SDRA0(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SDRA1(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000000)
+
+#if CONFIG_SH_MB442_128
+       POKE_LONG(SH4_CCN_CCR, 0x8000090d)
+#endif
+
+	/*
+	 * EMI setup
+	 */
+	POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000005)
+
+	POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000004)
+	POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x00000008)
+	POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x0000000a)
+	POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x0000000c)
+	/* FLASH */
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+	/* EPLD & LAN91C111 */
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 0x042086f1)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 0x88112111)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 0x88112211)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+	/* ATAPI */
+
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00021791)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x08004141)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x08004141)
+	ELSE
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00200791)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x0c006700)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x0c006700)
+	ENDIF
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
+
+	/* Program other EMI registers */
+
+	/* Program other EMI registers */
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7100_CUT2)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+	ENDIF
+	IF_DEVID(STB7100_CUT3)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+	ENDIF
+	IF_DEVID(STB7109_CUT1)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7109_CUT2)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7109_CUT3)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+
+#ifdef CONFIG_SH_SE_MODE
+  /*
+   * Note that we also manually need to move the System and Video LMI base
+   * addresses to their 32-bit SE mode locations as defined in the datasheet.
+   */
+        UPDATE_LONG(STB7100_SYSCONF_SYS_CFG36, 0xFF00FF00, 0x00600040)
+#ifdef CONFIG_SH_MB442_128
+        POKE_LONG(ST40_LMI_SDRA0_0(SYS), 0x48001a00)
+        POKE_LONG(ST40_LMI_SDRA1_0(SYS), 0x48001a00)
+#else
+        POKE_LONG(ST40_LMI_SDRA0_0(SYS), 0x44001900)
+        POKE_LONG(ST40_LMI_SDRA1_0(SYS), 0x44001900)
+#endif
+        POKE_LONG(ST40_LMI_SDRA0_0(VID), 0x64001900)
+        POKE_LONG(ST40_LMI_SDRA1_0(VID), 0x64001900)
+
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/mb442/mb442.c b/board/mb442/mb442.c
new file mode 100644
index 0000000..be0459e
--- /dev/null
+++ b/board/mb442/mb442.c
@@ -0,0 +1,137 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stb7100reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+void stb7100_reset(void);
+void stb7100_clocks(void);
+
+void flashWriteEnable(void)
+{
+  /* Enable Vpp for writing to flash */
+  /* QQQ - to do */
+}
+
+void flashWriteDisable(void)
+{
+  /* Disable Vpp for writing to flash */
+  /* QQQ - to do */
+}
+
+#define PIO_BASE  0xb8020000	/* Phys 0x18020000 */
+
+static void configPIO(void)
+{
+  /*  Setup PIO of ASC device */
+  SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
+  SET_PIO_ASC(PIO_PORT(5), 0, 1, 2, 3);  /* UART3 - AS1 */
+
+  /*  Setup up ethernet reset */
+#ifdef CONFIG_DRIVER_SMC91111
+  SET_PIO_PIN(PIO_PORT(2), 6, STPIO_OUT);
+#endif
+#ifdef CONFIG_DRIVER_NETSTMAC
+  SET_PIO_PIN(PIO_PORT(2), 4, STPIO_OUT);
+#endif
+}
+
+#if defined(CONFIG_CMD_IDE)
+
+#ifdef CONFIG_SH_STB7100_IDE
+static void stb7100ref_init_ide(void)
+{
+  /* Enable ATAPI mode of EMI */
+  /* QQQ - to do */
+}
+#endif
+
+#ifdef CONFIG_SH_STB7100_SATA
+extern void stb7100_sata_init(void);
+#endif
+
+#endif
+
+int board_init(void)
+{
+	unsigned long sysconf;
+	/* Route UART2 instead of SCI to PIO4 */
+	/* Set ssc2_mux_sel = 0 */
+	sysconf = *STB7100_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
+
+	configPIO();
+
+#ifdef CONFIG_DRIVER_SMC91111
+	/*  Reset ethernet chip */
+	STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 6, 1);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+#endif
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+	/*  Reset ethernet chip */
+	STPIO_SET_PIN(PIO_PORT(2), 4, 1);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 4, 0);
+	udelay(2000);
+	STPIO_SET_PIN(PIO_PORT(2), 4, 1);
+#endif
+
+#if defined(CONFIG_CMD_IDE)
+#ifdef CONFIG_SH_STB7100_IDE
+	stb7100ref_init_ide();
+#endif
+#ifdef CONFIG_SH_STB7100_SATA
+	stb7100_sata_init();
+#endif
+#endif
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STb7100-Reference (MB442)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	return 0;
+}
+
+int do_reset (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	stb7100_reset();
+	 /*NOTREACHED*/ return (0);
+}
diff --git a/board/mb442/sconsole.c b/board/mb442/sconsole.c
new file mode 100644
index 0000000..af92525
--- /dev/null
+++ b/board/mb442/sconsole.c
@@ -0,0 +1,129 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+
+#include "sconsole.h"
+
+#if 0
+void (*sconsole_putc) (char) = 0;
+void (*sconsole_puts) (const char *) = 0;
+int (*sconsole_getc) (void) = 0;
+int (*sconsole_tstc) (void) = 0;
+void (*sconsole_setbrg) (void) = 0;
+#endif
+
+#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
+int serial_init (void)
+{
+	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+	sb->pos = 0;
+	sb->size = 0;
+	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
+
+	return (0);
+}
+
+void serial_putc (char c)
+{
+	if (sconsole_putc) {
+		(*sconsole_putc) (c);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		if (c) {
+			sb->data[sb->pos++] = c;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+void serial_puts (const char *s)
+{
+	if (sconsole_puts) {
+		(*sconsole_puts) (s);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		while (*s) {
+			sb->data[sb->pos++] = *s++;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+int serial_getc (void)
+{
+	if (sconsole_getc) {
+		return (*sconsole_getc) ();
+	} else {
+		return 0;
+	}
+}
+
+int serial_tstc (void)
+{
+	if (sconsole_tstc) {
+		return (*sconsole_tstc) ();
+	} else {
+		return 0;
+	}
+}
+
+void serial_setbrg (void)
+{
+	if (sconsole_setbrg) {
+		(*sconsole_setbrg) ();
+	}
+}
+
+void sconsole_flush (void)
+{
+	if (sconsole_putc) {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+		unsigned int end = sb->pos < sb->size
+			? sb->pos + sb->max_size - sb->size
+			: sb->pos - sb->size;
+
+		while (sb->size) {
+			(*sconsole_putc) (sb->data[end++]);
+			if (end == sb->max_size) {
+				end = 0;
+			}
+			sb->size--;
+		}
+	}
+}
+#endif
diff --git a/board/mb442/sconsole.h b/board/mb442/sconsole.h
new file mode 100644
index 0000000..1666f21
--- /dev/null
+++ b/board/mb442/sconsole.h
@@ -0,0 +1,47 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SCONSOLE_H_
+#define _SCONSOLE_H_
+
+#include <config.h>
+
+typedef struct sconsole_buffer_s
+{
+	unsigned long size;
+	unsigned long max_size;
+	unsigned long pos;
+	char data[1];
+} sconsole_buffer_t;
+
+#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
+
+extern void (*sconsole_putc) (char);
+extern void (*sconsole_puts) (const char *);
+extern int (*sconsole_getc) (void);
+extern int (*sconsole_tstc) (void);
+extern void (*sconsole_setbrg) (void);
+
+extern void sconsole_flush (void);
+
+#endif
diff --git a/board/mb442/u-boot.lds b/board/mb442/u-boot.lds
new file mode 100644
index 0000000..246c526
--- /dev/null
+++ b/board/mb442/u-boot.lds
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(sh4)
+ENTRY(_start)
+
+SECTIONS
+{
+	.text ALIGN(0x4):
+	{
+		__text_start = .;
+		cpu/sh/start.o (.text)
+		*(.text)
+		__text_end = .;
+	}
+
+	.rodata ALIGN(0x4):
+	{
+		__rodata_start = .;
+		*(.rodata)
+		__rodata_end = .;
+	}
+
+	.data ALIGN(0x4):
+	{
+		__data_start = .;
+		*(.data)
+		__data_end = .;
+	}
+
+	.u_boot_cmd ALIGN(0x4):
+	{
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	_uboot_end_data = .;
+
+	.bss ALIGN(0x4):
+	{
+		__bss_start = .;
+		*(.bss)
+		__bss_end = .;
+	}
+	_uboot_end = .;
+}
diff --git a/board/mb448/Makefile b/board/mb448/Makefile
new file mode 100644
index 0000000..b06feaa
--- /dev/null
+++ b/board/mb448/Makefile
@@ -0,0 +1,44 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+AOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o sconsole.o
+
+OBJS	= $(COBJS) $(AOBJS)
+
+$(LIB):	.depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/mb448/config.mk b/board/mb448/config.mk
new file mode 100644
index 0000000..9db40e3
--- /dev/null
+++ b/board/mb448/config.mk
@@ -0,0 +1,30 @@
+#
+# (C) Copyright 2005
+# Andy Sturges (andy.sturges@st.com)
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB448 (STb7109EREF) board
+#
+
+# Installs at SDRAM BASE  + 31M in cache region
+TEXT_BASE = 0x85F00000
+PLATFORM_LDFLAGS +=
diff --git a/board/mb448/init-mb448.S b/board/mb448/init-mb448.S
new file mode 100644
index 0000000..cc2c920
--- /dev/null
+++ b/board/mb448/init-mb448.S
@@ -0,0 +1,165 @@
+
+#include "asm/stb7100reg.h"
+#include "../../cpu/sh/init_ram.S"
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * CLOCKGENA setup PLL0
+	 */
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00100000)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff7ffff, 0)
+#if (INPUT_CLOCK_RATE == 30)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x14 | (0xb1 << 8) | (0x0 << 16))
+#else
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x06 | (0x3b << 8) | (0x0 << 16))
+#endif
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL0_STATUS, 0x00000001, 0x00000001)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	/*
+	 * CLOCKGENA setup PLL1
+	 */
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000002)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff7ffff, 0)
+	IF_DEVID(STB7100_CUT2)
+#if (INPUT_CLOCK_RATE == 30)
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x0a | (0x80 << 8) | (0x1 << 16))
+#else
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x09 | (0x80 << 8) | (0x1 << 16))
+#endif
+	ENDIF
+	IF_DEVID(STB7100_CUT1)
+#if (INPUT_CLOCK_RATE == 30)
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1e | (0x85 << 8) | (0x0 << 16))
+#else
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0x85 << 8) | (0x0 << 16))
+#endif
+	ENDIF
+	OR_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL1_STATUS, 0x00000001, 0x00000001)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000000)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	/*
+	 * SYSCONF setup
+	 */
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x080780c0)
+
+	WHILE_NE(STB7100_SYSCONF_SYS_STA12, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	WHILE_NE(STB7100_SYSCONF_SYS_STA13, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG12, 0x4000000f | (0xf << 12) | (0xf << 23))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG13, 0x4000000f | (0xf << 12) | (0xf << 23))
+
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x5a << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0xa9 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x5a << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0xa9 << 20))
+	ENDIF
+
+	/*
+	 * LMI SYS setup
+	 */
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a0247)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010022)
+
+	POKE_LONG(ST40_LMI_STR(SYS), 0x35b06455)
+
+	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x08001900)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x08001900)
+
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000400)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000000)
+
+	/*
+	 * LMI VID setup
+	 */
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a0247)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010022)
+
+	POKE_LONG(ST40_LMI_STR(VID), 0x35b06455)
+	POKE_LONG(ST40_LMI_SDRA0(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SDRA1(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000000)
+	/*
+	 * EMI setup
+	 */
+	POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000005)
+
+	POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000004)
+	POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x00000008)
+	POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x0000000a)
+	POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x0000000c)
+	/* FLASH */
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+	/* EPLD & LAN91C111 */
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 0x042086f1)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 0x88112111)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 0x88112211)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+	/* ATAPI */
+
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00021791)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x08004141)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x08004141)
+	ENDIF
+	IF_DEVID(STB7100_CUT2)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00200791)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x0c006700)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x0c006700)
+	ENDIF
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
+
+	/* Program other EMI registers */
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7100_CUT2)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+	ENDIF
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/mb448/mb448.c b/board/mb448/mb448.c
new file mode 100644
index 0000000..f804886
--- /dev/null
+++ b/board/mb448/mb448.c
@@ -0,0 +1,128 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stb7100reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+void stb7100_reset(void);
+void stb7100_clocks(void);
+
+#define EPLD_FLASH *(volatile unsigned char *)(0xa3400000)
+#define EPLD_ATAPI *(volatile unsigned char *)(0xa3900000)
+
+#define LED *(volatile unsigned char *)(0xa2000000 + 0x00100010)
+
+void flashWriteEnable(void)
+{
+  /*  Enable vpp for writing to flash */
+  EPLD_FLASH = 3;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+
+void flashWriteDisable(void)
+{
+  /*  Disable vpp for writing to flash */
+  EPLD_FLASH = 2;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+
+#define PIO_BASE  0xb8020000
+#define PIO2_BASE  0xb8024000
+
+static void configPIO(void)
+{
+  /*  Setup PIO of ASC device */
+  SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);
+  /*  Setup up ethernet reset */
+  SET_PIO_PIN(PIO_PORT(2), 6, STPIO_OUT);
+}
+
+#if defined(CONFIG_CMD_IDE)
+
+#ifdef CONFIG_SH_STB7100_IDE
+static void stb7100ref_init_ide(void)
+{
+  EPLD_ATAPI = 1; /* Enable ATAPI mode of EMI */
+}
+#endif
+
+#ifdef CONFIG_SH_STB7100_SATA
+extern void stb7100_sata_init(void);
+#endif
+
+#endif
+
+int board_init(void)
+{
+	unsigned long sysconf;
+	/* Route UART2 instead of SCI to PIO4 */
+	/* Set ssc2_mux_sel = 0 */
+	sysconf = *STB7100_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
+
+	configPIO();
+
+#ifdef CONFIG_DRIVER_SMC91111
+	/*  Reset ethernet chip */
+	STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 6, 1);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+#endif
+
+#if defined(CONFIG_CMD_IDE)
+#ifdef CONFIG_SH_STB7100_IDE
+	stb7100ref_init_ide();
+#endif
+#ifdef CONFIG_SH_STB7100_SATA
+	stb7100_sata_init();
+#endif
+#endif
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STb7109E-Reference (MB448)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	LED = 1;
+
+	return 0;
+}
+
+int do_reset (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	stb7100_reset();
+	 /*NOTREACHED*/ return (0);
+}
diff --git a/board/mb448/sconsole.c b/board/mb448/sconsole.c
new file mode 100644
index 0000000..af92525
--- /dev/null
+++ b/board/mb448/sconsole.c
@@ -0,0 +1,129 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+
+#include "sconsole.h"
+
+#if 0
+void (*sconsole_putc) (char) = 0;
+void (*sconsole_puts) (const char *) = 0;
+int (*sconsole_getc) (void) = 0;
+int (*sconsole_tstc) (void) = 0;
+void (*sconsole_setbrg) (void) = 0;
+#endif
+
+#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
+int serial_init (void)
+{
+	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+	sb->pos = 0;
+	sb->size = 0;
+	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
+
+	return (0);
+}
+
+void serial_putc (char c)
+{
+	if (sconsole_putc) {
+		(*sconsole_putc) (c);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		if (c) {
+			sb->data[sb->pos++] = c;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+void serial_puts (const char *s)
+{
+	if (sconsole_puts) {
+		(*sconsole_puts) (s);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		while (*s) {
+			sb->data[sb->pos++] = *s++;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+int serial_getc (void)
+{
+	if (sconsole_getc) {
+		return (*sconsole_getc) ();
+	} else {
+		return 0;
+	}
+}
+
+int serial_tstc (void)
+{
+	if (sconsole_tstc) {
+		return (*sconsole_tstc) ();
+	} else {
+		return 0;
+	}
+}
+
+void serial_setbrg (void)
+{
+	if (sconsole_setbrg) {
+		(*sconsole_setbrg) ();
+	}
+}
+
+void sconsole_flush (void)
+{
+	if (sconsole_putc) {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+		unsigned int end = sb->pos < sb->size
+			? sb->pos + sb->max_size - sb->size
+			: sb->pos - sb->size;
+
+		while (sb->size) {
+			(*sconsole_putc) (sb->data[end++]);
+			if (end == sb->max_size) {
+				end = 0;
+			}
+			sb->size--;
+		}
+	}
+}
+#endif
diff --git a/board/mb448/sconsole.h b/board/mb448/sconsole.h
new file mode 100644
index 0000000..1666f21
--- /dev/null
+++ b/board/mb448/sconsole.h
@@ -0,0 +1,47 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SCONSOLE_H_
+#define _SCONSOLE_H_
+
+#include <config.h>
+
+typedef struct sconsole_buffer_s
+{
+	unsigned long size;
+	unsigned long max_size;
+	unsigned long pos;
+	char data[1];
+} sconsole_buffer_t;
+
+#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
+
+extern void (*sconsole_putc) (char);
+extern void (*sconsole_puts) (const char *);
+extern int (*sconsole_getc) (void);
+extern int (*sconsole_tstc) (void);
+extern void (*sconsole_setbrg) (void);
+
+extern void sconsole_flush (void);
+
+#endif
diff --git a/board/mb448/u-boot.lds b/board/mb448/u-boot.lds
new file mode 100644
index 0000000..246c526
--- /dev/null
+++ b/board/mb448/u-boot.lds
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(sh4)
+ENTRY(_start)
+
+SECTIONS
+{
+	.text ALIGN(0x4):
+	{
+		__text_start = .;
+		cpu/sh/start.o (.text)
+		*(.text)
+		__text_end = .;
+	}
+
+	.rodata ALIGN(0x4):
+	{
+		__rodata_start = .;
+		*(.rodata)
+		__rodata_end = .;
+	}
+
+	.data ALIGN(0x4):
+	{
+		__data_start = .;
+		*(.data)
+		__data_end = .;
+	}
+
+	.u_boot_cmd ALIGN(0x4):
+	{
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	_uboot_end_data = .;
+
+	.bss ALIGN(0x4):
+	{
+		__bss_start = .;
+		*(.bss)
+		__bss_end = .;
+	}
+	_uboot_end = .;
+}
diff --git a/board/mb519/Makefile b/board/mb519/Makefile
new file mode 100644
index 0000000..1f1f703
--- /dev/null
+++ b/board/mb519/Makefile
@@ -0,0 +1,44 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+AOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o sconsole.o
+
+OBJS	= $(COBJS) $(AOBJS)
+
+$(LIB):	.depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/mb519/config.mk b/board/mb519/config.mk
new file mode 100644
index 0000000..cf00d78
--- /dev/null
+++ b/board/mb519/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB519 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x8FF00000	29-bit mode (Traditional Mode)
+#	0x87F00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 127MB in P1 (cachable)
+TEXT_BASE = 0x8FF00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/mb519/init-mb519.S b/board/mb519/init-mb519.S
new file mode 100644
index 0000000..f1539e0
--- /dev/null
+++ b/board/mb519/init-mb519.S
@@ -0,0 +1,375 @@
+
+#include "asm/stx7200reg.h"
+#include "../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb519.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+
+.balign 32
+
+
+__memory_setup_table:
+
+  /* ----- STx7200 Clocks ----- */
+
+  /* Set CLOCKGENA PLL0 into BYPASS... */
+  OR_LONG(STX7200_CLOCKGENA_PLL0_CFG, 0x00100000)
+
+  /* Power down CLOCKGENA PLL0... */
+  OR_LONG(STX7200_CLOCKGENA_POWER_CFG, 0x00000001)
+
+  /* Configure CLOCKGENA PLL0... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x03 | (0x23 << 8) | (0x00 << 16))
+
+  /* Enable CLOCKGENA PLL0... */
+  UPDATE_LONG(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffe, 0)
+
+  /* Wait for CLOCKGENA PLL0 to lock... */
+  WHILE_NE(STX7200_CLOCKGENA_PLL0_CFG, 0x80000000, 0x80000000)
+
+  /* Clear CLOCKGENA PLL0 from BYPASS... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+
+  /* Set CLOCKGENA PLL1 into BYPASS... */
+  OR_LONG(STX7200_CLOCKGENA_PLL1_CFG, 0x00100000)
+
+  /* Power down CLOCKGENA PLL1... */
+  OR_LONG(STX7200_CLOCKGENA_POWER_CFG, 0x00000002)
+
+  /* Configure CLOCKGENA PLL1... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x01 | (0x0f << 8))
+
+  /* Enable CLOCKGENA PLL1... */
+  UPDATE_LONG(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffd, 0)
+
+  /* Wait for CLOCKGENA PLL1 to lock... */
+  WHILE_NE(STX7200_CLOCKGENA_PLL1_CFG, 0x80000000,  0x80000000)
+
+  /* Clear CLOCKGENA PLL1 from BYPASS... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL1_CFG, 0xffefffff, 0)
+
+  /* Set CLOCKGENA PLL2 into BYPASS... */
+  OR_LONG(STX7200_CLOCKGENA_PLL2_CFG, 0x00100000)
+
+  /* Power down CLOCKGENA PLL2... */
+  OR_LONG(STX7200_CLOCKGENA_POWER_CFG, 0x00000004)
+
+  /* Configure CLOCKGENA PLL2... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL2_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
+
+  /* Enable CLOCKGENA PLL2... */
+  UPDATE_LONG(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffb, 0)
+
+  /* Wait for CLOCKGENA PLL2 to lock... */
+  WHILE_NE(STX7200_CLOCKGENA_PLL2_CFG, 0x80000000,  0x80000000)
+
+  /* Clear CLOCKGENA PLL2 from BYPASS... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL2_CFG, 0xffefffff, 0)
+
+  /* Set CLOCKGENB PLL0 into BYPASS... */
+  OR_LONG(STX7200_CLOCKGENB_PLL0_CFG, 0x00100000)
+
+  /* Power down CLOCKGENB PLL0... */
+  OR_LONG(STX7200_CLOCKGENB_POWER_CFG, 0x00008000)
+
+  /* Configure CLOCKGENB PLL0... */
+  UPDATE_LONG(STX7200_CLOCKGENB_PLL0_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
+
+  /* Enable CLOCKGENB PLL0... */
+  UPDATE_LONG(STX7200_CLOCKGENB_POWER_CFG, 0xffff7fff, 0)
+
+  /* Wait for CLOCKGENB PLL0 to lock... */
+  WHILE_NE(STX7200_CLOCKGENB_PLL0_CFG, 0x80000000, 0x80000000)
+
+  /* Clear CLOCKGENB PLL0 from BYPASS... */
+  UPDATE_LONG(STX7200_CLOCKGENB_PLL0_CFG, 0xffefffff, 0)
+
+  /* Power down PLL... */
+  OR_LONG(STX7200_SYSCONF_SYS_CFG11, 0x00001000)
+
+  /* Configure PLL... */
+  /* Set LMI clock to 666MHz */
+  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x05 << 9) | (0x6f << 1))
+  /* On PCB rev A, we have a limitation on LMI1: Reset LMI clock to 400MHz */
+  IF(0xa5020000, 0x000000ff, 0x0000000a, UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x28 << 1)))
+
+  /* Enable CLOCKGENA PLL1... */
+  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xffffefff, 0)
+
+  /* Wait for CLOCKGENA PLL1 to lock... (polarity inverted on lock bit) */
+  WHILE_NE(STX7200_SYSCONF_SYS_STA03, 0x00000001, 0)
+
+  /* ----- STx7200 Sysconf ----- */
+
+  /* Exit from reset */
+  OR_LONG(STX7200_SYSCONF_SYS_CFG11, 0x00000001)
+  OR_LONG(STX7200_SYSCONF_SYS_CFG15, 0x00000001)
+
+  /* Check both DLL on LMI0 are locked */
+  WHILE_NE(STX7200_SYSCONF_SYS_STA03, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
+
+  /* Check both DLL on LMI1 are locked */
+  WHILE_NE(STX7200_SYSCONF_SYS_STA05, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
+
+  /* Adjust proga, progb, zoutproga, and receiver mode for LMI0 */
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG12, 0xa2007801 | (0x0 << 1) | (0x7 << 4) | (0x7 << 7) | (0x0 << 10))
+
+  /* Adjust proga, progb, zoutproga, and receiver mode for LMI1 */
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG16, 0xa2007801 | (0x0 << 1) | (0x7 << 4) | (0x7 << 7) | (0x0 << 10))
+
+  /* Enable AutoPrecharge */
+  OR_LONG(STX7200_SYSCONF_SYS_CFG38, 0x00030000)
+  OR_LONG(STX7200_SYSCONF_SYS_CFG39, 0x00030000)
+
+  /* Force DLL1 and DLL2 commands of LMI0 */
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG13, 0x00000002)
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG14, 0x00000002)
+
+  /* Force DLL1 and DLL2 commands of LMI1 */
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG17, 0x00000002)
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG18, 0x00000002)
+
+  /* ----- STx7200 EMI configuration ----- */
+
+  POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000005)
+
+  /* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
+  POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+  POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
+  POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x0000000c)
+  POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
+  POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x00000014)
+
+  /* Bank 0 - On-board 32MBytes Flash at address 0x00000000 -> 0x01ffffff */
+  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
+  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+
+  /* Bank 2 - DVB-CI at address 0x03000000 -> 0x03FFFFFF */
+  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
+  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
+  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
+  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+
+  /* Bank 4 - EPLD Registers at address 0x05000000 -> 0x05FFFFFF */
+  POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA0, 0x042086f1)
+  POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA1, 0x8a002200)
+  POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA2, 0x8a004200)
+  POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)
+
+  /* Program other EMI registers */
+  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+
+  /* ----- STx7200 LMI0 configuration ----- */
+
+  /* "Refresh Interval" is set equal to 0xA28=2600 => 2600*3ns=7.8us */
+  POKE_LONG(ST40_LMI_MIM_0(0), 0x0a28015b)
+  POKE_LONG(ST40_LMI_MIM_1(0), 0x000000b0)
+
+  POKE_LONG(ST40_LMI_STR_0(0), 0xcb2cab5b)
+  POKE_LONG(ST40_LMI_STR_1(0), 0x000002d6)
+
+  /* lmi base address 0x08000000 + 128Mbytes 13x10 */
+  POKE_LONG(ST40_LMI_SDRA0_0(0), 0x10000a00)
+
+  /* lmi base address 0x08000000 + 128Mbytes 13x10 */
+  POKE_LONG(ST40_LMI_SDRA1_0(0), 0x10000a00)
+
+  /* Enable clock with NOP command */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020023)
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+
+  /* Precharge all */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020022)
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+
+  /* Issue EMRS2 */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000800)
+
+  /* Issue EMRS3 */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000c00)
+
+  /* Issue EMRS1 to enable DLL */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000400)
+
+  /* Issue MRS with DLL reset(0), CAS 5(0), Write recovery 6(0), Sequentiel(0), Burst lengh 8 */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00002353)
+
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+
+  /* Precharge all */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020022)
+  /* 2 CBR (auto refresh) */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020024)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020024)
+
+  /* Issue MRS with CAS 5(0), Write recovery 6(0), Sequentiel(0), Burst lengh 8 */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00002253)
+
+  /* Issue EMRS1 for OCD calibration default */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x000007c4)
+
+  /* Issue EMRS1 for OCD calibration exit */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000444)
+
+  /* Enable auto refresh */
+  POKE_LONG(ST40_LMI_MIM_0(0), 0x0a28035b)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+
+  POKE_LONG(ST40_LMI_GCC_0(0), 0x00382003)
+
+  /* ----- STx7200 LMI1 configuration ----- */
+
+  /* "Refresh Interval" is set equal to 0xA28=0d2600 => 2600*3ns=7.8us */
+  POKE_LONG(ST40_LMI_MIM_0(1), 0x0a28015b)
+  POKE_LONG(ST40_LMI_MIM_1(1), 0x000000b0)
+
+  POKE_LONG(ST40_LMI_STR_0(1), 0xcb2cab5b)
+  POKE_LONG(ST40_LMI_STR_1(1), 0x000002d6)
+
+  /* lmi base address 0x18000000 + 64Mbytes 13x10 (all 128MBytes are not visible in 29bits mode) */
+  POKE_LONG(ST40_LMI_SDRA0_0(1), 0x1c000a00)
+
+  /* lmi base address 0x18000000 + 64Mbytes 13x10 (all 128MBytes are not visible in 29bits mode) */
+  POKE_LONG(ST40_LMI_SDRA1_0(1), 0x1c000a00)
+
+  /* Enable clock with NOP command */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020023)
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+
+  /* Precharge all */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020022)
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+
+  /* Issue EMRS2 */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000800)
+
+  /* Issue EMRS3 */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000c00)
+
+  /* Issue EMRS1 to enable DLL */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000400)
+
+  /* Issue MRS with DLL reset(1), CAS 5(1), Write recovery 6(1), Sequentiel(1), Burst lengh 8 */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00002353)
+
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+
+  /* Precharge all */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020022)
+  /* 2 CBR (auto refresh) */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020024)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020024)
+
+  /* Issue MRS with CAS 5(1), Write recovery 6(1), Sequentiel(1), Burst lengh 8 */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00002253)
+
+  /* Issue EMRS1 for OCD calibration default */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x000007c4)
+
+  /* Issue EMRS1 for OCD calibration exit */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000444)
+
+  /* Enable auto refresh */
+  POKE_LONG(ST40_LMI_MIM_0(1), 0x0a28035b)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+
+  POKE_LONG(ST40_LMI_GCC_0(1), 0x00382003)
+
+#ifdef CONFIG_SH_SE_MODE
+  /*
+   * Note that we also manually need to move the LMI0 and LMI1 base addresses to
+   * their 32-bit SE mode locations as defined in the datasheet and change the
+   * 'upper bound addresses' (in row attribute registers) for the LMIs.
+   */
+  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+  POKE_LONG(ST40_LMI_SDRA0_0(0), 0x48000a00)
+  POKE_LONG(ST40_LMI_SDRA1_0(0), 0x48000a00)
+  POKE_LONG(ST40_LMI_SDRA0_0(1), 0x88000a00)
+  POKE_LONG(ST40_LMI_SDRA1_0(1), 0x88000a00)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/mb519/mb519.c b/board/mb519/mb519.c
new file mode 100644
index 0000000..f6eec93
--- /dev/null
+++ b/board/mb519/mb519.c
@@ -0,0 +1,151 @@
+/*
+ * (C) Copyright 2007 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stx7200reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+void stx7200_reset(void);
+
+#ifdef CONFIG_SH_SE_MODE
+#define EPLD_BASE		0xb5000000	/* Phys 0x05000000 */
+#else
+#define EPLD_BASE		0xa5000000
+#endif	/* CONFIG_SH_SE_MODE */
+
+#define EPLD_FlashCtrlAddr	SH4_WORD_REG(EPLD_BASE + 0x400000)
+
+void flashWriteEnable(void)
+{
+	/*  Enable vpp for writing to flash */
+	*EPLD_FlashCtrlAddr = 3;
+}
+
+void flashWriteDisable(void)
+{
+	/*  Disable vpp for writing to flash */
+	*EPLD_FlashCtrlAddr = 2;
+}
+
+#define PIO_BASE  0xfd020000
+
+static void configPIO(void)
+{
+  /*  Setup PIO of ASC device */
+  SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
+  SET_PIO_ASC(PIO_PORT(5), 4, 3, 5, 6);  /* UART3 - AS1 */
+}
+
+int board_init(void)
+{
+	unsigned long sysconf;
+
+	/* Serial port set up */
+	/* Route UART2&3 or SCI inputs instead of DVP to pins: conf_pad_dvp = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG40;
+	sysconf &= ~(1<<16);
+	*STX7200_SYSCONF_SYS_CFG40 = sysconf;
+
+	/* Route UART2&3/SCI outputs instead of DVP to pins: conf_pad_pio[1]=0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<25);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* No idea, more routing: conf_pad_pio[0] = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<24);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART2 (inputs and outputs) instead of SCI to pins: ssc2_mux_sel = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<2);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* conf_pad_pio[4] = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<28);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART3 (inputs and outputs) instead of SCI to pins: ssc3_mux_sel = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* conf_pad_clkobs = 1 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf |= (1<<14);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* I2C and USB related routing */
+	/* bit4: ssc4_mux_sel = 0 (treat SSC4 as I2C) */
+	/* bit26: conf_pad_pio[2] = 0 route USB etc instead of DVO */
+	/* bit27: conf_pad_pio[3] = 0 DVO output selection (probably ignored) */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~((1<<27)|(1<<26)|(1<<4));
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Enable SOFT_JTAG mode.
+	 * Taken from OS21, but is this correct?
+	 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG33;
+	sysconf |= (1<<6);
+	sysconf &= ~((1<<0)|(1<<1)|(1<<2)|(1<<3));
+	*STX7200_SYSCONF_SYS_CFG33 = sysconf;
+
+	/* Route Ethernet pins to output */
+	/* bit26-16: conf_pad_eth(10:0) */
+	sysconf = *STX7200_SYSCONF_SYS_CFG41;
+	/* MII0: conf_pad_eth(0) = 0 (ethernet) */
+	sysconf &= ~(1<<16);
+	/* MII1: conf_pad_eth(2) = 0, (3)=0, (4)=0, (9)=0, (10)=0 (ethernet)
+	 * MII1: conf_pad_eth(6) = 0 (MII1TXD[0] = output) */
+	sysconf &= ~( (1<<(16+2)) | (1<<(16+3)) | (1<<(16+4)) | (1<<(16+6)) |
+		      (1<<(16+9)) | (1<<(16+10)));
+	*STX7200_SYSCONF_SYS_CFG41 = sysconf;
+
+	configPIO();
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STx7200-Reference (MB519)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	return 0;
+}
+
+int do_reset (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	stx7200_reset();
+	/*NOTREACHED*/ return (0);
+}
diff --git a/board/mb519/sconsole.c b/board/mb519/sconsole.c
new file mode 100644
index 0000000..af92525
--- /dev/null
+++ b/board/mb519/sconsole.c
@@ -0,0 +1,129 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+
+#include "sconsole.h"
+
+#if 0
+void (*sconsole_putc) (char) = 0;
+void (*sconsole_puts) (const char *) = 0;
+int (*sconsole_getc) (void) = 0;
+int (*sconsole_tstc) (void) = 0;
+void (*sconsole_setbrg) (void) = 0;
+#endif
+
+#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
+int serial_init (void)
+{
+	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+	sb->pos = 0;
+	sb->size = 0;
+	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
+
+	return (0);
+}
+
+void serial_putc (char c)
+{
+	if (sconsole_putc) {
+		(*sconsole_putc) (c);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		if (c) {
+			sb->data[sb->pos++] = c;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+void serial_puts (const char *s)
+{
+	if (sconsole_puts) {
+		(*sconsole_puts) (s);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		while (*s) {
+			sb->data[sb->pos++] = *s++;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+int serial_getc (void)
+{
+	if (sconsole_getc) {
+		return (*sconsole_getc) ();
+	} else {
+		return 0;
+	}
+}
+
+int serial_tstc (void)
+{
+	if (sconsole_tstc) {
+		return (*sconsole_tstc) ();
+	} else {
+		return 0;
+	}
+}
+
+void serial_setbrg (void)
+{
+	if (sconsole_setbrg) {
+		(*sconsole_setbrg) ();
+	}
+}
+
+void sconsole_flush (void)
+{
+	if (sconsole_putc) {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+		unsigned int end = sb->pos < sb->size
+			? sb->pos + sb->max_size - sb->size
+			: sb->pos - sb->size;
+
+		while (sb->size) {
+			(*sconsole_putc) (sb->data[end++]);
+			if (end == sb->max_size) {
+				end = 0;
+			}
+			sb->size--;
+		}
+	}
+}
+#endif
diff --git a/board/mb519/sconsole.h b/board/mb519/sconsole.h
new file mode 100644
index 0000000..1666f21
--- /dev/null
+++ b/board/mb519/sconsole.h
@@ -0,0 +1,47 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SCONSOLE_H_
+#define _SCONSOLE_H_
+
+#include <config.h>
+
+typedef struct sconsole_buffer_s
+{
+	unsigned long size;
+	unsigned long max_size;
+	unsigned long pos;
+	char data[1];
+} sconsole_buffer_t;
+
+#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
+
+extern void (*sconsole_putc) (char);
+extern void (*sconsole_puts) (const char *);
+extern int (*sconsole_getc) (void);
+extern int (*sconsole_tstc) (void);
+extern void (*sconsole_setbrg) (void);
+
+extern void sconsole_flush (void);
+
+#endif
diff --git a/board/mb519/u-boot.lds b/board/mb519/u-boot.lds
new file mode 100644
index 0000000..3a1e91b
--- /dev/null
+++ b/board/mb519/u-boot.lds
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2007 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(sh4)
+ENTRY(_start)
+
+SECTIONS
+{
+	.text ALIGN(0x4):
+	{
+		__text_start = .;
+		cpu/sh/start.o (.text)
+		*(.text)
+		__text_end = .;
+	}
+
+	.rodata ALIGN(0x4):
+	{
+		__rodata_start = .;
+		*(.rodata)
+		__rodata_end = .;
+	}
+
+	.data ALIGN(0x4):
+	{
+		__data_start = .;
+		*(.data)
+		__data_end = .;
+	}
+
+	.u_boot_cmd ALIGN(0x4):
+	{
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	_uboot_end_data = .;
+
+	.bss ALIGN(0x4):
+	{
+		__bss_start = .;
+		*(.bss)
+		__bss_end = .;
+	}
+	_uboot_end = .;
+}
diff --git a/common/cmd_bdinfo.c b/common/cmd_bdinfo.c
index d059983..228ebfc 100644
--- a/common/cmd_bdinfo.c
+++ b/common/cmd_bdinfo.c
@@ -271,7 +271,71 @@ int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	return 0;
 }
 
-#else /* ! PPC, which leaves MIPS */
+#elif defined(CONFIG_SH4)
+
+#if defined(CONFIG_SH_STB7100)
+#include <asm/stb7100reg.h>
+#elif defined(CONFIG_SH_STX7200)
+#include <asm/stx7200reg.h>
+#else
+#error Missing Device Defintions!
+#endif
+
+int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	int i;
+	bd_t *bd = gd->bd;
+
+	print_num ("boot_params",	(ulong)bd->bi_boot_params);
+	print_num ("memstart",		(ulong)bd->bi_memstart);
+	print_num ("memsize",		(ulong)bd->bi_memsize);
+	print_num ("flashstart",	(ulong)bd->bi_flashstart);
+	print_num ("flashsize",		(ulong)bd->bi_flashsize);
+	print_num ("flashoffset",	(ulong)bd->bi_flashoffset);
+
+	puts ("ethaddr     =");
+	for (i=0; i<6; ++i) {
+		printf ("%c%02X", i ? ':' : ' ', bd->bi_enetaddr[i]);
+	}
+	puts ("\nip_addr     = ");
+	print_IPaddr (bd->bi_ip_addr);
+	printf ("\nbaudrate    = %d bps\n", bd->bi_baudrate);
+
+#ifdef CONFIG_SH_STB7100
+	if (STB7100_DEVICEID_7109(bd->bi_devid))
+		printf("\nSTb7109 version %ld.x\n", STB7100_DEVICEID_CUT(bd->bi_devid));
+	else if ( STB7100_DEVICEID_7100(bd->bi_devid))
+		printf("\nSTb7100 version %ld.x\n", STB7100_DEVICEID_CUT(bd->bi_devid));
+	else
+		printf("\nUnknown device\n");
+	printf ("PLL0      = %3d MHz\n", bd->bi_pll0frq);
+	printf ("PLL1      = %3d MHz\n", bd->bi_pll1frq);
+	printf ("ST40  CPU = %3d MHz\n", bd->bi_st40cpufrq);
+	printf ("ST40  BUS = %3d MHz\n", bd->bi_st40busfrq);
+	printf ("ST40  PER = %3d MHz\n", bd->bi_st40perfrq);
+	printf ("ST231 CPU = %3d MHz\n", bd->bi_st231frq);
+	printf ("ST BUS    = %3d MHz\n", bd->bi_stbusfrq);
+	printf ("EMI       = %3d MHz\n", bd->bi_emifrq);
+	printf ("LMI       = %3d MHz\n", bd->bi_lmifrq);
+#endif
+#ifdef CONFIG_SH_STX7200
+	if (STX7200_DEVICEID_7200(bd->bi_devid))
+		printf("\nSTx7200 version %ld.x\n", STX7200_DEVICEID_CUT(bd->bi_devid));
+	else
+		printf("\nUnknown device\n");
+	printf ("EMI       = %3d MHz\n", bd->bi_emifrq);
+#endif
+#ifdef CONFIG_SH_SE_MODE
+	printf ("\nAddress Mode: 32-bit\n");
+#else
+	printf ("\nAddress Mode: 29-bit\n");
+#endif
+	return 0;
+}
+
+#else /* ! SH4 || PPC, which leaves MIPS */
 
 int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
diff --git a/common/cmd_bootm.c b/common/cmd_bootm.c
index d816349..7661160 100644
--- a/common/cmd_bootm.c
+++ b/common/cmd_bootm.c
@@ -260,6 +260,10 @@ int do_bootm (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	if (hdr->ih_arch != IH_CPU_NIOS2)
 #elif defined(__PPC__)
 	if (hdr->ih_arch != IH_CPU_PPC)
+#elif defined(__SH4__)
+	if (hdr->ih_arch != IH_CPU_SH)
+#elif defined(__ST200__)
+	if (hdr->ih_arch != IH_CPU_ST200)
 #else
 # error Unknown CPU type
 #endif
@@ -1471,6 +1475,7 @@ print_type (image_header_t *hdr)
 	case IH_CPU_SH:		arch = "SuperH";		break;
 	case IH_CPU_SPARC64:	arch = "SPARC 64 Bit";		break;
 	case IH_CPU_SPARC:	arch = "SPARC";			break;
+	case IH_CPU_ST200:	arch = "ST200";			break;
 	default:		arch = "Unknown Architecture";	break;
 	}
 
diff --git a/common/cmd_ide.c b/common/cmd_ide.c
index 821dcff..9e150b0 100644
--- a/common/cmd_ide.c
+++ b/common/cmd_ide.c
@@ -56,6 +56,10 @@
 #include <asm/io.h>
 #endif
 
+#if defined(CONFIG_SH_STB7100_SATA) && defined(CONFIG_SH_STB7100)
+#include <asm/stb7100reg.h>
+#endif
+
 #ifdef CONFIG_IDE_8xx_DIRECT
 DECLARE_GLOBAL_DATA_PTR;
 #endif
@@ -68,6 +72,12 @@ DECLARE_GLOBAL_DATA_PTR;
 # define SYNC		/* nothing */
 #endif
 
+#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
+#define INT64(X) X##LL	/* explicit qualification, to avoid warnings */
+#else
+#define INT64(X) X
+#endif
+
 #ifdef CONFIG_IDE_8xx_DIRECT
 /* Timings for IDE Interface
  *
@@ -930,6 +940,23 @@ output_data(int dev, ulong *sect_buf, int words)
 	}
 #endif
 }
+#elif defined(CONFIG_SH_STB7100_SATA) && defined(CONFIG_SH_STB7100)
+static void
+output_data(int dev, ulong *sect_buf, int words)
+{
+	int count = words<<1;
+	const unsigned short *buf = (unsigned short *)sect_buf;
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+	if (STB7100_DEVICEID_7109(bd->bi_devid) && (STB7100_DEVICEID_CUT(bd->bi_devid) >= 2))
+	{
+		while (count--)
+			writew(*buf++, ATA_CURR_BASE(dev)+ATA_DATA_REG);
+	} else {
+		while (count--)
+			writel(*buf++, ATA_CURR_BASE(dev)+ATA_DATA_REG);
+	}
+}
 #else	/* ! __PPC__ */
 static void
 output_data(int dev, ulong *sect_buf, int words)
@@ -988,6 +1015,23 @@ input_data(int dev, ulong *sect_buf, int words)
 	}
 #endif
 }
+#elif defined(CONFIG_SH_STB7100_SATA) && defined(CONFIG_SH_STB7100)
+static void
+input_data(int dev, ulong *sect_buf, int words)
+{
+	unsigned short *buf = (unsigned short *)sect_buf;
+	int count = words << 1;
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+	if (STB7100_DEVICEID_7109(bd->bi_devid) && (STB7100_DEVICEID_CUT(bd->bi_devid) >= 2))
+	{
+		while (count--)
+		  *buf++ = readw(ATA_CURR_BASE(dev)+ATA_DATA_REG);
+	} else {
+		while (count--)
+		  *buf++ = readl(ATA_CURR_BASE(dev)+ATA_DATA_REG);
+	}
+}
 #else	/* ! __PPC__ */
 static void
 input_data(int dev, ulong *sect_buf, int words)
@@ -1142,8 +1186,8 @@ static void ide_ident (block_dev_desc_t *dev_desc)
 	 * 6.2.1.6: Identfy Drive, Table 39 for more details
 	 */
 
-	strswab (dev_desc->revision);
-	strswab (dev_desc->vendor);
+	strswab ((char*)dev_desc->revision);
+	strswab ((char*)dev_desc->vendor);
 #endif /* __LITTLE_ENDIAN */
 
 	if ((iop->config & 0x0080)==0x0080)
@@ -1242,7 +1286,7 @@ ulong ide_read (int device, lbaint_t blknr, ulong blkcnt, void *buffer)
 #ifdef CONFIG_LBA48
 	unsigned char lba48 = 0;
 
-	if (blknr & 0x0000fffff0000000) {
+	if (blknr & INT64(0x0000fffff0000000)) {
 		/* more than 28 bits used, use 48bit mode */
 		lba48 = 1;
 	}
@@ -1361,7 +1405,7 @@ ulong ide_write (int device, lbaint_t blknr, ulong blkcnt, void *buffer)
 #ifdef CONFIG_LBA48
 	unsigned char lba48 = 0;
 
-	if (blknr & 0x0000fffff0000000) {
+	if (blknr & INT64(0x0000fffff0000000)) {
 		/* more than 28 bits used, use 48bit mode */
 		lba48 = 1;
 	}
@@ -1752,7 +1796,7 @@ unsigned char atapi_issue(int device,unsigned char* ccb,int ccblen, unsigned cha
 	}
 
 	output_data_shorts (device, (unsigned short *)ccb,ccblen/2); /* write command block */
- 	/* ATAPI Command written wait for completition */
+	/* ATAPI Command written wait for completition */
 	udelay (5000); /* device must set bsy */
 
 	mask = ATA_STAT_DRQ|ATA_STAT_BUSY|ATA_STAT_ERR;
diff --git a/common/cmd_itest.c b/common/cmd_itest.c
index ce98872..c6708b6 100644
--- a/common/cmd_itest.c
+++ b/common/cmd_itest.c
@@ -68,17 +68,23 @@ extern int cmd_get_data_size(char* arg, int default_size);
 
 static long evalexp(char *s, int w)
 {
-	long l, *p;
+	long l=0, *p;
 
 	/* if the parameter starts with a * then assume is a pointer to the value we want */
 	if (s[0] == '*') {
 		p = (long *)simple_strtoul(&s[1], NULL, 16);
-		l = *p;
+		switch (w)
+		{
+		  case 1: l = *(char*)p; break;
+		  case 2: l = *(short*)p; break;
+		  case 4: l = *(long*)p; break;
+		  default: BUG();
+		}
 	} else {
 		l = simple_strtoul(s, NULL, 16);
 	}
 
-	return (l & ((1 << (w * 8)) - 1));
+	return (w < 4) ? (l & ((1 << (w * 8)) - 1)) : l;
 }
 
 static char * evalstr(char *s)
diff --git a/common/cmd_usb.c b/common/cmd_usb.c
index c6b17c2..3d573c4 100644
--- a/common/cmd_usb.c
+++ b/common/cmd_usb.c
@@ -31,6 +31,10 @@
 #include <part.h>
 #include <usb.h>
 
+#if defined(__SH4__)
+#include <asm/cache.h>
+#endif
+
 #ifdef CONFIG_USB_STORAGE
 static int usb_stor_curr_dev=-1; /* current device */
 #endif
@@ -449,6 +453,7 @@ int do_usb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 
 	if ((strncmp(argv[1], "reset", 5) == 0) ||
 		 (strncmp(argv[1], "start", 5) == 0)){
+		sh_disable_data_caches();
 		usb_stop();
 		printf("(Re)start USB...\n");
 		i = usb_init();
@@ -457,6 +462,7 @@ int do_usb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 		if (i >= 0)
 	 		usb_stor_curr_dev = usb_stor_scan(1);
 #endif
+		sh_enable_data_caches();
 		return 0;
 	}
 	if (strncmp(argv[1],"stop",4) == 0) {
@@ -487,6 +493,7 @@ int do_usb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	}
 	if (strncmp(argv[1],"inf",3) == 0) {
 		int d;
+		sh_disable_data_caches();
 		if (argc==2) {
 			for(d=0;d<USB_MAX_DEVICE;d++) {
 				dev=usb_get_dev_index(d);
@@ -495,6 +502,7 @@ int do_usb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 				usb_display_desc(dev);
 				usb_display_config(dev);
 			}
+			sh_enable_data_caches();
 			return 0;
 		}
 		else {
@@ -511,6 +519,7 @@ int do_usb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 			}
 			if (dev==NULL) {
 				printf("*** NO Device avaiable ***\n");
+				sh_enable_data_caches();
 				return 0;
 			}
 			else {
@@ -518,6 +527,7 @@ int do_usb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 				usb_display_config(dev);
 			}
 		}
+		sh_enable_data_caches();
 		return 0;
 	}
 #ifdef CONFIG_USB_STORAGE
@@ -535,6 +545,7 @@ int do_usb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 
 	if (strncmp(argv[1],"part",4) == 0) {
 		int devno, ok;
+		sh_disable_data_caches();
 		for (ok=0, devno=0; devno<USB_MAX_STOR_DEV; ++devno) {
 			stor_dev=usb_stor_get_dev(devno);
 			if (stor_dev->type!=DEV_TYPE_UNKNOWN) {
@@ -545,6 +556,7 @@ int do_usb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 				print_part(stor_dev);
 			}
 		}
+		sh_enable_data_caches();
 		if (!ok) {
 			printf("\nno USB devices available\n");
 			return 1;
diff --git a/common/usb.c b/common/usb.c
index 933afa9..a30bdf7 100644
--- a/common/usb.c
+++ b/common/usb.c
@@ -180,7 +180,7 @@ int usb_control_msg(struct usb_device *dev, unsigned int pipe,
 	setup_packet.value = swap_16(value);
 	setup_packet.index = swap_16(index);
 	setup_packet.length = swap_16(size);
- 	USB_PRINTF("usb_control_msg: request: 0x%X, requesttype: 0x%X\nvalue 0x%X index 0x%X length 0x%X\n",
+	USB_PRINTF("usb_control_msg: request: 0x%X, requesttype: 0x%X\nvalue 0x%X index 0x%X length 0x%X\n",
 		request,requesttype,value,index,size);
 	dev->status=USB_ST_NOT_PROC; /*not yet processed */
 
@@ -241,6 +241,21 @@ int usb_maxpacket(struct usb_device *dev,unsigned long pipe)
 		return(dev->epmaxpacketin[((pipe>>15) & 0xf)]);
 }
 
+	/*
+	 * Due to a bug in the SH4 compiler, it can generate
+	 * an unaligned access if we evaluate ep->wMaxPacketSize.
+	 * As a workaround, we move such accesses into a different
+	 * non-inlineable function, which will make it safe.
+	 * This should be removed, once the compiler is fixed.
+	 * See https://bugzilla.stlinux.com/show_bug.cgi?id=3313
+	 * 2008-01-24 Sean McGoogan <Sean.McGoogan@st.com>
+	 */
+static short __attribute__((noinline))
+getMaxPacketSize(const struct usb_endpoint_descriptor * const ep)
+{
+	return ep->wMaxPacketSize;
+}
+
 /*
  * set the max packed value of all endpoints in the given configuration
  */
@@ -248,27 +263,29 @@ int usb_set_maxpacket(struct usb_device *dev)
 {
 	int i,ii,b;
 	struct usb_endpoint_descriptor *ep;
+	short wMaxPacketSize;
 
 	for(i=0; i<dev->config.bNumInterfaces;i++) {
 		for(ii=0; ii<dev->config.if_desc[i].bNumEndpoints; ii++) {
 			ep=&dev->config.if_desc[i].ep_desc[ii];
 			b=ep->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
+			wMaxPacketSize=getMaxPacketSize(ep);
 
 			if((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)==USB_ENDPOINT_XFER_CONTROL) {	/* Control => bidirectional */
-				dev->epmaxpacketout[b] = ep->wMaxPacketSize;
-				dev->epmaxpacketin [b] = ep->wMaxPacketSize;
+				dev->epmaxpacketout[b] = wMaxPacketSize;
+				dev->epmaxpacketin [b] = wMaxPacketSize;
 				USB_PRINTF("##Control EP epmaxpacketout/in[%d] = %d\n",b,dev->epmaxpacketin[b]);
 			}
 			else {
 				if ((ep->bEndpointAddress & 0x80)==0) { /* OUT Endpoint */
-					if(ep->wMaxPacketSize > dev->epmaxpacketout[b]) {
-						dev->epmaxpacketout[b] = ep->wMaxPacketSize;
+					if(wMaxPacketSize > dev->epmaxpacketout[b]) {
+						dev->epmaxpacketout[b] = wMaxPacketSize;
 						USB_PRINTF("##EP epmaxpacketout[%d] = %d\n",b,dev->epmaxpacketout[b]);
 					}
 				}
 				else  { /* IN Endpoint */
-					if(ep->wMaxPacketSize > dev->epmaxpacketin[b]) {
-						dev->epmaxpacketin[b] = ep->wMaxPacketSize;
+					if(wMaxPacketSize > dev->epmaxpacketin[b]) {
+						dev->epmaxpacketin[b] = wMaxPacketSize;
 						USB_PRINTF("##EP epmaxpacketin[%d] = %d\n",b,dev->epmaxpacketin[b]);
 					}
 				} /* if out */
@@ -1088,7 +1105,7 @@ int usb_hub_configure(struct usb_device *dev)
 	/* silence compiler warning if USB_BUFSIZ is > 256 [= sizeof(char)] */
 	i = descriptor->bLength;
 	if (i > USB_BUFSIZ) {
-		USB_HUB_PRINTF("usb_hub_configure: failed to get hub descriptor - too long: %d\N",
+		USB_HUB_PRINTF("usb_hub_configure: failed to get hub descriptor - too long: %d\n",
 			descriptor->bLength);
 		return -1;
 	}
diff --git a/common/usb_storage.c b/common/usb_storage.c
index 443d785..ee79191 100644
--- a/common/usb_storage.c
+++ b/common/usb_storage.c
@@ -55,6 +55,11 @@
 #include <asm/processor.h>
 
 
+#if defined(__SH4__)
+#include <asm/cache.h>
+#endif
+
+
 #if defined(CONFIG_CMD_USB)
 #include <part.h>
 #include <usb.h>
@@ -169,7 +174,7 @@ static struct us_data usb_stor[USB_MAX_STOR_DEV];
 
 int usb_stor_get_info(struct usb_device *dev, struct us_data *us, block_dev_desc_t *dev_desc);
 int usb_storage_probe(struct usb_device *dev, unsigned int ifnum,struct us_data *ss);
-unsigned long usb_stor_read(int device, unsigned long blknr, unsigned long blkcnt, void *buffer);
+unsigned long usb_stor_read(int device, lbaint_t blknr, unsigned long blkcnt, void *buffer);
 struct usb_device * usb_get_dev_index(int index);
 void uhci_show_temp_int_td(void);
 
@@ -941,13 +946,14 @@ static void usb_bin_fixup(struct usb_device_descriptor descriptor,
 
 #define USB_MAX_READ_BLK 20
 
-unsigned long usb_stor_read(int device, unsigned long blknr, unsigned long blkcnt, void *buffer)
+unsigned long usb_stor_read(int device, lbaint_t blknr, unsigned long blkcnt, void *buffer)
 {
 	unsigned long start,blks, buf_addr;
 	unsigned short smallblks;
 	struct usb_device *dev;
 	int retry,i;
 	ccb *srb = &usb_ccb;
+	const int my_data_caches_on = sh_data_caches_on;
 
 	if (blkcnt == 0)
 		return 0;
@@ -966,12 +972,17 @@ unsigned long usb_stor_read(int device, unsigned long blknr, unsigned long blkcn
 			break;
 	}
 
+	if (my_data_caches_on)	/* is data cache on ? */
+		sh_disable_data_caches();
+
 	usb_disable_asynch(1); /* asynch transfer not allowed */
 	srb->lun=usb_dev_desc[device].lun;
 	buf_addr=(unsigned long)buffer;
 	start=blknr;
 	blks=blkcnt;
 	if(usb_test_unit_ready(srb,(struct us_data *)dev->privptr)) {
+		if (my_data_caches_on)	/* were the data caches on ? */
+			sh_enable_data_caches();
 		printf("Device NOT ready\n   Request Sense returned %02X %02X %02X\n",
 			srb->sense_buf[2],srb->sense_buf[12],srb->sense_buf[13]);
 		return 0;
@@ -1002,6 +1013,10 @@ retry_it:
 		blks-=smallblks;
 		buf_addr+=srb->datalen;
 	} while(blks!=0);
+
+	if (my_data_caches_on)	/* were the data caches on ? */
+		sh_enable_data_caches();
+
 	USB_STOR_PRINTF("usb_read: end startblk %lx, blccnt %x buffer %lx\n",start,smallblks,buf_addr);
 	usb_disable_asynch(0); /* asynch transfer allowed */
 	if(blkcnt>=USB_MAX_READ_BLK)
diff --git a/cpu/sh/Makefile b/cpu/sh/Makefile
new file mode 100644
index 0000000..db4f8db
--- /dev/null
+++ b/cpu/sh/Makefile
@@ -0,0 +1,44 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(CPU).a
+
+START	= start.o
+OBJS	= cpu.o interrupts.o usb.o
+SOBJS	=
+
+all:	.depend $(START) $(LIB)
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $(OBJS) $(SOBJS)
+
+#########################################################################
+
+.depend:	Makefile $(START:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(START:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/cpu/sh/config.mk b/cpu/sh/config.mk
new file mode 100644
index 0000000..5cc8f25
--- /dev/null
+++ b/cpu/sh/config.mk
@@ -0,0 +1,24 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, <wd@denx.de>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+PLATFORM_CPPFLAGS += -m4 -m4-nofpu -U__sh3__
diff --git a/cpu/sh/cpu.c b/cpu/sh/cpu.c
new file mode 100644
index 0000000..0308118
--- /dev/null
+++ b/cpu/sh/cpu.c
@@ -0,0 +1,167 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "common.h"
+#include <asm/cache.h>
+#include <asm/io.h>
+#include <asm/sh4reg.h>
+
+struct __large_struct { unsigned long buf[100]; };
+#define __m(x) (*(struct __large_struct *)(x))
+
+/*
+ * Write back the dirty D-caches, but not invalidate them.
+ *
+ * START: Virtual Address (U0, P1, or P3)
+ * SIZE: Size of the region.
+ */
+#if 0
+static void __flush_wback_region(void *start, int size)
+{
+	unsigned long v;
+	unsigned long begin, end;
+
+	begin = (unsigned long)start & ~(L1_CACHE_BYTES-1);
+	end = ((unsigned long)start + size + L1_CACHE_BYTES-1)
+		& ~(L1_CACHE_BYTES-1);
+	for (v = begin; v < end; v+=L1_CACHE_BYTES) {
+		asm volatile("ocbwb	%0"
+			     : /* no output */
+			     : "m" __m(v));
+	}
+}
+#endif
+
+/*
+ * Write back the dirty D-caches and invalidate them.
+ *
+ * START: Virtual Address (U0, P1, or P3)
+ * SIZE: Size of the region.
+ */
+static void __flush_purge_region(unsigned long start, int size)
+{
+	unsigned long v;
+	unsigned long begin, end;
+
+	begin = (unsigned long)start & ~(L1_CACHE_BYTES-1);
+	end = ((unsigned long)start + size + L1_CACHE_BYTES-1)
+		& ~(L1_CACHE_BYTES-1);
+	for (v = begin; v < end; v+=L1_CACHE_BYTES) {
+		asm volatile("ocbp	%0"
+			     : /* no output */
+			     : "m" __m(v));
+	}
+}
+
+#if 0
+/*
+ * No write back please
+ */
+static void __flush_invalidate_region(void *start, int size)
+{
+	unsigned long v;
+	unsigned long begin, end;
+
+	begin = (unsigned long)start & ~(L1_CACHE_BYTES-1);
+	end = ((unsigned long)start + size + L1_CACHE_BYTES-1)
+		& ~(L1_CACHE_BYTES-1);
+	for (v = begin; v < end; v+=L1_CACHE_BYTES) {
+		asm volatile("ocbi	%0"
+			     : /* no output */
+			     : "m" __m(v));
+	}
+}
+#endif
+
+void flush_cache (ulong start_addr, ulong size)
+{
+   __flush_purge_region(start_addr, size);
+}
+
+/*
+ * Flush all the data cache lines
+ */
+extern void sh_flush_cache_all(void)
+{
+	unsigned long addr;
+	const unsigned long end_addr = CACHE_OC_ADDRESS_ARRAY +
+		(DCACHE_SETS << DCACHE_ENTRY_SHIFT) * DCACHE_WAYS;
+	const unsigned long entry_offset = 1ul << DCACHE_ENTRY_SHIFT;
+
+	for (addr = CACHE_OC_ADDRESS_ARRAY;
+	     addr < end_addr;
+	     addr += entry_offset) {
+		ctrl_outl(0, addr);
+	}
+}
+
+/*
+ * sh_disable_data_caches() and sh_enable_data_caches()
+ * compliment each other. They are designed to be used in
+ * pairs to surround code that is designed to work with code
+ * that is not cache-coherency aware. e.g. immature drivers.
+ *
+ * The default assumption is that the chaches are normally ON,
+ * and the OFF state is a temporary exception.
+ *
+ * As an optimization, consequtive calls to change the data
+ * cacheability will do nothing, if the caches are correct.
+ * A global variable 'sh_data_caches_on' is used to track
+ * the current state of the data caches.
+ */
+int sh_data_caches_on = 1;	/* assume caches are ON */
+
+extern void sh_disable_data_caches(void)
+{
+	if (!sh_data_caches_on)	/* already OFF ? */
+		return;		/* do nothing */
+
+	/*
+	 * Flush the operand caches, to ensure that there is
+	 * no unwritten data residing only in the data cache.
+	 */
+	sh_flush_cache_all();
+
+	/* Disable the Operand Caches */
+	sh_cache_clear_op(SH4_CCR_OCE);
+
+	sh_data_caches_on = 0;	/* caches are OFF */
+}
+
+extern void sh_enable_data_caches(void)
+{
+	if (sh_data_caches_on)	/* already ON ? */
+		return;		/* do nothing */
+
+	/* Invalidate, and enable the data caches */
+	sh_cache_set_op(SH4_CCR_OCI|SH4_CCR_OCE);
+
+	sh_data_caches_on = 1;	/* caches are ON */
+}
+
+int cleanup_before_linux (void)
+{
+	return (0);
+}
+
diff --git a/cpu/sh/init_ram.S b/cpu/sh/init_ram.S
new file mode 100644
index 0000000..a354471
--- /dev/null
+++ b/cpu/sh/init_ram.S
@@ -0,0 +1,246 @@
+/*
+ * (C) Copyright 2004-2007 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ * Start Menefy <stuart.menefy@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include "asm/regdef.h"
+#include "asm/asmdefs.h"
+#include "asm/linkage.h"
+
+/*
+ *	NOTE:	 ALL THIS CODE MUST BE PIC !!!!
+ *
+ *	This code expects to be run with the caches enabled.
+ */
+
+ENTRY(init_ram)
+	/* Stash the pr somewhere safe */
+	sts	pr, r14
+
+	/*
+	 * We need to get the poke loop & associated data
+	 * into caches. The poke loop is structured so that it is
+	 * all pulled into cache on it 1st iteration.
+	 * To get the poke table into D-cache, we simply read it all.
+	 */
+	GETDEVID r7
+	mova	poke_loop_address, r0	/* R6: &poke_loop() */
+	mov.l	@r0, r6
+	add	r0, r6
+	mov.l	p2_to_p1_mask, r3	/* R3: P2 -> P1 mapping */
+	and	r3, r6			/* convert to P1 addresses */
+	mov.l	data_start_address, r1	/* R1 = start address */
+	add	r0, r1
+	mov.l	data_end_address, r2	/* R2 = end address */
+	add	r0, r2
+	and	r3, r1			/* convert to a P1 addresses */
+	and	r3, r2
+	mov	r1, r5			/* R5 = scratch data ptr */
+
+1:	mov.l	@r5+, r4		/* Load poke table in D$ */
+	cmp/eq	r5, r2
+	bf	1b
+
+	/*
+	 * Its now safe to call the poke loop with real data, since it
+	 * and its associated data table are in onchip caches. Setting
+	 * up the memory interfaces may cause the EMI (where this FLASH
+	 * image resides) to briefly hang - but the CPU will be safely
+	 * executing from cache should this happen.
+	 */
+do_pokes:
+	jsr	@r6		/* R6 still points poke_loop() */
+	  nop
+
+	/* Restore the PR */
+	lds	r14, pr
+	rts
+	  nop
+
+
+	.balign 4
+poke_loop_address:	.long poke_loop - poke_loop_address
+data_start_address:	.long __memory_setup_table - poke_loop_address
+data_end_address:	.long __memory_setup_table_end - poke_loop_address
+p2_to_p1_mask:		.long ~0x20000000
+
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *	sh-superh-elf/examples/os21/romdynamic/bootstrap.S
+ * but it is not identical, because concurrently U-Boot added the
+ * IF_DEVID, IF_NOT_DEVID, ELSE and ENDIF commands, while the toolset
+ * added IF. This merged version supports both.
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+#define POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)	.long 8, A1, A2, AND, SHIFT, OR
+#define WHILE_NE(A, AND, VAL)				.long 7, A, AND, VAL
+#define UPDATE_LONG(A, AND, OR)				.long 6, A, AND, OR
+#define OR_LONG(A, V)					.long 5, A, V
+#define POKE_LONG(A, V)					.long 4, A, V
+#define POKE_SHORT(A, V)				.long 2, A, V
+#define POKE_CHAR(A, V)					.long 1, A, V
+#define IF_DEVID(V)					.long 9,  (1f - .) -8, V
+#define IF_NOT_DEVID(V)					.long 10, (1f - .) -8, V
+#define ELSE						.long 11, (2f - .) - 4 ; 1:
+#define ENDIF						2: ; 1:
+#define IF(A, AND, VAL, COMMAND)			.long 12, A, AND, VAL; COMMAND
+#define END_MARKER					.long 0, 0, 0
+
+
+#define STB7100_CUT1 (STB7100_DEVID_7100_VAL << STB7100_DEVID_ID_SHIFT)
+#define STB7100_CUT2 (STB7100_DEVID_7100_VAL << STB7100_DEVID_ID_SHIFT) | (1 << STB7100_DEVID_CUT_SHIFT)
+#define STB7100_CUT3 (STB7100_DEVID_7100_VAL << STB7100_DEVID_ID_SHIFT) | (2 << STB7100_DEVID_CUT_SHIFT)
+#define STB7109_CUT1 (STB7100_DEVID_7109_VAL << STB7100_DEVID_ID_SHIFT)
+#define STB7109_CUT2 (STB7100_DEVID_7109_VAL << STB7100_DEVID_ID_SHIFT) | (1 << STB7100_DEVID_CUT_SHIFT)
+#define STB7109_CUT3 (STB7100_DEVID_7109_VAL << STB7100_DEVID_ID_SHIFT) | (2 << STB7100_DEVID_CUT_SHIFT)
+#define STX7200_CUT1 (STX7200_DEVID_7200_VAL << STB7100_DEVID_ID_SHIFT)
+
+/*
+ * Routine to setup peripheral registers.
+ * It is executed from within the I-cache,
+ * with all its data in the D-cache
+ */
+poke_loop:
+	mov.l	@r1+, r0	/* opcode */
+	mov.l	@r1+, r2	/* address */
+	mov.l	@r1+, r3	/* value */
+
+	cmp/eq	#0, r0		/* End marker ? */
+	bf	1f
+
+	rts			/* Return point */
+	  nop
+
+1:	cmp/eq	#4, r0		/* 4 byte write... */
+	bf	1f
+	mov.l	r3, @r2
+
+1:	cmp/eq	#2, r0		/* 2 byte write... */
+	bf	1f
+	mov.w	r3, @r2
+
+1:	cmp/eq	#1, r0		/* 1 byte write... */
+	bf	1f
+	mov.b	r3, @r2
+
+1:	cmp/eq	#5, r0		/* 4 byte OR... */
+	bf	1f
+	mov.l	@r2,r4
+	or	r3,r4
+	mov.l	r4,@r2
+
+1:	cmp/eq	#6, r0		/* 4 byte UPDATE... */
+	bf	1f
+	mov.l	@r2,r4
+	and	r3,r4
+	mov.l	@r1+,r3
+	or	r3,r4
+	mov.l	r4,@r2
+
+1:	cmp/eq	#8, r0		/* 4 byte write UPDATE... */
+	bf	1f
+	mov.l	@r3,r4
+	mov.l	@r1+,r3
+	and	r3,r4
+	mov.l	@r1+,r3
+	shld	r3,r4
+	mov.l	@r1+,r3
+	or	r3,r4
+	mov.l	r4,@r2
+
+1:	cmp/eq	#7, r0		/* WHILE != ... */
+	bf	1f
+	mov.l	@r1+,r5
+2:	mov.l	@r2,r4
+	and	r3,r4
+	cmp/eq	r4,r5
+	bf	2b
+
+1:	cmp/eq	#9, r0		/* IF_DEVID */
+	bf	1f		/* r2 skip offset, r3 condition, r7 holds out cut value */
+	cmp/eq	r3, r7
+	bt	poke_loop	/* go ahead with these pokes */
+	add	r2, r1
+	bra	poke_loop
+	  nop
+
+1:	cmp/eq	#10, r0		/* IF_NOT_DEVID */
+	bf	1f		/* r2 skip offset, r3 condition, r7 holds out cut value */
+	cmp/eq	r3, r7
+	bf	poke_loop	/* go ahead with these pokes */
+	add	r2, r1
+	bra	poke_loop
+	  nop
+
+1:	cmp/eq	#11, r0		/* ELSE */
+	bf	1f		/* r2 skip offset, r3 condition, r7 holds out cut value */
+	add	r2, r1
+	bra	poke_loop
+	  nop
+
+1:	cmp/eq	#12,r0		/* IF == ... next op */
+	bf	delay
+	mov.l	@r1+,r5
+	mov.l	@r2,r4
+	and	r3,r4
+	cmp/eq	r4,r5
+	bt	poke_loop	/* Compare succeeded - perform next op */
+2:				/* Skip the next operation (read past it) */
+	mov.l	@r1+,r0		/* R0 = opcode */
+	mov.l	@r1+,r2		/* skip address */
+	mov.l	@r1+,r2		/* skip value */
+				/* How many further reads do we need to skip? */
+	cmp/eq	#12,r0		/* If it's another IF, skip 1 and go back to start of skip loop */
+	bf	3f
+	mov.l	@r1+,r2
+	bra	2b
+	  nop
+
+3:	mov	#5,r2
+	cmp/gt	r2,r0
+	bf	5f		/* 0 further reads */
+
+	cmp/eq	#8,r0		/* Is it number 8 (3 reads, otherwise 1 read) */
+	bf	4f
+	mov.l	@r1+,r2		/* Skip 1 read */
+	mov.l	@r1+,r2		/* Skip 1 read */
+4:	mov.l	@r1+,r2		/* Skip 1 read and continue */
+5:	bra	poke_loop
+	  nop
+
+delay:	mov	#1,r0		/* small delay after EACH opcode */
+	swap.w	r0, r0		/* 0x10000 iterations (~65k) */
+2:	add	#-1,r0
+	cmp/eq	#0, r0
+	bf	2b
+	bt	poke_loop
diff --git a/cpu/sh/interrupts.c b/cpu/sh/interrupts.c
new file mode 100644
index 0000000..0bcea59
--- /dev/null
+++ b/cpu/sh/interrupts.c
@@ -0,0 +1,34 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "common.h"
+
+void enable_interrupts (void)
+{
+}
+
+int disable_interrupts (void)
+{
+	return 0;
+}
diff --git a/cpu/sh/start.S b/cpu/sh/start.S
new file mode 100644
index 0000000..6907056
--- /dev/null
+++ b/cpu/sh/start.S
@@ -0,0 +1,274 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include "asm/regdef.h"
+#include "asm/addrspace.h"
+#include "asm/sh4reg.h"
+#include "asm/asmdefs.h"
+
+#if defined(CONFIG_SH_STB7100)
+#include <asm/stb7100reg.h>
+#elif defined(CONFIG_SH_STX7200)
+#include <asm/stx7200reg.h>
+#else
+#error Missing Device Defintions!
+#endif
+
+
+	.global _start
+_start:
+
+	/* Set SR:	MD=1, RB=0, BL=0, FD=0, IMASK=0xF */
+	MOV_CONST32_R0 0x400000F0
+	ldc	r0, sr
+
+	/* Set FPSCR:	FR=0, SZ=0, PR=1, DN=0, RM=01 */
+	MOV_CONST32_R0 0x00080001
+	lds	r0, fpscr
+
+	/* disable the watchdog timer */
+	MOV_CONST32_R0 ST40_CPG_WTCSR
+	mov	r0, r1
+	MOV_CONST16_R0 0xA500
+	mov.w   r0, @r1
+
+	/*
+	 * Determine if we are in the correct location ? (i.e. RAM)
+	 *  r8 == 1 in RAM, assume initialization already done by GDB.
+	 *  r8 == 0 in FLASH, need to relocate, set up memory, etc...
+	 *  r9 == where we actualy ARE       (PIC relocate source).
+	 * r10 == were we WANT to be [BEGIN] (PIC relocate target).
+	 * r11 == were we WANT to be [END]   (PIC relocate target).
+	 *
+	 * NOTE: when CONFIG_SH_SE_MODE is defined, then also:
+	 *  r8 == 1 assume we are already in 32-bit SE mode (done by GDB).
+	 *  r8 == 0 we are in 29-bit mode, and need to switch to 32-bit mode.
+	 */
+	MOV_CONST32_R0 0x1fffffff	/* set up P0 mask  */
+	mov	r0, r4
+	mova	_start_offset, r0	/* Load source address in r9 */
+	mov	r0, r9			/* i.e. where we actualy ARE */
+	mov.l	@r9, r10
+	sub	r10, r9
+#ifndef CONFIG_SH_SE_MODE
+	and	r4, r9			/* make sure its P0 (cached) */
+#endif	/* CONFIG_SH_SE_MODE */
+	mov.l	target_addr, r10	/* Load target address in r10 */
+					/* i.e. were we WANT to be */
+#ifndef CONFIG_SH_SE_MODE
+	and	r4, r10			/* make sure its P0 (cached) */
+#endif	/* CONFIG_SH_SE_MODE */
+	mov.l	bss_start, r11		/* load target END address in r11 */
+#ifndef CONFIG_SH_SE_MODE
+	and	r4, r11			/* make sure its P0 (cached) */
+#endif	/* CONFIG_SH_SE_MODE */
+	cmp/eq	r9, r10			/* Are we in correct place already ? */
+	movt	r8			/* save SR.T in r8. */
+#ifdef CONFIG_SH_SE_MODE
+	and	r4, r9			/* make sure its P0 (cached) */
+#endif	/* CONFIG_SH_SE_MODE */
+
+	/* set up the PMB entries we want to use */
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * explicitly invalidate all unused entries
+	 * NOTE: for running from RAM, then keep PMB[0] as is.
+	 */
+	MOV_CONST32_R0 (P4SEG_PMB_ADDR)
+	mov	r0, r1
+	mov	#0, r2			/* PMB[n].V = 0, i.e. INVALID */
+	mov	#1, r3
+	shll8	r3			/* R3 = address stride is 0x100 */
+	mov	#1, r0			/* R0 = counter (indexes: 1..15) */
+1:	add	r3, r1			/* next index pointer */
+	mov.l	r2, @r1			/* invalidate current entry */
+	cmp/eq	#15, r0			/* finished ? */
+	bf/s	1b			/* more to do ? */
+	  add	#1, r0			/* next index counter */
+
+	/* set up the new PMB entries we want to use */
+#if defined(CONFIG_SH_STB7100)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI-Sys UN-cached */
+	SH4_SET_PMB 1 0x90 0x40 128 0 0 1	/* LMI-Sys UN-cached */
+	SH4_SET_PMB 2 0xa0 0x00  16 0 0 1	/* FLASH   UN-cached */
+	SH4_SET_PMB 3 0xb2 0x02  16 0 0 1	/* OFF-chip  Peripherals UN-cached */
+	SH4_SET_PMB 4 0xb8 0x18  64 0 0 1	/* ON-chip   Peripherals UN-cached */
+	SH4_SET_PMB 5 0xbc 0x1c  64 0 0 1	/* ST40 core Peripherals UN-cached */
+#elif defined(CONFIG_SH_STX7200)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 UN-cached */
+	SH4_SET_PMB 1 0x90 0x40 128 0 0 1	/* LMI0 UN-cached */
+	SH4_SET_PMB 2 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 3 0xa1 0x01  16 0 0 1	/* NOR FLASH UN-cached */
+#if defined(CONFIG_SH_MB519)			/* MB519 */
+	SH4_SET_PMB 4 0xb5 0x05  16 0 0 1	/* EPLD UN-cached */
+#elif defined(CONFIG_SH_CB101)			/* CB101 */
+	SH4_SET_PMB 4 0xa2 0x02  16 0 0 1	/* NAND FLASH UN-cached */
+	SH4_SET_PMB 5 0xa3 0x03  16 0 0 1	/* NAND FLASH UN-cached */
+#else
+	#error Do not know which board we are using for PMB setup.
+#endif	/* defined(CONFIG_SH_MBxxx) */
+#else
+	#error Do not know which chip we are using for PMB setup.
+#endif	/* defined(CONFIG_SH_STxxx) */
+#endif	/* CONFIG_SH_SE_MODE */
+
+	cmp/pl	r8			/* Are we in correct place already ? */
+	bt	hyperspace
+
+	/* disable the caches */
+	mov	#-1, a0		/* clear all bits in the CCR */
+	CALL	sh_cache_clear_op_offset
+
+	/* invalidate+enable the caches: both I$ & D$ (with copy-back) */
+	MOV_CONST16_R0 (SH4_CCR_OCI|SH4_CCR_ICI|SH4_CCR_ICE|SH4_CCR_OCE|SH4_CCR_EMODE)
+	mov	r0, a0
+	CALL	sh_cache_set_op_offset
+
+	/*
+	 * switch to P0 region (cachable), if we need to.
+	 * Recall, we are still in 29-bit mode at this juncture.
+	 */
+	ENTER_P0
+
+	/*
+	 * initialize the memory controllers, if we need to.
+	 */
+	CALL	init_ram_offset		/* init_ram() */
+
+	/*
+	 * enable SE (32-bit) mode, if we need to.
+	 */
+#ifdef CONFIG_SH_SE_MODE
+	/* enable SE mode */
+	/* QQQ: for SH4-300, we will need different code here!  */
+	MOV_CONST32_R0 SH4_CCN_MMUCR
+	mov	#(SH4_MMUCR_TI|SH4_MMUCR_SE), r1
+	mov.l	r1, @r0
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+#endif	/* CONFIG_SH_SE_MODE */
+
+	/*
+	 * relocate code: r1=source, r2=dest, r3=dest_end
+	 */
+relocate:
+	mov	#0x1f, r0
+	not	r0, r0			/* mask = 0xffffffe0 */
+	mov	r9, r1			/* where we actualy ARE */
+	and	r0, r1			/* ensure source is 32-byte cache aligned */
+	mov	r10, r2			/* were we WANT to be: START off */
+	and	r0, r2			/* ensure destination is 32-byte cache aligned */
+	mov	r11, r3			/* were we WANT to be: END off */
+1:	mov.l	@(0,r1), r0		/* read & write a line at a time */
+	mov.l	r0, @(0,r2)
+	mov.l	@(4,r1), r0
+	mov.l	r0, @(4,r2)
+	mov.l	@(8,r1), r0
+	mov.l	r0, @(8,r2)
+	mov.l	@(12,r1), r0
+	mov.l	r0, @(12,r2)
+	mov.l	@(16,r1), r0
+	mov.l	r0, @(16,r2)
+	mov.l	@(20,r1), r0
+	mov.l	r0, @(20,r2)
+	mov.l	@(24,r1), r0
+	mov.l	r0, @(24,r2)
+	mov.l	@(28,r1), r0
+	mov.l	r0, @(28,r2)
+	ocbp	@r2			/* flush one line */
+	add	#32, r1			/* next line */
+	pref	@r1			/* pre-featch next line */
+	add	#32, r2			/* next line */
+	cmp/hi	r2, r3			/* while (r2<=r3) ... */
+	bt	1b
+
+	/*
+	 * now jump to absolute (non-PIC) address environent.
+	 */
+	mov.l	hyperspace_addr, r1
+	jmp	@r1		/* never returns */
+	  nop
+
+hyperspace:
+
+	/*
+	 * At this point:
+	 *	We can stop using PIC, and use absolute code.
+	 *	The EMI/LMI initialization has been complated.
+	 */
+
+#ifdef CONFIG_SH_SE_MODE
+	/* Enable the cacheability for PMB array #0 */
+	CALL sh_toggle_pmb_cacheability_offset
+#endif	/* CONFIG_SH_SE_MODE */
+
+	/* init stack pointer */
+init_sp:	
+	mov.l	stack_addr, sp
+
+	/* Clear the bss */
+clear_bss:
+	mov.l	bss_start, r1
+	add	#4, r1
+	mov.l	bss_end, r2
+	mov	#0, r0
+1:	cmp/hs	r2, r1
+	bf/s	1b			/* while (r1 < r2) */
+	  mov.l	r0, @-r2
+done_bss:
+
+	/* prepare to call board init routine: start_sh4boot() */
+	mov.l	start_sh4boot_addr, r1
+	jmp	@r1			/* never returns */
+	  mov r8, a0
+
+
+	/* Constants used above */
+
+.balign 4
+_start_offset:	.long . - _start
+target_addr:	.long TEXT_BASE
+stack_addr:	.long TEXT_BASE - (CFG_GBL_DATA_SIZE + CFG_MALLOC_LEN + CFG_BOOTPARAMS_LEN)
+bss_start:	.long __bss_start
+bss_end:	.long __bss_end
+hyperspace_addr:.long hyperspace
+
+start_sh4boot_addr:.long start_sh4boot
+
+	/* offsets for PIC calls */
+
+init_ram_offset:		.long init_ram - .
+sh_cache_clear_op_offset:	.long sh_cache_clear_op - .
+sh_cache_set_op_offset:		.long sh_cache_set_op - .
+#ifdef CONFIG_SH_SE_MODE
+sh_toggle_pmb_cacheability_offset:
+				.long sh_toggle_pmb_cacheability - .
+#endif	/* CONFIG_SH_SE_MODE */
diff --git a/cpu/sh/stb7100/Makefile b/cpu/sh/stb7100/Makefile
new file mode 100644
index 0000000..02ae195
--- /dev/null
+++ b/cpu/sh/stb7100/Makefile
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2000, 2001, 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(SOC).a
+
+OBJS	= stb7100.o
+SOBJS	=
+
+all:	.depend $(LIB)
+
+$(LIB):	$(SOBJS) $(OBJS)
+	$(AR) crv $@ $(SOBJS) $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/cpu/sh/stb7100/stb7100.c b/cpu/sh/stb7100/stb7100.c
new file mode 100644
index 0000000..7891c5c
--- /dev/null
+++ b/cpu/sh/stb7100/stb7100.c
@@ -0,0 +1,404 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stb7100reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stbus.h>
+#include <ata.h>
+
+#define PIO_BASE  0xb8020000	/* Phys 0x18020000 */
+
+static int st40c_div[] = {1, 2, 3, 4, 6, 8, 1, 1};
+static int st40b_div[] = {1, 2, 3, 4, 6, 8, 2, 2};
+static int st40p_div[] = {4, 2, 4, 4, 6, 8, 4, 4};
+
+void stb7100_clocks(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+	unsigned long data, mdiv, ndiv, pdiv, pll0frq, pll1frq, mainfrq ;
+
+	data = *STB7100_CLOCKGENA_PLL0_CFG;
+	mdiv = data & 0xff;
+	ndiv = (data >> 8) & 0xff;
+	pdiv = (data >> 16) & 0x7;
+
+	pll0frq = ((2 * INPUT_CLOCK_RATE * ndiv)/ mdiv) / (1 << pdiv);
+	mainfrq = pll0frq / 2;
+
+	data = *STB7100_CLOCKGENA_PLL1_CFG;
+	mdiv = data & 0xff;
+	ndiv = (data >> 8) & 0xff;
+	pdiv = (data >> 16) & 0x7;
+	pll1frq = ((2 * INPUT_CLOCK_RATE * ndiv)/ mdiv) / (1 << pdiv);
+
+	bd->bi_pll0frq = pll0frq;
+	bd->bi_pll1frq = pll1frq;
+	bd->bi_st40cpufrq = mainfrq / st40c_div[*STB7100_CLOCKGENA_PLL0_CLK1_CTRL & 0x7];
+	bd->bi_st40busfrq = mainfrq / st40b_div[*STB7100_CLOCKGENA_PLL0_CLK2_CTRL & 0x7];
+	bd->bi_st40perfrq = mainfrq / st40p_div[*STB7100_CLOCKGENA_PLL0_CLK3_CTRL & 0x7];
+	bd->bi_st231frq = pll1frq;
+	bd->bi_stbusfrq = pll1frq/2;
+	bd->bi_emifrq = pll1frq/4;
+	bd->bi_lmifrq = pll1frq/2;
+}
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+
+#define MAC_SPEED_SEL       0x00100000 /* MAC is running at 100 Mbps speed */
+#define PHY_CLK_EXT         0x00080000 /* PHY clock is external (RMII mode)*/
+#define MII_MODE            0x00040000 /* RMII interface activated */
+#define ETH_IF_ON           0x00010000 /* ETH interface on */
+#define DVO_ETH_PAD_DISABLE 0x00020000 /* DVO eth pad disable */
+
+int stmac_default_pbl(void)
+{
+  DECLARE_GLOBAL_DATA_PTR;
+  bd_t *bd = gd->bd;
+  if (STB7100_DEVICEID_CUT(bd->bi_devid) == 1)
+    return 1;
+  return 32; /*  may be modified externally */
+}
+
+#ifdef CONFIG_STMAC_STE101P_RMII
+void stb7109_mac_speed(int speed)
+{
+
+	unsigned long sysconf = *STB7100_SYSCONF_SYS_CFG07;
+
+	if (speed == 100)
+		sysconf |= MAC_SPEED_SEL;
+	else if (speed == 10)
+		sysconf &= ~MAC_SPEED_SEL;
+
+	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
+}
+#endif
+
+/* ETH MAC pad configuration */
+static void stmac_eth_hw_setup(void)
+{
+	unsigned long sysconf;
+
+	sysconf = *STB7100_SYSCONF_SYS_CFG07;
+	sysconf |= (DVO_ETH_PAD_DISABLE | ETH_IF_ON /*| MAC_SPEED_SEL*/);
+
+#ifdef CONFIG_STMAC_STE101P_RMII
+	sysconf |= MII_MODE; /* RMII selected*/
+#else
+	sysconf &= ~MII_MODE; /* MII selected */
+#endif
+	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* STe101P: enable the external interrupts */
+	sysconf = *STB7100_SYSCONF_SYS_CFG10;
+	sysconf |= 0x0000000f;
+	*STB7100_SYSCONF_SYS_CFG10;
+
+       /* Configure e/net PHY clock */
+	SET_PIO_PIN(PIO_PORT(3), 7, STPIO_ALT_OUT);
+
+	return;
+}
+#endif
+
+int soc_init(void)
+{
+  DECLARE_GLOBAL_DATA_PTR;
+  bd_t *bd = gd->bd;
+
+  stb7100_clocks();
+
+  #ifdef CONFIG_DRIVER_NETSTMAC
+  if (STB7100_DEVICEID_7109(*STB7100_SYSCONF_DEVICEID_0))
+	stmac_eth_hw_setup();
+  else
+	printf("warning STMAC configured for a non STb7109 device\n");
+  #endif
+
+  bd->bi_devid = *STB7100_SYSCONF_DEVICEID_0;
+
+  /*  Make sure reset period is shorter than WDT timeout */
+
+ *STB7100_SYSCONF_SYS_CFG09 = (*STB7100_SYSCONF_SYS_CFG09 & 0xFF000000) | 0x000A8C;
+
+  return 0;
+}
+
+void stb7100_reset(void)
+{
+	ulong sr;
+	asm ("stc sr, %0":"=r" (sr));
+	sr |= (1 << 28);	/* set block bit */
+	asm ("ldc %0, sr": :"r" (sr));
+	asm volatile ("trapa #0");
+}
+
+#if defined(CONFIG_SH_STB7100_SATA)
+
+#define SATA_AHB2STBUS_BASE			0xB9209000
+#define SATA_AHBHOST_BASE			0xB9209800
+
+/* AHB_STBus protocol converter */
+#define SATA_AHB2STBUS_STBUS_OPC		(SATA_AHB2STBUS_BASE + 0x0000)
+#define SATA_AHB2STBUS_MESSAGE_SIZE_CONFIG	(SATA_AHB2STBUS_BASE + 0x0004)
+#define SATA_AHB2STBUS_CHUNK_SIZE_CONFIG	(SATA_AHB2STBUS_BASE + 0x0008)
+#define SATA_AHB2STBUS_SW_RESET			(SATA_AHB2STBUS_BASE + 0x000c)
+#define SATA_AHB2STBUS_PC_STATUS		(SATA_AHB2STBUS_BASE + 0x0010)
+#define SATA_PC_GLUE_LOGIC			(SATA_AHB2STBUS_BASE + 0x0014)
+#define SATA_PC_GLUE_LOGICH			(SATA_AHB2STBUS_BASE + 0x0018)
+
+#define SATA_CDR0                               (SATA_AHBHOST_BASE + 0x00000000)
+#define SATA_CDR1                               (SATA_AHBHOST_BASE + 0x00000004)
+#define SATA_CDR2                               (SATA_AHBHOST_BASE + 0x00000008)
+#define SATA_CDR3                               (SATA_AHBHOST_BASE + 0x0000000c)
+#define SATA_CDR4                               (SATA_AHBHOST_BASE + 0x00000010)
+#define SATA_CDR5                               (SATA_AHBHOST_BASE + 0x00000014)
+#define SATA_CDR6                               (SATA_AHBHOST_BASE + 0x00000018)
+#define SATA_CDR7                               (SATA_AHBHOST_BASE + 0x0000001c)
+#define SATA_CLR0                               (SATA_AHBHOST_BASE + 0x00000020)
+#define SATA_SCR0                               (SATA_AHBHOST_BASE + 0x00000024)
+#define SATA_SCR1                               (SATA_AHBHOST_BASE + 0x00000028)
+#define SATA_SCR2                               (SATA_AHBHOST_BASE + 0x0000002c)
+#define SATA_SCR3                               (SATA_AHBHOST_BASE + 0x00000030)
+#define SATA_SCR4                               (SATA_AHBHOST_BASE + 0x00000034)
+#define SATA_DMACR                              (SATA_AHBHOST_BASE + 0x00000070)
+#define SATA_DBTSR                              (SATA_AHBHOST_BASE + 0x00000074)
+
+#define SATA_PHYCR				(SATA_AHBHOST_BASE + 0x88)
+
+static void stm_phy_reset(void)
+{
+  DECLARE_GLOBAL_DATA_PTR;
+  bd_t *bd = gd->bd;
+
+  if (STB7100_DEVICEID_7100(bd->bi_devid))
+  {
+    if (STB7100_DEVICEID_CUT(bd->bi_devid) == 1)
+	writel(0x0013704A, SATA_PHYCR);
+    else if (STB7100_DEVICEID_CUT(bd->bi_devid) == 3)
+	writel(0x388FC, SATA_PHYCR);
+    else
+	writel(0x3889C, SATA_PHYCR);
+  }
+
+  udelay(100000);
+}
+
+void stb7100_sata_init(void)
+{
+	int t;
+
+	/* AHB bus wrapper setup */
+
+	/*
+	// SATA_AHB2STBUS_STBUS_OPC
+	// 2:0  -- 100 = Store64/Load64
+	// 4    -- 1   = Enable write posting
+	// DMA Read, write posting always = 0
+	*/
+
+	/* opcode = Load4 |Store 4*/
+	writel(0, SATA_AHB2STBUS_STBUS_OPC);
+
+	/*
+	// SATA_AHB2STBUS_MESSAGE_SIZE_CONFIG
+	// 3:0  -- 0111 = 128 Packets
+	// 3:0  -- 0110 =  64 Packets
+	*/
+	/* WAS: Message size = 64 packet when 6 now 3*/
+	writel(3, SATA_AHB2STBUS_MESSAGE_SIZE_CONFIG);
+
+	/*
+	// SATA_AHB2STBUS_CHUNK_SIZE_CONFIG
+	// 3:0  -- 0110 = 64 Packets
+	// 3:0  -- 0001 =  2 Packets
+	*/
+
+	/* WAS Chunk size = 2 packet when 1, now 0 */
+	writel(0, SATA_AHB2STBUS_CHUNK_SIZE_CONFIG);
+
+	/*
+	// PC_GLUE_LOGIC
+	// 7:0  -- 0xFF = Set as reset value, 256 STBus Clock Cycles
+	// 8    -- 1  = Time out enabled
+	*/
+	/* time out count = 0xa0(160 dec)
+	 * time out enable = 1
+	 */
+
+	writel(0x1ff, SATA_PC_GLUE_LOGIC);
+
+	stm_phy_reset();
+
+	writel(0x301, SATA_SCR2);  /* issue phy wake/reset */
+	readl(SATA_SCR0);          /* dummy read; flush */
+	udelay(400);               /* FIXME: a guess */
+
+	writel(0x300, SATA_SCR2);  /* issue phy wake/reset */
+
+	{
+	  int timeout = 25;
+	  do {
+	    udelay(200000);
+	    t = readl(SATA_SCR0);
+	    if ((t & 0xf) != 1)
+	      break;
+	  } while (--timeout);
+	}
+
+	return;
+}
+
+extern ulong ide_bus_offset[CFG_IDE_MAXBUS];
+
+	/*
+	 * The following 2 functions are only required to
+	 * workround a silicon bug on the STb710x on SATA.
+	 *
+	 * This bug is present on all STb7100 chips, and
+	 * cut 1.x of the STb7109.  It was fixed on
+	 * cut 2.x (and later) of the STb7109.
+	 *
+	 * If is safe to enable these fuctions on all STb710x
+	 * chips, but it is less efficent if is not required.
+	 */
+
+extern void ide_outb(int dev, int port, unsigned char val)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+	if ( STB7100_DEVICEID_7109(bd->bi_devid) &&
+	     (STB7100_DEVICEID_CUT(bd->bi_devid) >= 2) )
+	  writeb(val, ATA_CURR_BASE(dev)+port);
+	else
+	  writel(val, ATA_CURR_BASE(dev)+port);
+}
+
+extern unsigned char ide_inb(int dev, int port)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+	if ( STB7100_DEVICEID_7109(bd->bi_devid) &&
+	     (STB7100_DEVICEID_CUT(bd->bi_devid) >= 2) )
+	  return readb(ATA_CURR_BASE(dev)+port);
+	else
+	  return readl(ATA_CURR_BASE(dev)+port);
+}
+
+#endif /* defined(CONFIG_SH_STB7100_SATA) */
+
+
+#if defined(CONFIG_USB_OHCI_NEW)
+
+extern void stb7100_usb_init(void)
+{
+	unsigned long reg;
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	/* Work around for USB over-current detection chip being
+	 * active low, and the 710x being active high.
+	 *
+	 * This test is wrong for 7100 cut 3.0 (which needs the work
+	 * around), but as we can't reliably determine the minor
+	 * revision number, hard luck, this works for most people.
+	 */
+	if ( ( (STB7100_DEVICEID_7109(bd->bi_devid)) &&
+	       (STB7100_DEVICEID_CUT(bd->bi_devid) < 2) ) ||
+	     ( (STB7100_DEVICEID_7100(bd->bi_devid)) &&
+	       (STB7100_DEVICEID_CUT(bd->bi_devid) < 3) ) )
+	{
+		/* Setup PIO for USB over-current */
+		SET_PIO_PIN(PIO_PORT(5), 6, STPIO_OUT);
+		STPIO_SET_PIN(PIO_PORT(5), 6, 0);
+	}
+
+	/*
+	 * There have been two changes to the USB power enable signal:
+	 *
+	 * - 7100 upto and including cut 3.0 and 7109 1.0 generated an
+	 *   active high enables signal. From 7100 cut 3.1 and 7109 cut 2.0
+	 *   the signal changed to active low.
+	 *
+	 * - The 710x ref board (mb442) has always used power distribution
+	 *   chips which have active high enables signals (on rev A and B
+	 *   this was a TI TPS2052, rev C used the ST equivalent a ST2052).
+	 *   However rev A and B had a pull up on the enables signal, while
+	 *   rev C changed this to a pull down.
+	 *
+	 * The net effect of all this is that the easiest way to drive
+	 * this signal is ignore the USB hardware and drive it as a PIO
+	 * pin.
+	 *
+	 * (Note the USB over current input on the 710x changed from active
+	 * high to low at the same cuts, but board revs A and B had a resistor
+	 * option to select an inverted output from the TPS2052, so no
+	 * software work around is required.)
+	 */
+	/* Setup PIO for USB power */
+	SET_PIO_PIN(PIO_PORT(5), 7, STPIO_OUT);
+	STPIO_SET_PIN(PIO_PORT(5), 7, 1);
+
+	/* Make sure PLL is on */
+#define SYS_CFG2_PLL_POWER_DOWN_BIT	1
+	reg = readl(STB7100_SYSCONF_SYS_CFG02);
+	if (reg & SYS_CFG2_PLL_POWER_DOWN_BIT)
+	{
+		writel(reg & (~SYS_CFG2_PLL_POWER_DOWN_BIT),
+			STB7100_SYSCONF_SYS_CFG02);
+		udelay(100000);	/* QQQ: can this delay be shorter ? */
+	}
+
+	/* Set strap mode */
+#define STRAP_MODE	AHB2STBUS_STRAP_16_BIT
+	reg = readl(AHB2STBUS_STRAP);
+#if STRAP_MODE == 0
+	reg &= ~AHB2STBUS_STRAP_16_BIT;
+#else
+	reg |= STRAP_MODE;
+#endif
+	writel(reg, AHB2STBUS_STRAP);
+
+	/* Start PLL */
+	reg = readl(AHB2STBUS_STRAP);
+	writel(reg | AHB2STBUS_STRAP_PLL, AHB2STBUS_STRAP);
+	udelay(100000);	/* QQQ: can this delay be shorter ? */
+	writel(reg & (~AHB2STBUS_STRAP_PLL), AHB2STBUS_STRAP);
+	udelay(100000);	/* QQQ: can this delay be shorter ? */
+
+	/* Set the STBus Opcode Config for 32-bit access */
+	writel(AHB2STBUS_STBUS_OPC_32BIT, AHB2STBUS_STBUS_OPC);
+
+	/* Set the Message Size Config to 4 packets per message */
+	writel(AHB2STBUS_MSGSIZE_4, AHB2STBUS_MSGSIZE);
+
+	/* Set the Chunk Size Config to 4 packets per chunk */
+	writel(AHB2STBUS_CHUNKSIZE_4, AHB2STBUS_CHUNKSIZE);
+}
+#endif /* defined(CONFIG_USB_OHCI_NEW) */
+
diff --git a/cpu/sh/stx7200/Makefile b/cpu/sh/stx7200/Makefile
new file mode 100644
index 0000000..51950cf
--- /dev/null
+++ b/cpu/sh/stx7200/Makefile
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(SOC).a
+
+OBJS	= stx7200.o
+SOBJS	=
+
+all:	.depend $(LIB)
+
+$(LIB):	$(SOBJS) $(OBJS)
+	$(AR) crv $@ $(SOBJS) $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/cpu/sh/stx7200/stx7200.c b/cpu/sh/stx7200/stx7200.c
new file mode 100644
index 0000000..0912ecf
--- /dev/null
+++ b/cpu/sh/stx7200/stx7200.c
@@ -0,0 +1,514 @@
+/*
+ * (C) Copyright 2007 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stx7200reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stbus.h>
+#include <ata.h>
+
+#define PIO_BASE  ST40_PIO0_REGS_BASE
+
+static void stx7200_clocks(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	/*
+	 * FIXME
+	 * Gross hack to get the serial port working.
+	 * See the defintion of PCLK in drivers/stm-asc.c
+	 * for where this is used.
+	 */
+	bd->bi_emifrq = 100;
+}
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+
+#define MII_MODE		(1<<0)
+#define PHY_CLK_EXT             (1<<2)
+#define MAC_SPEED               (1<<4)
+#define VCI_ACK_SOURCE          (1<<6)
+#define RESET                   (1<<8)
+#define DISABLE_MSG_READ        (1<<12)
+#define DISABLE_MSG_WRITE       (1<<14)
+/* Remaining bits define pad functions, default appears to work */
+
+int stmac_default_pbl(void)
+{
+	return 32;
+}
+
+#ifdef CONFIG_STMAC_STE101P_RMII
+void stb7109_mac_speed(int speed)
+{
+	unsigned long sysconf = *STX7200_SYSCONF_SYS_CFG41;
+
+	if (speed == 100)
+		sysconf |= MAC_SPEED;
+	else if (speed == 10)
+		sysconf &= ~MAC_SPEED;
+
+	*STX7200_SYSCONF_SYS_CFG41 = sysconf;
+}
+#endif
+
+/* ETH MAC pad configuration */
+static void stmac_eth_hw_setup(void)
+{
+	unsigned long sysconf;
+#if defined(CONFIG_STMAC_MAC0)
+	const int shift = 0;	/* First MAC */
+#elif defined(CONFIG_STMAC_MAC1)
+	const int shift = 1;	/* Second MAC */
+#endif
+
+	sysconf = *STX7200_SYSCONF_SYS_CFG41;
+        sysconf &= ~(DISABLE_MSG_READ << shift);
+        sysconf &= ~(DISABLE_MSG_WRITE << shift);
+        //sysconf |=  (VCI_ACK_SOURCE << shift);
+        sysconf &= ~(VCI_ACK_SOURCE << shift);
+        sysconf |=  (RESET << shift);
+
+#ifdef CONFIG_STMAC_STE101P_RMII
+        sysconf |= (MII_MODE << shift);
+        sysconf &= ~(PHY_CLK_EXT << shift);
+#else
+        sysconf &= ~(MII_MODE << shift);
+        sysconf &= ~(PHY_CLK_EXT << shift);
+#endif
+	*STX7200_SYSCONF_SYS_CFG41 = sysconf;
+}
+#endif
+
+int soc_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	stx7200_clocks();
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+	stmac_eth_hw_setup();
+#endif
+
+	bd->bi_devid = *STX7200_SYSCONF_DEVICEID_0;
+
+	/*  Make sure reset period is shorter than WDT timeout */
+	*STX7200_SYSCONF_SYS_CFG09 = (*STX7200_SYSCONF_SYS_CFG09 & 0xFF000000) | 0x000A8C;
+
+	return 0;
+}
+
+void stx7200_reset(void)
+{
+	ulong sr;
+	asm ("stc sr, %0":"=r" (sr));
+	sr |= (1 << 28);	/* set block bit */
+	asm ("ldc %0, sr": :"r" (sr));
+	asm volatile ("trapa #0");
+}
+
+
+#if defined(CONFIG_USB_OHCI_NEW)
+
+#ifdef CONFIG_USB_STI7200_CUT1_SOFT_JTAG_RESET_WORKAROUND
+/*
+ * The following function *may* be required for boards
+ * with cut 1.x of the STi7200 chip. This function must
+ * *not* be used on cut 2.x (or later) of that chip.
+ * There is a board modifiction comprising a R-C delay
+ * which if applied negates the requirement to use this
+ * workaround, so it is optional. However, it should be safe
+ * to use this workaround with any cut 1.x silicon,
+ * irrespective of the presence of the R-C delay board fix.
+ *
+ * NOTE: Register reads and USB_tdo variable:
+ * All the reads are for USB_tdo, which is not used in this code.
+ * They were commented-out debugging prints following each read,
+ * so it's entirely possible that the reads could be dropped. But
+ * they will affect timing and so might be significant. In the
+ * absence of any understanding of how exactly this "black box"
+ * code works, leave them in for safety.
+ */
+static void usb_soft_jtag_reset(void)
+{
+	int i, j;
+	unsigned long USB_tdo;
+
+	/* ENABLE SOFT JTAG */
+	writel(0x00000040, STX7200_SYSCONF_SYS_CFG33);
+
+	/* RELEASE TAP RESET */
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SET TAP INTO IDLE STATE */
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SET TAP INTO SHIFT IR STATE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SHIFT DATA IN TDI = 101 select TCB*/
+	writel(0x00000046, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000047, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004E, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004F, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SET TAP INTO IDLE MODE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SET TAP INTO SHIFT DR STATE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SHIFT DATA IN TCB */
+	for (i = 0; i <= 53; i++)
+	{
+		if ((i == 0) || (i == 1) || (i == 19) || (i == 36))
+		{
+			writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+			writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+		}
+		if ((i == 53))
+		{
+			writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+			writel(0x0000004D, STX7200_SYSCONF_SYS_CFG33);
+		}
+		writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+		writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	}
+
+	/* SET TAP INTO IDLE MODE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	for (i = 0; i <= 53; i++)
+	{
+		writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+		writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+		USB_tdo = readl(STX7200_SYSCONF_SYS_CFG00);
+	}
+
+	writel(0x00000040, STX7200_SYSCONF_SYS_CFG33);
+
+	/* RELEASE TAP RESET */
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SET TAP INTO IDLE STATE */
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SET TAP INTO SHIFT IR STATE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SHIFT DATA IN TDI = 110 select TPR */
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000046, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000047, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004E, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004F, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SET TAP INTO IDLE MODE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SET TAP INTO SHIFT DR STATE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SHIFT DATA IN TDO */
+	for (i = 0; i <= 366; i++)
+	{
+		writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+		writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+		USB_tdo = readl(STX7200_SYSCONF_SYS_CFG00);
+	}
+
+	for (j = 0; j < 2; j++)
+	{
+		for (i = 0; i <= 365; i++)
+		{
+			if ((i == 71) || (i == 192) || (i == 313))
+			{
+				writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+				writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+			}
+			writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+			writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+			if ((i == 365))
+			{
+				writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+				writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+			}
+		}
+	}
+
+	for (i = 0; i <= 366; i++)
+	{
+		writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+		writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+		USB_tdo = readl(STX7200_SYSCONF_SYS_CFG00);
+	}
+
+	/* SET TAP INTO IDLE MODE */
+	writel(0x0000004C, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004D, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004C, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004D, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SET TAP INTO SHIFT IR STATE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SHIFT DATA IN TDI = 101 select TCB */
+	writel(0x00000046, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000047, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004E, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004F, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SET TAP INTO IDLE MODE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SET TAP INTO SHIFT DR STATE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SHIFT DATA IN TCB */
+	for (i = 0; i <= 53; i++)
+	{
+		if ((i == 0) || (i == 1) || (i == 18) || (i == 19)
+		    || (i == 36) || (i == 37))
+		{
+			writel(0x00000046, STX7200_SYSCONF_SYS_CFG33);
+			writel(0x00000047, STX7200_SYSCONF_SYS_CFG33);
+		}
+		if ((i == 53))
+		{
+			writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+			writel(0x0000004D, STX7200_SYSCONF_SYS_CFG33);
+		}
+		writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+		writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	}
+
+	/* SET TAP INTO IDLE MODE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	for (i = 0; i <= 53; i++)
+	{
+		writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+		writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+		USB_tdo = readl(STX7200_SYSCONF_SYS_CFG00);
+	}
+
+	/* SET TAP INTO SHIFT IR STATE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SHIFT DATA IN TDI = 110 select TPR */
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000046, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000047, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004E, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004F, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SET TAP INTO IDLE MODE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SET TAP INTO SHIFT DR STATE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	for (i = 0; i <= 366; i++)
+	{
+		writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+		writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+		USB_tdo = readl(STX7200_SYSCONF_SYS_CFG00);
+	}
+
+	/* SET TAP INTO IDLE MODE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* 20ms delay */
+	udelay(20000);
+
+	/* ENABLE SOFT JTAG */
+	writel(0x00000040, STX7200_SYSCONF_SYS_CFG33);
+}
+#endif	/* CONFIG_USB_STI7200_CUT1_SOFT_JTAG_RESET_WORKAROUND */
+
+extern void stx7200_usb_init(void)
+{
+	unsigned long reg;
+	const unsigned char power_pins[3] = {1, 3, 4};
+	const unsigned char oc_pins[3] = {0, 2, 5};
+#if CFG_USB_BASE == CFG_USB0_BASE
+	const size_t port = 0;
+#elif CFG_USB_BASE == CFG_USB1_BASE
+	const size_t port = 1;
+#elif CFG_USB_BASE == CFG_USB2_BASE
+	const size_t port = 2;
+#else
+#error Unknown USB Host Controller Base Address
+#endif
+
+	/* ClockgenB powers up with all the frequency synths bypassed.
+	 * Enable them all here.  Without this, USB 1.1 doesn't work,
+	 * as it needs a 48MHz clock which is separate from the USB 2
+	 * clock which is derived from the SATA clock. */
+	writel(0, STX7200_CLOCKGENB_OUT_MUX_CFG);
+
+	/* route USB and parts of MAFE instead of DVO.*/
+	/* DVO output selection (probably ignored). */
+	reg = readl(STX7200_SYSCONF_SYS_CFG07);
+	reg &= ~(1ul<<26); /* conf_pad_pio[2] = 0 */
+	reg &= ~(1ul<<27); /* conf_pad_pio[3] = 0 */
+	writel(reg, STX7200_SYSCONF_SYS_CFG07);
+
+	/* Enable soft JTAG mode for USB and SATA */
+	reg = readl(STX7200_SYSCONF_SYS_CFG33);
+	reg |= (1ul<<6);    /* soft_jtag_en = 1 */
+	reg &= ~(0xful<<0); /* tck = tdi = trstn_usb = tms_usb = 0 */
+	writel(reg, STX7200_SYSCONF_SYS_CFG33);
+
+#ifdef CONFIG_USB_STI7200_CUT1_SOFT_JTAG_RESET_WORKAROUND
+	/* reset USB HC via the JTAG scan path */
+	usb_soft_jtag_reset();
+#endif
+
+	/* USB power */
+	SET_PIO_PIN(PIO_PORT(7), power_pins[port], STPIO_ALT_OUT);
+	STPIO_SET_PIN(PIO_PORT(7), power_pins[port], 1);
+	/* USB oc */
+	SET_PIO_PIN(PIO_PORT(7), oc_pins[port], STPIO_ALT_BIDIR);
+
+	/* tusb_powerdown_req[port] = 0 */
+	reg = readl(STX7200_SYSCONF_SYS_CFG22);
+	reg &= ~(1ul<<(port+3));
+	writel(reg, STX7200_SYSCONF_SYS_CFG22);
+
+	/* Set strap mode */
+#define STRAP_MODE	AHB2STBUS_STRAP_16_BIT
+	reg = readl(AHB2STBUS_STRAP);
+#if STRAP_MODE == 0
+	reg &= ~AHB2STBUS_STRAP_16_BIT;
+#else
+	reg |= STRAP_MODE;
+#endif
+	writel(reg, AHB2STBUS_STRAP);
+
+	/* Start PLL */
+	reg = readl(AHB2STBUS_STRAP);
+	writel(reg | AHB2STBUS_STRAP_PLL, AHB2STBUS_STRAP);
+	udelay(100000);	/* QQQ: can this delay be shorter ? */
+	writel(reg & (~AHB2STBUS_STRAP_PLL), AHB2STBUS_STRAP);
+	udelay(100000);	/* QQQ: can this delay be shorter ? */
+
+	/* Set the STBus Opcode Config for 32-bit access */
+	writel(AHB2STBUS_STBUS_OPC_32BIT, AHB2STBUS_STBUS_OPC);
+
+	/* Set the Message Size Config to 4 packets per message */
+	writel(AHB2STBUS_MSGSIZE_4, AHB2STBUS_MSGSIZE);
+
+	/* Set the Chunk Size Config to 4 packets per chunk */
+	writel(AHB2STBUS_CHUNKSIZE_4, AHB2STBUS_CHUNKSIZE);
+}
+
+#endif /* defined(CONFIG_USB_OHCI_NEW) */
+
diff --git a/cpu/sh/usb.c b/cpu/sh/usb.c
new file mode 100644
index 0000000..3ab525c
--- /dev/null
+++ b/cpu/sh/usb.c
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2007-2008 STMicroelectronics Limited
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+
+#if defined(CONFIG_SH_STB7100)
+extern void stb7100_usb_init(void);
+#elif defined(CONFIG_SH_STX7200)
+extern void stx7200_usb_init(void);
+#else
+#error Missing Device Defintions!
+#endif
+
+#if defined(CONFIG_USB_OHCI_NEW) && defined(CFG_USB_OHCI_CPU_INIT)
+
+extern int usb_cpu_init(void)
+{
+#if defined(CONFIG_SH_STB7100)
+	stb7100_usb_init();
+#elif defined(CONFIG_SH_STX7200)
+	stx7200_usb_init();
+#endif
+	return 0;
+}
+
+extern int usb_cpu_stop(void)
+{
+	return 0;
+}
+
+extern int usb_cpu_init_fail(void)
+{
+	return 0;
+}
+
+#endif /* defined(CONFIG_USB_OHCI_NEW) && defined(CFG_USB_OHCI_CPU_INIT) */
+
diff --git a/drivers/mtd/cfi_flash.c b/drivers/mtd/cfi_flash.c
index 5579a1e..ad401b8 100644
--- a/drivers/mtd/cfi_flash.c
+++ b/drivers/mtd/cfi_flash.c
@@ -497,8 +497,10 @@ int flash_erase (flash_info_t * info, int s_first, int s_last)
 			if (flash_full_status_check
 			    (info, sect, info->erase_blk_tout, "erase")) {
 				rcode = 1;
-			} else
+			} else {
+				flash_write_cmd (info, sect, 0, FLASH_CMD_RESET);
 				putc ('.');
+			}
 		}
 	}
 	puts (" done\n");
@@ -562,6 +564,9 @@ void flash_print_info (flash_info_t * info)
 		int erased;
 		volatile unsigned long *flash;
 
+		/* make sure the sector is in read mode first */
+		flash_write_cmd (info, i, 0, info->cmd_reset);
+
 		/*
 		 * Check if whole sector is erased
 		 */
@@ -727,6 +732,7 @@ int flash_real_protect (flash_info_t * info, long sector, int prot)
 			}
 		}
 	}
+	flash_write_cmd (info, sector, 0, FLASH_CMD_RESET);
 	return retcode;
 }
 
@@ -1267,6 +1273,7 @@ ulong flash_get_size (ulong base, int banknum)
 					num_erase_regions, NUM_ERASE_REGIONS);
 				break;
 			}
+			flash_write_cmd (info, 0, 0, FLASH_CMD_CFI);
 			if (geometry_reversed)
 				tmp = flash_read_long (info, 0,
 					       FLASH_OFFSET_ERASE_REGIONS +
@@ -1291,10 +1298,16 @@ ulong flash_get_size (ulong base, int banknum)
 				switch (info->vendor) {
 				case CFI_CMDSET_INTEL_EXTENDED:
 				case CFI_CMDSET_INTEL_STANDARD:
+					/* for multi-bank devices, the READ_ID command
+					 * must be issued on a per sector basis */
+					flash_write_cmd (info, sect_cnt, 0, FLASH_CMD_READ_ID);
 					info->protect[sect_cnt] =
 						flash_isset (info, sect_cnt,
 							     FLASH_OFFSET_PROTECT,
 							     FLASH_STATUS_PROTECT);
+					/* for multi-bank devices, the RESET command
+					 * must be issued on a per sector basis */
+					flash_write_cmd (info, sect_cnt, 0, FLASH_CMD_RESET);
 					break;
 				default:
 					info->protect[sect_cnt] = 0; /* default: not protected */
@@ -1346,13 +1359,18 @@ static flash_sect_t find_sector (flash_info_t * info, ulong addr)
 static int flash_write_cfiword (flash_info_t * info, ulong dest,
 				cfiword_t cword)
 {
+	flash_sect_t sector;
 	cfiptr_t ctladdr;
 	cfiptr_t cptr;
-	int flag;
+	int flag, retcode;
 
 	ctladdr.cp = flash_make_addr (info, 0, 0);
 	cptr.cp = (uchar *) dest;
 
+	/* put the flash in read mode */
+	sector = find_sector (info, dest);
+	flash_write_cmd (info, sector, 0, FLASH_CMD_RESET);
+
 	/* Check if Flash is (sufficiently) erased */
 	switch (info->portwidth) {
 	case FLASH_CFI_8BIT:
@@ -1379,8 +1397,8 @@ static int flash_write_cfiword (flash_info_t * info, ulong dest,
 	switch (info->vendor) {
 	case CFI_CMDSET_INTEL_EXTENDED:
 	case CFI_CMDSET_INTEL_STANDARD:
-		flash_write_cmd (info, 0, 0, FLASH_CMD_CLEAR_STATUS);
-		flash_write_cmd (info, 0, 0, FLASH_CMD_WRITE);
+		flash_write_cmd (info, sector, 0, FLASH_CMD_CLEAR_STATUS);
+		flash_write_cmd (info, sector, 0, FLASH_CMD_WRITE);
 		break;
 	case CFI_CMDSET_AMD_EXTENDED:
 	case CFI_CMDSET_AMD_STANDARD:
@@ -1408,8 +1426,10 @@ static int flash_write_cfiword (flash_info_t * info, ulong dest,
 	if (flag)
 		enable_interrupts ();
 
-	return flash_full_status_check (info, find_sector (info, dest),
+	retcode = flash_full_status_check (info, sector,
 					info->write_tout, "write");
+	flash_write_cmd (info, sector, 0, FLASH_CMD_RESET);
+	return retcode;
 }
 
 #ifdef CFG_FLASH_USE_BUFFER_WRITE
@@ -1429,6 +1449,7 @@ static int flash_write_cfibuffer (flash_info_t * info, ulong dest, uchar * cp,
 		src.cp = cp;
 		dst.cp = (uchar *) dest;
 		sector = find_sector (info, dest);
+		flash_write_cmd (info, sector, 0, FLASH_CMD_RESET);
 		flash_write_cmd (info, sector, 0, FLASH_CMD_CLEAR_STATUS);
 		flash_write_cmd (info, sector, 0, FLASH_CMD_WRITE_TO_BUFFER);
 		if ((retcode = flash_status_check (info, sector, info->buffer_write_tout,
@@ -1477,6 +1498,7 @@ static int flash_write_cfibuffer (flash_info_t * info, ulong dest, uchar * cp,
 							   info->buffer_write_tout,
 							   "buffer write");
 		}
+		flash_write_cmd (info, sector, 0, FLASH_CMD_RESET);
 		return retcode;
 
 	case CFI_CMDSET_AMD_STANDARD:
diff --git a/drivers/mtd/nand/nand.c b/drivers/mtd/nand/nand.c
index 27b5792..b532338 100644
--- a/drivers/mtd/nand/nand.c
+++ b/drivers/mtd/nand/nand.c
@@ -32,7 +32,7 @@
 #endif
 
 int nand_curr_device = -1;
-nand_info_t nand_info[CFG_MAX_NAND_DEVICE];
+nand_info_t nand_info[CFG_MAX_NAND_DEVICE] = {{0}};
 
 static struct nand_chip nand_chip[CFG_MAX_NAND_DEVICE];
 static ulong base_address[CFG_MAX_NAND_DEVICE] = CFG_NAND_BASE_LIST;
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 41e1bde..b9f9bb6 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -52,6 +52,8 @@ COBJS-y += rtl8139.o
 COBJS-y += rtl8169.o
 COBJS-y += s3c4510b_eth.o
 COBJS-y += smc91111.o
+COBJS-y += smc911x.o
+COBJS-y += stm-stmac.o
 COBJS-y += tigon3.o
 COBJS-y += tsec.o
 COBJS-y += tsi108_eth.o
diff --git a/drivers/net/smc911x.c b/drivers/net/smc911x.c
new file mode 100644
index 0000000..c1a689f
--- /dev/null
+++ b/drivers/net/smc911x.c
@@ -0,0 +1,1383 @@
+/*------------------------------------------------------------------------
+ . smc9111x.c
+ . This is a driver for SMSC's LAN911X single-chip Ethernet device.
+ . based on the SMC91111 driver from U-boot, sim911x.c of smsc and
+ . datsheet.
+
+ . (C) Copyright 2005
+ . Andy Sturges, STMicrolectronics <andy.sturges@st.com>
+
+ . (C) Copyright 2002
+ . Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ . Rolf Offermanns <rof@sysgo.de>
+ .
+ . Copyright (C) 2001 Standard Microsystems Corporation (SMSC)
+ .	 Developed by Simple Network Magic Corporation (SNMC)
+ . Copyright (C) 1996 by Erik Stahlman (ES)
+ .
+ . This program is free software; you can redistribute it and/or modify
+ . it under the terms of the GNU General Public License as published by
+ . the Free Software Foundation; either version 2 of the License, or
+ . (at your option) any later version.
+ .
+ . This program is distributed in the hope that it will be useful,
+ . but WITHOUT ANY WARRANTY; without even the implied warranty of
+ . MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ . GNU General Public License for more details.
+ .
+ . You should have received a copy of the GNU General Public License
+ . along with this program; if not, write to the Free Software
+ . Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
+ .
+ . Information contained in this file was obtained from the LAN9111x
+ . manual from SMC.  To get a copy, if you really want one, you can find
+ . information under www.smsc.com.
+ .
+
+  ----------------------------------------------------------------------------*/
+
+#include <common.h>
+#include <command.h>
+#include <config.h>
+#include "smc911x.h"
+#include <net.h>
+
+#ifdef CONFIG_DRIVER_SMC911X
+
+#define SMC_DEBUG 0
+
+#if SMC_DEBUG > 1
+
+#define USE_TRACE 1
+#define USE_WARNING 1
+
+#endif
+
+#ifdef USE_TRACE
+#ifndef USE_WARNING
+#define USE_WARNING
+#endif
+#	define SMSC_TRACE(msg,args...)			\
+		printf("SMSC: " msg "\n", ## args);
+#else
+#	define SMSC_TRACE(msg,args...)
+#endif
+
+#ifdef USE_WARNING
+#define SMSC_WARNING(msg, args...)				\
+		printf("SMSC_WARNING: " msg "\n",## args);
+#else
+#	define SMSC_WARNING(msg, args...)
+#endif
+
+/* Autonegotiation timeout in seconds */
+#ifndef CONFIG_SMC_AUTONEG_TIMEOUT
+#define CONFIG_SMC_AUTONEG_TIMEOUT 10
+#endif
+
+#if (SMC_DEBUG > 2 )
+#define PRINTK3(args...) printf(args)
+#else
+#define PRINTK3(args...)
+#endif
+
+#if SMC_DEBUG > 1
+#define PRINTK2(args...) printf(args)
+#else
+#define PRINTK2(args...)
+#endif
+
+#ifdef SMC_DEBUG
+#define PRINTK(args...) printf(args)
+#else
+#define PRINTK(args...)
+#endif
+
+
+/*------------------------------------------------------------------------
+ .
+ . The internal workings of the driver.	 If you are changing anything
+ . here with the SMC stuff, you should have the datasheet and know
+ . what you are doing.
+ .
+ -------------------------------------------------------------------------*/
+
+static dword dwIdRev;
+static dword dwPhyAddress;
+static dword dwLinkSpeed;
+static dword dwLinkSettings;
+
+#define CARDNAME "LAN911X"
+
+#ifndef CONFIG_SMC911X_BASE
+#error Must define memory base address fpr SMC911X
+#endif
+
+#define SMC_BASE_ADDRESS CONFIG_SMC911X_BASE
+
+#define SMC_DEV_NAME "SMC911X"
+#define SMC_PHY_ADDR 0xFFFFFFFFUL
+
+#define SMC_TX_TIMEOUT 30
+
+#define ETH_ZLEN 60
+
+/* static functions */
+
+static void Phy_SetLink(void);
+static word Phy_GetRegW(dword dwRegIndex);
+static void Phy_SetRegW(dword dwRegIndex, word wVal);
+static void Phy_UpdateLinkMode(void);
+static void Phy_GetLinkMode(void);
+static void Phy_CheckLink(void);
+
+static void Tx_WriteFifo(dword *pdwBuf, dword dwDwordCount);
+static dword Tx_GetTxStatusCount(void);
+static dword Tx_CompleteTx(void);
+static void Tx_UpdateTxCounters(void);
+
+static void Rx_ReadFifo(dword *pdwBuf,dword dwDwordCount);
+static dword Rx_PopRxStatus(void);
+static void Rx_FastForward(dword dwDwordCount);
+
+/*-----------------------------------------------------------------
+ .
+ .  The driver can be entered at any of the following entry points.
+ .
+ .------------------------------------------------------------------  */
+
+extern int eth_init(bd_t *bd);
+extern void eth_halt(void);
+extern int eth_rx(void);
+extern int eth_send(volatile void *packet, int length);
+
+static BOOLEAN MacNotBusy(void)
+{
+	int i=0;
+
+	/*  wait for MAC not busy, w/ timeout */
+	for(i=0;i<40;i++)
+	{
+		if((Lan_GetRegDW(MAC_CSR_CMD) & MAC_CSR_CMD_CSR_BUSY_)==(0UL)) {
+			return TRUE;
+		}
+	}
+	SMSC_WARNING("timeout waiting for MAC not BUSY. MAC_CSR_CMD = 0x%08lX",
+		Lan_GetRegDW(MAC_CSR_CMD));
+	return FALSE;
+}
+
+/* Gets a mac register value */
+dword Mac_GetRegDW(dword dwRegOffset)
+{
+	dword result=0xFFFFFFFFUL;
+	dword dwTemp=0;
+
+	/*  wait until not busy */
+	if (Lan_GetRegDW(MAC_CSR_CMD) & MAC_CSR_CMD_CSR_BUSY_)
+	{
+		SMSC_WARNING("Mac_GetRegDW() failed, MAC already busy at entry");
+		goto DONE;
+	}
+
+	/*  send the MAC Cmd w/ offset */
+	Lan_SetRegDW(MAC_CSR_CMD,
+		((dwRegOffset & 0x000000FFUL) | MAC_CSR_CMD_CSR_BUSY_ | MAC_CSR_CMD_R_NOT_W_));
+	dwTemp=Lan_GetRegDW(BYTE_TEST);/* to flush previous write */
+	dwTemp=dwTemp;
+
+	/*  wait for the read to happen, w/ timeout */
+	if (!MacNotBusy())
+	{
+		SMSC_WARNING("Mac_GetRegDW() failed, waiting for MAC not busy after read");
+		goto DONE;
+	} else {
+		/*  finally, return the read data */
+		result=Lan_GetRegDW(MAC_CSR_DATA);
+	}
+DONE:
+	return result;
+}
+
+/* Sets a Mac register */
+void Mac_SetRegDW(dword dwRegOffset,dword dwVal)
+{
+	dword dwTemp=0;
+
+	if (Lan_GetRegDW(MAC_CSR_CMD) & MAC_CSR_CMD_CSR_BUSY_)
+	{
+		SMSC_WARNING("Mac_SetRegDW() failed, MAC already busy at entry");
+		goto DONE;
+	}
+
+	/*  send the data to write */
+	Lan_SetRegDW(MAC_CSR_DATA,dwVal);
+
+	/*  do the actual write */
+	Lan_SetRegDW(MAC_CSR_CMD,((dwRegOffset & 0x000000FFUL) | MAC_CSR_CMD_CSR_BUSY_));
+	dwTemp=Lan_GetRegDW(BYTE_TEST);/* force flush of previous write */
+	dwTemp=dwTemp;
+
+	/*  wait for the write to complete, w/ timeout */
+	if (!MacNotBusy())
+	{
+		SMSC_WARNING("Mac_SetRegDW() failed, waiting for MAC not busy after write");
+	}
+DONE:
+	return;
+}
+
+/* Gets a phy register */
+word Phy_GetRegW(
+	dword dwRegIndex)
+{
+	dword dwAddr=0;
+	int i=0;
+	word result=0xFFFFU;
+
+	/*  confirm MII not busy */
+	if ((Mac_GetRegDW(MII_ACC) & MII_ACC_MII_BUSY_) != 0UL)
+	{
+		SMSC_WARNING("MII is busy in Phy_GetRegW???");
+		result=0;
+		goto DONE;
+	}
+
+	/*  set the address, index & direction (read from PHY) */
+	dwAddr = (((dwPhyAddress) & 0x1FUL)<<11) | ((dwRegIndex & 0x1FUL)<<6);
+	Mac_SetRegDW(MII_ACC, dwAddr);
+
+	/*  wait for read to complete w/ timeout */
+	for(i=0;i<100;i++) {
+		/*  see if MII is finished yet */
+		if ((Mac_GetRegDW(MII_ACC) & MII_ACC_MII_BUSY_) == 0UL)
+		{
+			/*  get the read data from the MAC & return i */
+			result=((word)Mac_GetRegDW(MII_DATA));
+			goto DONE;
+		}
+	}
+	SMSC_WARNING("timeout waiting for MII write to finish");
+
+DONE:
+	return result;
+}
+
+/* Sets a phy register */
+void Phy_SetRegW(
+	dword dwRegIndex,word wVal)
+{
+	dword dwAddr=0;
+	int i=0;
+
+	/*  confirm MII not busy */
+	if ((Mac_GetRegDW(MII_ACC) & MII_ACC_MII_BUSY_) != 0UL)
+	{
+		SMSC_WARNING("MII is busy in Phy_SetRegW???");
+		goto DONE;
+	}
+
+	/*  put the data to write in the MAC */
+	Mac_SetRegDW(MII_DATA, (dword)wVal);
+
+	/*  set the address, index & direction (write to PHY) */
+	dwAddr = (((dwPhyAddress) & 0x1FUL)<<11) | ((dwRegIndex & 0x1FUL)<<6) | MII_ACC_MII_WRITE_;
+	Mac_SetRegDW(MII_ACC, dwAddr);
+
+	/*  wait for write to complete w/ timeout */
+	for(i=0;i<100;i++) {
+		/*  see if MII is finished yet */
+		if ((Mac_GetRegDW(MII_ACC) & MII_ACC_MII_BUSY_) == 0UL)
+		{
+			goto DONE;
+		}
+	}
+	SMSC_WARNING("timeout waiting for MII write to finish");
+DONE:
+	return;
+}
+
+/* Update link mode if any thing has changed */
+void Phy_UpdateLinkMode()
+{
+	dword dwOldLinkSpeed=dwLinkSpeed;
+
+	SMSC_TRACE("Update Link mode");
+
+	Phy_GetLinkMode();
+
+	switch(dwLinkSpeed) {
+	case LINK_OFF:
+	  SMSC_TRACE("Link is now down");
+	  break;
+	case LINK_SPEED_10HD:
+	  SMSC_TRACE("Link is now UP at 10Mbps HD");
+	  break;
+	case LINK_SPEED_10FD:
+	  SMSC_TRACE("Link is now UP at 10Mbps FD");
+	  break;
+	case LINK_SPEED_100HD:
+	  SMSC_TRACE("Link is now UP at 100Mbps HD");
+	  break;
+	case LINK_SPEED_100FD:
+	  SMSC_TRACE("Link is now UP at 100Mbps FD");
+	  break;
+	default:
+	  SMSC_WARNING("Link is now UP at Unknown Link Speed, dwLinkSpeed=0x%08lX",
+					dwLinkSpeed);
+	  break;
+	}
+
+	if(dwOldLinkSpeed!=(dwLinkSpeed)) {
+		if(dwLinkSpeed!=LINK_OFF) {
+			dword dwRegVal=0;
+			switch(dwLinkSpeed) {
+			case LINK_SPEED_10HD:
+				SMSC_TRACE("Link is now UP at 10Mbps HD");
+				break;
+			case LINK_SPEED_10FD:
+				SMSC_TRACE("Link is now UP at 10Mbps FD");
+				break;
+			case LINK_SPEED_100HD:
+				SMSC_TRACE("Link is now UP at 100Mbps HD");
+				break;
+			case LINK_SPEED_100FD:
+				SMSC_TRACE("Link is now UP at 100Mbps FD");
+				break;
+			default:
+				SMSC_WARNING("Link is now UP at Unknown Link Speed, dwLinkSpeed=0x%08lX",
+					dwLinkSpeed);
+				break;
+			}
+
+			dwRegVal=Mac_GetRegDW(MAC_CR);
+			dwRegVal&=~(MAC_CR_FDPX_|MAC_CR_RCVOWN_);
+			switch(dwLinkSpeed) {
+			case LINK_SPEED_10HD:
+			case LINK_SPEED_100HD:
+				dwRegVal|=MAC_CR_RCVOWN_;
+				break;
+			case LINK_SPEED_10FD:
+			case LINK_SPEED_100FD:
+				dwRegVal|=MAC_CR_FDPX_;
+				break;
+			default:
+				SMSC_WARNING("Unknown Link Speed, dwLinkSpeed=0x%08lX",
+					dwLinkSpeed);
+				break;
+			}
+
+			Mac_SetRegDW(
+				MAC_CR,dwRegVal);
+
+			if(dwLinkSettings&LINK_AUTO_NEGOTIATE) {
+				word linkPartner=0;
+				word localLink=0;
+				localLink=Phy_GetRegW(4);
+				linkPartner=Phy_GetRegW(5);
+				switch(dwLinkSpeed) {
+				case LINK_SPEED_10FD:
+				case LINK_SPEED_100FD:
+					if(((localLink&linkPartner)&((word)0x0400U)) != ((word)0U)) {
+						/* Enable PAUSE receive and transmit */
+						Mac_SetRegDW(FLOW,0xFFFF0002UL);
+						Lan_SetBitsDW(AFC_CFG,0x0000000FUL);
+					} else if(((localLink&((word)0x0C00U))==((word)0x0C00U)) &&
+							((linkPartner&((word)0x0C00U))==((word)0x0800U)))
+					{
+						/* Enable PAUSE receive, disable PAUSE transmit */
+						Mac_SetRegDW(FLOW,0xFFFF0002UL);
+						Lan_ClrBitsDW(AFC_CFG,0x0000000FUL);
+					} else {
+						/* Disable PAUSE receive and transmit */
+						Mac_SetRegDW(FLOW,0UL);
+						Lan_ClrBitsDW(AFC_CFG,0x0000000FUL);
+					};break;
+				case LINK_SPEED_10HD:
+				case LINK_SPEED_100HD:
+					Mac_SetRegDW(FLOW,0UL);
+					Lan_SetBitsDW(AFC_CFG,0x0000000FUL);
+					break;
+				default:
+					SMSC_WARNING("Unknown Link Speed, dwLinkSpeed=0x%08lX\n",dwLinkSpeed);
+					break;
+				}
+				SMSC_TRACE("LAN911x: %s,%s,%s,%s,%s,%s",
+					(localLink&PHY_ANEG_ADV_ASYMP_)?"ASYMP":"     ",
+					(localLink&PHY_ANEG_ADV_SYMP_)?"SYMP ":"     ",
+					(localLink&PHY_ANEG_ADV_100F_)?"100FD":"     ",
+					(localLink&PHY_ANEG_ADV_100H_)?"100HD":"     ",
+					(localLink&PHY_ANEG_ADV_10F_)?"10FD ":"     ",
+					(localLink&PHY_ANEG_ADV_10H_)?"10HD ":"     ");
+
+				SMSC_TRACE("Partner: %s,%s,%s,%s,%s,%s",
+					(linkPartner&PHY_ANEG_LPA_ASYMP_)?"ASYMP":"     ",
+					(linkPartner&PHY_ANEG_LPA_SYMP_)?"SYMP ":"     ",
+					(linkPartner&PHY_ANEG_LPA_100FDX_)?"100FD":"     ",
+					(linkPartner&PHY_ANEG_LPA_100HDX_)?"100HD":"     ",
+					(linkPartner&PHY_ANEG_LPA_10FDX_)?"10FD ":"     ",
+					(linkPartner&PHY_ANEG_LPA_10HDX_)?"10HD ":"     ");
+			} else {
+				switch(dwLinkSpeed) {
+				case LINK_SPEED_10HD:
+				case LINK_SPEED_100HD:
+					Mac_SetRegDW(FLOW,0x0UL);
+					Lan_SetBitsDW(AFC_CFG,0x0000000FUL);
+					break;
+				default:
+					Mac_SetRegDW(FLOW,0x0UL);
+					Lan_ClrBitsDW(AFC_CFG,0x0000000FUL);
+					break;
+				}
+			}
+		} else {
+			SMSC_TRACE("Link is now DOWN");
+			Mac_SetRegDW(FLOW,0UL);
+			Lan_ClrBitsDW(AFC_CFG,0x0000000FUL);
+		}
+	}
+}
+
+/* entry point for the link poller */
+void Phy_CheckLink()
+{
+	/* must call this twice */
+	Phy_UpdateLinkMode();
+	Phy_UpdateLinkMode();
+
+}
+
+/* gets the current link mode */
+void Phy_GetLinkMode()
+{
+	dword result=LINK_OFF;
+	word wRegVal=0;
+	word wRegBSR=0;
+
+	/* Assuming MacPhyAccessLock has already been acquired */
+
+	wRegBSR=Phy_GetRegW(PHY_BSR);
+	dwLinkSettings=LINK_OFF;
+
+	if(wRegBSR&PHY_BSR_LINK_STATUS_) {
+		wRegVal=Phy_GetRegW(PHY_BCR);
+		if(wRegVal&PHY_BCR_AUTO_NEG_ENABLE_) {
+			dword linkSettings=LINK_AUTO_NEGOTIATE;
+			word wRegADV=Phy_GetRegW(PHY_ANEG_ADV);
+			word wRegLPA=Phy_GetRegW(PHY_ANEG_LPA);
+
+			if(wRegADV&PHY_ANEG_ADV_ASYMP_) {
+				linkSettings|=LINK_ASYMMETRIC_PAUSE;
+			}
+			if(wRegADV&PHY_ANEG_ADV_SYMP_) {
+				linkSettings|=LINK_SYMMETRIC_PAUSE;
+			}
+			if(wRegADV&PHY_ANEG_LPA_100FDX_) {
+				linkSettings|=LINK_SPEED_100FD;
+			}
+			if(wRegADV&PHY_ANEG_LPA_100HDX_) {
+				linkSettings|=LINK_SPEED_100HD;
+			}
+			if(wRegADV&PHY_ANEG_LPA_10FDX_) {
+				linkSettings|=LINK_SPEED_10FD;
+			}
+			if(wRegADV&PHY_ANEG_LPA_10HDX_) {
+				linkSettings|=LINK_SPEED_10HD;
+			}
+			dwLinkSettings=linkSettings;
+			wRegLPA&=wRegADV;
+			if(wRegLPA&PHY_ANEG_LPA_100FDX_) {
+				result=LINK_SPEED_100FD;
+			} else if(wRegLPA&PHY_ANEG_LPA_100HDX_) {
+				result=LINK_SPEED_100HD;
+			} else if(wRegLPA&PHY_ANEG_LPA_10FDX_) {
+				result=LINK_SPEED_10FD;
+			} else if(wRegLPA&PHY_ANEG_LPA_10HDX_) {
+				result=LINK_SPEED_10HD;
+			}
+		} else {
+			if(wRegVal&PHY_BCR_SPEED_SELECT_) {
+				if(wRegVal&PHY_BCR_DUPLEX_MODE_) {
+					dwLinkSettings=result=LINK_SPEED_100FD;
+				} else {
+					dwLinkSettings=result=LINK_SPEED_100HD;
+				}
+			} else {
+				if(wRegVal&PHY_BCR_DUPLEX_MODE_) {
+					dwLinkSettings=result=LINK_SPEED_10FD;
+				} else {
+					dwLinkSettings=result=LINK_SPEED_10HD;
+				}
+			}
+		}
+	}
+	dwLinkSpeed=result;
+}
+
+int smc_init(void);
+void smc_destructor(void);
+static int smc_open(bd_t *bd);
+static int smc_close(void);
+
+/*
+ . Configures the PHY through the MII Management interface
+*/
+#ifndef CONFIG_SMC911X_EXT_PHY
+static void smc_phy_configure(void);
+#endif /* !CONFIG_SMC91111_EXT_PHY */
+
+/*
+ . This is a separate procedure to handle the receipt of a packet, to
+ . leave the interrupt code looking slightly cleaner
+*/
+static int smc_rcv(void);
+
+/* See if a MAC address is defined in the current environment. If so use it. If not
+ . print a warning and set the environment and other globals with the default.
+ . If an EEPROM is present it really should be consulted.
+*/
+
+int smc_get_ethaddr(bd_t *bd);
+static int get_rom_mac(unsigned char *v_rom_mac);
+
+/*
+ ------------------------------------------------------------
+ .
+ . Internal routines
+ .
+ ------------------------------------------------------------
+*/
+
+static char unsigned smc_mac_addr[6] = {0x02, 0x80, 0xad, 0x20, 0x31, 0xb8};
+
+/*
+ * This function must be called before smc_open() if you want to override
+ * the default mac address.
+ */
+
+void smc_set_mac_addr(const char *addr) {
+	int i;
+
+	for (i=0; i < sizeof(smc_mac_addr); i++){
+		smc_mac_addr[i] = addr[i];
+	}
+}
+
+/*
+ * smc_get_macaddr is no longer used. If you want to override the default
+ * mac address, call smc_get_mac_addr as a part of the board initialization.
+ */
+
+/*
+ . A rather simple routine to print out a packet for debugging purposes.
+*/
+
+#if SMC_DEBUG > 2
+static void print_packet( byte *, int );
+#endif
+
+/* this does a soft reset on the device */
+static void smc_reset( void );
+
+/* Enable Interrupts, Receive, and Transmit */
+static void smc_enable( void );
+
+/* this puts the device in an inactive state */
+static void smc_shutdown( void );
+
+/*
+ . Function: smc_reset
+ . Method:
+ .      Init the device
+*/
+
+static void smc_reset (void)
+{
+	dword dwTimeOut=0;
+	dword dwTemp=0;
+
+	PRINTK2 ("%s: smc_reset\n", SMC_DEV_NAME);
+
+	/* Reset the LAN911x */
+	Lan_SetRegDW(HW_CFG,HW_CFG_SRST_);
+	dwTimeOut=10;
+	do {
+		udelay(10);
+		dwTemp=Lan_GetRegDW(HW_CFG);
+		dwTimeOut--;
+	} while((dwTimeOut>0)&&(dwTemp&HW_CFG_SRST_));
+	if(dwTemp&HW_CFG_SRST_) {
+		SMSC_WARNING("  Failed to complete reset.");
+		goto DONE;
+	}
+
+	Lan_SetRegDW(HW_CFG,0x00050000UL);
+	Lan_SetRegDW(AFC_CFG,0x006E3740UL);
+
+	/* make sure EEPROM has finished loading before setting GPIO_CFG */
+	dwTimeOut=50;
+	while((dwTimeOut>0)&&(Lan_GetRegDW(E2P_CMD)&E2P_CMD_EPC_BUSY_)) {
+		udelay(10);
+		dwTimeOut--;
+	}
+	if(dwTimeOut==0) {
+		SMSC_WARNING("Lan_Initialize: Timed out waiting for EEPROM busy bit to clear\n");
+	}
+
+	Lan_SetRegDW(GPIO_CFG,0x70070000UL);
+
+	/* initialize interrupts */
+	Lan_SetRegDW(INT_EN,0);
+	Lan_SetRegDW(INT_STS,0xFFFFFFFFUL);
+	Lan_SetRegDW(INT_CFG,0);
+
+DONE:
+	SMSC_TRACE("<--Lan_Initialize");
+}
+
+/*
+ . Function: smc_enable
+ . Purpose: let the chip talk to the outside work
+ . Method:
+ .	Enable the transmitter
+ .	Enable the receiver
+ .	Enable interrupts
+*/
+
+static void smc_enable()
+{
+	dword dwRegVal=0;
+
+	/* Init Tx */
+
+	dwRegVal=Lan_GetRegDW(HW_CFG);
+	dwRegVal&=HW_CFG_TX_FIF_SZ_;
+	dwRegVal|=HW_CFG_SF_;
+	Lan_SetRegDW(HW_CFG,dwRegVal);
+
+	Lan_SetBitsDW(FIFO_INT,0xFF000000UL);
+
+	{
+	  dword dwMacCr=Mac_GetRegDW(MAC_CR);
+	  dwMacCr|=(MAC_CR_TXEN_|MAC_CR_HBDIS_);
+	  Mac_SetRegDW(MAC_CR,dwMacCr);
+	  Lan_SetRegDW(TX_CFG,TX_CFG_TX_ON_);
+	}
+
+	/* Init Rx */
+
+	Lan_SetRegDW(RX_CFG,0x00000200UL);
+
+	{
+	  dword dwMacCr=Mac_GetRegDW(MAC_CR);
+	  dwMacCr|=MAC_CR_RXEN_;
+	  Mac_SetRegDW(MAC_CR,dwMacCr);
+	}
+
+	Lan_ClrBitsDW(FIFO_INT,0x000000FFUL);
+
+	/* Disable all interrupts */
+
+	Lan_SetBitsDW(INT_EN, 0);
+}
+
+/*
+ . Function: smc_shutdown
+ . Purpose:  closes down the SMC91xxx chip.
+ . Method:
+ .	1. zero the interrupt mask
+ .	2. clear the enable receive flag
+ .	3. clear the enable xmit flags
+ .
+ . TODO:
+ .   (1) maybe utilize power down mode.
+ .	Why not yet?  Because while the chip will go into power down mode,
+ .	the manual says that it will wake up in response to any I/O requests
+ .	in the register space.	 Empirical results do not show this working.
+*/
+static void smc_shutdown()
+{
+	PRINTK2(CARDNAME ": smc_shutdown\n");
+}
+
+/* Writes a packet to the TX_DATA_FIFO */
+static void Tx_WriteFifo(
+	dword *pdwBuf,
+	dword dwDwordCount)
+{
+	volatile dword *pdwReg;
+	pdwReg = (volatile dword *)(SMC_BASE_ADDRESS+TX_DATA_FIFO);
+	while(dwDwordCount)
+	{
+		*pdwReg = *pdwBuf++;
+		dwDwordCount--;
+	}
+}
+
+/* Gets the number of Tx Statuses in the fifo */
+static dword Tx_GetTxStatusCount()
+{
+	dword result=0;
+	result=Lan_GetRegDW(TX_FIFO_INF);
+	result&=TX_FIFO_INF_TSUSED_;
+	result>>=16;
+	return result;
+}
+
+/* gets a tx status out of the status fifo */
+static dword Tx_CompleteTx()
+{
+	dword result=0;
+	result=Lan_GetRegDW(TX_FIFO_INF);
+
+	result&=TX_FIFO_INF_TSUSED_;
+	if(result!=0x00000000UL) {
+		result=Lan_GetRegDW(TX_STATUS_FIFO);
+	} else {
+		result=0;
+	}
+
+	return result;
+}
+
+/* reads tx statuses and increments counters where necessary */
+void Tx_UpdateTxCounters()
+{
+	dword dwTxStatus=0;
+	while((dwTxStatus=Tx_CompleteTx())!=0)
+	{
+		if(dwTxStatus&0x80000000UL) {
+			SMSC_WARNING("Packet tag reserved bit is high");
+			/* In this driver the packet tag is used as the packet */
+			/*   length. Since a packet length can never reach */
+			/*   the size of 0x8000, I made this bit reserved */
+			/*   so if I ever decided to use packet tracking  */
+			/*   tags then those tracking tags would set the  */
+			/*   reserved bit. And I would use this control path */
+			/*   to look up the packet and perhaps free it. */
+			/*   As you can see I never persued this idea. */
+			/*   because it never provided any benefit in this */
+			/*   linux environment. */
+			/* But it is worth noting that the "reserved bit" */
+			/*   in the warning above does not reference a */
+			/*   hardware defined reserved bit but rather a  */
+			/*   driver defined reserved bit.  */
+		} else {
+			if(dwTxStatus&0x00008000UL) {
+			  SMSC_WARNING("Tx error sending packet");
+			}
+		}
+	}
+}
+
+/*
+ .	This sends the actual packet to the SMC911x chip.
+*/
+
+static int smc_send_packet (volatile void *packet, int packet_length)
+{
+	int length;
+	dword dwFreeSpace=0;
+	dword dwTxCmdA=0;
+	dword dwTxCmdB=0;
+
+	PRINTK3 ("%s: smc_hardware_send_packet\n", SMC_DEV_NAME);
+
+	length = ETH_ZLEN < packet_length ? packet_length : ETH_ZLEN;
+
+	/* I can send the packet now.. */
+
+#if SMC_DEBUG > 2
+	printf ("Transmitting Packet\n");
+	print_packet ((byte*)packet, length);
+#endif
+
+	dwFreeSpace=Lan_GetRegDW(TX_FIFO_INF);
+	dwFreeSpace&=TX_FIFO_INF_TDFREE_;
+	if(dwFreeSpace<TX_FIFO_LOW_THRESHOLD) {
+		SMSC_WARNING("Tx Data Fifo Low, space available = %ld",dwFreeSpace);
+	}
+	dwTxCmdA=
+		((((dword)(packet))&0x03UL)<<16) | /* dword alignment adjustment */
+		TX_CMD_A_FIRST_SEG_ | TX_CMD_A_LAST_SEG_ |
+		((dword)(length));
+	dwTxCmdB=
+		(((dword)(length))<<16) |
+		((dword)(length));
+	Lan_SetRegDW(TX_DATA_FIFO,dwTxCmdA);
+	Lan_SetRegDW(TX_DATA_FIFO,dwTxCmdB);
+	Tx_WriteFifo(
+		(dword *)(((dword)(packet))&0xFFFFFFFCUL),
+		(((dword)(length))+3+
+		(((dword)(packet))&0x03UL))>>2);
+
+	dwFreeSpace-=(length+32);
+
+	if(Tx_GetTxStatusCount()>=30)
+	{
+		Tx_UpdateTxCounters();
+	}
+
+	if(dwFreeSpace<TX_FIFO_LOW_THRESHOLD) {
+		dword temp=Lan_GetRegDW(FIFO_INT);
+		temp&=0x00FFFFFFUL;
+		temp|=0x32000000UL;
+		Lan_SetRegDW(FIFO_INT,temp);
+	}
+
+	return length;
+
+}
+
+/*-------------------------------------------------------------------------
+ |
+ | smc_destructor( struct net_device * dev )
+ |   Input parameters:
+ |	dev, pointer to the device structure
+ |
+ |   Output:
+ |	None.
+ |
+ ---------------------------------------------------------------------------
+*/
+void smc_destructor()
+{
+	PRINTK2(CARDNAME ": smc_destructor\n");
+}
+
+
+/*
+ * Open and Initialize the board
+ *
+ * Set up everything, reset the card, etc ..
+ *
+ */
+static int smc_open (bd_t * bd)
+{
+	int err;
+
+	err = 0;
+
+	PRINTK2 ("%s: smc_open\n", SMC_DEV_NAME);
+
+	/* Detect if smc_chip type */
+
+	dwIdRev=Lan_GetRegDW(ID_REV);
+	if(HIWORD(dwIdRev)==LOWORD(dwIdRev)) {
+		/* this may mean the chip is set for 32 bit  */
+		/*   while the bus is reading as 16 bit */
+UNKNOWN_CHIP:
+		SMSC_WARNING("LAN911x NOT Identified, dwIdRev==0x%08lX",dwIdRev);
+		err = 1;
+		goto DONE;
+	}
+	switch(dwIdRev&0xFFFF0000UL) {
+	case 0x01180000UL:
+		SMSC_TRACE("LAN9118 identified, dwIdRev==0x%08lX",dwIdRev);break;
+	case 0x01170000UL:
+		SMSC_TRACE("LAN9117 identified, dwIdRev==0x%08lX",dwIdRev);break;
+	case 0x01160000UL:
+		SMSC_TRACE("LAN9116 identified, dwIdRev==0x%08lX",dwIdRev);break;
+	case 0x01150000UL:
+		SMSC_TRACE("LAN9115 identified, dwIdRev==0x%08lX",dwIdRev);break;
+	default:
+		goto UNKNOWN_CHIP;
+	}
+
+	/* reset the hardware */
+	smc_reset ();
+	smc_enable();
+
+	/* Configure the PHY */
+#ifndef CONFIG_SMC911X_EXT_PHY
+	smc_phy_configure ();
+#endif
+
+	err = smc_get_ethaddr (bd);	/* set smc_mac_addr, and sync it with u-boot globals */
+
+	if (err < 0) {
+		memset (bd->bi_enetaddr, 0, 6); /* hack to make error stick! upper code will abort if not set */
+		return (-1);	/* upper code ignores this, but NOT bi_enetaddr */
+	}
+
+	/* Set Mac address */
+	{
+	  dword dwHigh16, dwLow32;
+
+	  dwLow32  = smc_mac_addr[0]|(smc_mac_addr[1] << 8)|(smc_mac_addr[2] << 16)|(smc_mac_addr[3] << 24);
+	  dwHigh16 = smc_mac_addr[4]|(smc_mac_addr[5] << 8);
+
+	  Mac_SetRegDW(ADDRH,dwHigh16);
+	  Mac_SetRegDW(ADDRL,dwLow32);
+	}
+
+	Phy_CheckLink();
+
+DONE:
+	return err;
+}
+
+static void Rx_ReadFifo(
+	dword *pdwBuf,
+	dword dwDwordCount)
+{
+	const volatile dword * const pdwReg =
+		(const volatile dword * const)(SMC_BASE_ADDRESS+RX_DATA_FIFO);
+
+	while (dwDwordCount)
+	{
+		*pdwBuf++ = *pdwReg;
+		dwDwordCount--;
+	}
+}
+
+/* Gets the next rx status */
+static dword Rx_PopRxStatus()
+{
+	dword result=Lan_GetRegDW(RX_FIFO_INF);
+	if(result&0x00FF0000UL) {
+		/* Rx status is available, read it */
+		result=Lan_GetRegDW(RX_STATUS_FIFO);
+	} else {
+		result=0;
+	}
+	return result;
+}
+
+/* This function is used to quickly dump bad packets */
+void Rx_FastForward(dword dwDwordCount)
+{
+	if(dwDwordCount>=4)
+	{
+		dword dwTimeOut=500;
+		Lan_SetRegDW(RX_DP_CTRL,RX_DP_CTRL_RX_FFWD_);
+		while((dwTimeOut)&&(Lan_GetRegDW(RX_DP_CTRL)&RX_DP_CTRL_RX_FFWD_))
+		{
+			udelay(1);
+			dwTimeOut--;
+		}
+		if(dwTimeOut==0) {
+			SMSC_WARNING("timed out waiting for RX FFWD to finish, RX_DP_CTRL=0x%08lX",
+				Lan_GetRegDW(RX_DP_CTRL));
+		}
+	} else {
+		while(dwDwordCount) {
+			dword dwTemp=Lan_GetRegDW(RX_DATA_FIFO);
+			dwTemp=dwTemp;
+			dwDwordCount--;
+		}
+	}
+}
+
+/*-------------------------------------------------------------
+ .
+ . smc_rcv -  receive a packet from the card
+ .
+ . There is ( at least ) a packet waiting to be read from
+ . chip-memory.
+ .
+ . o Read the status
+ . o If an error, record it
+ . o otherwise, read in the packet
+ --------------------------------------------------------------
+*/
+
+static int smc_rcv()
+{
+	dword dwRxStatus=0;
+
+	if ((dwRxStatus=Rx_PopRxStatus())!=0)
+	{
+		dword dwPacketLength=((dwRxStatus&0x3FFF0000UL)>>16);
+		if((dwRxStatus&RX_STS_ES_)==0) {
+			Rx_ReadFifo(
+			  ((dword *)NetRxPackets[0]),
+			  (dwPacketLength+2+3)>>2);
+
+#if	SMC_DEBUG > 2
+			printf("Receiving Packet\n");
+			print_packet( NetRxPackets[0], dwPacketLength );
+#endif
+			NetReceive(NetRxPackets[0]+2, dwPacketLength-2);
+			return dwPacketLength;
+		}
+
+		/* if we get here then the packet is to be read */
+		/*   out of the fifo and discarded */
+		dwPacketLength+=(2+3);
+		dwPacketLength>>=2;
+		Rx_FastForward(dwPacketLength);
+	}
+
+	return 0;
+}
+
+
+/*----------------------------------------------------
+ . smc_close
+ .
+ . this makes the board clean up everything that it can
+ . and not talk to the outside world.	Caused by
+ . an 'ifconfig ethX down'
+ .
+ -----------------------------------------------------*/
+static int smc_close()
+{
+	PRINTK2("%s: smc_close\n", SMC_DEV_NAME);
+
+	/* clear everything */
+	smc_shutdown();
+
+	return 0;
+}
+
+/*------------------------------------------------------------
+ . Configures the specified PHY using Autonegotiation. Calls
+ . smc_phy_fixed() if the user has requested a certain config.
+ .-------------------------------------------------------------*/
+
+#ifndef CONFIG_SMC91111_EXT_PHY
+
+static void Phy_SetLink()
+{
+	word wTemp;
+	word status;
+	int timeout;
+
+	SMSC_TRACE("-->Phy_SetLink");
+
+	/* Because this is part of the single threaded initialization */
+	/*   path there is no need to acquire the MacPhyAccessLock */
+
+	wTemp=Phy_GetRegW(PHY_ANEG_ADV);
+	/* Advertise all speeds and pause capabilities */
+	wTemp|=(PHY_ANEG_ADV_PAUSE_|PHY_ANEG_ADV_SPEED_);
+	Phy_SetRegW(PHY_ANEG_ADV,wTemp);
+
+	/*  begin to establish link */
+	Phy_SetRegW(PHY_BCR,
+		PHY_BCR_AUTO_NEG_ENABLE_|
+		PHY_BCR_RESTART_AUTO_NEG_);
+
+	/* Wait for autoneg to complete */
+	timeout = CONFIG_SMC_AUTONEG_TIMEOUT * 100;
+	do {
+
+		status = Phy_GetRegW(PHY_BSR);
+		if (status & PHY_BSR_AUTO_NEG_COMP_) {
+	SMSC_TRACE("-->Phy_SetLink autoneg complete");
+			/* auto-negotiate complete */
+			break;
+		}
+
+		udelay(5000);	/* wait 500 millisecs */
+
+		/* Restart auto-negotiation if remote fault */
+		if (status & PHY_BSR_REMOTE_FAULT_) {
+			printf ("%s: PHY remote fault detected\n",
+				SMC_DEV_NAME);
+
+			/* Restart auto-negotiation */
+			printf ("%s: PHY restarting auto-negotiation\n",SMC_DEV_NAME);
+			Phy_SetRegW(PHY_BCR,
+				    PHY_BCR_AUTO_NEG_ENABLE_|
+				    PHY_BCR_RESTART_AUTO_NEG_);
+		}
+	} while (timeout--);
+
+	if (timeout < 1) {
+		printf ("%s: PHY auto-negotiate timed out\n", SMC_DEV_NAME);
+	}
+
+	if (status & PHY_BSR_REMOTE_FAULT_) {
+		printf ("%s: PHY remote fault detected\n", SMC_DEV_NAME);
+	}
+}
+
+static void smc_phy_configure ()
+{
+	word wTemp=0;
+	word wPhyId1=0;
+	dword wPhyId2=0;
+	dword dwLoopCount=0;
+	dword dwPhyAddr = SMC_PHY_ADDR;
+
+	SMSC_TRACE("-->Phy_Initialize");
+
+	if(dwPhyAddr!=0xFFFFFFFFUL) {
+		switch(dwIdRev&0xFFFF0000) {
+		case 0x01170000UL:
+		case 0x01150000UL:
+			{
+				dword dwHwCfg=Lan_GetRegDW(HW_CFG);
+				if(dwHwCfg&HW_CFG_EXT_PHY_DET_) {
+		    /* External phy is requested, supported, and detected */
+					/* Attempt to switch */
+					/* NOTE: Assuming Rx and Tx are stopped */
+					/*   because Phy_Initialize is called before  */
+					/*   Rx_Initialize and Tx_Initialize */
+
+					/* Disable phy clocks to the mac */
+					dwHwCfg&= (~HW_CFG_PHY_CLK_SEL_);
+					dwHwCfg|= HW_CFG_PHY_CLK_SEL_CLK_DIS_;
+					Lan_SetRegDW(HW_CFG,dwHwCfg);
+					udelay(10);/* wait for clocks to acutally stop */
+
+					/* switch to external phy */
+					dwHwCfg|=HW_CFG_EXT_PHY_EN_;
+					Lan_SetRegDW(HW_CFG,dwHwCfg);
+
+					/* Enable phy clocks to the mac */
+					dwHwCfg&= (~HW_CFG_PHY_CLK_SEL_);
+					dwHwCfg|= HW_CFG_PHY_CLK_SEL_EXT_PHY_;
+					Lan_SetRegDW(HW_CFG,dwHwCfg);
+					udelay(10);/* wait for clocks to actually start */
+
+					dwHwCfg|=HW_CFG_SMI_SEL_;
+					Lan_SetRegDW(HW_CFG,dwHwCfg);
+
+					/* Because this is part of the single threaded initialization */
+					/*   path there is no need to acquire the MacPhyAccessLock */
+					if(dwPhyAddr<=31) {
+						/* only check the phy address specified */
+						dwPhyAddress=dwPhyAddr;
+						wPhyId1=Phy_GetRegW(PHY_ID_1);
+						wPhyId2=Phy_GetRegW(PHY_ID_2);
+					} else {
+						/* auto detect phy */
+						dword address=0;
+						for(address=0;address<=31;address++) {
+							dwPhyAddress=address;
+							wPhyId1=Phy_GetRegW(PHY_ID_1);
+							wPhyId2=Phy_GetRegW(PHY_ID_2);
+							if((wPhyId1!=0xFFFFU)||(wPhyId2!=0xFFFFU)) {
+								SMSC_TRACE("Detected Phy at address = 0x%02lX = %ld",
+									address,address);
+								break;
+							}
+						}
+						if(address>=32) {
+							SMSC_WARNING("Failed to auto detect external phy");
+						}
+					}
+					if((wPhyId1==0xFFFFU)&&(wPhyId2==0xFFFFU)) {
+						SMSC_WARNING("External Phy is not accessable");
+						SMSC_WARNING("  using internal phy instead");
+						/* revert back to interal phy settings. */
+
+						/* Disable phy clocks to the mac */
+						dwHwCfg&= (~HW_CFG_PHY_CLK_SEL_);
+						dwHwCfg|= HW_CFG_PHY_CLK_SEL_CLK_DIS_;
+						Lan_SetRegDW(HW_CFG,dwHwCfg);
+						udelay(10);/* wait for clocks to actually stop */
+
+						/* switch to internal phy */
+						dwHwCfg&=(~HW_CFG_EXT_PHY_EN_);
+						Lan_SetRegDW(HW_CFG,dwHwCfg);
+
+						/* Enable phy clocks to the mac */
+						dwHwCfg&= (~HW_CFG_PHY_CLK_SEL_);
+						dwHwCfg|= HW_CFG_PHY_CLK_SEL_INT_PHY_;
+						Lan_SetRegDW(HW_CFG,dwHwCfg);
+						udelay(10);/* wait for clocks to actually start */
+
+						dwHwCfg&=(~HW_CFG_SMI_SEL_);
+						Lan_SetRegDW(HW_CFG,dwHwCfg);
+						goto USE_INTERNAL_PHY;
+					} else {
+						SMSC_TRACE("Successfully switched to external phy");
+					}
+				} else {
+					SMSC_WARNING("No External Phy Detected");
+					SMSC_WARNING("  using internal phy instead");
+					goto USE_INTERNAL_PHY;
+				}
+			};break;
+		default:
+			SMSC_WARNING("External Phy is not supported");
+			SMSC_WARNING("  using internal phy instead");
+			goto USE_INTERNAL_PHY;
+		}
+	} else {
+USE_INTERNAL_PHY:
+		SMSC_TRACE("Using internal phy");
+		dwPhyAddress=1;
+	}
+
+	wPhyId1=Phy_GetRegW(PHY_ID_1);
+	wPhyId2=Phy_GetRegW(PHY_ID_2);
+	if((wPhyId1==0xFFFFU)&&(wPhyId2==0xFFFFU)) {
+		SMSC_WARNING("Phy Not detected");
+		goto DONE;
+	}
+
+	dwLinkSpeed=LINK_OFF;
+	dwLinkSettings=LINK_OFF;
+	/* reset the PHY */
+	Phy_SetRegW(PHY_BCR,PHY_BCR_RESET_);
+	dwLoopCount=100000;
+	do {
+		udelay(10);
+		wTemp=Phy_GetRegW(PHY_BCR);
+		dwLoopCount--;
+	} while((dwLoopCount>0) && (wTemp&PHY_BCR_RESET_));
+	if(wTemp&PHY_BCR_RESET_) {
+		SMSC_WARNING("PHY reset failed to complete.");
+		goto DONE;
+	}
+
+	Phy_SetLink();
+
+	/*
+	init_timer(&(LinkPollingTimer));
+	LinkPollingTimer.function=Phy_CheckLink;
+	LinkPollingTimer.data=(unsigned long)privateData;
+	LinkPollingTimer.expires=jiffies+HZ;
+	add_timer(&(LinkPollingTimer));
+	*/
+
+
+DONE:
+	SMSC_TRACE("<--Phy_Initialize");
+}
+#endif /* !CONFIG_SMC91111_EXT_PHY */
+
+
+#if SMC_DEBUG > 2
+static void print_packet( byte * buf, int length )
+{
+	int i;
+	int remainder;
+	int lines;
+
+	printf("Packet of length %d \n", length );
+
+#if SMC_DEBUG > 3
+	lines = length / 16;
+	remainder = length % 16;
+
+	for ( i = 0; i < lines ; i ++ ) {
+		int cur;
+
+		for ( cur = 0; cur < 8; cur ++ ) {
+			byte a, b;
+
+			a = *(buf ++ );
+			b = *(buf ++ );
+			printf("%02x%02x ", a, b );
+		}
+		printf("\n");
+	}
+	for ( i = 0; i < remainder/2 ; i++ ) {
+		byte a, b;
+
+		a = *(buf ++ );
+		b = *(buf ++ );
+		printf("%02x%02x ", a, b );
+	}
+	printf("\n");
+#endif
+}
+#endif
+
+int eth_init(bd_t *bd) {
+	return (smc_open(bd));
+}
+
+void eth_halt() {
+	smc_close();
+}
+
+int eth_rx() {
+	return smc_rcv();
+}
+
+int eth_send(volatile void *packet, int length) {
+	return smc_send_packet(packet, length);
+}
+
+int smc_get_ethaddr (bd_t * bd)
+{
+	int env_size, rom_valid, env_present = 0, reg;
+	char *s = NULL, *e,  es[] = "11:22:33:44:55:66";
+	char s_env_mac[64];
+	uchar v_env_mac[6], v_rom_mac[6], *v_mac;
+
+	env_size = getenv_r ("ethaddr", s_env_mac, sizeof (s_env_mac));
+	if ((env_size > 0) && (env_size < sizeof (es))) {	/* exit if env is bad */
+		printf ("\n*** ERROR: ethaddr is not set properly!!\n");
+		return (-1);
+	}
+
+	if (env_size > 0) {
+		env_present = 1;
+		s = s_env_mac;
+	}
+
+	for (reg = 0; reg < 6; ++reg) { /* turn string into mac value */
+		v_env_mac[reg] = s ? simple_strtoul (s, &e, 16) : 0;
+		if (s)
+			s = (*e) ? e + 1 : e;
+	}
+
+	rom_valid = get_rom_mac (v_rom_mac);	/* get ROM mac value if any */
+
+	if (!env_present) {	/* if NO env */
+		if (rom_valid) {	/* but ROM is valid */
+			v_mac = v_rom_mac;
+			sprintf (s_env_mac, "%02X:%02X:%02X:%02X:%02X:%02X",
+				 v_mac[0], v_mac[1], v_mac[2], v_mac[3],
+				 v_mac[4], v_mac[5]);
+			setenv ("ethaddr", s_env_mac);
+		} else {	/* no env, bad ROM */
+			printf ("\n*** ERROR: ethaddr is NOT set !!\n");
+			return (-1);
+		}
+	} else {		/* good env, don't care ROM */
+		v_mac = v_env_mac;	/* always use a good env over a ROM */
+	}
+
+	if (env_present && rom_valid) { /* if both env and ROM are good */
+		if (memcmp (v_env_mac, v_rom_mac, 6) != 0) {
+			printf ("\nWarning: MAC addresses don't match:\n");
+			printf ("\tHW MAC address:  "
+				"%02X:%02X:%02X:%02X:%02X:%02X\n",
+				v_rom_mac[0], v_rom_mac[1],
+				v_rom_mac[2], v_rom_mac[3],
+				v_rom_mac[4], v_rom_mac[5] );
+			printf ("\t\"ethaddr\" value: "
+				"%02X:%02X:%02X:%02X:%02X:%02X\n",
+				v_env_mac[0], v_env_mac[1],
+				v_env_mac[2], v_env_mac[3],
+				v_env_mac[4], v_env_mac[5]) ;
+			debug ("### Set MAC addr from environment\n");
+		}
+	}
+	memcpy (bd->bi_enetaddr, v_mac, 6);	/* update global address to match env (allows env changing) */
+	smc_set_mac_addr ((char*)v_mac);        /* use old function to update smc default */
+	PRINTK("Using MAC Address %02X:%02X:%02X:%02X:%02X:%02X\n", v_mac[0], v_mac[1],
+		v_mac[2], v_mac[3], v_mac[4], v_mac[5]);
+	return (0);
+}
+
+static int get_rom_mac (unsigned char *v_rom_mac)
+{
+	dword dwHigh16=0;
+	dword dwLow32=0;
+
+	dwHigh16=Mac_GetRegDW(ADDRH);
+	dwLow32=Mac_GetRegDW(ADDRL);
+
+	if((dwHigh16==0x0000FFFFUL)&&(dwLow32==0xFFFFFFFF))
+	  return 0;
+
+	v_rom_mac[0]=LOBYTE(LOWORD(dwLow32));
+	v_rom_mac[1]=HIBYTE(LOWORD(dwLow32));
+	v_rom_mac[2]=LOBYTE(HIWORD(dwLow32));
+	v_rom_mac[3]=HIBYTE(HIWORD(dwLow32));
+	v_rom_mac[4]=LOBYTE(LOWORD(dwHigh16));
+	v_rom_mac[5]=HIBYTE(LOWORD(dwHigh16));
+
+	return 1;
+}
+#endif /* CONFIG_DRIVER_SMC911X */
diff --git a/drivers/net/smc911x.h b/drivers/net/smc911x.h
new file mode 100644
index 0000000..26e1435
--- /dev/null
+++ b/drivers/net/smc911x.h
@@ -0,0 +1,488 @@
+/*------------------------------------------------------------------------
+ . smc911x.h - macros for the LAN911X Ethernet Driver
+ .
+ . (C) Copyright 2002
+ . Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ . Rolf Offermanns <rof@sysgo.de>
+ . Copyright (C) 2001 Standard Microsystems Corporation (SMSC)
+ .       Developed by Simple Network Magic Corporation (SNMC)
+ . Copyright (C) 1996 by Erik Stahlman (ES)
+ .
+ . This program is free software; you can redistribute it and/or modify
+ . it under the terms of the GNU General Public License as published by
+ . the Free Software Foundation; either version 2 of the License, or
+ . (at your option) any later version.
+ .
+ . This program is distributed in the hope that it will be useful,
+ . but WITHOUT ANY WARRANTY; without even the implied warranty of
+ . MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ . GNU General Public License for more details.
+ .
+ . You should have received a copy of the GNU General Public License
+ . along with this program; if not, write to the Free Software
+ . Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ .
+ . This file contains register information and access macros for
+ . the LAN91C111 single chip ethernet controller.  It is a modified
+ . version of the smc9194.h file.
+ .
+ . Information contained in this file was obtained from the LAN91C111
+ . manual from SMC.  To get a copy, if you really want one, you can find
+ . information under www.smsc.com.
+ .
+ . Authors
+ . 	Erik Stahlman				( erik@vt.edu )
+ .	Daris A Nevil				( dnevil@snmc.com )
+ .
+ . History
+ . 03/16/01		Daris A Nevil	Modified for use with LAN91C111 device
+ .
+ ---------------------------------------------------------------------------*/
+#ifndef _SMC911X_H_
+#define _SMC911X_H_
+
+#include <asm/types.h>
+#include <config.h>
+
+/*
+ * This function may be called by the board specific initialisation code
+ * in order to override the default mac address.
+ */
+
+void smc_set_mac_addr(const char *addr);
+
+
+/* I want some simple types */
+
+typedef unsigned char			byte;
+typedef unsigned short			word;
+typedef unsigned long int 		dword;
+
+/*
+ . DEBUGGING LEVELS
+ .
+ . 0 for normal operation
+ . 1 for slightly more details
+ . >2 for various levels of increasingly useless information
+ .    2 for interrupt tracking, status flags
+ .    3 for packet info
+ .    4 for complete packet dumps
+*/
+/*#define SMC_DEBUG 0 */
+
+
+typedef unsigned char BOOLEAN;
+
+#define TRUE	((BOOLEAN)1)
+#define FALSE	((BOOLEAN)0)
+
+#define HIBYTE(w)  ((byte)(((word)(w))>>8))
+#define LOBYTE(w)  ((byte)(((word)(w))&0x00FFU))
+#define HIWORD(dW) ((word)(((dword)(dW))>>16))
+#define LOWORD(dW) ((word)(((dword)(dW))&0x0000FFFFUL))
+
+
+
+#define Lan_GetRegDW(dwOffset) \
+	((*(volatile dword *)(SMC_BASE_ADDRESS+dwOffset)))
+#define Lan_SetRegDW(dwOffset,dwVal) \
+	((*(volatile dword *)(SMC_BASE_ADDRESS+dwOffset))=(dwVal))
+#define Lan_ClrBitsDW(dwOffset,dwBits) \
+	((*(volatile dword *)(SMC_BASE_ADDRESS+dwOffset))&=(~dwBits))
+#define Lan_SetBitsDW(dwOffset,dwBits) \
+	((*(volatile dword *)(SMC_BASE_ADDRESS+dwOffset))|=(dwBits))
+
+
+//Below are the register offsets and bit definitions
+//  of the Lan911x memory space
+#define RX_DATA_FIFO	    (0x00UL)
+
+#define TX_DATA_FIFO        (0x20UL)
+#define		TX_CMD_A_ON_COMP_			(0x80000000UL)
+#define		TX_CMD_A_BUF_END_ALGN_		(0x03000000UL)
+#define		TX_CMD_A_4_BYTE_ALGN_		(0x00000000UL)
+#define		TX_CMD_A_16_BYTE_ALGN_		(0x01000000UL)
+#define		TX_CMD_A_32_BYTE_ALGN_		(0x02000000UL)
+#define		TX_CMD_A_DATA_OFFSET_		(0x001F0000UL)
+#define		TX_CMD_A_FIRST_SEG_			(0x00002000UL)
+#define		TX_CMD_A_LAST_SEG_			(0x00001000UL)
+#define		TX_CMD_A_BUF_SIZE_			(0x000007FFUL)
+#define		TX_CMD_B_PKT_TAG_			(0xFFFF0000UL)
+#define		TX_CMD_B_ADD_CRC_DISABLE_	(0x00002000UL)
+#define		TX_CMD_B_DISABLE_PADDING_	(0x00001000UL)
+#define		TX_CMD_B_PKT_BYTE_LENGTH_	(0x000007FFUL)
+
+#define RX_STATUS_FIFO      (0x40UL)
+#define		RX_STS_ES_			(0x00008000UL)
+#define		RX_STS_MCAST_		(0x00000400UL)
+#define RX_STATUS_FIFO_PEEK (0x44UL)
+#define TX_STATUS_FIFO		(0x48UL)
+#define TX_STATUS_FIFO_PEEK (0x4CUL)
+#define ID_REV              (0x50UL)
+#define		ID_REV_CHIP_ID_		(0xFFFF0000UL)	// RO
+#define		ID_REV_REV_ID_		(0x0000FFFFUL)	// RO
+
+#define INT_CFG				(0x54UL)
+#define		INT_CFG_INT_DEAS_		(0xFF000000UL)	// R/W
+#define     INT_CFG_INT_DEAS_CLR_	(0x00004000UL)  // SC
+#define     INT_CFG_INT_DEAS_STS_	(0x00002000UL)  // SC
+#define		INT_CFG_IRQ_INT_		(0x00001000UL)	// RO
+#define		INT_CFG_IRQ_EN_			(0x00000100UL)	// R/W
+#define		INT_CFG_IRQ_POL_		(0x00000010UL)	// R/W Not Affected by SW Reset
+#define		INT_CFG_IRQ_TYPE_		(0x00000001UL)	// R/W Not Affected by SW Reset
+
+#define INT_STS				(0x58UL)
+#define		INT_STS_SW_INT_		(0x80000000UL)	// R/WC
+#define		INT_STS_TXSTOP_INT_	(0x02000000UL)	// R/WC
+#define		INT_STS_RXSTOP_INT_	(0x01000000UL)	// R/WC
+#define		INT_STS_RXDFH_INT_	(0x00800000UL)	// R/WC
+#define		INT_STS_RXDF_INT_	(0x00400000UL)	// R/WC
+#define		INT_STS_TX_IOC_		(0x00200000UL)	// R/WC
+#define		INT_STS_RXD_INT_	(0x00100000UL)	// R/WC
+#define		INT_STS_GPT_INT_	(0x00080000UL)	// R/WC
+#define		INT_STS_PHY_INT_	(0x00040000UL)	// RO
+#define		INT_STS_PME_INT_	(0x00020000UL)	// R/WC
+#define		INT_STS_TXSO_		(0x00010000UL)	// R/WC
+#define		INT_STS_RWT_		(0x00008000UL)	// R/WC
+#define		INT_STS_RXE_		(0x00004000UL)	// R/WC
+#define		INT_STS_TXE_		(0x00002000UL)	// R/WC
+#define		INT_STS_TDFU_		(0x00000800UL)	// R/WC
+#define		INT_STS_TDFO_		(0x00000400UL)	// R/WC
+#define		INT_STS_TDFA_		(0x00000200UL)	// R/WC
+#define		INT_STS_TSFF_		(0x00000100UL)	// R/WC
+#define		INT_STS_TSFL_		(0x00000080UL)	// R/WC
+#define		INT_STS_RXDF_		(0x00000040UL)	// R/WC
+#define		INT_STS_RDFL_		(0x00000020UL)	// R/WC
+#define		INT_STS_RSFF_		(0x00000010UL)	// R/WC
+#define		INT_STS_RSFL_		(0x00000008UL)	// R/WC
+#define		INT_STS_GPIO2_INT_	(0x00000004UL)	// R/WC
+#define		INT_STS_GPIO1_INT_	(0x00000002UL)	// R/WC
+#define		INT_STS_GPIO0_INT_	(0x00000001UL)	// R/WC
+
+#define INT_EN				(0x5CUL)
+#define		INT_EN_SW_INT_EN_		(0x80000000UL)	// R/W
+#define		INT_EN_TXSTOP_INT_EN_	(0x02000000UL)	// R/W
+#define		INT_EN_RXSTOP_INT_EN_	(0x01000000UL)	// R/W
+#define		INT_EN_RXDFH_INT_EN_	(0x00800000UL)	// R/W
+#define		INT_EN_TIOC_INT_EN_		(0x00200000UL)	// R/W
+#define		INT_EN_RXD_INT_EN_		(0x00100000UL)	// R/W
+#define		INT_EN_GPT_INT_EN_		(0x00080000UL)	// R/W
+#define		INT_EN_PHY_INT_EN_		(0x00040000UL)	// R/W
+#define		INT_EN_PME_INT_EN_		(0x00020000UL)	// R/W
+#define		INT_EN_TXSO_EN_			(0x00010000UL)	// R/W
+#define		INT_EN_RWT_EN_			(0x00008000UL)	// R/W
+#define		INT_EN_RXE_EN_			(0x00004000UL)	// R/W
+#define		INT_EN_TXE_EN_			(0x00002000UL)	// R/W
+#define		INT_EN_TDFU_EN_			(0x00000800UL)	// R/W
+#define		INT_EN_TDFO_EN_			(0x00000400UL)	// R/W
+#define		INT_EN_TDFA_EN_			(0x00000200UL)	// R/W
+#define		INT_EN_TSFF_EN_			(0x00000100UL)	// R/W
+#define		INT_EN_TSFL_EN_			(0x00000080UL)	// R/W
+#define		INT_EN_RXDF_EN_			(0x00000040UL)	// R/W
+#define		INT_EN_RDFL_EN_			(0x00000020UL)	// R/W
+#define		INT_EN_RSFF_EN_			(0x00000010UL)	// R/W
+#define		INT_EN_RSFL_EN_			(0x00000008UL)	// R/W
+#define		INT_EN_GPIO2_INT_		(0x00000004UL)	// R/W
+#define		INT_EN_GPIO1_INT_		(0x00000002UL)	// R/W
+#define		INT_EN_GPIO0_INT_		(0x00000001UL)	// R/W
+
+#define BYTE_TEST				(0x64UL)
+#define FIFO_INT				(0x68UL)
+#define		FIFO_INT_TX_AVAIL_LEVEL_	(0xFF000000UL)	// R/W
+#define		FIFO_INT_TX_STS_LEVEL_		(0x00FF0000UL)	// R/W
+#define		FIFO_INT_RX_AVAIL_LEVEL_	(0x0000FF00UL)	// R/W
+#define		FIFO_INT_RX_STS_LEVEL_		(0x000000FFUL)	// R/W
+
+#define RX_CFG					(0x6CUL)
+#define		RX_CFG_RX_END_ALGN_		(0xC0000000UL)	// R/W
+#define			RX_CFG_RX_END_ALGN4_		(0x00000000UL)	// R/W
+#define			RX_CFG_RX_END_ALGN16_		(0x40000000UL)	// R/W
+#define			RX_CFG_RX_END_ALGN32_		(0x80000000UL)	// R/W
+#define		RX_CFG_RX_DMA_CNT_		(0x0FFF0000UL)	// R/W
+#define		RX_CFG_RX_DUMP_			(0x00008000UL)	// R/W
+#define		RX_CFG_RXDOFF_			(0x00001F00UL)	// R/W
+
+#define TX_CFG					(0x70UL)
+#define		TX_CFG_TXS_DUMP_		(0x00008000UL)	// Self Clearing
+#define		TX_CFG_TXD_DUMP_		(0x00004000UL)	// Self Clearing
+#define		TX_CFG_TXSAO_			(0x00000004UL)	// R/W
+#define		TX_CFG_TX_ON_			(0x00000002UL)	// R/W
+#define		TX_CFG_STOP_TX_			(0x00000001UL)	// Self Clearing
+
+#define HW_CFG					(0x74UL)
+#define		HW_CFG_TTM_				(0x00200000UL)	// R/W
+#define		HW_CFG_SF_				(0x00100000UL)	// R/W
+#define		HW_CFG_TX_FIF_SZ_		(0x000F0000UL)	// R/W
+#define		HW_CFG_TR_				(0x00003000UL)	// R/W
+#define     HW_CFG_PHY_CLK_SEL_		(0x00000060UL)  // R/W //only available on 115/117
+#define         HW_CFG_PHY_CLK_SEL_INT_PHY_	(0x00000000UL) //R/W //only available on 115/117
+#define         HW_CFG_PHY_CLK_SEL_EXT_PHY_	(0x00000020UL) //R/W //only available on 115/117
+#define         HW_CFG_PHY_CLK_SEL_CLK_DIS_	(0x00000040UL) //R/W //only available on 115/117
+#define     HW_CFG_SMI_SEL_			(0x00000010UL)  // R/W //only available on 115/117
+#define     HW_CFG_EXT_PHY_DET_		(0x00000008UL)  // RO  //only available on 115/117
+#define     HW_CFG_EXT_PHY_EN_		(0x00000004UL)  // R/W //only available on 115/117
+#define		HW_CFG_32_16_BIT_MODE_	(0x00000004UL)	// RO  //only available on 116/118
+#define     HW_CFG_SRST_TO_			(0x00000002UL)  // RO  //only available on 115/117
+#define		HW_CFG_SRST_			(0x00000001UL)	// Self Clearing
+
+#define RX_DP_CTRL				(0x78UL)
+#define		RX_DP_CTRL_RX_FFWD_		(0x80000000UL)	// RO
+
+#define RX_FIFO_INF				(0x7CUL)
+#define		RX_FIFO_INF_RXSUSED_	(0x00FF0000UL)	// RO
+#define		RX_FIFO_INF_RXDUSED_	(0x0000FFFFUL)	// RO
+
+#define TX_FIFO_INF				(0x80UL)
+#define		TX_FIFO_INF_TSUSED_		(0x00FF0000UL)  // RO
+#define		TX_FIFO_INF_TDFREE_		(0x0000FFFFUL)	// RO
+
+#define PMT_CTRL				(0x84UL)
+#define		PMT_CTRL_PM_MODE_			(0x00003000UL)	// Self Clearing
+#define	        PMT_CTRL_PM_MODE_D0_	(0x00000000UL)  // Self Clearing
+#define         PMT_CTRL_PM_MODE_D1_	(0x00001000UL)  // Self Clearing
+#define         PMT_CTRL_PM_MODE_D2_	(0x00002000UL)  // Self Clearing
+#define         PMT_CTRL_PM_MODE_D3_	(0x00003000UL)  // Self Clearing
+#define		PMT_CTRL_PHY_RST_			(0x00000400UL)	// Self Clearing
+#define		PMT_CTRL_WOL_EN_			(0x00000200UL)	// R/W
+#define		PMT_CTRL_ED_EN_				(0x00000100UL)	// R/W
+#define		PMT_CTRL_PME_TYPE_			(0x00000040UL)	// R/W Not Affected by SW Reset
+#define		PMT_CTRL_WUPS_				(0x00000030UL)	// R/WC
+#define			PMT_CTRL_WUPS_NOWAKE_		(0x00000000UL)	// R/WC
+#define			PMT_CTRL_WUPS_ED_			(0x00000010UL)	// R/WC
+#define			PMT_CTRL_WUPS_WOL_			(0x00000020UL)	// R/WC
+#define			PMT_CTRL_WUPS_MULTI_		(0x00000030UL)	// R/WC
+#define		PMT_CTRL_PME_IND_		(0x00000008UL)	// R/W
+#define		PMT_CTRL_PME_POL_		(0x00000004UL)	// R/W
+#define		PMT_CTRL_PME_EN_		(0x00000002UL)	// R/W Not Affected by SW Reset
+#define		PMT_CTRL_READY_			(0x00000001UL)	// RO
+
+#define GPIO_CFG				(0x88UL)
+#define		GPIO_CFG_LED3_EN_		(0x40000000UL)	// R/W
+#define		GPIO_CFG_LED2_EN_		(0x20000000UL)	// R/W
+#define		GPIO_CFG_LED1_EN_		(0x10000000UL)	// R/W
+#define		GPIO_CFG_GPIO2_INT_POL_	(0x04000000UL)	// R/W
+#define		GPIO_CFG_GPIO1_INT_POL_	(0x02000000UL)	// R/W
+#define		GPIO_CFG_GPIO0_INT_POL_	(0x01000000UL)	// R/W
+#define		GPIO_CFG_EEPR_EN_		(0x00700000UL)	// R/W
+#define		GPIO_CFG_GPIOBUF2_		(0x00040000UL)	// R/W
+#define		GPIO_CFG_GPIOBUF1_		(0x00020000UL)	// R/W
+#define		GPIO_CFG_GPIOBUF0_		(0x00010000UL)	// R/W
+#define		GPIO_CFG_GPIODIR2_		(0x00000400UL)	// R/W
+#define		GPIO_CFG_GPIODIR1_		(0x00000200UL)	// R/W
+#define		GPIO_CFG_GPIODIR0_		(0x00000100UL)	// R/W
+#define		GPIO_CFG_GPIOD4_		(0x00000020UL)	// R/W
+#define		GPIO_CFG_GPIOD3_		(0x00000010UL)	// R/W
+#define		GPIO_CFG_GPIOD2_		(0x00000004UL)	// R/W
+#define		GPIO_CFG_GPIOD1_		(0x00000002UL)	// R/W
+#define		GPIO_CFG_GPIOD0_		(0x00000001UL)	// R/W
+
+#define GPT_CFG					(0x8CUL)
+#define		GPT_CFG_TIMER_EN_		(0x20000000UL)	// R/W
+#define		GPT_CFG_GPT_LOAD_		(0x0000FFFFUL)	// R/W
+
+#define GPT_CNT					(0x90UL)
+#define		GPT_CNT_GPT_CNT_		(0x0000FFFFUL)	// RO
+
+#define ENDIAN					(0x98UL)
+#define FREE_RUN				(0x9CUL)
+#define RX_DROP					(0xA0UL)
+#define MAC_CSR_CMD				(0xA4UL)
+#define		MAC_CSR_CMD_CSR_BUSY_	(0x80000000UL)	// Self Clearing
+#define		MAC_CSR_CMD_R_NOT_W_	(0x40000000UL)	// R/W
+#define		MAC_CSR_CMD_CSR_ADDR_	(0x000000FFUL)	// R/W
+
+#define MAC_CSR_DATA			(0xA8UL)
+#define AFC_CFG					(0xACUL)
+#define		AFC_CFG_AFC_HI_			(0x00FF0000UL)	// R/W
+#define		AFC_CFG_AFC_LO_			(0x0000FF00UL)	// R/W
+#define		AFC_CFG_BACK_DUR_		(0x000000F0UL)	// R/W
+#define		AFC_CFG_FCMULT_			(0x00000008UL)	// R/W
+#define		AFC_CFG_FCBRD_			(0x00000004UL)	// R/W
+#define		AFC_CFG_FCADD_			(0x00000002UL)	// R/W
+#define		AFC_CFG_FCANY_			(0x00000001UL)	// R/W
+
+#define E2P_CMD					(0xB0UL)
+#define		E2P_CMD_EPC_BUSY_		(0x80000000UL)	// Self Clearing
+#define		E2P_CMD_EPC_CMD_		(0x70000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_READ_	(0x00000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_EWDS_	(0x10000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_EWEN_	(0x20000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_WRITE_	(0x30000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_WRAL_	(0x40000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_ERASE_	(0x50000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_ERAL_	(0x60000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_RELOAD_	(0x70000000UL)  // R/W
+#define		E2P_CMD_EPC_TIMEOUT_	(0x00000200UL)	// R
+#define		E2P_CMD_MAC_ADDR_LOADED_	(0x00000100UL)	// RO
+#define		E2P_CMD_EPC_ADDR_		(0x000000FFUL)	// R/W
+
+#define E2P_DATA				(0xB4UL)
+#define		E2P_DATA_EEPROM_DATA_	(0x000000FFUL)	// R/W
+//end of lan register offsets and bit definitions
+#define LAN_REGISTER_EXTENT		(0x00000100UL)
+
+#define LINK_OFF				(0x00UL)
+#define LINK_SPEED_10HD			(0x01UL)
+#define LINK_SPEED_10FD			(0x02UL)
+#define LINK_SPEED_100HD		(0x04UL)
+#define LINK_SPEED_100FD		(0x08UL)
+#define LINK_SYMMETRIC_PAUSE	(0x10UL)
+#define LINK_ASYMMETRIC_PAUSE	(0x20UL)
+#define LINK_AUTO_NEGOTIATE		(0x40UL)
+
+
+
+/*
+ ****************************************************************************
+ ****************************************************************************
+ *	MAC Control and Status Register (Indirect Address)
+ *	Offset (through the MAC_CSR CMD and DATA port)
+ ****************************************************************************
+ ****************************************************************************
+ *
+ */
+#define MAC_CR				(0x01UL)	// R/W
+
+	/* MAC_CR - MAC Control Register */
+	#define MAC_CR_RXALL_		(0x80000000UL)
+	#define MAC_CR_HBDIS_		(0x10000000UL)
+	#define MAC_CR_RCVOWN_		(0x00800000UL)
+	#define MAC_CR_LOOPBK_		(0x00200000UL)
+	#define MAC_CR_FDPX_		(0x00100000UL)
+	#define MAC_CR_MCPAS_		(0x00080000UL)
+	#define MAC_CR_PRMS_		(0x00040000UL)
+	#define MAC_CR_INVFILT_		(0x00020000UL)
+	#define MAC_CR_PASSBAD_		(0x00010000UL)
+	#define MAC_CR_HFILT_		(0x00008000UL)
+	#define MAC_CR_HPFILT_		(0x00002000UL)
+	#define MAC_CR_LCOLL_		(0x00001000UL)
+	#define MAC_CR_BCAST_		(0x00000800UL)
+	#define MAC_CR_DISRTY_		(0x00000400UL)
+	#define MAC_CR_PADSTR_		(0x00000100UL)
+	#define MAC_CR_BOLMT_MASK_	(0x000000C0UL)
+	#define MAC_CR_DFCHK_		(0x00000020UL)
+	#define MAC_CR_TXEN_		(0x00000008UL)
+	#define MAC_CR_RXEN_		(0x00000004UL)
+
+#define ADDRH				(0x02UL)	// R/W mask 0x0000FFFFUL
+#define ADDRL				(0x03UL)	// R/W mask 0xFFFFFFFFUL
+#define HASHH				(0x04UL)	// R/W
+#define HASHL				(0x05UL)	// R/W
+
+#define MII_ACC				(0x06UL)	// R/W
+	#define MII_ACC_PHY_ADDR_	(0x0000F800UL)
+	#define MII_ACC_MIIRINDA_	(0x000007C0UL)
+	#define MII_ACC_MII_WRITE_	(0x00000002UL)
+	#define MII_ACC_MII_BUSY_	(0x00000001UL)
+
+#define MII_DATA			(0x07UL)	// R/W mask 0x0000FFFFUL
+
+#define FLOW				(0x08UL)	// R/W
+	#define FLOW_FCPT_			(0xFFFF0000UL)
+	#define FLOW_FCPASS_		(0x00000004UL)
+	#define FLOW_FCEN_			(0x00000002UL)
+	#define FLOW_FCBSY_			(0x00000001UL)
+
+#define VLAN1				(0x09UL)	// R/W mask 0x0000FFFFUL
+#define VLAN2				(0x0AUL)	// R/W mask 0x0000FFFFUL
+
+#define WUFF				(0x0BUL)	// WO
+
+#define WUCSR				(0x0CUL)	// R/W
+	#define WUCSR_GUE_			(0x00000200UL)
+	#define WUCSR_WUFR_			(0x00000040UL)
+	#define WUCSR_MPR_			(0x00000020UL)
+	#define WUCSR_WAKE_EN_		(0x00000004UL)
+	#define WUCSR_MPEN_			(0x00000002UL)
+
+
+/*
+ ****************************************************************************
+ *	Chip Specific MII Defines
+ ****************************************************************************
+ *
+ *	Phy register offsets and bit definitions
+ *
+ */
+#define LAN9118_PHY_ID	(0x00C0001C)
+
+#define PHY_BCR		((dword)0U)
+#define PHY_BCR_RESET_					((word)0x8000U)
+#define PHY_BCR_SPEED_SELECT_		((word)0x2000U)
+#define PHY_BCR_AUTO_NEG_ENABLE_	((word)0x1000U)
+#define PHY_BCR_RESTART_AUTO_NEG_	((word)0x0200U)
+#define PHY_BCR_DUPLEX_MODE_		((word)0x0100U)
+
+#define PHY_BSR		((dword)1U)
+	#define PHY_BSR_LINK_STATUS_	((word)0x0004U)
+	#define PHY_BSR_REMOTE_FAULT_	((word)0x0010U)
+	#define PHY_BSR_AUTO_NEG_COMP_	((word)0x0020U)
+
+#define PHY_ID_1	((dword)2U)
+#define PHY_ID_2	((dword)3U)
+
+#define PHY_ANEG_ADV    ((dword)4U)
+#define PHY_ANEG_ADV_PAUSE_ ((word)0x0C00)
+#define PHY_ANEG_ADV_ASYMP_	((word)0x0800)
+#define PHY_ANEG_ADV_SYMP_	((word)0x0400)
+#define PHY_ANEG_ADV_10H_	((word)0x020)
+#define PHY_ANEG_ADV_10F_	((word)0x040)
+#define PHY_ANEG_ADV_100H_	((word)0x080)
+#define PHY_ANEG_ADV_100F_	((word)0x100)
+#define PHY_ANEG_ADV_SPEED_	((word)0x1E0)
+
+#define PHY_ANEG_LPA	((dword)5U)
+#define PHY_ANEG_LPA_ASYMP_		((word)0x0800)
+#define PHY_ANEG_LPA_SYMP_		((word)0x0400)
+#define PHY_ANEG_LPA_100FDX_	((word)0x0100)
+#define PHY_ANEG_LPA_100HDX_	((word)0x0080)
+#define PHY_ANEG_LPA_10FDX_		((word)0x0040)
+#define PHY_ANEG_LPA_10HDX_		((word)0x0020)
+
+#define PHY_MODE_CTRL_STS		((dword)17)	// Mode Control/Status Register
+	#define MODE_CTRL_STS_EDPWRDOWN_	((word)0x2000U)
+	#define MODE_CTRL_STS_ENERGYON_		((word)0x0002U)
+
+#define PHY_INT_SRC			((dword)29)
+#define PHY_INT_SRC_ENERGY_ON_			((word)0x0080U)
+#define PHY_INT_SRC_ANEG_COMP_			((word)0x0040U)
+#define PHY_INT_SRC_REMOTE_FAULT_		((word)0x0020U)
+#define PHY_INT_SRC_LINK_DOWN_			((word)0x0010U)
+
+#define PHY_INT_MASK		((dword)30)
+#define PHY_INT_MASK_ENERGY_ON_		((word)0x0080U)
+#define PHY_INT_MASK_ANEG_COMP_		((word)0x0040U)
+#define PHY_INT_MASK_REMOTE_FAULT_	((word)0x0020U)
+#define PHY_INT_MASK_LINK_DOWN_		((word)0x0010U)
+
+#define PHY_SPECIAL			((dword)31)
+#define PHY_SPECIAL_SPD_	((word)0x001CU)
+#define PHY_SPECIAL_SPD_10HALF_		((word)0x0004U)
+#define PHY_SPECIAL_SPD_10FULL_		((word)0x0014U)
+#define PHY_SPECIAL_SPD_100HALF_	((word)0x0008U)
+#define PHY_SPECIAL_SPD_100FULL_	((word)0x0018U)
+
+#define LINK_OFF				(0x00UL)
+#define LINK_SPEED_10HD			(0x01UL)
+#define LINK_SPEED_10FD			(0x02UL)
+#define LINK_SPEED_100HD		(0x04UL)
+#define LINK_SPEED_100FD		(0x08UL)
+#define LINK_SYMMETRIC_PAUSE	(0x10UL)
+#define LINK_ASYMMETRIC_PAUSE	(0x20UL)
+#define LINK_AUTO_NEGOTIATE		(0x40UL)
+
+/*-------------------------------------------------------------------------
+ .  I define some macros to make it easier to do somewhat common
+ . or slightly complicated, repeated tasks.
+ --------------------------------------------------------------------------*/
+
+/* this enables an interrupt in the interrupt mask register */
+#define SMC_ENABLE_INT(x) {;}
+
+/* this disables an interrupt from the interrupt mask register */
+
+#define SMC_DISABLE_INT(x) {;}
+
+#define TX_FIFO_LOW_THRESHOLD	(1600)
+
+#endif  /* _SMC_911X_H_ */
diff --git a/drivers/net/stm-stmac.c b/drivers/net/stm-stmac.c
new file mode 100644
index 0000000..0668b64
--- /dev/null
+++ b/drivers/net/stm-stmac.c
@@ -0,0 +1,1059 @@
+/*
+ *  Copyright (c) 2006  STMicroelectronics Limited
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * author(s): Andy Sturges (andy.sturges@st.com)
+ */
+
+#include <common.h>
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+
+#include <command.h>
+#include <asm/addrspace.h>
+#include <asm/io.h>
+#include <net.h>
+#include <malloc.h>
+#include <miiphy.h>
+#include "stm-stmac.h"
+
+#if defined(CONFIG_CMD_NET)
+
+/* #define DEBUG */
+
+#ifdef DEBUG
+#define PRINTK(args...) printf(args)
+#else
+#define PRINTK(args...)
+#endif
+
+/* This structure is common for both receive and transmit DMA descriptors.
+ * A descriptor should not be used for storing more than one frame. */
+struct stmac_dma_des_t
+{
+	unsigned int des0;	/* Status */
+	unsigned int des1;	/* Ctrl bits, Buffer 2 length, Buffer 1 length */
+	void *des2;		/* Buffer 1 Address Pointer */
+	void *des3;		/* Buffer 2 Address Pointer or the next Descriptor */
+};
+
+typedef struct stmac_dma_des_t stmac_dma_des;
+
+/* Use single dma descriptors */
+
+#define CONFIG_DMA_RX_SIZE 8
+#define CONFIG_DMA_TX_SIZE 1	/* Only ever use 1 tx buffer */
+
+static volatile stmac_dma_des *dma_tx;
+static volatile stmac_dma_des *dma_rx;
+static int cur_rx;
+static int eth_phy_addr;
+static char miidevice[] = "stmacphy";
+
+#define MAX_ETH_FRAME_SIZE      1536
+#define MAX_PAUSE_TIME (MAC_FLOW_CONTROL_PT_MASK>>MAC_FLOW_CONTROL_PT_SHIFT)
+
+static void stmac_mii_write (int phy_addr, int reg, int value);
+static unsigned int stmac_mii_read (int phy_addr, int reg);
+static void stmac_set_mac_mii_cap (int full_duplex, unsigned int speed);
+
+/* DMA structure */
+
+struct dma_t
+{
+	uchar _dummy1[L1_CACHE_BYTES];
+	stmac_dma_des desc_rx[CONFIG_DMA_RX_SIZE];
+	stmac_dma_des desc_tx[CONFIG_DMA_TX_SIZE];
+	uchar rx_buff[CONFIG_DMA_RX_SIZE * (PKTSIZE_ALIGN)];
+	uchar _dummy2[L1_CACHE_BYTES];
+} dma;
+
+static uchar *rx_packets[CONFIG_DMA_RX_SIZE];
+
+extern int stmac_default_pbl(void);
+
+/* ----------------------------------------------------------------------------
+				 Phy interface
+   ---------------------------------------------------------------------------*/
+
+#if defined(CONFIG_STMAC_STE10XP)	/* ST STE10xP */
+
+/* STE101P phy identifier values */
+#define STE100P_PHY_HI_ID       0x1c04
+#define STE100P_PHY_LO_ID       0x0011
+
+#define STE101P_PHY_HI_ID       0x0006
+#define STE101P_PHY_LO_ID_REVA  0x1c51
+#define STE101P_PHY_LO_ID_REVB  0x1c52
+
+/******************************************************************************
+ * IEEE Standard 802.3-2002 vendor specific registers (0x10-0x1e) STe10xP
+ *****************************************************************************/
+#define MII_XCIIS                0x11	/* Config info & int status register */
+#define MII_XIE                  0x12	/* Interrupt enable register */
+#define MII_100CTR               0x13	/* 100BaseX control register */
+#define MII_XMC                  0x14	/* Mode control register */
+
+/******************************************************************************
+ * 100BaseX Auxiliary Status register defines
+ *****************************************************************************/
+#define XCIIS_FIFO_OVR           0x0800	/* FIFO Overrun */
+#define XCIIS_SPEED              0x0200	/* Speed */
+#define XCIIS_DUPLEX             0x0100	/* Duplex */
+#define XCIIS_PAUSE              0x0080	/* Pause */
+#define XCIIS_ANEG_INT           0x0040	/* Auto Negotiation Interrupt */
+#define XCIIS_RFAULT             0x0020	/* Remote Fault Interrupt */
+#define XCIIS_LDOWN              0x0010	/* Link Down Interrupt */
+#define XCIIS_LCWR               0x0008	/* Link Code Word Received Interrupt */
+#define XCIIS_PFAULT             0x0004	/* Parallel Detection Fault */
+#define XCIIS_ANEG_PAGE          0x0002	/* Auto Negotiation Page Rec Intr */
+#define XCIIS_REF_INTR           0x0001	/* Ref Interrupt */
+
+/******************************************************************************
+ * XCVR Mode Control register defines
+ *****************************************************************************/
+#define XMC_LDETECT              0x0800	/* Link Detect */
+#define XMC_PHY_ADDR_MSK         0x00f8	/* PHY Address Mask */
+#define XMC_PHY_ADDR_SHIFT       3	/* PHY Address Mask */
+#define XMC_PRE_SUP              0x0002	/* Preamble Suppression */
+
+/* MII mode */
+#define MII_TSTAT_SMII  0x1000
+#define MII_TSTAT_RMII  0x0800
+#define MII_TSTAT_MII   0x0400
+
+#elif defined(CONFIG_STMAC_LAN8700)	/* SMSC LAN8700 */
+
+/* SMSC LAN8700 phy identifier values */
+#define LAN8700_PHY_HI_ID       0x0007
+#define LAN8700_PHY_LO_ID       0xc0c3
+
+#define	SPECIAL_MODE_REG	0x12		/* Special Modes Register */
+#define	PHY_ADDR_MSK		0x001f		/* PHY Address Mask */
+#define	PHY_ADDR_SHIFT		0		/* PHY Address Mask */
+
+#else
+#error Need to define PHY
+#endif
+
+
+/* MII mode */
+#define MII_ADVERTISE_PAUSE 0x0400	/* supports the pause command */
+
+
+static int stmac_phy_negotiate (int phy_addr)
+{
+	uint now, tmp, status;
+
+	status = 0;
+
+	tmp = stmac_mii_read (phy_addr, MII_BMCR);
+	tmp |= (BMCR_ANENABLE | BMCR_ANRESTART);
+	stmac_mii_write (phy_addr, MII_BMCR, tmp);
+
+	now = get_timer (0);
+	while (get_timer (now) < CONFIG_STMAC_AUTONEG_TIMEOUT) {
+		status = stmac_mii_read (phy_addr, MII_BMSR);
+		if (status & BMSR_ANEGCOMPLETE) {
+			break;
+		}
+
+		/* Restart auto-negotiation if remote fault */
+		if (status & BMSR_RFAULT) {
+			printf ("PHY remote fault detected\n");
+			/* Restart auto-negotiation */
+			printf ("PHY restarting auto-negotiation\n");
+			stmac_mii_write (phy_addr, MII_BMCR,
+					 BMCR_ANENABLE | BMCR_ANRESTART);
+		}
+	}
+
+	if (!(status & BMSR_ANEGCOMPLETE)) {
+		printf ("PHY auto-negotiate timed out\n");
+	}
+
+	if (status & BMSR_RFAULT) {
+		printf ("PHY remote fault detected\n");
+	}
+
+	return (1);
+}
+
+static unsigned int stmac_phy_check_speed (int phy_addr)
+{
+	unsigned int status;
+	int full_duplex = 0;
+	int speed = 0;
+
+	/* Read Status register */
+	status = stmac_mii_read (phy_addr, MII_BMSR);
+
+	printf ("STMAC: ");
+
+	/* Check link status.  If 0, default to 100 Mbps. */
+	if ((status & BMSR_LSTATUS) == 0) {
+		printf ("*Warning* no link detected\n");
+		return 1;
+	} else {
+		int negotiated = stmac_mii_read (phy_addr, MII_LPA);
+
+		if (negotiated & LPA_100FULL) {
+			printf ("100Mbs full duplex link detected\n");
+			full_duplex = 1;
+			speed = 100;
+		} else if (negotiated & LPA_100HALF) {
+			printf ("100Mbs half duplex link detected\n");
+			full_duplex = 0;
+			speed = 100;
+		} else if (negotiated & LPA_10FULL) {
+			printf ("10Mbs full duplex link detected\n");
+			full_duplex = 1;
+			speed = 10;
+		} else {
+			printf ("10Mbs half duplex link detected\n");
+			full_duplex = 0;
+			speed = 10;
+		}
+	}
+	stmac_set_mac_mii_cap (full_duplex, speed);
+	return 0;
+}
+
+/* Automatically gets and returns the PHY device */
+static unsigned int stmac_phy_get_addr (void)
+{
+	int i, phyaddr;
+
+	uint stmac_phy_id = 0;
+
+	for (i = 0; i < 32; i++) {
+		unsigned int id1, id2;
+		phyaddr = (i + 1) % 32;
+
+		id1 = stmac_mii_read (phyaddr, MII_PHYSID1);
+		id2 = stmac_mii_read (phyaddr, MII_PHYSID2);
+
+		/* Make sure it is a valid identifier */
+#if defined(CONFIG_STMAC_STE10XP)
+		if ((id1 == STE101P_PHY_HI_ID) &&
+		    ((id2 == STE101P_PHY_LO_ID_REVB) ||
+		     (id2 == STE101P_PHY_LO_ID_REVA))) {
+			stmac_phy_id = id1;
+			printf ("STMAC: STE101P found\n");
+		} else if ((id1 == STE100P_PHY_HI_ID) &&
+			   (id2 == STE100P_PHY_LO_ID)) {
+			stmac_phy_id = id1;
+			printf ("STMAC: STE100P found\n");
+		}
+#elif defined(CONFIG_STMAC_LAN8700)
+		if ((id1 == LAN8700_PHY_HI_ID) &&
+		    (id2 == LAN8700_PHY_LO_ID)) {
+			stmac_phy_id = id1;
+			printf ("STMAC: SMSC LAN8700 found\n");
+		}
+#endif	/* CONFIG_STMAC_LAN8700 */
+
+		if (stmac_phy_id)
+			return phyaddr;
+	}
+	return (-1);
+}
+
+static int stmac_phy_init (void)
+{
+	uint advertised_caps, value;
+
+	/* Obtain the PHY's address/id */
+	eth_phy_addr = stmac_phy_get_addr ();
+	if (eth_phy_addr < 0)
+		return -1;
+
+	/* Now reset the PHY we just found */
+	if (miiphy_reset (miidevice, eth_phy_addr)< 0) {
+		PRINTK ("PHY reset failed!");
+		return -1;
+	}
+
+	/* test for H/W address disagreement with the assigned address */
+#if defined(CONFIG_STMAC_STE10XP)
+	value = stmac_mii_read (eth_phy_addr, MII_XMC);
+	value = (value & XMC_PHY_ADDR_MSK) >> XMC_PHY_ADDR_SHIFT;
+#elif defined(CONFIG_STMAC_LAN8700)
+	value = stmac_mii_read (eth_phy_addr, SPECIAL_MODE_REG);
+	value = (value & PHY_ADDR_MSK) >> PHY_ADDR_SHIFT;
+#else
+#error Need to define PHY
+#endif
+	if (value != eth_phy_addr) {
+		printf ("PHY address mismatch with hardware (hw %d != %d)\n",
+			value,
+			eth_phy_addr);
+	}
+
+	/* Read the ANE Advertisement register */
+	advertised_caps = stmac_mii_read (eth_phy_addr, MII_ADVERTISE);
+
+	/* Copy our capabilities from MII_BMSR to MII_ADVERTISE */
+	value = stmac_mii_read (eth_phy_addr, MII_BMSR);
+
+	/* Set the advertised capabilities */
+	if (value & BMSR_100BASE4)
+		advertised_caps |= ADVERTISE_100BASE4;
+	if (value & BMSR_100FULL)
+		advertised_caps |= ADVERTISE_100FULL;
+	if (value & BMSR_100HALF)
+		advertised_caps |= ADVERTISE_100HALF;
+	if (value & BMSR_10FULL)
+		advertised_caps |= ADVERTISE_10FULL;
+	if (value & BMSR_10HALF)
+		advertised_caps |= ADVERTISE_10HALF;
+
+#ifdef CONFIG_STMAC_FLOWCTRL
+	advertised_caps |= MII_ADVERTISE_PAUSE;
+#else
+	advertised_caps &= ~MII_ADVERTISE_PAUSE;
+#endif
+
+	/* Update our Auto-Neg Advertisement Register */
+	stmac_mii_write (eth_phy_addr, MII_ADVERTISE, advertised_caps);
+
+	stmac_phy_negotiate (eth_phy_addr);
+	stmac_phy_check_speed (eth_phy_addr);
+
+	return 0;
+}
+
+
+/* ----------------------------------------------------------------------------
+				 MII Interface
+   ---------------------------------------------------------------------------*/
+
+static int stmac_mii_poll_busy (void)
+{
+	/* arm simple, non interrupt dependent timer */
+	ulong now = get_timer (0);
+	while (get_timer (now) < CONFIG_STMAC_MII_POLL_BUSY_DELAY) {
+		if (!(STMAC_READ (MAC_MII_ADDR) & MAC_MII_ADDR_BUSY)) {
+			return 1;
+		}
+	}
+	printf ("stmac_mii_busy timeout\n");
+	return (0);
+}
+
+static void stmac_mii_write (int phy_addr, int reg, int value)
+{
+	int mii_addr;
+
+	/* Select register */
+	mii_addr =
+		((phy_addr & MAC_MII_ADDR_PHY_MASK) << MAC_MII_ADDR_PHY_SHIFT)
+		| ((reg & MAC_MII_ADDR_REG_MASK) << MAC_MII_ADDR_REG_SHIFT) |
+		MAC_MII_ADDR_WRITE;
+
+	stmac_mii_poll_busy ();
+
+	/* Set the MII address register to write */
+	STMAC_WRITE (mii_addr, MAC_MII_DATA);
+	STMAC_WRITE (value, MAC_MII_ADDR);
+
+	stmac_mii_poll_busy ();
+
+	(void) stmac_mii_read (phy_addr, reg);
+}
+
+static unsigned int stmac_mii_read (int phy_addr, int reg)
+{
+	int mii_addr, val;
+
+	mii_addr =
+		((phy_addr & MAC_MII_ADDR_PHY_MASK) << MAC_MII_ADDR_PHY_SHIFT)
+		| ((reg & MAC_MII_ADDR_REG_MASK) << MAC_MII_ADDR_REG_SHIFT);
+
+	/* Select register */
+	stmac_mii_poll_busy ();
+
+	STMAC_WRITE (mii_addr, MAC_MII_ADDR);
+
+	stmac_mii_poll_busy ();
+
+	/* Return read value */
+	val = STMAC_READ (MAC_MII_DATA);
+	return val;
+}
+
+/* define external interface to mii, through miiphy_register() */
+static int stmac_miiphy_read (char *devname, unsigned char addr, unsigned char reg, unsigned short *value)
+{
+	*value = stmac_mii_read (addr, reg);
+	return 0;
+}
+
+static int stmac_miiphy_write (char *devname, unsigned char addr, unsigned char reg, unsigned short value)
+{
+	stmac_mii_write (addr, reg, value);
+	return 0;
+}
+
+/* ----------------------------------------------------------------------------
+				 MAC CORE Interface
+   ---------------------------------------------------------------------------*/
+
+static void stmac_set_mac_addr (unsigned char *Addr)
+{
+	unsigned long data;
+
+	data = (Addr[5] << 8) | Addr[4];
+	STMAC_WRITE (data, MAC_ADDR_HIGH);
+	data = (Addr[3] << 24) | (Addr[2] << 16) | (Addr[1] << 8) | Addr[0];
+	STMAC_WRITE (data, MAC_ADDR_LOW);
+
+	return;
+}
+
+static int stmac_get_mac_addr (unsigned char *addr)
+{
+	unsigned int hi_addr, lo_addr;
+
+	/* Read the MAC address from the hardware */
+	hi_addr = (unsigned int) STMAC_READ (MAC_ADDR_HIGH);
+	lo_addr = (unsigned int) STMAC_READ (MAC_ADDR_LOW);
+
+	if ((hi_addr == 0x0000FFFFUL) && (lo_addr == 0xFFFFFFFF))
+		return 0;
+
+	/* Extract the MAC address from the high and low words */
+	addr[0] = lo_addr & 0xffu;
+	addr[1] = (lo_addr >> 8) & 0xffu;
+	addr[2] = (lo_addr >> 16) & 0xffu;
+	addr[3] = (lo_addr >> 24) & 0xffu;
+	addr[4] = hi_addr & 0xffu;
+	addr[5] = (hi_addr >> 8) & 0xffu;
+
+	return 1;
+}
+
+static void stmac_mac_enable (void)
+{
+	unsigned int value = (unsigned int) STMAC_READ (MAC_CONTROL);
+
+	PRINTK ("MAC RX/TX enabled\n");
+
+	/* set: TE (transmitter enable, bit 3), RE (receive enable, bit 2)
+	   and RA (receive all mode, bit 31) */
+	value |= (MAC_CONTROL_RA | MAC_CONTROL_TE | MAC_CONTROL_RE);
+	STMAC_WRITE (value, MAC_CONTROL);
+	return;
+}
+
+static void stmac_mac_disable (void)
+{
+	unsigned int value = (unsigned int) STMAC_READ (MAC_CONTROL);
+
+	PRINTK ("%s: MAC RX/TX disabled\n", __FUNCTION__);
+
+	value &= ~(MAC_CONTROL_RA | MAC_CONTROL_TE | MAC_CONTROL_RE);
+	STMAC_WRITE (value, MAC_CONTROL);
+	return;
+}
+
+static void stmac_set_rx_mode (void)
+{
+	unsigned int value = (unsigned int) STMAC_READ (MAC_CONTROL);
+
+	PRINTK ("STMAC: perfect filtering mode.\n");
+	value &= ~(MAC_CONTROL_PM | MAC_CONTROL_PR | MAC_CONTROL_IF |
+		   MAC_CONTROL_HO | MAC_CONTROL_HP);
+	STMAC_WRITE (0x0, MAC_HASH_HIGH);
+	STMAC_WRITE (0x0, MAC_HASH_LOW);
+
+	STMAC_WRITE (value, MAC_CONTROL);
+
+	return;
+}
+
+static void stmac_set_mac_mii_cap (int full_duplex, unsigned int speed)
+{
+	unsigned int flow = (unsigned int) STMAC_READ (MAC_FLOW_CONTROL),
+		ctrl = (unsigned int) STMAC_READ (MAC_CONTROL);
+
+	PRINTK ("%s\n", __FUNCTION__);
+
+	if (!(full_duplex)) {	/* Half Duplex */
+		flow &= ~(MAC_FLOW_CONTROL_FCE | MAC_FLOW_CONTROL_PT_MASK |
+			  MAC_FLOW_CONTROL_PCF);
+		ctrl &= ~MAC_CONTROL_F;
+		ctrl |= MAC_CONTROL_DRO;
+	} else {		/* Full Duplex */
+		flow |= MAC_FLOW_CONTROL_FCE | MAC_FLOW_CONTROL_PCF |
+			(MAX_PAUSE_TIME << MAC_FLOW_CONTROL_PT_SHIFT);
+		ctrl |= MAC_CONTROL_F;
+		ctrl &= ~MAC_CONTROL_DRO;
+	}
+
+	STMAC_WRITE (flow, MAC_FLOW_CONTROL);
+	STMAC_WRITE (ctrl, MAC_CONTROL);
+#ifdef CONFIG_STMAC_STE101P_RMII
+	stb7109_mac_speed (speed);
+#endif
+	return;
+}
+
+/* This function provides the initial setup of the MAC controller */
+static void stmac_mac_core_init (void)
+{
+	unsigned int value = 0;
+
+	/* Set the MAC control register with our default value */
+	value = (unsigned int) STMAC_READ (MAC_CONTROL);
+	value |= MAC_CONTROL_HBD | MAC_CONTROL_PM;
+	STMAC_WRITE (value, MAC_CONTROL);
+
+	/* Change the MAX_FRAME bits in the MMC control register. */
+	STMAC_WRITE (((MAX_ETH_FRAME_SIZE << MMC_CONTROL_MAX_FRM_SHIFT) &
+		      MMC_CONTROL_MAX_FRM_MASK), MMC_CONTROL);
+
+	return;
+}
+
+/* ----------------------------------------------------------------------------
+ *  			DESCRIPTORS functions
+ * ---------------------------------------------------------------------------*/
+static void display_dma_desc_ring (volatile stmac_dma_des * p, int size)
+{
+	int i;
+	for (i = 0; i < size; i++)
+		printf ("\t%d [0x%x]: "
+			"desc0=0x%x desc1=0x%x buffer1=0x%x\n", i,
+			(unsigned int) &p[i].des0, p[i].des0,
+			p[i].des1, (unsigned int) p[i].des2);
+}
+
+static void init_desc_owner (volatile stmac_dma_des * head, unsigned int size,
+			     unsigned int owner)
+{
+	int i;
+	volatile stmac_dma_des *p = head;
+
+	for (i = 0; i < size; i++) {
+		p->des0 = owner;
+		p++;
+	}
+	return;
+}
+
+static void init_dma_ring (volatile stmac_dma_des * p, uchar ** phy,
+			   unsigned int ring_size, unsigned int own_bit)
+{
+	int i;
+	for (i = 0; i < ring_size; i++) {
+		p->des0 = own_bit;
+		p->des1 = (!(own_bit) ? 0 :
+			   ((PKTSIZE_ALIGN) << DES1_RBS1_SIZE_SHIFT));
+		if (i == ring_size - 1) {
+			p->des1 |= DES1_CONTROL_TER;
+		}
+		p->des2 = (!(own_bit) ? 0 : ((void *) (PHYSADDR (phy[i]))));
+		p->des3 = NULL;
+		p++;
+	}
+	return;
+}
+
+/* Allocate and init the TX and RX descriptors rings.
+ * The driver uses the 'implicit' scheme for implementing the TX/RX DMA
+ * linked lists. */
+
+static void init_dma_desc_rings (void)
+{
+	int i;
+
+	PRINTK ("allocate and init the DMA RX/TX lists\n");
+
+	/* Clean out uncached buffers */
+
+	flush_cache ((unsigned long)&dma, sizeof (struct dma_t));
+
+	/* Allocate memory for the DMA RX/TX buffer descriptors */
+	dma_rx = (volatile stmac_dma_des *) P2SEGADDR (&dma.desc_rx[0]);
+	dma_tx = (volatile stmac_dma_des *) P2SEGADDR (&dma.desc_tx[0]);
+
+	cur_rx = 0;
+
+	if ((dma_rx == NULL) || (dma_tx == NULL)) {
+		printf ("%s:ERROR allocating the DMA Tx/Rx desc\n",
+			__FUNCTION__);
+		return;
+	}
+
+	for (i = 0; i < CONFIG_DMA_RX_SIZE; i++)
+		rx_packets[i] = (uchar*)P2SEGADDR (dma.rx_buff + (PKTSIZE_ALIGN * i));
+
+	init_dma_ring (dma_rx, rx_packets, CONFIG_DMA_RX_SIZE, OWN_BIT);
+	init_dma_ring (dma_tx, 0, CONFIG_DMA_TX_SIZE, 0);
+
+#ifdef DEBUG
+	printf (" - RX descriptor ring:\n");
+	display_dma_desc_ring (dma_rx, CONFIG_DMA_RX_SIZE);
+	printf (" - TX descriptor ring:\n");
+	display_dma_desc_ring (dma_tx, CONFIG_DMA_TX_SIZE);
+#endif
+
+	return;
+}
+
+/* Release and free the descriptor resources. */
+static void free_dma_desc_resources (void)
+{
+	dma_tx = NULL;
+	dma_rx = NULL;
+	return;
+}
+
+/* ----------------------------------------------------------------------------
+				DMA FUNCTIONS
+ * ---------------------------------------------------------------------------*/
+
+/* DMA SW reset.
+ *  NOTE1: the MII_TxClk and the MII_RxClk must be active before this
+ *	   SW reset otherwise the MAC core won't exit the reset state.
+ *  NOTE2: after a SW reset all interrupts are disabled */
+
+static void stmac_dma_reset (void)
+{
+	unsigned int value;
+
+	value = (unsigned int) STMAC_READ (DMA_BUS_MODE);
+	value |= DMA_BUS_MODE_SFT_RESET;
+
+	STMAC_WRITE (value, DMA_BUS_MODE);
+
+	while ((STMAC_READ (DMA_BUS_MODE) & DMA_BUS_MODE_SFT_RESET)) {
+	}
+
+	return;
+}
+
+/* START/STOP the DMA TX/RX processes */
+static void stmac_dma_start_tx (void)
+{
+	unsigned int value;
+
+	value = (unsigned int) STMAC_READ (DMA_CONTROL);
+	value |= DMA_CONTROL_ST;
+	STMAC_WRITE (value, DMA_CONTROL);
+
+	return;
+}
+
+static void stmac_dma_stop_tx (void)
+{
+	unsigned int value;
+
+	value = (unsigned int) STMAC_READ (DMA_CONTROL);
+	value |= ~DMA_CONTROL_ST;
+	STMAC_WRITE (value, DMA_CONTROL);
+
+	return;
+}
+static void stmac_dma_start_rx (void)
+{
+	unsigned int value;
+
+	value = (unsigned int) STMAC_READ (DMA_CONTROL);
+	value |= DMA_CONTROL_SR;
+	STMAC_WRITE (value, DMA_CONTROL);
+
+	return;
+}
+
+static void stmac_dma_stop_rx (void)
+{
+	unsigned int value;
+
+	value = (unsigned int) STMAC_READ (DMA_CONTROL);
+	value |= ~DMA_CONTROL_SR;
+	STMAC_WRITE (value, DMA_CONTROL);
+
+	return;
+}
+
+static void stmac_eth_stop_tx (void)
+{
+
+	stmac_dma_stop_tx ();
+
+	init_desc_owner (dma_tx, CONFIG_DMA_TX_SIZE, 0);
+
+	return;
+}
+
+/* The DMA init function performs:
+ * - the DMA RX/TX SW descriptors initialization
+ * - the DMA HW controller initialization
+ * NOTE: the DMA TX/RX processes will be started in the 'open' method. */
+
+static int stmac_dma_init (void)
+{
+
+	PRINTK ("STM-STMAC: DMA Core setup\n");
+
+	/* DMA SW reset */
+	stmac_dma_reset ();
+
+	/* Enable Application Access by writing to DMA CSR0 */
+	STMAC_WRITE (DMA_BUS_MODE_DEFAULT |
+		     (stmac_default_pbl () << DMA_BUS_MODE_PBL_SHIFT),
+		     DMA_BUS_MODE);
+
+	/* Disable interrupts */
+	STMAC_WRITE (0, DMA_INTR_ENA);
+
+	/* The base address of the RX/TX descriptor */
+
+	STMAC_WRITE (PHYSADDR (dma_tx), DMA_TX_BASE_ADDR);
+	STMAC_WRITE (PHYSADDR (dma_rx), DMA_RCV_BASE_ADDR);
+
+	return (0);
+}
+
+static int check_tx_error_summary (uint status)
+{
+
+	PRINTK ("TDES0: 0x%x\n", status);
+
+	if (status & TDES0_STATUS_ES) {
+		printf ("STMAC: DMA tx ERROR: ");
+
+		if (status & TDES0_STATUS_UF) {
+			printf ("Underflow Error\n");
+			goto out_error;
+		}
+		if (status & TDES0_STATUS_EX_DEF) {
+			printf ("Ex Deferrals\n");
+			goto set_collision;
+		}
+		if (status & TDES0_STATUS_EX_COL) {
+			printf ("Ex Collisions\n");
+			goto set_collision;
+		}
+		if (status & TDES0_STATUS_LATE_COL) {
+			printf ("Late Collision\n");
+			goto set_collision;
+		}
+		if (status & TDES0_STATUS_NO_CARRIER) {
+			printf ("No Carrier\n");
+			goto out_error;
+		}
+		if (status & TDES0_STATUS_LOSS_CARRIER) {
+			printf ("Loss of Carrier\n");
+			goto out_error;
+		}
+	}
+
+	return (0);
+
+      set_collision:
+      out_error:
+
+	return (-1);
+}
+
+/* When a frame is received the status is written into TDESC0 of the descriptor
+ * having the LS bit set. */
+static int check_rx_error_summary (unsigned int status)
+{
+	if (status & RDES0_STATUS_ES) {
+		printf ("STMAC: DMA rx ERROR: ");
+		if (status & RDES0_STATUS_DE)
+			printf ("descriptor error\n");
+		if (status & RDES0_STATUS_PFE)
+			printf ("partial frame error\n");
+		if (status & RDES0_STATUS_RUNT_FRM)
+			printf ("runt Frame\n");
+		if (status & RDES0_STATUS_TL)
+			printf ("frame too long\n");
+		if (status & RDES0_STATUS_COL_SEEN) {
+			printf ("collision seen\n");
+		}
+		if (status & RDES0_STATUS_CE)
+			printf ("CRC Error\n");
+
+		return (-1);
+	}
+	return (0);
+}
+
+static int stmac_eth_tx (volatile uchar * data, int len)
+{
+	volatile stmac_dma_des *p = dma_tx;
+	uint now = get_timer (0);
+	uint status = 0;
+
+	while ((p->des0 & OWN_BIT)
+	       && (get_timer (now) < CONFIG_STMAC_TX_TIMEOUT)) {
+		;
+	}
+
+	if (p->des0 & OWN_BIT) {
+		printf ("STMAC: tx timeout - no desc available\n");
+		return -1;
+	}
+
+	flush_cache ((ulong) data, len);	/* Make sure data in memory */
+	p->des2 = (stmac_dma_des *) PHYSADDR (data);
+
+	/* Clean and set the descriptor 1 */
+
+	p->des1 = ((TDES1_CONTROL_IC | TDES1_CONTROL_FS | TDES1_CONTROL_LS) |
+		   ((p->des1 & DES1_CONTROL_TER) ? DES1_CONTROL_TER : 0) |
+		   ((len << DES1_RBS1_SIZE_SHIFT) & DES1_RBS1_SIZE_MASK));
+	p->des0 = OWN_BIT;
+
+#ifdef DEBUG
+	PRINTK ("\nSTMAC: TX (cur_tx = %d)\n", cur_tx);
+	display_dma_desc_ring (dma_tx, CONFIG_DMA_TX_SIZE);
+#endif
+
+	/* CSR1 enables the transmit DMA to check for new descriptor */
+	STMAC_WRITE (DMA_STATUS_TI, DMA_STATUS);
+	STMAC_WRITE (1, DMA_XMT_POLL_DEMAND);
+
+	now = get_timer (0);
+	while (get_timer (now) < CONFIG_STMAC_TX_TIMEOUT) {
+		status = STMAC_READ (DMA_STATUS);
+		if (status & DMA_STATUS_TI)
+			break;
+	}
+	if (!(status & DMA_STATUS_TI)) {
+		printf ("STMAC: tx timeout\n");
+	}
+	check_tx_error_summary (status);
+
+	return (0);
+}
+
+/* Receive function */
+static void stmac_eth_rx (void)
+{
+	int frame_len = 0, pos;
+	volatile stmac_dma_des *drx;
+
+	pos = cur_rx;
+	drx = dma_rx + pos;
+
+	if ((pos < 0) || (pos >= CONFIG_DMA_RX_SIZE)) {
+		printf ("STMAC %s: [dma drx = 0x%x, pos=%d]\n", __FUNCTION__,
+			(unsigned int) drx, pos);
+		display_dma_desc_ring (dma_rx, CONFIG_DMA_RX_SIZE);
+	}
+
+	if (!(drx->des0 & OWN_BIT) && (drx->des0 & RDES0_STATUS_LS)) {
+		unsigned int status = drx->des0;
+#ifdef  DEBUG
+		PRINTK ("RX descriptor ring:\n");
+		display_dma_desc_ring (dma_rx, CONFIG_DMA_RX_SIZE);
+#endif
+
+		/* Check if the frame was not successfully received */
+		if (check_rx_error_summary (status) < 0) {
+			drx->des0 = OWN_BIT;
+		} else if ((status & RDES0_STATUS_FS)
+			   && (status & RDES0_STATUS_LS)) {
+
+			/* FL (frame length) indicates the length in byte including
+			 * the CRC */
+			frame_len =
+				(status & RDES0_STATUS_FL_MASK) >>
+				RDES0_STATUS_FL_SHIFT;
+
+			if ((frame_len >= 0) && (frame_len <= PKTSIZE_ALIGN)) {
+				memcpy ((void*)NetRxPackets[0], rx_packets[pos],
+					frame_len);
+				NetReceive (NetRxPackets[0], frame_len);
+			} else {
+				printf ("%s: Framelen %d too long\n",
+					__FUNCTION__, frame_len);
+			}
+
+			drx->des0 = OWN_BIT;
+
+#ifdef DEBUG
+			PRINTK ("%s: frame received \n", __FUNCTION__);
+#endif
+		} else {
+			printf ("%s: very long frame received\n",
+				__FUNCTION__);
+		}
+
+		if (drx->des1 & DES1_CONTROL_TER)
+			pos = 0;
+		else
+			pos++;
+		/* drx = dma_rx + pos; */
+		cur_rx = pos;
+
+	} else {
+		STMAC_WRITE (1, DMA_RCV_POLL_DEMAND);	/* request input */
+	}
+	return;
+}
+
+static int stmac_get_ethaddr (bd_t * bd)
+{
+	int env_size, rom_valid, env_present = 0, reg;
+	char *s = NULL, *e, es[] = "11:22:33:44:55:66";
+	char s_env_mac[64];
+	uchar v_env_mac[6], v_rom_mac[6], *v_mac;
+
+	env_size = getenv_r ("ethaddr", s_env_mac, sizeof (s_env_mac));
+	if ((env_size > 0) && (env_size < sizeof (es))) {	/* exit if env is bad */
+		printf ("\n*** ERROR: ethaddr is not set properly!!\n");
+		return (-1);
+	}
+
+	if (env_size > 0) {
+		env_present = 1;
+		s = s_env_mac;
+	}
+
+	for (reg = 0; reg < 6; ++reg) {	/* turn string into mac value */
+		v_env_mac[reg] = s ? simple_strtoul (s, &e, 16) : 0;
+		if (s)
+			s = (*e) ? e + 1 : e;
+	}
+
+	rom_valid = stmac_get_mac_addr (v_rom_mac);	/* get ROM mac value if any */
+
+	if (!env_present) {	/* if NO env */
+		if (rom_valid) {	/* but ROM is valid */
+			v_mac = v_rom_mac;
+			sprintf (s_env_mac, "%02X:%02X:%02X:%02X:%02X:%02X",
+				 v_mac[0], v_mac[1], v_mac[2], v_mac[3],
+				 v_mac[4], v_mac[5]);
+			setenv ("ethaddr", s_env_mac);
+		} else {	/* no env, bad ROM */
+			printf ("\n*** ERROR: ethaddr is NOT set !!\n");
+			return (-1);
+		}
+	} else {		/* good env, don't care ROM */
+		v_mac = v_env_mac;	/* always use a good env over a ROM */
+	}
+
+	if (env_present && rom_valid) {	/* if both env and ROM are good */
+		if (memcmp (v_env_mac, v_rom_mac, 6) != 0) {
+			printf ("\nWarning: MAC addresses don't match:\n");
+			printf ("\tHW MAC address:  "
+				"%02X:%02X:%02X:%02X:%02X:%02X\n",
+				v_rom_mac[0], v_rom_mac[1],
+				v_rom_mac[2], v_rom_mac[3],
+				v_rom_mac[4], v_rom_mac[5]);
+			printf ("\t\"ethaddr\" value: "
+				"%02X:%02X:%02X:%02X:%02X:%02X\n",
+				v_env_mac[0], v_env_mac[1],
+				v_env_mac[2], v_env_mac[3],
+				v_env_mac[4], v_env_mac[5]);
+		}
+	}
+	memcpy (bd->bi_enetaddr, v_mac, 6);	/* update global address to match env (allows env changing) */
+	stmac_set_mac_addr (v_mac);	/* use old function to update default */
+	printf ("Using MAC Address %02X:%02X:%02X:%02X:%02X:%02X\n", v_mac[0],
+		v_mac[1], v_mac[2], v_mac[3], v_mac[4], v_mac[5]);
+	return (0);
+}
+
+static int stmac_reset_eth (bd_t * bd)
+{
+	int err;
+
+	err = stmac_get_ethaddr (bd);	/* set smc_mac_addr, and sync it with u-boot globals */
+
+	if (err < 0) {
+		memset (bd->bi_enetaddr, 0, 6);	/* hack to make error stick! upper code will abort if not set */
+		return (-1);	/* upper code ignores this, but NOT bi_enetaddr */
+	}
+
+	if (stmac_phy_init () < 0) {
+		printf ("Phy not detected\n");
+		return -1;
+	}
+
+	init_dma_desc_rings ();
+
+	stmac_mac_core_init ();
+	stmac_dma_init ();
+
+	stmac_set_rx_mode ();
+
+	stmac_mac_enable ();
+
+	stmac_dma_start_rx ();
+	stmac_dma_start_tx ();
+
+	STMAC_WRITE (1, DMA_RCV_POLL_DEMAND);	/* request input */
+
+	return (0);
+}
+
+extern int eth_init (bd_t * bd)
+{
+	stmac_reset_eth (bd);
+	return 0;
+}
+
+extern void eth_halt (void)
+{
+	PRINTK ("%s\n", __FUNCTION__);
+
+	/* Reset the TX/RX processes */
+	stmac_dma_stop_rx ();
+	stmac_eth_stop_tx ();
+
+	/* Disable the MAC core */
+	stmac_mac_disable ();
+
+	/* Free buffers */
+
+	free_dma_desc_resources ();
+}
+
+/* Get a data block via Ethernet */
+extern int eth_rx (void)
+{
+	PRINTK ("%s: status 0x%x\n", __FUNCTION__, status);
+	stmac_eth_rx ();
+	return 1;
+}
+
+/* Send a data block via Ethernet. */
+extern int eth_send (volatile void *packet, int length)
+{
+	stmac_eth_tx (packet, length);
+	return 1;
+}
+
+#endif /* COMMANDS & CFG_NET */
+
+extern int stmac_miiphy_initialize(bd_t *bis)
+{
+#if defined(CONFIG_MII) || defined(CONFIG_CMD_MII)
+	miiphy_register(miidevice, stmac_miiphy_read, stmac_miiphy_write);
+#endif
+	return 0;
+}
+
+#endif /* CONFIG_DRIVER_NETSTMAC */
diff --git a/drivers/net/stm-stmac.h b/drivers/net/stm-stmac.h
new file mode 100644
index 0000000..f3619d0
--- /dev/null
+++ b/drivers/net/stm-stmac.h
@@ -0,0 +1,334 @@
+
+/*----------------------------------------------------------------------------
+ *	 			MAC BLOCK defines
+ *---------------------------------------------------------------------------*/
+/* MAC CSR offset */
+#define MAC_CONTROL               0x00000000  /* MAC Control */
+#define MAC_ADDR_HIGH             0x00000004  /* MAC Address High */
+#define MAC_ADDR_LOW              0x00000008  /* MAC Address Low */
+#define MAC_HASH_HIGH             0x0000000c  /* Multicast Hash Table High */
+#define MAC_HASH_LOW              0x00000010  /* Multicast Hash Table Low */
+#define MAC_MII_ADDR              0x00000014  /* MII Address */
+#define MAC_MII_DATA              0x00000018  /* MII Data */
+#define MAC_FLOW_CONTROL          0x0000001c  /* Flow Control */
+#define MAC_VLAN1                 0x00000020  /* VLAN1 Tag */
+#define MAC_VLAN2                 0x00000024  /* VLAN2 Tag */
+#define MAC_WAKEUP_FILTER         0x00000028  /* Wake-up Frame Filter */
+#define MAC_WAKEUP_CONTROL_STATUS 0x0000002c  /* Wake-up Control And Status */
+
+
+/* MAC CTRL defines */
+#define MAC_CONTROL_RA            0x80000000  /* Receive All Mode */
+#define MAC_CONTROL_BLE           0x40000000  /* Endian Mode */
+#define MAC_CONTROL_HBD           0x10000000  /* Heartbeat Disable */
+#define MAC_CONTROL_PS            0x08000000  /* Port Select */
+#define MAC_CONTROL_DRO           0x00800000  /* Disable Receive Own */
+#define MAC_CONTROL_EXT_LOOPBACK  0x00400000  /* Reserved (ext loopback?) */
+#define MAC_CONTROL_OM            0x00200000  /* Loopback Operating Mode */
+#define MAC_CONTROL_F             0x00100000  /* Full Duplex Mode */
+#define MAC_CONTROL_PM            0x00080000  /* Pass All Multicast */
+#define MAC_CONTROL_PR            0x00040000  /* Promiscuous Mode */
+#define MAC_CONTROL_IF            0x00020000  /* Inverse Filtering */
+#define MAC_CONTROL_PB            0x00010000  /* Pass Bad Frames */
+#define MAC_CONTROL_HO            0x00008000  /* Hash Only Filtering Mode */
+#define MAC_CONTROL_HP            0x00002000  /* Hash/Perfect Filtering Mode */
+#define MAC_CONTROL_LCC           0x00001000  /* Late Collision Control */
+#define MAC_CONTROL_DBF           0x00000800  /* Disable Broadcast Frames */
+#define MAC_CONTROL_DRTY          0x00000400  /* Disable Retry */
+#define MAC_CONTROL_ASTP          0x00000100  /* Automatic Pad Stripping */
+#define MAC_CONTROL_BOLMT_10      0x00000000  /* Back Off Limit 10 */
+#define MAC_CONTROL_BOLMT_8       0x00000040  /* Back Off Limit 8 */
+#define MAC_CONTROL_BOLMT_4       0x00000080  /* Back Off Limit 4 */
+#define MAC_CONTROL_BOLMT_1       0x000000c0  /* Back Off Limit 1 */
+#define MAC_CONTROL_DC            0x00000020  /* Deferral Check */
+#define MAC_CONTROL_TE            0x00000008  /* Transmitter Enable */
+#define MAC_CONTROL_RE            0x00000004  /* Receiver Enable */
+
+/* MAC FLOW CTRL defines */
+#define MAC_FLOW_CONTROL_PT_MASK  0xffff0000  /* Pause Time Mask */
+#define MAC_FLOW_CONTROL_PT_SHIFT 16
+#define MAC_FLOW_CONTROL_PCF      0x00000004  /* Pass Control Frames */
+#define MAC_FLOW_CONTROL_FCE      0x00000002  /* Flow Control Enable */
+#define MAC_FLOW_CONTROL_PAUSE    0x00000001  /* Flow Control Busy ... */
+
+/* MII ADDR  defines */
+#define MAC_MII_ADDR_WRITE        0x00000002  /* MII Write */
+#define MAC_MII_ADDR_BUSY         0x00000001  /* MII Busy */
+#define MAC_MII_ADDR_PHY_MASK     0x0000001f  /* MII PHY address mask */
+#define MAC_MII_ADDR_PHY_SHIFT    11          /* MII PHY address shift */
+#define MAC_MII_ADDR_REG_MASK     0x0000001f  /* MII register mask */
+#define MAC_MII_ADDR_REG_SHIFT    6           /* MII register shift */
+
+/* MAC Management Counters register */
+#define MMC_CONTROL               0x00000100  /* MMC Control */
+#define MMC_HIGH_INTR             0x00000104  /* MMC High Interrupt */
+#define MMC_LOW_INTR              0x00000108  /* MMC Low Interrupt */
+#define MMC_HIGH_INTR_MASK        0x0000010c  /* MMC High Interrupt Mask */
+#define MMC_LOW_INTR_MASK         0x00000110  /* MMC Low Interrupt Mask */
+
+#define MMC_CONTROL_MAX_FRM_MASK  0x0003ff8   /* Maximum Frame Size */
+#define MMC_CONTROL_MAX_FRM_SHIFT 3
+#define MMC_CONTROL_MAX_FRAME 	  0x7FF
+
+/*----------------------------------------------------------------------------
+ * 				DMA BLOCK defines
+ *---------------------------------------------------------------------------*/
+/* DMA CRS Control and Status Register Mapping */
+#define DMA_BUS_MODE              0x00001000  /* Bus Mode */
+#define DMA_XMT_POLL_DEMAND       0x00001004  /* Transmit Poll Demand */
+#define DMA_RCV_POLL_DEMAND       0x00001008  /* Received Poll Demand */
+#define DMA_RCV_BASE_ADDR         0x0000100c  /* Receive List Base */
+#define DMA_TX_BASE_ADDR          0x00001010  /* Transmit List Base */
+#define DMA_STATUS                0x00001014  /* Status Register */
+#define DMA_CONTROL               0x00001018  /* Control (Operational Mode) */
+#define DMA_INTR_ENA              0x0000101c  /* Interrupt Enable */
+#define DMA_MISSED_FRAME_CTR      0x00001020  /* Missed Frame Counter */
+#define DMA_CUR_TX_BUF_ADDR       0x00001050  /* Current Host Transmit Buffer */
+#define DMA_CUR_RX_BUF_ADDR       0x00001054  /* Current Host Receive Buffer */
+
+/*  DMA Bus Mode register defines */
+#define DMA_BUS_MODE_DBO          0x00100000  /* Descriptor Byte Ordering */
+#define DMA_BUS_MODE_PBL_MASK     0x00003f00  /* Programmable Burst Length */
+#define DMA_BUS_MODE_PBL_SHIFT    8
+#define DMA_BUS_MODE_BLE          0x00000080  /* Big Endian/Little Endian */
+#define DMA_BUS_MODE_DSL_MASK     0x0000007c  /* Descriptor Skip Length */
+#define DMA_BUS_MODE_DSL_SHIFT    2           /*       (in DWORDS)      */
+#define DMA_BUS_MODE_BAR_BUS      0x00000002  /* Bar-Bus Arbitration */
+#define DMA_BUS_MODE_SFT_RESET    0x00000001  /* Software Reset */
+#define DMA_BUS_MODE_DEFAULT      0x00000000
+
+/* DMA Status register defines */
+#define DMA_STATUS_EB_MASK        0x00380000  /* Error Bits Mask */
+#define DMA_STATUS_EB_TX_ABORT    0x00080000  /* Error Bits - TX Abort */
+#define DMA_STATUS_EB_RX_ABORT    0x00100000  /* Error Bits - RX Abort */
+#define DMA_STATUS_TS_MASK        0x00700000  /* Transmit Process State */
+#define DMA_STATUS_TS_SHIFT       20
+#define DMA_STATUS_RS_MASK        0x000e0000  /* Receive Process State */
+#define DMA_STATUS_RS_SHIFT       17
+#define DMA_STATUS_NIS            0x00010000  /* Normal Interrupt Summary */
+#define DMA_STATUS_AIS            0x00008000  /* Abnormal Interrupt Summary */
+#define DMA_STATUS_ERI            0x00004000  /* Early Receive Interrupt */
+#define DMA_STATUS_FBI            0x00002000  /* Fatal Bus Error Interrupt */
+#define DMA_STATUS_ETI            0x00000400  /* Early Transmit Interrupt */
+#define DMA_STATUS_RWT            0x00000200  /* Receive Watchdog Timeout */
+#define DMA_STATUS_RPS            0x00000100  /* Receive Process Stopped */
+#define DMA_STATUS_RU             0x00000080  /* Receive Buffer Unavailable */
+#define DMA_STATUS_RI             0x00000040  /* Receive Interrupt */
+#define DMA_STATUS_UNF            0x00000020  /* Transmit Underflow */
+#define DMA_STATUS_OVF            0x00000010  /* Receive Overflow */
+#define DMA_STATUS_TJT            0x00000008  /* Transmit Jabber Timeout */
+#define DMA_STATUS_TU             0x00000004  /* Transmit Buffer Unavailable */
+#define DMA_STATUS_TPS            0x00000002  /* Transmit Process Stopped */
+#define DMA_STATUS_TI             0x00000001  /* Transmit Interrupt */
+
+/* DMA Control register defines */
+#define DMA_CONTROL_SF            0x00200000  /* Store And Forward */
+#define DMA_CONTROL_TTC_MASK      0x0001c000  /* Transmit Threshold Control */
+#define DMA_CONTROL_TTC_32        0x00000000  /* Threshold is 32 DWORDS */
+#define DMA_CONTROL_TTC_64        0x00004000  /* Threshold is 64 DWORDS */
+#define DMA_CONTROL_TTC_128       0x00008000  /* Threshold is 128 DWORDS */
+#define DMA_CONTROL_TTC_256       0x0000c000  /* Threshold is 256 DWORDS */
+#define DMA_CONTROL_TTC_18        0x00010000  /* Threshold is 18 DWORDS */
+#define DMA_CONTROL_TTC_24        0x00014000  /* Threshold is 24 DWORDS */
+#define DMA_CONTROL_TTC__32_      0x00018000  /* Threshold is 32 DWORDS */
+#define DMA_CONTROL_TTC_40        0x0001c000  /* Threshold is 40 DWORDS */
+#define DMA_CONTROL_ST            0x00002000  /* Start/Stop Transmission */
+#define DMA_CONTROL_SE            0x00000008  /* Stop On Empty */
+#define DMA_CONTROL_OSF           0x00000004  /* Operate On 2nd Frame */
+#define DMA_CONTROL_SR            0x00000002  /* Start/Stop Receive */
+
+/* DMA Interrupt Enable register defines */
+#define DMA_INTR_ENA_NIE          0x00010000  /* Normal Interrupt Summary */
+#define DMA_INTR_ENA_AIE          0x00008000  /* Abnormal Interrupt Summary */
+#define DMA_INTR_ENA_ERE          0x00004000  /* Early Receive */
+#define DMA_INTR_ENA_FBE          0x00002000  /* Fatal Bus Error */
+#define DMA_INTR_ENA_ETE          0x00000400  /* Early Transmit */
+#define DMA_INTR_ENA_RWE          0x00000200  /* Receive Watchdog */
+#define DMA_INTR_ENA_RSE          0x00000100  /* Receive Stopped */
+#define DMA_INTR_ENA_RUE          0x00000080  /* Receive Buffer Unavailable */
+#define DMA_INTR_ENA_RIE          0x00000040  /* Receive Interrupt */
+#define DMA_INTR_ENA_UNE          0x00000020  /* Underflow */
+#define DMA_INTR_ENA_OVE          0x00000010  /* Receive Overflow */
+#define DMA_INTR_ENA_TJE          0x00000008  /* Transmit Jabber */
+#define DMA_INTR_ENA_TUE          0x00000004  /* Transmit Buffer Unavailable */
+#define DMA_INTR_ENA_TSE          0x00000002  /* Transmit Stopped */
+#define DMA_INTR_ENA_TIE          0x00000001  /* Transmit Interrupt */
+/* DMA default interrupt mask */
+#define DMA_INTR_DEFAULT_MASK 	(DMA_INTR_ENA_NIE | DMA_INTR_ENA_AIE | \
+				DMA_INTR_ENA_FBE | DMA_INTR_ENA_RWE | \
+				DMA_INTR_ENA_RSE | DMA_INTR_ENA_RUE | \
+				DMA_INTR_ENA_RIE | DMA_INTR_ENA_UNE | \
+				DMA_INTR_ENA_OVE | DMA_INTR_ENA_TJE | \
+				DMA_INTR_ENA_TUE | DMA_INTR_ENA_TSE | \
+				/*DMA_INTR_ENA_ERE | DMA_INTR_ENA_ETE | */ \
+				DMA_INTR_ENA_TIE)
+
+/* STMAC110 DMA Missed Frame Counter register defines */
+#define DMA_MISSED_FRAME_OVE      0x10000000  /* FIFO Overflow Overflow */
+#define DMA_MISSED_FRAME_OVE_CNTR 0x0ffe0000  /* Overflow Frame Counter */
+#define DMA_MISSED_FRAME_OVE_M    0x00010000  /* Missed Frame Overflow */
+#define DMA_MISSED_FRAME_M_CNTR   0x0000ffff  /* Missed Frame Couinter */
+
+/*----------------------------------------------------------------------------
+ * 		    	    Descriptor defines
+ *---------------------------------------------------------------------------*/
+/* Common fields */
+#define OWN_BIT			0x80000000  /* Own Bit (owned by hardware) */
+#define DES1_CONTROL_CH		0x01000000  /* Second Address Chained */
+#define DES1_CONTROL_TER	0x02000000  /* End of Ring */
+#define DES1_RBS2_SIZE_MASK	0x003ff800  /* Buffer 2 Size Mask */
+#define DES1_RBS2_SIZE_SHIFT	11          /* Buffer 2 Size Shift */
+#define DES1_RBS1_SIZE_MASK	0x000007ff  /* Buffer 1 Size Mask */
+#define DES1_RBS1_SIZE_SHIFT	0           /* Buffer 1 Size Shift */
+
+/* Receive Descriptor */
+#define RDES0_STATUS_FILTER_FAIL  0x40000000  /* Filtering Fail */
+#define RDES0_STATUS_FL_MASK      0x3fff0000  /* Frame Length Mask */
+#define RDES0_STATUS_FL_SHIFT     16          /* Frame Length Shift */
+#define RDES0_STATUS_ES           0x00008000  /* Error Summary */
+#define RDES0_STATUS_DE           0x00004000  /* Descriptor Error */
+#define RDES0_STATUS_PFE          0x00002000  /* Partial Frame Error */
+#define RDES0_STATUS_LENGTH_ERROR 0x00001000  /* Length Error */
+#define RDES0_STATUS_RUNT_FRM     0x00000800  /* Runt Frame */
+#define RDES0_STATUS_MULTICST_FRM 0x00000400  /* Multicast Frame */
+#define RDES0_STATUS_FS           0x00000200  /* First Descriptor */
+#define RDES0_STATUS_LS           0x00000100  /* Last Descriptor */
+#define RDES0_STATUS_TL           0x00000080  /* Frame Too Long */
+#define RDES0_STATUS_COL_SEEN     0x00000040  /* Collision Seen */
+#define RDES0_STATUS_FRM_TYPE     0x00000020  /* Frame Type */
+#define RDES0_STATUS_RX_WATCHDOG  0x00000010  /* Receive Watchdog */
+#define RDES0_STATUS_MII_ERR      0x00000008  /* Report on MII Error */
+#define RDES0_STATUS_DRIBBLE      0x00000004  /* Dribbling Bit */
+#define RDES0_STATUS_CE           0x00000002  /* CRC Error */
+#define RDES0_STATUS_0            0x00000000  /* Always tied to zero */
+
+#define RDES1_CONTROL_DIOC        0x80000000  /* Disable Intr On Completion */
+
+/* Transmit Descriptor */
+#define TDES0_STATUS_ES		  0x00008000  /* Error Summary */
+#define TDES0_STATUS_LOSS_CARRIER 0x00000800  /* Loss of Carrier */
+#define TDES0_STATUS_NO_CARRIER   0x00000400  /* No Carrier */
+#define TDES0_STATUS_LATE_COL     0x00000200  /* Late Collision */
+#define TDES0_STATUS_EX_COL       0x00000100  /* Excessive Collisions */
+#define TDES0_STATUS_HRTBT_FAIL   0x00000080  /* Heartbeat Fail */
+#define TDES0_STATUS_COLCNT_MASK  0x00000078  /* Collision Count Mask */
+#define TDES0_STATUS_COLCNT_SHIFT 3           /* Collision Count Shift */
+#define TDES0_STATUS_EX_DEF       0x00000004  /* Excessive Deferrals */
+#define TDES0_STATUS_UF           0x00000002  /* Underflow Error */
+#define TDES0_STATUS_DF           0x00000001  /* Deferred */
+
+#define TDES1_CONTROL_IC          0x80000000  /* Interrupt on Completion */
+#define TDES1_CONTROL_LS          0x40000000  /* Last Segment */
+#define TDES1_CONTROL_FS          0x20000000  /* First Segment */
+#define TDES1_CONTROL_AC          0x04000000  /* Add CRC Disable */
+#define TDES1_CONTROL_DPD         0x00800000  /* Disable Padding */
+
+#define STMAC_READ(REG)		readl(CFG_STM_STMAC_BASE+(REG))
+#define STMAC_WRITE(V, REG)	writel(V, CFG_STM_STMAC_BASE+(REG))
+
+/* MII interface defns */
+
+#ifndef CONFIG_STMAC_MII_POLL_BUSY_DELAY
+#define CONFIG_STMAC_MII_POLL_BUSY_DELAY 1000
+#endif
+
+#ifndef CONFIG_STMAC_AUTONEG_TIMEOUT
+#define CONFIG_STMAC_AUTONEG_TIMEOUT  (10*CFG_HZ) /* ticks */
+#endif
+
+#ifndef CONFIG_STMAC_TX_TIMEOUT
+#define CONFIG_STMAC_TX_TIMEOUT  (5*CFG_HZ) /* ticks */
+#endif
+
+#define MII_BMCR            0x00        /* Basic mode control register */
+#define MII_BMSR            0x01        /* Basic mode status register  */
+#define MII_PHYSID1         0x02        /* PHYS ID 1                   */
+#define MII_PHYSID2         0x03        /* PHYS ID 2                   */
+#define MII_ADVERTISE       0x04        /* Advertisement control reg   */
+#define MII_LPA             0x05        /* Link partner ability reg    */
+#define MII_EXPANSION       0x06        /* Expansion register          */
+
+#if defined(CONFIG_STMAC_STE10XP)
+#define MII_DCOUNTER        0x12        /* Disconnect counter          */
+#define MII_FCSCOUNTER      0x13        /* False carrier counter       */
+#define MII_NWAYTEST        0x14        /* N-way auto-neg test reg     */
+#define MII_RERRCOUNTER     0x15        /* Receive error counter       */
+#define MII_SREVISION       0x16        /* Silicon revision            */
+#define MII_RESV1           0x17        /* Reserved...                 */
+#define MII_LBRERROR        0x18        /* Lpback, rx, bypass error    */
+#define MII_PHYADDR         0x19        /* PHY address                 */
+#define MII_RESV2           0x1a        /* Reserved...                 */
+#define MII_TPISTATUS       0x1b        /* TPI status for 10mbps       */
+#define MII_NCONFIG         0x1c        /* Network interface config    */
+#endif	/* CONFIG_STMAC_STE10XP */
+
+/* Basic mode control register. */
+#define BMCR_RESV               0x003f  /* Unused...                   */
+#define BMCR_SPEED1000          0x0040  /* MSB of Speed (1000)         */
+#define BMCR_CTST               0x0080  /* Collision test              */
+#define BMCR_FULLDPLX           0x0100  /* Full duplex                 */
+#define BMCR_ANRESTART          0x0200  /* Auto negotiation restart    */
+#define BMCR_ISOLATE            0x0400  /* Disconnect DP83840 from MII */
+#define BMCR_PDOWN              0x0800  /* Powerdown the DP83840       */
+#define BMCR_ANENABLE           0x1000  /* Enable auto negotiation     */
+#define BMCR_SPEED100           0x2000  /* Select 100Mbps              */
+#define BMCR_LOOPBACK           0x4000  /* TXD loopback bits           */
+#define BMCR_RESET              0x8000  /* Reset                       */
+
+/* Basic mode status register. */
+#define BMSR_ERCAP              0x0001  /* Ext-reg capability          */
+#define BMSR_JCD                0x0002  /* Jabber detected             */
+#define BMSR_LSTATUS            0x0004  /* Link status                 */
+#define BMSR_ANEGCAPABLE        0x0008  /* Able to do auto-negotiation */
+#define BMSR_RFAULT             0x0010  /* Remote fault detected       */
+#define BMSR_ANEGCOMPLETE       0x0020  /* Auto-negotiation complete   */
+#define BMSR_RESV               0x07c0  /* Unused...                   */
+#define BMSR_10HALF             0x0800  /* Can do 10mbps, half-duplex  */
+#define BMSR_10FULL             0x1000  /* Can do 10mbps, full-duplex  */
+#define BMSR_100HALF            0x2000  /* Can do 100mbps, half-duplex */
+#define BMSR_100FULL            0x4000  /* Can do 100mbps, full-duplex */
+#define BMSR_100BASE4           0x8000  /* Can do 100mbps, 4k packets  */
+
+
+/* Advertisement control register. */
+#define ADVERTISE_SLCT          0x001f  /* Selector bits               */
+#define ADVERTISE_CSMA          0x0001  /* Only selector supported     */
+#define ADVERTISE_10HALF        0x0020  /* Try for 10mbps half-duplex  */
+#define ADVERTISE_10FULL        0x0040  /* Try for 10mbps full-duplex  */
+#define ADVERTISE_100HALF       0x0080  /* Try for 100mbps half-duplex */
+#define ADVERTISE_100FULL       0x0100  /* Try for 100mbps full-duplex */
+#define ADVERTISE_100BASE4      0x0200  /* Try for 100mbps 4k packets  */
+#define ADVERTISE_RESV          0x1c00  /* Unused...                   */
+#define ADVERTISE_RFAULT        0x2000  /* Say we can detect faults    */
+#define ADVERTISE_LPACK         0x4000  /* Ack link partners response  */
+#define ADVERTISE_NPAGE         0x8000  /* Next page bit               */
+
+#define ADVERTISE_FULL (ADVERTISE_100FULL | ADVERTISE_10FULL | \
+                        ADVERTISE_CSMA)
+#define ADVERTISE_ALL (ADVERTISE_10HALF | ADVERTISE_10FULL | \
+                       ADVERTISE_100HALF | ADVERTISE_100FULL)
+
+/* Link partner ability register. */
+#define LPA_SLCT                0x001f  /* Same as advertise selector  */
+#define LPA_10HALF              0x0020  /* Can do 10mbps half-duplex   */
+#define LPA_10FULL              0x0040  /* Can do 10mbps full-duplex   */
+#define LPA_100HALF             0x0080  /* Can do 100mbps half-duplex  */
+#define LPA_100FULL             0x0100  /* Can do 100mbps full-duplex  */
+#define LPA_100BASE4            0x0200  /* Can do 100mbps 4k packets   */
+#define LPA_RESV                0x1c00  /* Unused...                   */
+#define LPA_RFAULT              0x2000  /* Link partner faulted        */
+#define LPA_LPACK               0x4000  /* Link partner acked us       */
+#define LPA_NPAGE               0x8000  /* Next page bit               */
+
+#define LPA_DUPLEX              (LPA_10FULL | LPA_100FULL)
+#define LPA_100                 (LPA_100FULL | LPA_100HALF | LPA_100BASE4)
+
+/* Allocate DMA coherent memory */
+
+#ifdef CONFIG_SH4
+#define DMA_ALLOC(LEN) P2SEGADDR(malloc(LEN))
+#define DMA_FREE(P) free(P)
+#else
+#define DMA_ALLOC(LEN) malloc(LEN)
+#define DMA_FREE(P) free(P)
+#endif
diff --git a/drivers/serial/Makefile b/drivers/serial/Makefile
index 735c630..d95f67b 100644
--- a/drivers/serial/Makefile
+++ b/drivers/serial/Makefile
@@ -35,6 +35,8 @@ COBJS-y += serial_max3100.o
 COBJS-y += serial_pl010.o
 COBJS-y += serial_pl011.o
 COBJS-y += serial_xuartlite.o
+COBJS-y += sh-sci.o
+COBJS-y += stm-asc.o
 COBJS-y += usbtty.o
 
 COBJS	:= $(COBJS-y)
diff --git a/drivers/serial/sh-sci.c b/drivers/serial/sh-sci.c
new file mode 100644
index 0000000..47750ab
--- /dev/null
+++ b/drivers/serial/sh-sci.c
@@ -0,0 +1,235 @@
+/*
+ *  drivers/sh-sci.c
+ *
+ *  SuperH on-chip serial module support.  (SCI with no FIFO / with FIFO)
+ *  Copyright (C) 1999, 2000  Niibe Yutaka
+ *  Copyright (C) 2000  Sugioka Toshinobu
+ *  Modified to support multiple serial ports. Stuart Menefy (May 2000).
+ *  Modified to support SecureEdge. David McCullough (2002)
+ *  Modified to support SH7300 SCIF. Takashi Kusuda (Jun 2003).
+ *  Modified for u-boot Andy Sturges (Nov 2004)
+ *
+ * TTY code is based on sx.c (Specialix SX driver) by:
+ *
+ *   (C) 1998 R.E.Wolff@BitWizard.nl
+ *
+ */
+
+#include "common.h"
+
+#ifdef CONFIG_SH_SCIF_SERIAL
+
+#include "asm/termbits.h"
+#include "asm/io.h"
+#include "sh-sci.h"
+
+static void sci_init_pins_scif (struct sci_port *port, unsigned int cflag);
+static struct sci_port sci_ports[SCI_NPORTS] = SCI_INIT;
+
+static void put_char (struct sci_port *port, char c)
+{
+	unsigned short status;
+
+	do
+		status = sci_in (port, SCxSR);
+	while (!(status & SCxSR_TDxE (port)));
+
+	sci_out (port, SCxTDR, c);
+	sci_in (port, SCxSR);	/* Dummy read */
+	sci_out (port, SCxSR, SCxSR_TDxE_CLEAR (port));
+
+}
+
+static void handle_error (struct sci_port *port)
+{				/* Clear error flags */
+	sci_out (port, SCxSR, SCxSR_ERROR_CLEAR (port));
+}
+
+static int get_char (struct sci_port *port)
+{
+	unsigned short status;
+	int c;
+
+	do {
+		status = sci_in (port, SCxSR);
+		if (status & SCxSR_ERRORS (port)) {
+			handle_error (port);
+			continue;
+		}
+	} while (!(status & SCxSR_RDxF (port)));
+	c = sci_in (port, SCxRDR);
+	sci_in (port, SCxSR);	/* Dummy read */
+	sci_out (port, SCxSR, SCxSR_RDxF_CLEAR (port));
+
+	return c;
+}
+
+#if 0
+static void put_string (struct sci_port *port, const char *buffer, int count)
+{
+	int i;
+	const unsigned char *p = buffer;
+
+	for (i = 0; i < count; i++) {
+		if (*p == 10)
+			put_char (port, '\r');
+		put_char (port, *p++);
+	}
+}
+#endif
+
+static int is_char_ready (struct sci_port *port)
+{
+	unsigned short status = sci_in (port, SCxSR);
+
+	if (status & (SCxSR_ERRORS (port) | SCxSR_BRK (port)))
+		handle_error (port);
+
+	return (status & SCxSR_RDxF (port));
+}
+
+static void sci_init_pins_scif (struct sci_port *port, unsigned int cflag)
+{
+	unsigned int fcr_val = 0;
+
+	if (cflag & CRTSCTS) {
+		fcr_val |= SCFCR_MCE;
+	} else {
+		sci_out (port, SCSPTR, 0x0080);	/* Set RTS = 1 */
+	}
+	sci_out (port, SCFCR, fcr_val);
+}
+
+static void sci_setsignals (struct sci_port *port, int dtr, int rts)
+{
+	/* This routine is used for seting signals of: DTR, DCD, CTS/RTS */
+	/* We use SCIF's hardware for CTS/RTS, so don't need any for that. */
+	/* If you have signals for DTR and DCD, please implement here. */
+}
+
+static void sci_set_baud (struct sci_port *port, int baud)
+{
+	int t;
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	switch (baud) {
+	case 0:
+		t = -1;
+		break;
+	case 2400:
+		t = BPS_2400;
+		break;
+	case 4800:
+		t = BPS_4800;
+		break;
+	case 9600:
+		t = BPS_9600;
+		break;
+	case 19200:
+		t = BPS_19200;
+		break;
+	case 38400:
+		t = BPS_38400;
+		break;
+	case 57600:
+		t = BPS_57600;
+		break;
+	case 230400:
+		if (BPS_230400 != BPS_115200) {
+			t = BPS_230400;
+			break;
+		}
+	default:
+		printf ("sci: unsupported baud rate: %d, using 115200 instead.\n", baud);
+	case 115200:
+		t = BPS_115200;
+		break;
+	}
+
+	if (t > 0) {
+		sci_setsignals (port, 1, -1);
+		if (t >= 256) {
+			sci_out (port, SCSMR,
+				 (sci_in (port, SCSMR) & ~3) | 1);
+			t >>= 2;
+		} else {
+			sci_out (port, SCSMR, sci_in (port, SCSMR) & ~3);
+		}
+		sci_out (port, SCBRR, t);
+		udelay ((1000000 + (baud - 1)) / baud);	/* Wait one bit interval */
+	} else {
+		sci_setsignals (port, 0, -1);
+	}
+}
+
+static void sci_set_termios_cflag (struct sci_port *port, int cflag, int baud)
+{
+	unsigned int status;
+	unsigned int smr_val;
+
+	do
+		status = sci_in (port, SCxSR);
+	while (!(status & SCxSR_TEND (port)));
+
+	sci_out (port, SCSCR, 0x00);	/* TE=0, RE=0, CKE1=0 */
+
+	if (port->type == PORT_SCIF) {
+		sci_out (port, SCFCR, SCFCR_RFRST | SCFCR_TFRST);
+	}
+
+	smr_val = sci_in (port, SCSMR) & 3;
+	if ((cflag & CSIZE) == CS7)
+		smr_val |= 0x40;
+	if (cflag & PARENB)
+		smr_val |= 0x20;
+	if (cflag & PARODD)
+		smr_val |= 0x30;
+	if (cflag & CSTOPB)
+		smr_val |= 0x08;
+	sci_out (port, SCSMR, smr_val);
+	sci_set_baud (port, baud);
+
+	port->init_pins (port, cflag);
+	sci_out (port, SCSCR, SCSCR_INIT (port));
+}
+
+int serial_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	int cflags = CS8 | CREAD | HUPCL | CLOCAL | CRTSCTS;
+	sci_set_termios_cflag (&sci_ports[CONFIG_CONS_INDEX], cflags,
+			       gd->baudrate);
+	return (0);
+}
+
+void serial_putc (const char c)
+{
+	if (c == 10)
+		put_char (&sci_ports[CONFIG_CONS_INDEX], '\r');
+	put_char (&sci_ports[CONFIG_CONS_INDEX], c);
+}
+
+void serial_puts (const char *s)
+{
+	while (*s) {
+		serial_putc (*s++);
+	}
+}
+
+int serial_getc (void)
+{
+	return get_char (&sci_ports[CONFIG_CONS_INDEX]);
+}
+
+int serial_tstc (void)
+{
+	return is_char_ready (&sci_ports[CONFIG_CONS_INDEX]);
+}
+
+void serial_setbrg (void)
+{
+	/* */
+}
+
+#endif /* CONFIG_SH_SCIF_SERIAL */
diff --git a/drivers/serial/stm-asc.c b/drivers/serial/stm-asc.c
new file mode 100644
index 0000000..de241ca
--- /dev/null
+++ b/drivers/serial/stm-asc.c
@@ -0,0 +1,291 @@
+/*
+ * drivers/stm-asc.c
+ *
+ * Support for Serial I/O using STMicroelectronics' on-chip ASC.
+ *
+ *  Copyright (c) 2004  STMicroelectronics Limited
+ *  Copyright (C) 1999  Takeshi Yaegachi & Niibe Yutaka
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License.  See the file "COPYING.LIB" in the main
+ * directory of this archive for more details.
+ *
+ */
+
+#include "common.h"
+
+#ifdef CONFIG_STM_ASC_SERIAL
+
+#include "asm/termbits.h"
+#include "asm/io.h"
+#include "asm/pio.h"
+
+#define CREAD	0000200
+#define HUPCL	0002000
+#define CLOCAL	0004000
+#define	CSTOPB	0000100
+#define CSIZE	0000060
+#define CS7	0000040
+#define CS8	0000060
+#define PARENB	0000400
+#define PARODD  0001000
+
+#define BAUDMODE	0x00001000
+#define CTSENABLE	0x00000800
+#define RXENABLE	0x00000100
+#define RUN		0x00000080
+#define LOOPBACK	0x00000000
+#define STOPBIT		0x00000008
+#define MODE		0x00000001
+#define MODE_7BIT_PAR	0x0003
+#define MODE_8BIT_PAR	0x0007
+#define MODE_8BIT	0x0001
+#define STOP_1BIT	0x0008
+#define PARITYODD	0x0020
+
+#define STA_NKD		0x0400
+#define STA_TF		0x0200
+#define STA_RHF		0x0100
+#define STA_TOI		0x0080
+#define STA_TNE		0x0040
+#define STA_OE		0x0020
+#define STA_FE		0x0010
+#define STA_PE		0x0008
+#define	STA_THE		0x0004
+#define STA_TE		0x0002
+#define STA_RBF		0x0001
+
+
+#define UART_BAUDRATE_OFFSET    0x00
+#define UART_TXBUFFER_OFFSET    0x04
+#define UART_RXBUFFER_OFFSET    0x08
+#define UART_CONTROL_OFFSET     0x0C
+#define UART_INTENABLE_OFFSET   0x10
+#define UART_STATUS_OFFSET      0x14
+#define UART_GUARDTIME_OFFSET   0x18
+#define UART_TIMEOUT_OFFSET     0x1C
+#define UART_TXRESET_OFFSET     0x20
+#define UART_RXRESET_OFFSET     0x24
+#define UART_RETRIES_OFFSET     0x28
+
+#define UART_BAUDRATE_REG   (CFG_STM_ASC_BASE + UART_BAUDRATE_OFFSET)
+#define UART_TXBUFFER_REG   (CFG_STM_ASC_BASE + UART_TXBUFFER_OFFSET)
+#define UART_RXBUFFER_REG   (CFG_STM_ASC_BASE + UART_RXBUFFER_OFFSET)
+#define UART_CONTROL_REG    (CFG_STM_ASC_BASE + UART_CONTROL_OFFSET)
+#define UART_INTENABLE_REG  (CFG_STM_ASC_BASE + UART_INTENABLE_OFFSET)
+#define UART_STATUS_REG     (CFG_STM_ASC_BASE + UART_STATUS_OFFSET)
+#define UART_GUARDTIME_REG  (CFG_STM_ASC_BASE + UART_GUARDTIME_OFFSET)
+#define UART_TIMEOUT_REG    (CFG_STM_ASC_BASE + UART_TIMEOUT_OFFSET)
+#define UART_TXRESET_REG    (CFG_STM_ASC_BASE + UART_TXRESET_OFFSET)
+#define UART_RXRESET_REG    (CFG_STM_ASC_BASE + UART_RXRESET_OFFSET)
+#define UART_RETRIES_REG    (CFG_STM_ASC_BASE + UART_RETRIES_OFFSET)
+
+
+/*---- Values for the BAUDRATE Register -----------------------*/
+
+
+#if defined(CONFIG_SH_STB7100) || defined(CONFIG_SH_STX7200)
+#define PCLK			(gd->bd->bi_emifrq*1000000)
+#define BAUDRATE_VAL_M0(bps)	(PCLK / (16 * (bps)))
+#define BAUDRATE_VAL_M1(bps)    ( (((bps * (1 << 14))+ (1<<13)) / (PCLK/(1 << 6))))
+#else
+#define PCLK			B_CLOCK_RATE
+#define BAUDRATE_VAL_M0(bps)	(PCLK / (16 * (bps)))
+#define BAUDRATE_VAL_M1(bps)	(int)((((double)bps * (1 << 20))/ PCLK)+0.5)
+#endif
+
+/*
+ * MODE 0
+ *                       ICCLK
+ * ASCBaudRate =   ----------------
+ *                   baudrate * 16
+ *
+ * MODE 1
+ *                   baudrate * 16 * 2^16
+ * ASCBaudRate =   ------------------------
+ *                          ICCLK
+ */
+
+#define BPS_2400	BAUDRATE_VAL_M0(2400)
+#define BPS_4800	BAUDRATE_VAL_M0(4800)
+#define BPS_9600	BAUDRATE_VAL_M0(9600)
+#define BPS_19200	BAUDRATE_VAL_M1(19200)
+#define BPS_38400	BAUDRATE_VAL_M1(38400)
+#define BPS_57600	BAUDRATE_VAL_M1(57600)
+#define BPS_96000	BAUDRATE_VAL_M1(96000)
+#define BPS_115200	BAUDRATE_VAL_M1(115200)
+
+
+#if defined(CONFIG_STM_ST231)
+
+#define p2_outl(addr,b) writel(b,addr)
+#define p2_inl(addr)    readl(addr)
+
+#endif
+
+
+/* This function should be implemented for asc driver */
+void handleError (void)
+{
+	return;
+}
+
+static int hwflow = 0;		/* turned off by default */
+
+int serial_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	int cflag = CREAD | HUPCL | CLOCAL | CSTOPB;
+	unsigned int status;
+	int baud = gd->baudrate;
+	int t;
+	int p2_val;
+	switch (baud) {
+	case 0:
+		t = -1;
+		break;
+	case 2400:
+		t = BPS_2400;
+		break;
+	case 4800:
+		t = BPS_4800;
+		break;
+	case 9600:
+		t = BPS_9600;
+		break;
+	case 19200:
+		t = BPS_19200;
+		break;
+	case 38400:
+		t = BPS_38400;
+		break;
+	case 57600:
+		t = BPS_57600;
+		break;
+	default:
+		printf ("sci: unsupported baud rate: %d, using 115200 instead.\n", baud);
+	case 115200:
+		t = BPS_115200;
+		break;
+	}
+
+	cflag |= CS8;
+	cflag |= PARODD;
+
+	/* wait for end of current transmission */
+	do {
+		status = p2_inl (UART_STATUS_REG);
+	} while (status & STA_TF);
+
+	p2_val = p2_inl (UART_CONTROL_REG);
+	p2_outl (UART_CONTROL_REG, (p2_val & ~RUN));
+	p2_val = RXENABLE;
+
+	/* reset fifo rx e tx */
+	p2_outl (UART_TXRESET_REG, 1);
+	p2_outl (UART_RXRESET_REG, 1);
+
+	/* set character length */
+	if ((cflag & CSIZE) == CS7)
+		p2_val |= MODE_7BIT_PAR;
+	else {
+		if (cflag & PARENB)
+			p2_val |= MODE_8BIT_PAR;
+		else
+			p2_val |= MODE_8BIT;
+	}
+
+	/* set stop bit */
+	/* it seems no '0 stop bits' option is available: by default
+	 * we get 0.5 stop bits */
+	if (cflag & CSTOPB)
+		p2_val |= STOP_1BIT;
+
+	/* odd parity */
+	if (cflag & PARODD)
+		p2_val |= PARITYODD;
+
+	/*  set flow control */
+	if (hwflow)
+		p2_val |= CTSENABLE;
+
+	/* set speed and baud generator mode */
+	p2_outl (UART_BAUDRATE_REG, t);
+	p2_val |= BAUDMODE;
+
+	/* write final value and enable port */
+	p2_outl (UART_CONTROL_REG, (p2_val | RUN));
+	return 0;
+}
+
+int serial_tstc (void)
+{
+	unsigned short status;
+
+	status = p2_inl (UART_STATUS_REG);
+	return (status & STA_RBF);
+}
+
+/* This function doesn't correctly work */
+int serial_getc (void)
+{
+	char ch;
+
+	while (!serial_tstc ());
+
+	ch = p2_inl (UART_RXBUFFER_REG);
+
+	return ch;
+}
+
+static inline int putDebugCharReady (void)
+{
+	unsigned long status;
+
+	status = p2_inl (UART_STATUS_REG);
+	return !(status & STA_TF);
+}
+
+void serial_putc (char ch)
+{
+	if (ch == 10)
+		serial_putc ('\r');
+	while (!putDebugCharReady ());
+	p2_outl (UART_TXBUFFER_REG, ch);
+}
+
+void serial_puts (const char *s)
+{
+	while (*s) {
+		serial_putc (*s++);
+	}
+}
+
+
+void serial_setbrg (void)
+{
+
+  serial_init();
+}
+
+#ifdef CONFIG_HWFLOW
+int hwflow_onoff (int on)
+{
+	switch (on) {
+	case 0:
+	default:
+		break;		/* return current */
+	case 1:
+		hwflow = 1;	/* turn on */
+		serial_init ();
+		break;
+	case -1:
+		hwflow = 0;	/* turn off */
+		serial_init ();
+		break;
+	}
+	return hwflow;
+}
+#endif
+
+#endif	/* CONFIG_STM_ASC_SERIAL */
diff --git a/drivers/usb/Makefile b/drivers/usb/Makefile
index f8ea167..2b6de5a 100644
--- a/drivers/usb/Makefile
+++ b/drivers/usb/Makefile
@@ -50,3 +50,6 @@ include $(SRCTREE)/rules.mk
 sinclude $(obj).depend
 
 #########################################################################
+
+usb_ohci.o:	CFLAGS += -Wno-strict-aliasing
+
diff --git a/drivers/usb/usb_ohci.c b/drivers/usb/usb_ohci.c
index cfa384e..cb06316 100644
--- a/drivers/usb/usb_ohci.c
+++ b/drivers/usb/usb_ohci.c
@@ -72,6 +72,43 @@
 # define OHCI_USE_NPS		/* force NoPowerSwitching mode */
 #endif
 
+/*
+ * On the SuperH architecture, we need to pass 'physical' addresses
+ * to the on-chip USB hardware, and not use 'virtual' CPU addresses.
+ *
+ * In 29-bit mode, we just zero the top 3 bits of the virtual address.
+ *
+ * In 32-bit mode, we need to honour the PMB mappings.
+ * 	i.e. VA 0x80000000 == PA 0x40000000
+ *
+ * Note: We must not modify at all if the address is 0x00000000.
+ */
+#ifdef __SH4__
+#if defined(CONFIG_SH_SE_MODE)
+#	define PHYSICAL_ADDR(addr)	\
+	((__u32)(addr) ? ((0x1ffffffful&(__u32)(addr))|0x40000000ul) : 0ul)
+#else
+#	define PHYSICAL_ADDR(addr)	( 0x1ffffffful & (__u32)(addr) )
+#endif	/* CONFIG_SH_SE_MODE */
+#else	/* __SH4__ */
+#	define PHYSICAL_ADDR(addr)	(addr)
+#endif	/* __SH4__ */
+
+/* WARNING! WARNING! WARNING! WARNING!
+ * Uncommenting the following line will remove some delays in the USB
+ * sub-system. However, it is possible that some of these removed delays
+ * may be actually necessary on some hardware devices.
+ * So, although this gives a useful performance improvement, it does
+ * so at the potential risk of reliability and stability.  This should be
+ * considered as an experiential configuration, and not at all recommended
+ * for production or deployment code, unless it has been thoroughly
+ * tested for your specific hardware.
+ * Enabling this optimisation makes some assumptions, that may be totally
+ * without any foundation.  If reliability or stability becomes an issue,
+ * then please disable this configuration option, as a first step.
+ * Use it at your own peril - caveat emptor! */
+//#define CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS
+
 #undef OHCI_VERBOSE_DEBUG	/* not always helpful */
 #undef DEBUG
 #undef SHOW_INFO
@@ -414,7 +451,7 @@ static void ohci_dump (ohci_t *controller, int verbose)
 		ep_print_int_eds (controller, "hcca");
 	dbg ("hcca frame #%04x", controller->hcca->frame_no);
 	ohci_dump_roothub (controller, 1);
-
+}
 #endif /* DEBUG */
 
 /*-------------------------------------------------------------------------*
@@ -631,9 +668,9 @@ static int ep_link (ohci_t *ohci, ed_t *edi)
 	case PIPE_CONTROL:
 		ed->hwNextED = 0;
 		if (ohci->ed_controltail == NULL) {
-			writel (ed, &ohci->regs->ed_controlhead);
+			writel (PHYSICAL_ADDR(ed), &ohci->regs->ed_controlhead);
 		} else {
-			ohci->ed_controltail->hwNextED = m32_swap ((unsigned long)ed);
+			ohci->ed_controltail->hwNextED = PHYSICAL_ADDR(m32_swap ((unsigned long)ed));
 		}
 		ed->ed_prev = ohci->ed_controltail;
 		if (!ohci->ed_controltail && !ohci->ed_rm_list[0] &&
@@ -647,9 +684,9 @@ static int ep_link (ohci_t *ohci, ed_t *edi)
 	case PIPE_BULK:
 		ed->hwNextED = 0;
 		if (ohci->ed_bulktail == NULL) {
-			writel (ed, &ohci->regs->ed_bulkhead);
+			writel (PHYSICAL_ADDR(ed), &ohci->regs->ed_bulkhead);
 		} else {
-			ohci->ed_bulktail->hwNextED = m32_swap ((unsigned long)ed);
+			ohci->ed_bulktail->hwNextED = PHYSICAL_ADDR(m32_swap ((unsigned long)ed));
 		}
 		ed->ed_prev = ohci->ed_bulktail;
 		if (!ohci->ed_bulktail && !ohci->ed_rm_list[0] &&
@@ -788,7 +825,7 @@ static ed_t * ep_add_ed (struct usb_device *usb_dev, unsigned long pipe,
 		ed->hwINFO = m32_swap (OHCI_ED_SKIP); /* skip ed */
 		/* dummy td; end of td list for ed */
 		td = td_alloc (usb_dev);
-		ed->hwTailP = m32_swap ((unsigned long)td);
+		ed->hwTailP = PHYSICAL_ADDR(m32_swap ((unsigned long)td));
 		ed->hwHeadP = ed->hwTailP;
 		ed->state = ED_UNLINK;
 		ed->type = usb_pipetype (pipe);
@@ -851,12 +888,12 @@ static void td_fill (ohci_t *ohci, unsigned int info,
 		data = 0;
 
 	td->hwINFO = m32_swap (info);
-	td->hwCBP = m32_swap ((unsigned long)data);
+	td->hwCBP = PHYSICAL_ADDR(m32_swap ((unsigned long)data));
 	if (data)
-		td->hwBE = m32_swap ((unsigned long)(data + len - 1));
+		td->hwBE = PHYSICAL_ADDR(m32_swap ((unsigned long)(data + len - 1)));
 	else
 		td->hwBE = 0;
-	td->hwNextTD = m32_swap ((unsigned long)td_pt);
+	td->hwNextTD = PHYSICAL_ADDR(m32_swap ((unsigned long)td_pt));
 
 	/* append to queue */
 	td->ed->hwTailP = td->hwNextTD;
@@ -875,6 +912,7 @@ static void td_submit_job (struct usb_device *dev, unsigned long pipe, void *buf
 	int cnt = 0;
 	__u32 info = 0;
 	unsigned int toggle = 0;
+	volatile struct ed * ed;
 
 	/* OHCI handles the DATA-toggles itself, we just use the USB-toggle bits for reseting */
 	if(usb_gettoggle(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe))) {
@@ -902,6 +940,27 @@ static void td_submit_job (struct usb_device *dev, unsigned long pipe, void *buf
 		td_fill (ohci, info | (cnt? TD_T_TOGGLE:toggle), data, data_len, dev, cnt, urb);
 		cnt++;
 
+		/* check for possible DataToggle errors */
+		ed = urb->td[0]->ed;
+		if ( ((ed->hwHeadP>>1)&0x1) != (toggle ? 0 : 1) )
+		{
+			/*
+			 * If we were now to instruct the HC to process
+			 * the TDs, we would yield a DataToggle error.
+			 * We correct this here, by ensuring the HC
+			 * is back in sync with the device.
+			 */
+#if 0
+			printf ("\n************************************************************\n"
+				"OHCI: Correcting putative DataToggle Error for dev=%u, en=%u-%s\n"
+				"************************************************************\n",
+				usb_pipedevice(pipe),
+				usb_pipeendpoint(pipe),
+				usb_pipeout(pipe) ? "O" : "I");
+#endif
+				/* invert the "toggleCarry" bit in the ED */
+			ed->hwHeadP ^= 0x2;
+		}
 		if (!ohci->sleeping)
 			writel (OHCI_BLF, &ohci->regs->cmdstatus); /* start bulk list */
 		break;
@@ -1032,6 +1091,12 @@ static int dl_done_list (ohci_t *ohci, td_t *td_list)
 			stat = cc_to_error[cc];
 		}
 
+		/* save the toggleCarry bit, for later use */
+		usb_settoggle (lurb_priv->dev,
+			usb_pipeendpoint(lurb_priv->pipe),
+			usb_pipeout(lurb_priv->pipe),
+			(ed->hwHeadP>>1)&0x1);
+
 		/* see if this done list makes for all TD's of current URB,
 		 * and mark the URB finished if so */
 		if (++(lurb_priv->td_cnt) == lurb_priv->length) {
@@ -1454,7 +1519,9 @@ int submit_common_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
 	urb->actual_length = 0;
 	pkt_print(urb, dev, pipe, buffer, transfer_len, setup, "SUB", usb_pipein(pipe));
 #else
+#ifndef CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS
 	wait_ms(1);
+#endif	/* CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS */
 #endif
 	if (!maxsize) {
 		err("submit_common_message: pipesize for pipe %lx is zero",
@@ -1478,6 +1545,10 @@ int submit_common_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
 		timeout = BULK_TO;
 	else
 		timeout = 100;
+#ifdef CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS
+	/* use units of 100us, instead of 1ms */
+	timeout *= 10;
+#endif	/* CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS */
 
 	/* wait for it to complete */
 	for (;;) {
@@ -1503,7 +1574,12 @@ int submit_common_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
 		}
 
 		if (--timeout) {
+#ifdef CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS
+			/* use units of 100us, instead of 1ms */
+			udelay(100);
+#else
 			wait_ms(1);
+#endif	/* CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS */
 			if (!urb->finished)
 				dbg("\%");
 
@@ -1522,7 +1598,9 @@ int submit_common_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
 #ifdef DEBUG
 	pkt_print(urb, dev, pipe, buffer, transfer_len, setup, "RET(ctlr)", usb_pipein(pipe));
 #else
+#ifndef CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS
 	wait_ms(1);
+#endif	/* CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS */
 #endif
 
 	/* free TDs in urb_priv */
@@ -1548,7 +1626,9 @@ int submit_control_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
 #ifdef DEBUG
 	pkt_print(NULL, dev, pipe, buffer, transfer_len, setup, "SUB", usb_pipein(pipe));
 #else
+#ifndef CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS
 	wait_ms(1);
+#endif	/* CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS */
 #endif
 	if (!maxsize) {
 		err("submit_control_message: pipesize for pipe %lx is zero",
@@ -1640,7 +1720,7 @@ static int hc_start (ohci_t * ohci)
 	writel (0, &ohci->regs->ed_controlhead);
 	writel (0, &ohci->regs->ed_bulkhead);
 
-	writel ((__u32)ohci->hcca, &ohci->regs->hcca); /* a reset clears this */
+	writel (PHYSICAL_ADDR((__u32)ohci->hcca), &ohci->regs->hcca); /* a reset clears this */
 
 	fminterval = 0x2edf;
 	writel ((fminterval * 9) / 10, &ohci->regs->periodicstart);
@@ -1738,7 +1818,9 @@ static int hc_interrupt (void)
 	}
 
 	if (ints & OHCI_INTR_WDH) {
+#ifndef CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS
 		wait_ms(1);
+#endif	/* CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS */
 		writel (OHCI_INTR_WDH, &regs->intrdisable);
 		(void)readl (&regs->intrdisable); /* flush */
 		stat = dl_done_list (&gohci, dl_reverse_done_list (&gohci));
diff --git a/examples/Makefile b/examples/Makefile
index e9b4974..9aa829b 100644
--- a/examples/Makefile
+++ b/examples/Makefile
@@ -61,6 +61,15 @@ ifeq ($(ARCH),avr32)
 LOAD_ADDR = 0x00000000
 endif
 
+ifeq ($(ARCH),sh)
+include $(TOPDIR)/include/config.mk
+ifneq (,$(findstring $(BOARD),mb411 mb442))
+LOAD_ADDR = 0x84000000
+else
+LOAD_ADDR = 0x88000000
+endif
+endif
+
 include $(TOPDIR)/config.mk
 
 ELF	= hello_world
diff --git a/examples/stubs.c b/examples/stubs.c
index 26df6e0..3f965b0 100644
--- a/examples/stubs.c
+++ b/examples/stubs.c
@@ -151,6 +151,24 @@ gd_t *global_data;
 		:					\
 		: "i"(offsetof(gd_t, jt)), "i"(XF_ ##x)	\
 		: "r8");
+#elif defined(CONFIG_SH4)
+/*
+ * r13 holds the pointer to the global_data. r0 is a call-clobbered.
+ */
+#define EXPORT_FUNC(x)				\
+do {						\
+	int o;					\
+	asm volatile (				\
+	".globl " #x "\n"			\
+	#x ":");				\
+	o=offsetof(gd_t, jt);			\
+	asm volatile (				\
+		"mov.l	@(%0, r13), r0\n"	\
+	"	mov.l	@(r0, %1), r0\n"	\
+	"	jmp	@r0\n"			\
+	"	nop\n"				\
+	: "+z"(o) : "r"(XF_ ## x * sizeof(void *))) ; \
+} while (0);
 #else
 #error stubs definition missing for this architecture
 #endif
@@ -189,3 +207,4 @@ void app_startup(char **argv)
 }
 
 #undef EXPORT_FUNC
+
diff --git a/include/asm-sh/addrspace.h b/include/asm-sh/addrspace.h
new file mode 100644
index 0000000..78c8e54
--- /dev/null
+++ b/include/asm-sh/addrspace.h
@@ -0,0 +1,77 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1999 by Kaz Kojima
+ *
+ * Defitions for the address spaces of the SH CPUs.
+ */
+#ifndef __ASM_SH_ADDRSPACE_H
+#define __ASM_SH_ADDRSPACE_H
+
+/* Memory segments (32bit Priviledged mode addresses)  */
+#define P0SEG		0x00000000
+#define P1SEG		0x80000000
+#define P2SEG		0xa0000000
+#define P3SEG		0xc0000000
+#define P4SEG		0xe0000000
+
+#if defined(__sh3__)
+/* Should fill here */
+#elif defined(__SH4__)
+/* Detailed P4SEG  */
+#define P4SEG_STORE_QUE	(P4SEG)
+#define P4SEG_IC_ADDR	0xf0000000
+#define P4SEG_IC_DATA	0xf1000000
+#define P4SEG_ITLB_ADDR	0xf2000000
+#define P4SEG_ITLB_DATA	0xf3000000
+#define P4SEG_OC_ADDR	0xf4000000
+#define P4SEG_OC_DATA	0xf5000000
+#define P4SEG_TLB_ADDR	0xf6000000
+#define P4SEG_PMB_ADDR	0xf6100000
+#define P4SEG_TLB_DATA	0xf7000000
+#define P4SEG_PMB_DATA	0xf7100000
+#define P4SEG_REG_BASE	0xff000000
+#endif
+
+
+/* ----------------------------------------------------------------------------
+		29-bit Mode memory alias translations
+   ---------------------------------------------------------------------------*/
+#ifndef CONFIG_SH_SE_MODE
+
+/* Returns the privileged segment base of a given address  */
+#define PXSEG(a)	(((unsigned long)(a)) & 0xe0000000)
+
+/* Returns the physical address of a PnSEG (n=1,2) address   */
+#define PHYSADDR(a)	(((unsigned long)(a)) & 0x1fffffff)
+
+/*
+ * Map an address to a certain privileged segment
+ */
+#define P1SEGADDR(a)	((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | P1SEG))
+#define P2SEGADDR(a)	((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | P2SEG))
+#define P3SEGADDR(a)	((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | P3SEG))
+#define P4SEGADDR(a)	((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | P4SEG))
+#endif /* CONFIG_SH_SE_MODE */
+
+
+/* ----------------------------------------------------------------------------
+		SE-Mode memory alias translations
+   ---------------------------------------------------------------------------*/
+#ifdef CONFIG_SH_SE_MODE
+#if !defined(CFG_SE_SDRAM_WINDOW) || !defined(CFG_SE_PHYSICAL_BASE) || !defined(CFG_SE_UNACHED_BASE)
+#error	SH-4 SE Memory Mappings needs to be defined!
+#endif
+	/*
+	 *	Convert VIRTUAL (cached) address to a UN-CACHED one.
+	 */
+#define P2SEGADDR(a)	(((unsigned long)(a)&CFG_SE_SDRAM_WINDOW)|CFG_SE_UNACHED_BASE)
+	/*
+	 *	Convert VIRTUAL address to a PHYSICAL one.
+	 */
+#define PHYSADDR(a)	(((unsigned long)(a)&CFG_SE_SDRAM_WINDOW)|CFG_SE_PHYSICAL_BASE)
+#endif	/* CONFIG_SH_SE_MODE */
+
+#endif /* __ASM_SH_ADDRSPACE_H */
diff --git a/include/asm-sh/asmdefs.h b/include/asm-sh/asmdefs.h
new file mode 100644
index 0000000..7163fd5
--- /dev/null
+++ b/include/asm-sh/asmdefs.h
@@ -0,0 +1,184 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* Macros to support assembly programing */
+
+
+	/* build up a 32-bit constant into R0 */
+.macro MOV_CONST32_R0 p1:req
+	mov	#(\p1>>24), r0
+	shll8	r0
+	.ifne    ((\p1 >> 16)&0xFF)
+	or	#((\p1 >> 16)&0xFF), r0
+	.endif
+	shll8	r0
+	.ifne    ((\p1 >> 8) &0xFF)
+	or	#((\p1 >> 8) &0xFF), r0
+	.endif
+	shll8	r0
+	.ifne    (\p1 &0xFF)
+	or	#(\p1 &0xFF), r0
+	.endif
+.endm
+
+	/* build up a 16-bit constant into R0 */
+.macro MOV_CONST16_R0 p1:req
+	mov	#((\p1 >> 8) &0xFF), r0
+	shll8	r0
+	.ifne    (\p1 &0xFF)
+	or	#(\p1 &0xFF), r0
+	.endif
+.endm
+
+	/* unset top 3 bits of PC */
+.macro ENTER_P0
+	mova	1f, r0
+	mov	#0xE0, r1
+	shll16	r1
+	shll8	r1
+	not	r1, r1		/* MASK is 0x1fffffff */
+	and	r1, r0		/* unset top 3-bits */
+	jmp	@r0
+	  nop
+.balign 4
+1:
+.endm
+
+	/* OR 0x80 into top byte of PC */
+.macro ENTER_P1
+	mova	1f, r0
+	mov	#0xE0, r1
+	shll16	r1
+	shll8	r1
+	not	r1, r1		/* MASK is 0x1fffffff */
+	and	r1, r0		/* unset top 3-bits */
+	mov	#0x80, r1
+	shll16	r1
+	shll8	r1		/* MASK is 0x80000000 */
+	or	r1, r0		/* put PC in P1 */
+	jmp	@r0
+	  nop
+.balign 4
+1:
+.endm
+
+	/* OR 0xA0 into top byte of PC */
+.macro ENTER_P2
+	mova	1f, r0
+	mov	#0xE0, r1
+	shll16	r1
+	shll8	r1
+	not	r1, r1		/* MASK is 0x1fffffff */
+	and	r1, r0		/* unset top 3-bits */
+	mov	#0xA0, r1
+	shll16	r1
+	shll8	r1		/* MASK is 0xA0000000 */
+	or	r1, r0		/* put PC in P2 */
+	jmp	@r0
+	  nop
+.balign 4
+1:
+.endm
+
+	/* call a routine in another file */
+.macro CALL p1:req
+	mova	\p1, r0
+	mov.l	@r0, r1
+	add	r1, r0
+	jsr	@r0
+	  nop
+.endm
+
+	/* put device id in p1 */
+.macro GETDEVID p1:req
+#ifdef CONFIG_SH_STB7100
+	mov.l	1f, r0
+	mov.l	@r0, \p1
+	mov.l	2f, r0
+	bra	3f
+	  and	r0, \p1
+	.balign 4
+1:	.long STB7100_SYSCONF_DEVICEID_0
+2:	.long (STB7100_DEVID_ID_MASK << STB7100_DEVID_ID_SHIFT) | (STB7100_DEVID_CUT_MASK << STB7100_DEVID_CUT_SHIFT)
+3:
+#endif
+.endm
+
+/* Enable a single PMB entry
+Note: This macro will clobber both r0 and r1.
+Usage: SH4_SET_PMB <index> <virtual> <physical> <size> [<cache>=1 [<wt>=0 [<ub>=0]]]]
+where <index> is the PMB entry
+	<virtual> is the virtual page number	(required)
+	<physical> is the physical page number	(required)
+	<size> is the page size in MBytes	(required)
+	<cache> is optional and is the page cacheability (default: 1 [on])
+	<wt> is optional and is the page cache mode (default: 0 [copy-back])
+	<ub> is optional and is the page buffer mode (default: 0 [buffered]) */
+.macro SH4_SET_PMB i:req, vpn:req, ppn:req, size:req, cache=1, wt=0, ub=0
+	.set pmbdata, 0
+
+	.if (\size==16)		/* PMB[n].SZ */
+		.set pmbdata, pmbdata|0x00000000
+	.elseif (\size==64)
+		.set pmbdata, pmbdata|0x00000010
+	.elseif (\size==128)
+		.set pmbdata, pmbdata|0x00000080
+	.elseif (\size==512)
+		.set pmbdata, pmbdata|0x00000090
+	.else
+		.error "Unsupported page SIZE for a PMB entry"
+	.endif
+
+	.if (\cache)		/* PMB[n].C */
+		.set pmbdata, pmbdata|(SH4_PMB_C)
+	.endif
+
+	.if (\wt)		/* PMB[n].WT */
+		.set pmbdata, pmbdata|(SH4_PMB_WT)
+	.endif
+
+	.if (\ub)		/* PMB[n].UB */
+		.set pmbdata, pmbdata|(SH4_PMB_UB)
+	.endif
+
+	.if ( (\vpn<0x80) || (\vpn>=0xc0) )
+		.error "Invalid Virtual Page Number for PMB entry"
+	.endif
+
+	.if (\i>15)
+		.error "Invalid Index for PMB entry"
+	.endif
+
+		/* poke ADDR_ARRAY entry */
+	MOV_CONST32_R0	(\vpn<<24)
+	mov	r0,r1
+	MOV_CONST32_R0	(P4SEG_PMB_ADDR | (\i<<8))
+	mov.l	r1,@r0
+
+		/* poke DATA_ARRAY entry */
+	MOV_CONST32_R0	((\ppn<<24) | SH4_PMB_V | pmbdata)
+	mov	r0,r1
+	MOV_CONST32_R0	(P4SEG_PMB_DATA | (\i<<8))
+	mov.l	r1,@r0
+.endm
diff --git a/include/asm-sh/bitops.h b/include/asm-sh/bitops.h
new file mode 100644
index 0000000..22b4b1f
--- /dev/null
+++ b/include/asm-sh/bitops.h
@@ -0,0 +1,378 @@
+/*
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef __ASM_SH_BITOPS_H
+#define __ASM_SH_BITOPS_H
+
+#ifdef __KERNEL__
+#include <asm/system.h>
+/* For __swab32 */
+#include <asm/byteorder.h>
+
+static __inline__ void set_bit (int nr, volatile void *addr)
+{
+	int mask;
+	volatile unsigned int *a = addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	save_and_cli (flags);
+	*a |= mask;
+	restore_flags (flags);
+}
+
+static __inline__ void __set_bit (int nr, volatile void *addr)
+{
+	int mask;
+	volatile unsigned int *a = addr;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	*a |= mask;
+}
+
+/*
+ * clear_bit() doesn't provide any barrier for the compiler.
+ */
+#define smp_mb__before_clear_bit()	barrier()
+#define smp_mb__after_clear_bit()	barrier()
+static __inline__ void clear_bit (int nr, volatile void *addr)
+{
+	int mask;
+	volatile unsigned int *a = addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	save_and_cli (flags);
+	*a &= ~mask;
+	restore_flags (flags);
+}
+
+static __inline__ void __clear_bit (int nr, volatile void *addr)
+{
+	int mask;
+	volatile unsigned int *a = addr;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	*a &= ~mask;
+}
+
+static __inline__ void change_bit (int nr, volatile void *addr)
+{
+	int mask;
+	volatile unsigned int *a = addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	save_and_cli (flags);
+	*a ^= mask;
+	restore_flags (flags);
+}
+
+static __inline__ void __change_bit (int nr, volatile void *addr)
+{
+	int mask;
+	volatile unsigned int *a = addr;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	*a ^= mask;
+}
+
+static __inline__ int test_and_set_bit (int nr, volatile void *addr)
+{
+	int mask, retval;
+	volatile unsigned int *a = addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	save_and_cli (flags);
+	retval = (mask & *a) != 0;
+	*a |= mask;
+	restore_flags (flags);
+
+	return retval;
+}
+
+static __inline__ int __test_and_set_bit (int nr, volatile void *addr)
+{
+	int mask, retval;
+	volatile unsigned int *a = addr;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	retval = (mask & *a) != 0;
+	*a |= mask;
+
+	return retval;
+}
+
+static __inline__ int test_and_clear_bit (int nr, volatile void *addr)
+{
+	int mask, retval;
+	volatile unsigned int *a = addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	save_and_cli (flags);
+	retval = (mask & *a) != 0;
+	*a &= ~mask;
+	restore_flags (flags);
+
+	return retval;
+}
+
+static __inline__ int __test_and_clear_bit (int nr, volatile void *addr)
+{
+	int mask, retval;
+	volatile unsigned int *a = addr;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	retval = (mask & *a) != 0;
+	*a &= ~mask;
+
+	return retval;
+}
+
+static __inline__ int test_and_change_bit (int nr, volatile void *addr)
+{
+	int mask, retval;
+	volatile unsigned int *a = addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	save_and_cli (flags);
+	retval = (mask & *a) != 0;
+	*a ^= mask;
+	restore_flags (flags);
+
+	return retval;
+}
+
+static __inline__ int __test_and_change_bit (int nr, volatile void *addr)
+{
+	int mask, retval;
+	volatile unsigned int *a = addr;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	retval = (mask & *a) != 0;
+	*a ^= mask;
+
+	return retval;
+}
+
+static __inline__ int test_bit (int nr, const volatile void *addr)
+{
+	return 1UL & (((const volatile unsigned int *) addr)[nr >> 5] >>
+		      (nr & 31));
+}
+
+static __inline__ unsigned long ffz (unsigned long word)
+{
+	unsigned long result;
+
+      __asm__ ("1:\n\t" "shlr	%1\n\t" "bt/s	1b\n\t" " add	#1, %0":"=r" (result),
+		 "=r"
+		 (word)
+      :	 "0" (~0L), "1" (word)
+      :	 "t");
+	return result;
+}
+
+static __inline__ int find_next_zero_bit (void *addr, int size, int offset)
+{
+	unsigned long *p = ((unsigned long *) addr) + (offset >> 5);
+	unsigned long result = offset & ~31UL;
+	unsigned long tmp;
+
+	if (offset >= size)
+		return size;
+	size -= result;
+	offset &= 31UL;
+	if (offset) {
+		tmp = *(p++);
+		tmp |= ~0UL >> (32 - offset);
+		if (size < 32)
+			goto found_first;
+		if (~tmp)
+			goto found_middle;
+		size -= 32;
+		result += 32;
+	}
+	while (size & ~31UL) {
+		if (~(tmp = *(p++)))
+			goto found_middle;
+		result += 32;
+		size -= 32;
+	}
+	if (!size)
+		return result;
+	tmp = *p;
+
+      found_first:
+	tmp |= ~0UL << size;
+      found_middle:
+	return result + ffz (tmp);
+}
+
+#define find_first_zero_bit(addr, size) \
+	find_next_zero_bit((addr), (size), 0)
+
+/*
+ * ffs: find first bit set. This is defined the same way as
+ * the libc and compiler builtin ffs routines, therefore
+ * differs in spirit from the above ffz (man ffs).
+ */
+
+#define ffs(x) generic_ffs(x)
+
+/*
+ * hweightN: returns the hamming weight (i.e. the number
+ * of bits set) of a N-bit word
+ */
+
+#define hweight32(x) generic_hweight32(x)
+#define hweight16(x) generic_hweight16(x)
+#define hweight8(x) generic_hweight8(x)
+
+#ifdef __LITTLE_ENDIAN__
+#define ext2_set_bit(nr, addr) test_and_set_bit((nr), (addr))
+#define ext2_clear_bit(nr, addr) test_and_clear_bit((nr), (addr))
+#define ext2_test_bit(nr, addr) test_bit((nr), (addr))
+#define ext2_find_first_zero_bit(addr, size) find_first_zero_bit((addr), (size))
+#define ext2_find_next_zero_bit(addr, size, offset) \
+		find_next_zero_bit((addr), (size), (offset))
+#else
+static __inline__ int ext2_set_bit (int nr, volatile void *addr)
+{
+	int mask, retval;
+	unsigned long flags;
+	volatile unsigned char *ADDR = (unsigned char *) addr;
+
+	ADDR += nr >> 3;
+	mask = 1 << (nr & 0x07);
+	save_and_cli (flags);
+	retval = (mask & *ADDR) != 0;
+	*ADDR |= mask;
+	restore_flags (flags);
+	return retval;
+}
+
+static __inline__ int ext2_clear_bit (int nr, volatile void *addr)
+{
+	int mask, retval;
+	unsigned long flags;
+	volatile unsigned char *ADDR = (unsigned char *) addr;
+
+	ADDR += nr >> 3;
+	mask = 1 << (nr & 0x07);
+	save_and_cli (flags);
+	retval = (mask & *ADDR) != 0;
+	*ADDR &= ~mask;
+	restore_flags (flags);
+	return retval;
+}
+
+static __inline__ int ext2_test_bit (int nr, const volatile void *addr)
+{
+	int mask;
+	const volatile unsigned char *ADDR = (const unsigned char *) addr;
+
+	ADDR += nr >> 3;
+	mask = 1 << (nr & 0x07);
+	return ((mask & *ADDR) != 0);
+}
+
+#define ext2_find_first_zero_bit(addr, size) \
+	ext2_find_next_zero_bit((addr), (size), 0)
+
+static __inline__ unsigned long ext2_find_next_zero_bit (void *addr,
+							 unsigned long size,
+							 unsigned long offset)
+{
+	unsigned long *p = ((unsigned long *) addr) + (offset >> 5);
+	unsigned long result = offset & ~31UL;
+	unsigned long tmp;
+
+	if (offset >= size)
+		return size;
+	size -= result;
+	offset &= 31UL;
+	if (offset) {
+		/* We hold the little endian value in tmp, but then the
+		 * shift is illegal. So we could keep a big endian value
+		 * in tmp, like this:
+		 *
+		 * tmp = __swab32(*(p++));
+		 * tmp |= ~0UL >> (32-offset);
+		 *
+		 * but this would decrease preformance, so we change the
+		 * shift:
+		 */
+		tmp = *(p++);
+		tmp |= __swab32 (~0UL >> (32 - offset));
+		if (size < 32)
+			goto found_first;
+		if (~tmp)
+			goto found_middle;
+		size -= 32;
+		result += 32;
+	}
+	while (size & ~31UL) {
+		if (~(tmp = *(p++)))
+			goto found_middle;
+		result += 32;
+		size -= 32;
+	}
+	if (!size)
+		return result;
+	tmp = *p;
+
+      found_first:
+	/* tmp is little endian, so we would have to swab the shift,
+	 * see above. But then we have to swab tmp below for ffz, so
+	 * we might as well do this here.
+	 */
+	return result + ffz (__swab32 (tmp) | (~0UL << size));
+      found_middle:
+	return result + ffz (__swab32 (tmp));
+}
+#endif
+
+/* Bitmap functions for the minix filesystem.  */
+#define minix_test_and_set_bit(nr,addr) test_and_set_bit(nr,addr)
+#define minix_set_bit(nr,addr) set_bit(nr,addr)
+#define minix_test_and_clear_bit(nr,addr) test_and_clear_bit(nr,addr)
+#define minix_test_bit(nr,addr) test_bit(nr,addr)
+#define minix_find_first_zero_bit(addr,size) find_first_zero_bit(addr,size)
+
+#endif /* __KERNEL__ */
+
+#endif /* __ASM_SH_BITOPS_H */
diff --git a/include/asm-sh/byteorder.h b/include/asm-sh/byteorder.h
new file mode 100644
index 0000000..02ebca8
--- /dev/null
+++ b/include/asm-sh/byteorder.h
@@ -0,0 +1,38 @@
+#ifndef __ASM_SH_BYTEORDER_H
+#define __ASM_SH_BYTEORDER_H
+
+/*
+ * Copyright (C) 1999  Niibe Yutaka
+ */
+
+#include <asm/types.h>
+
+static __inline__ __attribute__((const)) __u32 ___arch__swab32 (__u32 x)
+{
+      __asm__ ("swap.b	%0, %0\n\t" "swap.w %0, %0\n\t" "swap.b %0, %0":"=r" (x)
+      :	 "0" (x));
+	return x;
+}
+
+static __inline__ __attribute__((const)) __u16 ___arch__swab16 (__u16 x)
+{
+      __asm__ ("swap.b %0, %0":"=r" (x)
+      :	 "0" (x));
+	return x;
+}
+
+#define __arch__swab32(x) ___arch__swab32(x)
+#define __arch__swab16(x) ___arch__swab16(x)
+
+#if !defined(__STRICT_ANSI__) || defined(__KERNEL__)
+#  define __BYTEORDER_HAS_U64__
+#  define __SWAB_64_THRU_32__
+#endif
+
+#ifdef __LITTLE_ENDIAN__
+#include <linux/byteorder/little_endian.h>
+#else
+#include <linux/byteorder/big_endian.h>
+#endif
+
+#endif /* __ASM_SH_BYTEORDER_H */
diff --git a/include/asm-sh/cache.h b/include/asm-sh/cache.h
new file mode 100644
index 0000000..85cb449
--- /dev/null
+++ b/include/asm-sh/cache.h
@@ -0,0 +1,45 @@
+/*
+ * include/asm-sh/cache.h
+ *
+ * Copyright 1999 (C) Niibe Yutaka
+ * Copyright 2005 (C) Andy Sturges
+ */
+
+#ifndef __ASM_SH_CACHE_H
+#define __ASM_SH_CACHE_H
+
+#define L1_CACHE_BYTES			32
+
+#define CACHE_IC_ADDRESS_ARRAY		0xf0000000
+#define CACHE_OC_ADDRESS_ARRAY		0xf4000000
+
+#if defined(CONFIG_CPU_SUBTYPE_SH4_1XX)		/* it's an SH4-100 */
+#	define DCACHE_WAY_INCR		(1 << 14)
+#	define DCACHE_ENTRY_SHIFT	5
+#	define DCACHE_ENTRY_MASK	0x3fe0
+#	define DCACHE_SETS		512
+#	define DCACHE_WAYS		1
+#	define DCACHE_LINESZ		L1_CACHE_BYTES
+#elif defined(CONFIG_CPU_SUBTYPE_SH4_2XX)	/* it's an SH4-200 */
+#	define DCACHE_SIZE		32768
+#	define DCACHE_WAY_INCR		(DCACHE_SIZE >> 1)
+#	define DCACHE_ENTRY_SHIFT	5
+#	define DCACHE_ENTRY_MASK	(DCACHE_WAY_INCR - (1 << 5))
+#	define DCACHE_SETS		(DCACHE_SIZE >> 6)
+#	define DCACHE_WAYS		2
+#	define DCACHE_LINESZ		L1_CACHE_BYTES
+#else
+#	error Unknown CPU
+#endif
+
+extern void sh_cache_set_op(unsigned long);
+extern void sh_cache_clear_op(unsigned long);
+
+extern void sh_flush_cache_all(void);
+extern void sh_disable_data_caches(void);
+extern void sh_enable_data_caches(void);
+
+/* following stores if the data caches currently on */
+extern int sh_data_caches_on;
+
+#endif /* __ASM_SH_CACHE_H */
diff --git a/include/asm-sh/errno.h b/include/asm-sh/errno.h
new file mode 100644
index 0000000..aafc0e7
--- /dev/null
+++ b/include/asm-sh/errno.h
@@ -0,0 +1,138 @@
+#ifndef _SH_ERRNO_H
+#define _SH_ERRNO_H
+
+#define	EPERM		 1	/* Operation not permitted */
+#define	ENOENT		 2	/* No such file or directory */
+#define	ESRCH		 3	/* No such process */
+#define	EINTR		 4	/* Interrupted system call */
+#define	EIO		 5	/* I/O error */
+#define	ENXIO		 6	/* No such device or address */
+#define	E2BIG		 7	/* Arg list too long */
+#define	ENOEXEC		 8	/* Exec format error */
+#define	EBADF		 9	/* Bad file number */
+#define	ECHILD		10	/* No child processes */
+#define	EAGAIN		11	/* Try again */
+#define	ENOMEM		12	/* Out of memory */
+#define	EACCES		13	/* Permission denied */
+#define	EFAULT		14	/* Bad address */
+#define	ENOTBLK		15	/* Block device required */
+#define	EBUSY		16	/* Device or resource busy */
+#define	EEXIST		17	/* File exists */
+#define	EXDEV		18	/* Cross-device link */
+#define	ENODEV		19	/* No such device */
+#define	ENOTDIR		20	/* Not a directory */
+#define	EISDIR		21	/* Is a directory */
+#define	EINVAL		22	/* Invalid argument */
+#define	ENFILE		23	/* File table overflow */
+#define	EMFILE		24	/* Too many open files */
+#define	ENOTTY		25	/* Not a typewriter */
+#define	ETXTBSY		26	/* Text file busy */
+#define	EFBIG		27	/* File too large */
+#define	ENOSPC		28	/* No space left on device */
+#define	ESPIPE		29	/* Illegal seek */
+#define	EROFS		30	/* Read-only file system */
+#define	EMLINK		31	/* Too many links */
+#define	EPIPE		32	/* Broken pipe */
+#define	EDOM		33	/* Math argument out of domain of func */
+#define	ERANGE		34	/* Math result not representable */
+#define	EDEADLK		35	/* Resource deadlock would occur */
+#define	ENAMETOOLONG	36	/* File name too long */
+#define	ENOLCK		37	/* No record locks available */
+#define	ENOSYS		38	/* Function not implemented */
+#define	ENOTEMPTY	39	/* Directory not empty */
+#define	ELOOP		40	/* Too many symbolic links encountered */
+#define	EWOULDBLOCK	EAGAIN	/* Operation would block */
+#define	ENOMSG		42	/* No message of desired type */
+#define	EIDRM		43	/* Identifier removed */
+#define	ECHRNG		44	/* Channel number out of range */
+#define	EL2NSYNC	45	/* Level 2 not synchronized */
+#define	EL3HLT		46	/* Level 3 halted */
+#define	EL3RST		47	/* Level 3 reset */
+#define	ELNRNG		48	/* Link number out of range */
+#define	EUNATCH		49	/* Protocol driver not attached */
+#define	ENOCSI		50	/* No CSI structure available */
+#define	EL2HLT		51	/* Level 2 halted */
+#define	EBADE		52	/* Invalid exchange */
+#define	EBADR		53	/* Invalid request descriptor */
+#define	EXFULL		54	/* Exchange full */
+#define	ENOANO		55	/* No anode */
+#define	EBADRQC		56	/* Invalid request code */
+#define	EBADSLT		57	/* Invalid slot */
+#define	EDEADLOCK	58	/* File locking deadlock error */
+#define	EBFONT		59	/* Bad font file format */
+#define	ENOSTR		60	/* Device not a stream */
+#define	ENODATA		61	/* No data available */
+#define	ETIME		62	/* Timer expired */
+#define	ENOSR		63	/* Out of streams resources */
+#define	ENONET		64	/* Machine is not on the network */
+#define	ENOPKG		65	/* Package not installed */
+#define	EREMOTE		66	/* Object is remote */
+#define	ENOLINK		67	/* Link has been severed */
+#define	EADV		68	/* Advertise error */
+#define	ESRMNT		69	/* Srmount error */
+#define	ECOMM		70	/* Communication error on send */
+#define	EPROTO		71	/* Protocol error */
+#define	EMULTIHOP	72	/* Multihop attempted */
+#define	EDOTDOT		73	/* RFS specific error */
+#define	EBADMSG		74	/* Not a data message */
+#define	EOVERFLOW	75	/* Value too large for defined data type */
+#define	ENOTUNIQ	76	/* Name not unique on network */
+#define	EBADFD		77	/* File descriptor in bad state */
+#define	EREMCHG		78	/* Remote address changed */
+#define	ELIBACC		79	/* Can not access a needed shared library */
+#define	ELIBBAD		80	/* Accessing a corrupted shared library */
+#define	ELIBSCN		81	/* .lib section in a.out corrupted */
+#define	ELIBMAX		82	/* Attempting to link in too many shared libraries */
+#define	ELIBEXEC	83	/* Cannot exec a shared library directly */
+#define	EILSEQ		84	/* Illegal byte sequence */
+#define	ERESTART	85	/* Interrupted system call should be restarted */
+#define	ESTRPIPE	86	/* Streams pipe error */
+#define	EUSERS		87	/* Too many users */
+#define	ENOTSOCK	88	/* Socket operation on non-socket */
+#define	EDESTADDRREQ	89	/* Destination address required */
+#define	EMSGSIZE	90	/* Message too long */
+#define	EPROTOTYPE	91	/* Protocol wrong type for socket */
+#define	ENOPROTOOPT	92	/* Protocol not available */
+#define	EPROTONOSUPPORT	93	/* Protocol not supported */
+#define	ESOCKTNOSUPPORT	94	/* Socket type not supported */
+#define	EOPNOTSUPP	95	/* Operation not supported on transport endpoint */
+#define	EPFNOSUPPORT	96	/* Protocol family not supported */
+#define	EAFNOSUPPORT	97	/* Address family not supported by protocol */
+#define	EADDRINUSE	98	/* Address already in use */
+#define	EADDRNOTAVAIL	99	/* Cannot assign requested address */
+#define	ENETDOWN	100	/* Network is down */
+#define	ENETUNREACH	101	/* Network is unreachable */
+#define	ENETRESET	102	/* Network dropped connection because of reset */
+#define	ECONNABORTED	103	/* Software caused connection abort */
+#define	ECONNRESET	104	/* Connection reset by peer */
+#define	ENOBUFS		105	/* No buffer space available */
+#define	EISCONN		106	/* Transport endpoint is already connected */
+#define	ENOTCONN	107	/* Transport endpoint is not connected */
+#define	ESHUTDOWN	108	/* Cannot send after transport endpoint shutdown */
+#define	ETOOMANYREFS	109	/* Too many references: cannot splice */
+#define	ETIMEDOUT	110	/* Connection timed out */
+#define	ECONNREFUSED	111	/* Connection refused */
+#define	EHOSTDOWN	112	/* Host is down */
+#define	EHOSTUNREACH	113	/* No route to host */
+#define	EALREADY	114	/* Operation already in progress */
+#define	EINPROGRESS	115	/* Operation now in progress */
+#define	ESTALE		116	/* Stale NFS file handle */
+#define	EUCLEAN		117	/* Structure needs cleaning */
+#define	ENOTNAM		118	/* Not a XENIX named type file */
+#define	ENAVAIL		119	/* No XENIX semaphores available */
+#define	EISNAM		120	/* Is a named type file */
+#define	EREMOTEIO	121	/* Remote I/O error */
+#define	EDQUOT		122	/* Quota exceeded */
+
+#define	ENOMEDIUM	123	/* No medium found */
+#define	EMEDIUMTYPE	124	/* Wrong medium type */
+
+/* Should never be seen by user programs */
+#define ERESTARTSYS	512
+#define ERESTARTNOINTR	513
+#define ERESTARTNOHAND	514	/* restart if no handler.. */
+#define ENOIOCTLCMD	515	/* No ioctl command */
+
+#define _LAST_ERRNO	515
+
+#endif
diff --git a/include/asm-sh/global_data.h b/include/asm-sh/global_data.h
new file mode 100644
index 0000000..4f10e7f
--- /dev/null
+++ b/include/asm-sh/global_data.h
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2002-2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef	__ASM_GBL_DATA_H
+#define __ASM_GBL_DATA_H
+
+
+/*
+ * The following data structure is placed in some memory wich is
+ * available very early after boot (like DPRAM on MPC8xx/MPC82xx, or
+ * some locked parts of the data cache) to allow for a minimum set of
+ * global variables during system initialization (until we have set
+ * up the memory controller so that we can use RAM).
+ *
+ * Keep it *SMALL* and remember to set CFG_GBL_DATA_SIZE > sizeof(gd_t)
+ */
+
+typedef struct global_data
+{
+	bd_t *bd;
+	unsigned long flags;
+	unsigned long baudrate;
+	unsigned long have_console;	/* serial_init() was called */
+	unsigned long ram_size;	/* RAM size */
+	unsigned long reloc_off;	/* Relocation Offset */
+	unsigned long env_addr;	/* Address  of Environment struct */
+	unsigned long env_valid;	/* Checksum of Environment valid? */
+	void **jt;		/* jump table */
+} gd_t;
+
+/*
+ * Global Data Flags
+ */
+
+#define	GD_FLG_RELOC	0x00001	/* Code was relocated to RAM     */
+#define	GD_FLG_DEVINIT	0x00002	/* Devices have been initialized */
+#define	GD_FLG_SILENT	0x00004	/* Silent mode                   */
+
+register volatile gd_t *gd asm ("r13");	/* declare this in all files     */
+
+#define DECLARE_GLOBAL_DATA_PTR
+
+#endif /* __ASM_GBL_DATA_H */
diff --git a/include/asm-sh/io.h b/include/asm-sh/io.h
new file mode 100644
index 0000000..5e92b50
--- /dev/null
+++ b/include/asm-sh/io.h
@@ -0,0 +1,405 @@
+#ifndef __ASM_SH_IO_H
+#define __ASM_SH_IO_H
+
+/*
+ * Convention:
+ *    read{b,w,l}/write{b,w,l} are for PCI,
+ *    while in{b,w,l}/out{b,w,l} are for ISA
+ * These may (will) be platform specific function.
+ * In addition we have 'pausing' versions: in{b,w,l}_p/out{b,w,l}_p
+ * and 'string' versions: ins{b,w,l}/outs{b,w,l}
+ * For read{b,w,l} and write{b,w,l} there are also __raw versions, which
+ * do not have a memory barrier after them.
+ *
+ * In addition, we have
+ *   ctrl_in{b,w,l}/ctrl_out{b,w,l} for SuperH specific I/O.
+ *   which are processor specific.
+ */
+
+/*
+ * We follow the Alpha convention here:
+ *  __inb expands to an inline function call (which either calls via the
+ *        mach_vec if generic, or a machine specific implementation)
+ *  _inb  is a real function call (note ___raw fns are _ version of __raw)
+ *  inb   by default expands to _inb, but the machine specific code may
+ *        define it to __inb if it chooses.
+ */
+
+#include "common.h"
+
+#include "asm/cache.h"
+#include "asm/system.h"
+#include "linux/config.h"
+
+/*
+ * Depending on which platform we are running on, we need different
+ * I/O functions.
+ */
+
+/* Control operations through platform specific headers */
+
+#ifdef __KERNEL__
+
+#define _readb(addr) (*(volatile unsigned char *)(addr))
+#define _readw(addr) (*(volatile unsigned short *)(addr))
+#define _readl(addr) (*(volatile unsigned int *)(addr))
+
+#define _writeb(b,addr) (*(volatile unsigned char *)(addr) = (b))
+#define _writew(b,addr) (*(volatile unsigned short *)(addr) = (b))
+#define _writel(b,addr) (*(volatile unsigned int *)(addr) = (b))
+
+#define __WANT_IO_DEF
+
+#if defined(CONFIG_SH_MB411)	|| \
+       defined(CONFIG_SH_MB442)	|| \
+       defined(CONFIG_SH_MB448)	|| \
+       defined(CONFIG_SH_HMS1)	|| \
+       defined(CONFIG_SH_MB519)	|| \
+       defined(CONFIG_SH_CB101)
+#  include "asm/io_stb1eval.h"
+#else
+#  error "What system is this?"
+#endif
+
+#undef __WANT_IO_DEF
+
+#endif /* __KERNEL__ */
+
+/* These are always function calls, in both kernel and user space */
+
+static __inline__ unsigned char _inb (unsigned long addr)
+{
+	return *(volatile unsigned char *) addr;
+}
+
+static __inline__ unsigned short _inw (unsigned long addr)
+{
+	return *(volatile unsigned short *) addr;
+}
+
+static __inline__ unsigned int _inl (unsigned long addr)
+{
+	return *(volatile unsigned long *) addr;
+}
+
+static __inline__ void _outb (unsigned char b, unsigned long addr)
+{
+	*(volatile unsigned char *) addr = b;
+}
+
+static __inline__ void _outw (unsigned short b, unsigned long addr)
+{
+	*(volatile unsigned short *) addr = b;
+}
+
+static __inline__ void _outl (unsigned int b, unsigned long addr)
+{
+	*(volatile unsigned long *) addr = b;
+}
+
+extern void _insb (unsigned long port, void *dst, unsigned long count);
+extern void _insw (unsigned long port, void *dst, unsigned long count);
+extern void _insl (unsigned long port, void *dst, unsigned long count);
+extern void _outsb (unsigned long port, const void *src, unsigned long count);
+extern void _outsw (unsigned long port, const void *src, unsigned long count);
+extern void _outsl (unsigned long port, const void *src, unsigned long count);
+
+#ifdef __KERNEL__
+extern unsigned char ___raw_readb (unsigned long addr);
+extern unsigned short ___raw_readw (unsigned long addr);
+extern unsigned int ___raw_readl (unsigned long addr);
+extern void ___raw_writeb (unsigned char b, unsigned long addr);
+extern void ___raw_writew (unsigned short b, unsigned long addr);
+extern void ___raw_writel (unsigned int b, unsigned long addr);
+#endif
+
+#ifdef __KERNEL__
+/*
+ * The platform header files may define some of these macros to use
+ * the inlined versions where appropriate.  These macros may also be
+ * redefined by userlevel programs.
+ */
+#ifndef inb
+# define inb(p)		_inb(p)
+#endif
+#ifndef inw
+# define inw(p)		_inw(p)
+#endif
+#ifndef inl
+# define inl(p)		_inl(p)
+#endif
+
+#ifndef outb
+# define outb(b,p)	_outb((b),(p))
+#endif
+#ifndef outw
+# define outw(w,p)	_outw((w),(p))
+#endif
+#ifndef outl
+# define outl(l,p)	_outl((l),(p))
+#endif
+
+#ifndef inb_p
+# define inb_p		_inb_p
+#endif
+#ifndef inw_p
+# define inw_p		_inw_p
+#endif
+#ifndef inl_p
+# define inl_p		_inl_p
+#endif
+
+#ifndef outb_p
+# define outb_p		_outb_p
+#endif
+#ifndef outw_p
+# define outw_p		_outw_p
+#endif
+#ifndef outl_p
+# define outl_p		_outl_p
+#endif
+
+#ifndef insb
+# define insb(p,d,c)	_insb((p),(d),(c))
+#endif
+#ifndef insw
+# define insw(p,d,c)	_insw((p),(d),(c))
+#endif
+#ifndef insl
+# define insl(p,d,c)	_insl((p),(d),(c))
+#endif
+#ifndef outsb
+# define outsb(p,s,c)	_outsb((p),(s),(c))
+#endif
+#ifndef outsw
+# define outsw(p,s,c)	_outsw((p),(s),(c))
+#endif
+#ifndef outsl
+# define outsl(p,s,c)	_outsl((p),(s),(c))
+#endif
+
+#ifdef __raw_readb
+# define readb(a)	({ unsigned long r_ = __raw_readb(a); mb(); r_; })
+#endif
+#ifdef __raw_readw
+# define readw(a)	({ unsigned long r_ = __raw_readw(a); mb(); r_; })
+#endif
+#ifdef __raw_readl
+# define readl(a)	({ unsigned long r_ = __raw_readl(a); mb(); r_; })
+#endif
+
+#ifdef __raw_writeb
+# define writeb(v,a)	({ __raw_writeb((v),(a)); mb(); })
+#endif
+#ifdef __raw_writew
+# define writew(v,a)	({ __raw_writew((v),(a)); mb(); })
+#endif
+#ifdef __raw_writel
+# define writel(v,a)	({ __raw_writel((v),(a)); mb(); })
+#endif
+
+#ifndef __raw_readb
+# define __raw_readb(a)	___raw_readb((unsigned long)(a))
+#endif
+#ifndef __raw_readw
+# define __raw_readw(a)	___raw_readw((unsigned long)(a))
+#endif
+#ifndef __raw_readl
+# define __raw_readl(a)	___raw_readl((unsigned long)(a))
+#endif
+
+#ifndef __raw_writeb
+# define __raw_writeb(v,a)  ___raw_writeb((v),(unsigned long)(a))
+#endif
+#ifndef __raw_writew
+# define __raw_writew(v,a)  ___raw_writew((v),(unsigned long)(a))
+#endif
+#ifndef __raw_writel
+# define __raw_writel(v,a)  ___raw_writel((v),(unsigned long)(a))
+#endif
+
+#ifndef readb
+# define readb(a)	_readb((unsigned long)(a))
+#endif
+#ifndef readw
+# define readw(a)	_readw((unsigned long)(a))
+#endif
+#ifndef readl
+# define readl(a)	_readl((unsigned long)(a))
+#endif
+
+#ifndef writeb
+# define writeb(v,a)	_writeb((v),(unsigned long)(a))
+#endif
+#ifndef writew
+# define writew(v,a)	_writew((v),(unsigned long)(a))
+#endif
+#ifndef writel
+# define writel(v,a)	_writel((v),(unsigned long)(a))
+#endif
+
+#else
+
+/* Userspace declarations.  */
+
+extern unsigned char inb (unsigned long port);
+extern unsigned short inw (unsigned long port);
+extern unsigned int inl (unsigned long port);
+extern void outb (unsigned char b, unsigned long port);
+extern void outw (unsigned short w, unsigned long port);
+extern void outl (unsigned int l, unsigned long port);
+extern void insb (unsigned long port, void *dst, unsigned long count);
+extern void insw (unsigned long port, void *dst, unsigned long count);
+extern void insl (unsigned long port, void *dst, unsigned long count);
+extern void outsb (unsigned long port, const void *src, unsigned long count);
+extern void outsw (unsigned long port, const void *src, unsigned long count);
+extern void outsl (unsigned long port, const void *src, unsigned long count);
+extern unsigned char readb (unsigned long addr);
+extern unsigned short readw (unsigned long addr);
+extern unsigned long readl (unsigned long addr);
+extern void writeb (unsigned char b, unsigned long addr);
+extern void writew (unsigned short b, unsigned long addr);
+extern void writel (unsigned int b, unsigned long addr);
+
+#endif /* __KERNEL__ */
+
+#ifdef __KERNEL__
+
+/*
+ * If the platform has PC-like I/O, this function converts the offset into
+ * an address.
+ */
+static __inline__ unsigned long isa_port2addr (unsigned long offset)
+{
+	return __isa_port2addr (offset);
+}
+
+#define isa_readb(a) readb(isa_port2addr(a))
+#define isa_readw(a) readw(isa_port2addr(a))
+#define isa_readl(a) readl(isa_port2addr(a))
+#define isa_writeb(b,a) writeb(b,isa_port2addr(a))
+#define isa_writew(w,a) writew(w,isa_port2addr(a))
+#define isa_writel(l,a) writel(l,isa_port2addr(a))
+#define isa_memset_io(a,b,c) \
+  memset((void *)(isa_port2addr((unsigned long)a)),(b),(c))
+#define isa_memcpy_fromio(a,b,c) \
+  memcpy((a),(void *)(isa_port2addr((unsigned long)(b))),(c))
+#define isa_memcpy_toio(a,b,c) \
+  memcpy((void *)(isa_port2addr((unsigned long)(a))),(b),(c))
+
+/* We really want to try and get these to memcpy etc */
+extern void memcpy_fromio (void *, unsigned long, unsigned long);
+extern void memcpy_toio (unsigned long, const void *, unsigned long);
+extern void memset_io (unsigned long, int, unsigned long);
+
+static __inline__ unsigned char ctrl_inb (unsigned long addr)
+{
+	return *(volatile unsigned char *) addr;
+}
+
+static __inline__ unsigned short ctrl_inw (unsigned long addr)
+{
+	return *(volatile unsigned short *) addr;
+}
+
+static __inline__ unsigned int ctrl_inl (unsigned long addr)
+{
+	return *(volatile unsigned long *) addr;
+}
+
+static __inline__ void ctrl_outb (unsigned char b, unsigned long addr)
+{
+	*(volatile unsigned char *) addr = b;
+}
+
+static __inline__ void ctrl_outw (unsigned short b, unsigned long addr)
+{
+	*(volatile unsigned short *) addr = b;
+}
+
+static __inline__ void ctrl_outl (unsigned int b, unsigned long addr)
+{
+	*(volatile unsigned long *) addr = b;
+}
+
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+/*
+ * readX/writeX() are used to access memory mapped devices. On some
+ * architectures the memory mapped IO stuff needs to be accessed
+ * differently. On the x86 architecture, we just read/write the
+ * memory location directly.
+ *
+ * On SH, we have the whole physical address space mapped at all times
+ * (as MIPS does), so "ioremap()" and "iounmap()" do not need to do
+ * anything.  (This isn't true for all machines but we still handle
+ * these cases with wired TLB entries anyway ...)
+ *
+ * We cheat a bit and always return uncachable areas until we've fixed
+ * the drivers to handle caching properly.
+ */
+static __inline__ void *ioremap (unsigned long offset, unsigned long size)
+{
+	return __ioremap (offset, size);
+}
+
+static __inline__ void iounmap (void *addr)
+{
+	return __iounmap (addr);
+}
+
+#define ioremap_nocache(off,size) ioremap(off,size)
+
+static __inline__ int check_signature (unsigned long io_addr,
+				       const unsigned char *signature,
+				       int length)
+{
+	int retval = 0;
+	do {
+		if (readb (io_addr) != *signature)
+			goto out;
+		io_addr++;
+		signature++;
+		length--;
+	} while (length);
+	retval = 1;
+      out:
+	return retval;
+}
+
+/*
+ * The caches on some architectures aren't dma-coherent and have need to
+ * handle this in software.  There are three types of operations that
+ * can be applied to dma buffers.
+ *
+ *  - dma_cache_wback_inv(start, size) makes caches and RAM coherent by
+ *    writing the content of the caches back to memory, if necessary.
+ *    The function also invalidates the affected part of the caches as
+ *    necessary before DMA transfers from outside to memory.
+ *  - dma_cache_inv(start, size) invalidates the affected parts of the
+ *    caches.  Dirty lines of the caches may be written back or simply
+ *    be discarded.  This operation is necessary before dma operations
+ *    to the memory.
+ *  - dma_cache_wback(start, size) writes back any dirty lines but does
+ *    not invalidate the cache.  This can be used before DMA reads from
+ *    memory,
+ */
+
+#define dma_cache_wback_inv(_start,_size) \
+    __flush_purge_region(_start,_size)
+#define dma_cache_inv(_start,_size) \
+    __flush_invalidate_region(_start,_size)
+#define dma_cache_wback(_start,_size) \
+    __flush_wback_region(_start,_size)
+
+static inline void sync(void)
+{
+	/* do nothing */
+	/* Note: may need to include a "synco" instruction here, if we
+	 * have silicon with agressive write-combiners on the SH4-300
+	 * series cores in the future */
+}
+
+#endif /* __KERNEL__ */
+#endif /* __ASM_SH_IO_H */
diff --git a/include/asm-sh/io_generic.h b/include/asm-sh/io_generic.h
new file mode 100644
index 0000000..cfea623
--- /dev/null
+++ b/include/asm-sh/io_generic.h
@@ -0,0 +1,57 @@
+/*
+ * include/asm-sh/io_generic.h
+ *
+ * Copyright 2000 Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Generic IO functions
+ */
+
+#ifndef _ASM_SH_IO_GENERIC_H
+#define _ASM_SH_IO_GENERIC_H
+
+extern unsigned long generic_io_base;
+
+extern unsigned char generic_inb (unsigned long port);
+extern unsigned short generic_inw (unsigned long port);
+extern unsigned int generic_inl (unsigned long port);
+
+extern void generic_outb (unsigned char value, unsigned long port);
+extern void generic_outw (unsigned short value, unsigned long port);
+extern void generic_outl (unsigned int value, unsigned long port);
+
+extern unsigned char generic_inb_p (unsigned long port);
+extern unsigned short generic_inw_p (unsigned long port);
+extern unsigned int generic_inl_p (unsigned long port);
+extern void generic_outb_p (unsigned char value, unsigned long port);
+extern void generic_outw_p (unsigned short value, unsigned long port);
+extern void generic_outl_p (unsigned int value, unsigned long port);
+
+extern void generic_insb (unsigned long port, void *addr,
+			  unsigned long count);
+extern void generic_insw (unsigned long port, void *addr,
+			  unsigned long count);
+extern void generic_insl (unsigned long port, void *addr,
+			  unsigned long count);
+extern void generic_outsb (unsigned long port, const void *addr,
+			   unsigned long count);
+extern void generic_outsw (unsigned long port, const void *addr,
+			   unsigned long count);
+extern void generic_outsl (unsigned long port, const void *addr,
+			   unsigned long count);
+
+extern unsigned char generic_readb (unsigned long addr);
+extern unsigned short generic_readw (unsigned long addr);
+extern unsigned int generic_readl (unsigned long addr);
+extern void generic_writeb (unsigned char b, unsigned long addr);
+extern void generic_writew (unsigned short b, unsigned long addr);
+extern void generic_writel (unsigned int b, unsigned long addr);
+
+extern void *generic_ioremap (unsigned long offset, unsigned long size);
+extern void generic_iounmap (void *addr);
+
+extern unsigned long generic_isa_port2addr (unsigned long offset);
+
+#endif /* _ASM_SH_IO_GENERIC_H */
diff --git a/include/asm-sh/io_stb1eval.h b/include/asm-sh/io_stb1eval.h
new file mode 100644
index 0000000..4d5b723
--- /dev/null
+++ b/include/asm-sh/io_stb1eval.h
@@ -0,0 +1,89 @@
+ /*
+  * include/asm-sh/io_stb1eval.h
+  *
+  * Copyright 2001 Stuart Menefy (stuart.menefy@st.com)
+  *
+  * May be copied or modified under the terms of the GNU General Public
+  * License.  See linux/COPYING for more information.
+  *
+  * IO functions for the ST40STB1 Eval board
+  */
+
+#ifndef _ASM_SH_IO_STB1EVAL_H
+#define _ASM_SH_IO_STB1EVAL_H
+
+#include <asm/io_generic.h>
+
+extern unsigned long stb1eval_isa_port2addr (unsigned long offset);
+
+#ifdef __WANT_IO_DEF
+# define __inb			generic_inb
+# define __inw			generic_inw
+# define __inl			generic_inl
+# define __outb			generic_outb
+# define __outw			generic_outw
+# define __outl			generic_outl
+
+# define __inb_p		generic_inb_p
+# define __inw_p		generic_inw
+# define __inl_p		generic_inl
+# define __outb_p		generic_outb_p
+# define __outw_p		generic_outw
+# define __outl_p		generic_outl
+
+# define __insb			generic_insb
+# define __insw			generic_insw
+# define __insl			generic_insl
+# define __outsb		generic_outsb
+# define __outsw		generic_outsw
+# define __outsl		generic_outsl
+
+# define __readb		generic_readb
+# define __readw		generic_readw
+# define __readl		generic_readl
+# define __writeb		generic_writeb
+# define __writew		generic_writew
+# define __writel		generic_writel
+
+# define __isa_port2addr	stb1eval_isa_port2addr
+# define __ioremap		generic_ioremap
+# define __iounmap		generic_iounmap
+#endif
+
+static __inline__ unsigned long p4_inb (unsigned long addr)
+{
+	return *(volatile unsigned char *) addr;
+}
+
+static __inline__ unsigned long p4_inw (unsigned long addr)
+{
+	return *(volatile unsigned short *) addr;
+}
+
+static __inline__ unsigned long p4_inl (unsigned long addr)
+{
+	return *(volatile unsigned long *) addr;
+}
+
+static __inline__ void p4_outb (unsigned long addr, unsigned short b)
+{
+	*(volatile unsigned char *) addr = b;
+}
+
+static __inline__ void p4_outw (unsigned long addr, unsigned short b)
+{
+	*(volatile unsigned short *) addr = b;
+}
+
+static __inline__ void p4_outl (unsigned long addr, unsigned int b)
+{
+	*(volatile unsigned long *) addr = b;
+}
+
+#define p4_in(addr)	*(addr)
+#define p4_out(addr,data) *(addr) = (data)
+
+#define p2_inl	p4_inl
+#define p2_outl	p4_outl
+
+#endif /* _ASM_SH_IO_STB1EVAL_H */
diff --git a/include/asm-sh/linkage.h b/include/asm-sh/linkage.h
new file mode 100644
index 0000000..749adc2
--- /dev/null
+++ b/include/asm-sh/linkage.h
@@ -0,0 +1,14 @@
+#ifndef _LINUX_LINKAGE_H
+#define _LINUX_LINKAGE_H
+
+#define SYMBOL_NAME(name) name
+#define SYMBOL_NAME_LABEL(name) name ## :
+
+#define ALIGN .balign 4
+
+#define ENTRY(name) \
+  .globl SYMBOL_NAME(name); \
+  ALIGN; \
+  SYMBOL_NAME_LABEL(name)
+
+#endif
diff --git a/include/asm-sh/pio.h b/include/asm-sh/pio.h
new file mode 100644
index 0000000..a2556e5
--- /dev/null
+++ b/include/asm-sh/pio.h
@@ -0,0 +1,81 @@
+/*
+ * (C) Copyright 2005
+ * Andy Stugres, STMicroelectronics, <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _PIO_H_
+#define _PIO_H_	1
+
+#define STPIO_NONPIO            0       /* Non-PIO function (ST40 defn) */
+#define STPIO_BIDIR_Z1          0       /* Input weak pull-up (arch defn) */
+#define STPIO_BIDIR             1       /* Bidirectonal open-drain */
+#define STPIO_OUT               2       /* Output push-pull */
+/*efine STPIO_BIDIR             3        * Bidirectional open drain */
+#define STPIO_IN                4       /* Input Hi-Z */
+/*efine STPIO_IN                5        * Input Hi-Z */
+#define STPIO_ALT_OUT           6       /* Alt output push-pull (arch defn) */
+#define STPIO_ALT_BIDIR         7       /* Alt bidir open drain (arch defn) */
+
+#define STPIO_POUT_OFFSET	0x00
+#define STPIO_PIN_OFFSET	0x10
+#define STPIO_PC0_OFFSET	0x20
+#define STPIO_PC1_OFFSET	0x30
+#define STPIO_PC2_OFFSET	0x40
+#define STPIO_PCOMP_OFFSET	0x50
+#define STPIO_PMASK_OFFSET	0x60
+
+#define STPIO_SET_OFFSET	0x4
+#define STPIO_CLEAR_OFFSET	0x8
+
+#define PIO_PORT_SIZE 0x1000
+
+#define PIO_PORT(n) (((n)*PIO_PORT_SIZE) + PIO_BASE)
+
+#define PIN_C0(PIN, DIR) (((DIR & 0x1)!=0) << PIN)
+#define PIN_C1(PIN, DIR) (((DIR & 0x2)!=0) << PIN)
+#define PIN_C2(PIN, DIR) (((DIR & 0x4)!=0) << PIN)
+
+#define CLEAR_PIN_C0(PIN, DIR) (((DIR & 0x1)==0) << PIN)
+#define CLEAR_PIN_C1(PIN, DIR) (((DIR & 0x2)==0) << PIN)
+#define CLEAR_PIN_C2(PIN, DIR) (((DIR & 0x4)==0) << PIN)
+
+#define SET_PIO_PIN(PIO_ADDR, PIN, DIR) do {writel(PIN_C0(PIN,DIR),PIO_ADDR+0x24);\
+				    writel(PIN_C1(PIN,DIR),PIO_ADDR+0x34);\
+				    writel(PIN_C2(PIN,DIR),PIO_ADDR+0x44);\
+				    writel(CLEAR_PIN_C0(PIN,DIR),PIO_ADDR+0x28);\
+				    writel(CLEAR_PIN_C1(PIN,DIR),PIO_ADDR+0x38);\
+				    writel(CLEAR_PIN_C2(PIN,DIR),PIO_ADDR+0x48);} while (0)
+
+#define STPIO_SET_PIN(PIO_ADDR, PIN, V) writel(1<<PIN, PIO_ADDR + STPIO_POUT_OFFSET + ((V)? STPIO_SET_OFFSET : STPIO_CLEAR_OFFSET))
+#define STPIO_GET_PIN(PORT, PIN) ((readb(PIO_PORT(PORT)+STPIO_PIN_OFFSET)>>(PIN))&0x01)
+
+#define SET_PIO_ASC(PIO_ADDR, TX, RX, CTS, RTS) \
+	writel(PIN_C0(TX, STPIO_ALT_OUT) | PIN_C0(RX, STPIO_IN) | \
+	       PIN_C0(CTS, STPIO_IN) | PIN_C0(RTS, STPIO_ALT_OUT),\
+	       PIO_ADDR+0x24) ; \
+	writel(PIN_C1(TX, STPIO_ALT_OUT) | PIN_C1(RX, STPIO_IN) | \
+	       PIN_C1(CTS, STPIO_IN) | PIN_C1(RTS, STPIO_ALT_OUT),\
+	       PIO_ADDR+0x34) ; \
+	writel(PIN_C2(TX, STPIO_ALT_OUT) | PIN_C2(RX, STPIO_IN) | \
+	       PIN_C2(CTS, STPIO_IN) | PIN_C2(RTS, STPIO_ALT_OUT),\
+	       PIO_ADDR+0x44) ;
+
+#endif
diff --git a/include/asm-sh/posix_types.h b/include/asm-sh/posix_types.h
new file mode 100644
index 0000000..a85c8eb
--- /dev/null
+++ b/include/asm-sh/posix_types.h
@@ -0,0 +1,138 @@
+#ifndef __ASM_SH_POSIX_TYPES_H
+#define __ASM_SH_POSIX_TYPES_H
+
+/*
+ * This file is generally used by user-level software, so you need to
+ * be a little careful about namespace pollution etc.  Also, we cannot
+ * assume GCC is being used.
+ */
+
+typedef unsigned short __kernel_dev_t;
+typedef unsigned long __kernel_ino_t;
+typedef unsigned short __kernel_mode_t;
+typedef unsigned short __kernel_nlink_t;
+typedef long __kernel_off_t;
+typedef int __kernel_pid_t;
+typedef unsigned short __kernel_ipc_pid_t;
+typedef unsigned short __kernel_uid_t;
+typedef unsigned short __kernel_gid_t;
+typedef unsigned int __kernel_size_t;
+typedef int __kernel_ssize_t;
+typedef int __kernel_ptrdiff_t;
+typedef long __kernel_time_t;
+typedef long __kernel_suseconds_t;
+typedef long __kernel_clock_t;
+typedef int __kernel_daddr_t;
+typedef char *__kernel_caddr_t;
+typedef unsigned short __kernel_uid16_t;
+typedef unsigned short __kernel_gid16_t;
+typedef unsigned int __kernel_uid32_t;
+typedef unsigned int __kernel_gid32_t;
+
+typedef unsigned short __kernel_old_uid_t;
+typedef unsigned short __kernel_old_gid_t;
+
+#ifdef __GNUC__
+typedef long long __kernel_loff_t;
+#endif
+
+typedef struct
+{
+#if defined(__KERNEL__) || defined(__USE_ALL)
+	int val[2];
+#else				/* !defined(__KERNEL__) && !defined(__USE_ALL) */
+	int __val[2];
+#endif				/* !defined(__KERNEL__) && !defined(__USE_ALL) */
+} __kernel_fsid_t;
+
+#if defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2)
+
+#undef	__FD_SET
+static __inline__ void __FD_SET (unsigned long __fd,
+				 __kernel_fd_set * __fdsetp)
+{
+	unsigned long __tmp = __fd / __NFDBITS;
+	unsigned long __rem = __fd % __NFDBITS;
+	__fdsetp->fds_bits[__tmp] |= (1UL << __rem);
+}
+
+#undef	__FD_CLR
+static __inline__ void __FD_CLR (unsigned long __fd,
+				 __kernel_fd_set * __fdsetp)
+{
+	unsigned long __tmp = __fd / __NFDBITS;
+	unsigned long __rem = __fd % __NFDBITS;
+	__fdsetp->fds_bits[__tmp] &= ~(1UL << __rem);
+}
+
+
+#undef	__FD_ISSET
+static __inline__ int __FD_ISSET (unsigned long __fd,
+				  const __kernel_fd_set * __p)
+{
+	unsigned long __tmp = __fd / __NFDBITS;
+	unsigned long __rem = __fd % __NFDBITS;
+	return (__p->fds_bits[__tmp] & (1UL << __rem)) != 0;
+}
+
+/*
+ * This will unroll the loop for the normal constant case (8 ints,
+ * for a 256-bit fd_set)
+ */
+#undef	__FD_ZERO
+static __inline__ void __FD_ZERO (__kernel_fd_set * __p)
+{
+	unsigned long *__tmp = __p->fds_bits;
+	int __i;
+
+	if (__builtin_constant_p (__FDSET_LONGS)) {
+		switch (__FDSET_LONGS) {
+		case 16:
+			__tmp[0] = 0;
+			__tmp[1] = 0;
+			__tmp[2] = 0;
+			__tmp[3] = 0;
+			__tmp[4] = 0;
+			__tmp[5] = 0;
+			__tmp[6] = 0;
+			__tmp[7] = 0;
+			__tmp[8] = 0;
+			__tmp[9] = 0;
+			__tmp[10] = 0;
+			__tmp[11] = 0;
+			__tmp[12] = 0;
+			__tmp[13] = 0;
+			__tmp[14] = 0;
+			__tmp[15] = 0;
+			return;
+
+		case 8:
+			__tmp[0] = 0;
+			__tmp[1] = 0;
+			__tmp[2] = 0;
+			__tmp[3] = 0;
+			__tmp[4] = 0;
+			__tmp[5] = 0;
+			__tmp[6] = 0;
+			__tmp[7] = 0;
+			return;
+
+		case 4:
+			__tmp[0] = 0;
+			__tmp[1] = 0;
+			__tmp[2] = 0;
+			__tmp[3] = 0;
+			return;
+		}
+	}
+	__i = __FDSET_LONGS;
+	while (__i) {
+		__i--;
+		*__tmp = 0;
+		__tmp++;
+	}
+}
+
+#endif /* defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2) */
+
+#endif /* __ASM_SH_POSIX_TYPES_H */
diff --git a/include/asm-sh/processor.h b/include/asm-sh/processor.h
new file mode 100644
index 0000000..9165166
--- /dev/null
+++ b/include/asm-sh/processor.h
@@ -0,0 +1,240 @@
+/*
+ * include/asm-sh/processor.h
+ *
+ * Copyright (C) 1999, 2000  Niibe Yutaka
+ */
+
+#ifndef __ASM_SH_PROCESSOR_H
+#define __ASM_SH_PROCESSOR_H
+
+/* #include <asm/page.h> */
+#include <asm/types.h>
+
+/* #include <linux/threads.h> */
+
+/*
+ * Default implementation of macro that returns current
+ * instruction pointer ("program counter").
+ */
+#define current_text_addr() ({ void *pc; __asm__("mova	1f, %0\n1:":"=z" (pc)); pc; })
+
+/*
+ *  CPU type and hardware bug flags. Kept separately for each CPU.
+ */
+enum cpu_type
+{
+	CPU_SH7708,		/* Represents 7707, 7708, 7708S, 7708R, 7709 */
+	CPU_SH7729,		/* Represents 7709A, 7729 */
+	CPU_SH7750,		/* Represents 7750, 7751 */
+	CPU_ST40,		/* Represents ST40STB1 and ST40GX1 */
+	CPU_SH4202,
+	CPU_SH_NONE
+};
+
+struct sh_cpuinfo
+{
+	enum cpu_type type;
+	char hard_math;
+	unsigned long loops_per_jiffy;
+
+	unsigned int cpu_clock, master_clock, bus_clock, module_clock;
+#ifdef CONFIG_CPU_SUBTYPE_ST40
+	unsigned int memory_clock;
+#endif
+};
+
+extern struct sh_cpuinfo boot_cpu_data;
+
+#define cpu_data (&boot_cpu_data)
+#define current_cpu_data boot_cpu_data
+
+/*
+ * User space process size: 2GB.
+ *
+ * Since SH7709 and SH7750 have "area 7", we can't use 0x7c000000--0x7fffffff
+ */
+#define TASK_SIZE	0x7c000000UL
+
+/* This decides where the kernel will search for a free chunk of vm
+ * space during mmap's.
+ */
+#define TASK_UNMAPPED_BASE	(TASK_SIZE / 3)
+
+/*
+ * Bit of SR register
+ *
+ * FD-bit:
+ *     When it's set, it means the processor doesn't have right to use FPU,
+ *     and it results exception when the floating operation is executed.
+ *
+ * IMASK-bit:
+ *     Interrupt level mask
+ */
+#define SR_FD    0x00008000
+#define SR_IMASK 0x000000f0
+
+/*
+ * FPU structure and data
+ */
+
+struct sh_fpu_hard_struct
+{
+	unsigned long fp_regs[16];
+	unsigned long xfp_regs[16];
+	unsigned long fpscr;
+	unsigned long fpul;
+
+	long status;		/* software status information */
+};
+
+/* Dummy fpu emulator  */
+struct sh_fpu_soft_struct
+{
+	unsigned long fp_regs[16];
+	unsigned long xfp_regs[16];
+	unsigned long fpscr;
+	unsigned long fpul;
+
+	unsigned char lookahead;
+	unsigned long entry_pc;
+};
+
+union sh_fpu_union
+{
+	struct sh_fpu_hard_struct hard;
+	struct sh_fpu_soft_struct soft;
+};
+
+struct thread_struct
+{
+	unsigned long sp;
+	unsigned long pc;
+
+	unsigned long trap_no, error_code;
+	unsigned long address;
+
+	/* Hardware debugging registers */
+	unsigned long ubc_pc1, ubc_pc2;
+
+	/* floating point info */
+	union sh_fpu_union fpu;
+};
+
+/* Count of active tasks with UBC settings */
+extern int ubc_usercnt;
+
+#define INIT_THREAD  {						\
+	sizeof(init_stack) + (long) &init_stack, /* sp */	\
+	0,					 /* pc */	\
+	0, 0, 							\
+	0, 							\
+	0, -1, 							\
+	{{{0,}},} 				/* fpu state */	\
+}
+
+/*
+ * Do necessary setup to start up a newly executed thread.
+ */
+#define start_thread(regs, new_pc, new_sp)	 \
+	set_fs(USER_DS);			 \
+	regs->pr = 0;   		 	 \
+	regs->sr = 0;		/* User mode. */ \
+	regs->pc = new_pc;			 \
+	regs->regs[15] = new_sp
+
+/* Forward declaration, a strange C thing */
+struct task_struct;
+struct mm_struct;
+
+/* Free all resources held by a thread. */
+extern void release_thread (struct task_struct *);
+/*
+ * create a kernel thread without removing it from tasklists
+ */
+extern int arch_kernel_thread (int (*fn) (void *), void *arg,
+			       unsigned long flags);
+
+/*
+ * Bus types
+ */
+#define EISA_bus 0
+#define EISA_bus__is_a_macro	/* for versions in ksyms.c */
+#define MCA_bus 0
+#define MCA_bus__is_a_macro	/* for versions in ksyms.c */
+
+
+/* Copy and release all segment info associated with a VM */
+#define copy_segments(p, mm)	do { } while(0)
+#define release_segments(mm)	do { } while(0)
+
+/*
+ * FPU lazy state save handling.
+ */
+
+static __inline__ void release_fpu (void)
+{
+	unsigned long __dummy;
+
+	/* Set FD flag in SR */
+	__asm__ __volatile__ ("stc	sr, %0\n\t"
+			      "or	%1, %0\n\t"
+			      "ldc	%0, sr":"=&r" (__dummy)
+			      :"r" (SR_FD));
+}
+
+static __inline__ void grab_fpu (void)
+{
+	unsigned long __dummy;
+
+	/* Clear out FD flag in SR */
+	__asm__ __volatile__ ("stc	sr, %0\n\t"
+			      "and	%1, %0\n\t"
+			      "ldc	%0, sr":"=&r" (__dummy)
+			      :"r" (~SR_FD));
+}
+
+extern void save_fpu (struct task_struct *__tsk);
+
+#define unlazy_fpu(tsk) do { 			\
+	if ((tsk)->flags & PF_USEDFPU) {	\
+		save_fpu(tsk); 			\
+	}					\
+} while (0)
+
+#define clear_fpu(tsk) do { 			\
+	if ((tsk)->flags & PF_USEDFPU) { 	\
+		(tsk)->flags &= ~PF_USEDFPU; 	\
+		release_fpu();			\
+	}					\
+} while (0)
+
+/* Double presision, NANS as NANS, rounding to nearest, no exceptions */
+#define FPSCR_INIT  0x00080000
+
+#define	FPSCR_CAUSE_MASK	0x0001f000	/* Cause bits */
+#define	FPSCR_FLAG_MASK		0x0000007c	/* Flag bits */
+
+/*
+ * Return saved PC of a blocked thread.
+ */
+static __inline__ unsigned long thread_saved_pc (struct thread_struct *t)
+{
+	return t->pc;
+}
+
+extern unsigned long get_wchan (struct task_struct *p);
+
+#define KSTK_EIP(tsk)  ((tsk)->thread.pc)
+#define KSTK_ESP(tsk)  ((tsk)->thread.sp)
+
+#define THREAD_SIZE (2*PAGE_SIZE)
+extern struct task_struct *alloc_task_struct (void);
+extern void free_task_struct (struct task_struct *);
+#define get_task_struct(tsk)      atomic_inc(&virt_to_page(tsk)->count)
+
+#define init_task	(init_task_union.task)
+#define init_stack	(init_task_union.stack)
+
+#define cpu_relax()	do { } while (0)
+
+#endif /* __ASM_SH_PROCESSOR_H */
diff --git a/include/asm-sh/ptrace.h b/include/asm-sh/ptrace.h
new file mode 100644
index 0000000..2dde7f3
--- /dev/null
+++ b/include/asm-sh/ptrace.h
@@ -0,0 +1,75 @@
+#ifndef __ASM_SH_PTRACE_H
+#define __ASM_SH_PTRACE_H
+
+#include <asm/processor.h>
+#include <asm/ubc.h>
+
+/*
+ * Copyright (C) 1999, 2000  Niibe Yutaka
+ *
+ */
+
+/*
+ * GCC defines register number like this:
+ * -----------------------------
+ *	 0 - 15 are integer registers
+ *	17 - 22 are control/special registers
+ *	24 - 39 fp registers
+ *	40 - 47 xd registers
+ *	48 -    fpscr register
+ * -----------------------------
+ *
+ * We follows above, except:
+ *	16 --- program counter (PC)
+ *	22 --- expevt # (Exception Event Number)
+ *	23 --- floating point communication register
+ */
+#define REG_REG0	 0
+#define REG_REG15	15
+
+#define REG_PC		16
+
+#define REG_PR		17
+#define REG_SR		18
+#define REG_GBR      	19
+#define REG_MACH	20
+#define REG_MACL	21
+
+#define REG_EXPEVT	22
+
+#define REG_FPREG0	23
+#define REG_FPREG15	38
+#define REG_XFREG0	39
+#define REG_XFREG15	54
+
+#define REG_FPSCR	55
+#define REG_FPUL	56
+
+#define PTRACE_SETOPTIONS         21
+
+/* options set using PTRACE_SETOPTIONS */
+#define PTRACE_O_TRACESYSGOOD     0x00000001
+
+/*
+ * This struct defines the way the registers are stored on the
+ * kernel stack during a system call or other kernel entry.
+ */
+struct pt_regs
+{
+	unsigned long regs[16];
+	unsigned long pc;
+	unsigned long pr;
+	unsigned long sr;
+	unsigned long gbr;
+	unsigned long mach;
+	unsigned long macl;
+	unsigned long expevt;
+};
+
+#ifdef __KERNEL__
+#define user_mode(regs) (((regs)->sr & 0x40000000)==0)
+#define instruction_pointer(regs) ((regs)->pc)
+extern void show_regs (struct pt_regs *);
+#endif
+
+#endif /* __ASM_SH_PTRACE_H */
diff --git a/include/asm-sh/regdef.h b/include/asm-sh/regdef.h
new file mode 100644
index 0000000..fd7e2df
--- /dev/null
+++ b/include/asm-sh/regdef.h
@@ -0,0 +1,35 @@
+/*
+ * include/asm-sh/regdefs.h
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004, STMicroelectronics
+ */
+
+#ifndef __ASM_SH_REGDEF_H
+#define __ASM_SH_REGDEF_H
+
+/*
+ * Symbolic register names for 32 bit ABI
+ */
+
+#define v0      r0		/* return value */
+#define v1      r1
+#define v2      r2
+#define v3      r3
+#define a0      r4		/* argument registers */
+#define a1      r5
+#define a2      r6
+#define a3      r7
+#define s0      r8		/* callee saved */
+#define s1      r9
+#define s2      r10
+#define s3      r11
+#define gp      r12		/* global pointer */
+#define s4      r13
+#define fp      r14		/* frame pointer */
+#define sp      r15		/* stack pointer */
+
+#endif /* __ASM_SH_REGDEF_H */
diff --git a/include/asm-sh/sh4reg.h b/include/asm-sh/sh4reg.h
new file mode 100644
index 0000000..59fa7f9
--- /dev/null
+++ b/include/asm-sh/sh4reg.h
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) STMicroelectronics Ltd. 2002, 2003.
+ *
+ * andy.sturges@st.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*----------------------------------------------------------------------------*/
+
+#ifndef __SH4REG_H
+#define __SH4REG_H
+
+#include "asm/sh4regtype.h"
+
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Core SH4 control registers
+ */
+
+/* Core control registers (common to all SH4 variants) */
+#define SH4_CCN_PTEH	SH4_DWORD_REG(0xff000000)
+#define SH4_CCN_PTEL	SH4_DWORD_REG(0xff000004)
+#define SH4_CCN_TTB	SH4_DWORD_REG(0xff000008)
+#define SH4_CCN_TEA	SH4_DWORD_REG(0xff00000c)
+#define SH4_CCN_MMUCR	SH4_DWORD_REG(0xff000010)
+#define SH4_CCN_BASRA	SH4_BYTE_REG(0xff000014)
+#define SH4_CCN_BASRB	SH4_BYTE_REG(0xff000018)
+#define SH4_CCN_CCR	SH4_DWORD_REG(0xff00001c)
+#define SH4_CCN_TRA	SH4_DWORD_REG(0xff000020)
+#define SH4_CCN_EXPEVT	SH4_DWORD_REG(0xff000024)
+#define SH4_CCN_INTEVT	SH4_DWORD_REG(0xff000028)
+#define SH4_CCN_PVR	SH4_DWORD_REG(0xff000030)
+#define SH4_CCN_PTEA	SH4_DWORD_REG(0xff000034)
+#define SH4_CCN_QACR0	SH4_DWORD_REG(0xff000038)
+#define SH4_CCN_QACR1	SH4_DWORD_REG(0xff00003c)
+#define SH4_CCN_CVR	SH4_DWORD_REG(0xff000040)
+#define SH4_CCN_PRR	SH4_DWORD_REG(0xff000044)
+
+/* Some bits in the CCN.CCR register */
+#define SH4_CCR_OCE	(1<<0)
+#define SH4_CCR_WT	(1<<1)
+#define SH4_CCR_CB	(1<<2)
+#define SH4_CCR_OCI	(1<<3)
+#define SH4_CCR_ORA	(1<<5)
+#define SH4_CCR_ICE	(1<<8)
+#define SH4_CCR_ICI	(1<<11)
+#define SH4_CCR_EMODE	(1<<31)
+
+/* Some bits in the CCN.MMUCR register */
+#define	SH4_MMUCR_TI	(1<<2)		/* MMUCR.TI */
+#define	SH4_MMUCR_SE	(1<<4)		/* MMUCR.SE */
+
+
+/* User Break Controller control registers (common to all SH4 variants) */
+#define SH4_UBC_BARA	SH4_DWORD_REG(0xff200000)
+#define SH4_UBC_BAMRA	SH4_BYTE_REG(0xff200004)
+#define SH4_UBC_BBRA	SH4_WORD_REG(0xff200008)
+#define SH4_UBC_BASRA	SH4_BYTE_REG(0xff000014)
+#define SH4_UBC_BARB	SH4_DWORD_REG(0xff20000c)
+#define SH4_UBC_BAMRB	SH4_BYTE_REG(0xff200010)
+#define SH4_UBC_BBRB	SH4_WORD_REG(0xff200014)
+#define SH4_UBC_BASRB	SH4_BYTE_REG(0xff000018)
+#define SH4_UBC_BDRB	SH4_DWORD_REG(0xff200018)
+#define SH4_UBC_BDMRB	SH4_DWORD_REG(0xff20001c)
+#define SH4_UBC_BRCR	SH4_WORD_REG(0xff200020)
+
+/* User Debug Interface control registers (common to all SH4 variants) */
+#define SH4_UDI_SDIR	SH4_WORD_REG(0xfff00000)
+#define SH4_UDI_SDDR	SH4_DWORD_REG(0xfff00008)
+#define SH4_UDI_SDDRH	SH4_WORD_REG(0xfff00008)
+#define SH4_UDI_SDDRL	SH4_WORD_REG(0xfff0000a)
+#define SH4_UDI_SDINT	SH4_WORD_REG(0xfff00014)
+
+/* Advanced User Debugger control registers (common to all SH4 variants) */
+#define SH4_AUD_AUCSR	SH4_WORD_REG(0xff2000cc)
+#define SH4_AUD_AUWASR	SH4_DWORD_REG(0xff2000d0)
+#define SH4_AUD_AUWAER	SH4_DWORD_REG(0xff2000d4)
+#define SH4_AUD_AUWBSR	SH4_DWORD_REG(0xff2000d8)
+#define SH4_AUD_AUWBER	SH4_DWORD_REG(0xff2000dc)
+
+/*
+ * Generic SH4 control registers
+ */
+
+/* Timer Unit control registers (common to all SH4 variants) */
+#define SH4_TMU_TOCR	SH4_BYTE_REG(SH4_TMU_REGS_BASE + 0x00)
+#define SH4_TMU_TSTR	SH4_BYTE_REG(SH4_TMU_REGS_BASE + 0x04)
+#define SH4_TMU_TCOR0	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x08)
+#define SH4_TMU_TCNT0	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x0c)
+#define SH4_TMU_TCR0	SH4_WORD_REG(SH4_TMU_REGS_BASE + 0x10)
+#define SH4_TMU_TCOR1	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x14)
+#define SH4_TMU_TCNT1	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x18)
+#define SH4_TMU_TCR1	SH4_WORD_REG(SH4_TMU_REGS_BASE + 0x1c)
+#define SH4_TMU_TCOR2	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x20)
+#define SH4_TMU_TCNT2	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x24)
+#define SH4_TMU_TCR2	SH4_WORD_REG(SH4_TMU_REGS_BASE + 0x28)
+#define SH4_TMU_TCPR2	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x2c)
+
+/* Real Time Clock control registers (common to all SH4 variants) */
+#define SH4_RTC_R64CNT	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x00)
+#define SH4_RTC_RSECCNT	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x04)
+#define SH4_RTC_RMINCNT	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x08)
+#define SH4_RTC_RHRCNT	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x0c)
+#define SH4_RTC_RWKCNT	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x10)
+#define SH4_RTC_RDAYCNT	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x14)
+#define SH4_RTC_RMONCNT	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x18)
+#define SH4_RTC_RYRCNT	SH4_WORD_REG(SH4_RTC_REGS_BASE + 0x1c)
+#define SH4_RTC_RSECAR	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x20)
+#define SH4_RTC_RMINAR	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x24)
+#define SH4_RTC_RHRAR	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x28)
+#define SH4_RTC_RWKAR	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x2c)
+#define SH4_RTC_RDAYAR	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x30)
+#define SH4_RTC_RMONAR	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x34)
+#define SH4_RTC_RCR1	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x38)
+#define SH4_RTC_RCR2	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x3c)
+
+/*
+ * Privileged Mapping Buffer (PMB) bit-field defintions
+ */
+#define	SH4_PMB_WT		(1<<0)	/* PMB[n].WT */
+#define	SH4_PMB_C		(1<<3)	/* PMB[n].C */
+#define	SH4_PMB_V		(1<<8)	/* PMB[n].V */
+#define	SH4_PMB_UB		(1<<9)	/* PMB[n].UB */
+
+/*----------------------------------------------------------------------------*/
+
+#endif /* __SH4REG_H */
diff --git a/include/asm-sh/sh4regtype.h b/include/asm-sh/sh4regtype.h
new file mode 100644
index 0000000..acc1e6d
--- /dev/null
+++ b/include/asm-sh/sh4regtype.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) STMicroelectronics Ltd. 2002.
+ *
+ * andy.sturges@st.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __SH4REGTYPE_H
+#define __SH4REGTYPE_H
+
+
+#ifndef __ASSEMBLY__
+
+typedef volatile unsigned char *const		sh4_byte_reg_t;
+typedef volatile unsigned short *const		sh4_word_reg_t;
+typedef volatile unsigned int *const		sh4_dword_reg_t;
+typedef volatile unsigned long long *const	sh4_gword_reg_t;
+
+#define SH4_BYTE_REG(address)	((sh4_byte_reg_t) (address))
+#define SH4_WORD_REG(address)	((sh4_word_reg_t) (address))
+#define SH4_DWORD_REG(address)	((sh4_dword_reg_t) (address))
+#define SH4_GWORD_REG(address)	((sh4_gword_reg_t) (address))
+
+#else	/* __ASSEMBLY__ */
+
+#define SH4_BYTE_REG(address)	(address)
+#define SH4_WORD_REG(address)	(address)
+#define SH4_DWORD_REG(address)	(address)
+#define SH4_GWORD_REG(address)	(address)
+
+#endif	/* __ASSEMBLY__ */
+
+
+#endif /* __SH4REGTYPE_H */
diff --git a/include/asm-sh/st40reg.h b/include/asm-sh/st40reg.h
new file mode 100644
index 0000000..724b178
--- /dev/null
+++ b/include/asm-sh/st40reg.h
@@ -0,0 +1,651 @@
+/*
+ * Copyright (C) STMicroelectronics Ltd. 2002, 2003, 2007.
+ *
+ * andy.sturges@st.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/bare/sh4reg/st40reg.h
+ */
+
+#ifndef __ST40REG_H
+#define __ST40REG_H
+
+#include "asm/sh4regtype.h"
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Set default endian to little
+ */
+
+#if defined(ST40_LITTLE_ENDIAN) && defined(ST40_BIG_ENDIAN)
+#error ST40_LITTLE_ENDIAN and ST40_BIG_ENDIAN both defined
+#endif
+
+#if !defined(ST40_LITTLE_ENDIAN) && !defined(ST40_BIG_ENDIAN)
+#define ST40_LITTLE_ENDIAN
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+#include "sh4reg.h"
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * ST40 control registers
+ */
+
+/* Clock Pulse Generator control registers (all ST40 variants) */
+#define ST40_CPG_FRQCR			SH4_WORD_REG(ST40_CPG_REGS_BASE + 0x00)
+#define ST40_CPG_STBCR			SH4_BYTE_REG(ST40_CPG_REGS_BASE + 0x04)
+#define ST40_CPG_WTCNT			SH4_WORD_REG(ST40_CPG_REGS_BASE + 0x08)
+#define ST40_CPG_WTCNT_R		SH4_BYTE_REG(ST40_CPG_REGS_BASE + 0x08)
+#define ST40_CPG_WTCSR			SH4_WORD_REG(ST40_CPG_REGS_BASE + 0x0c)
+#define ST40_CPG_WTCSR_R		SH4_BYTE_REG(ST40_CPG_REGS_BASE + 0x0c)
+#define ST40_CPG_STBCR2			SH4_BYTE_REG(ST40_CPG_REGS_BASE + 0x10)
+#define ST40_CPG_FRQCR2			SH4_WORD_REG(ST40_CPG_REGS_BASE + 0xc0)
+
+/* Interrupt controller registers (all ST40 variants) */
+#define ST40_INTC_ICR			SH4_WORD_REG(ST40_INTC_REGS_BASE + 0x00)
+#define ST40_INTC_IPRA			SH4_WORD_REG(ST40_INTC_REGS_BASE + 0x04)
+#define ST40_INTC_IPRB			SH4_WORD_REG(ST40_INTC_REGS_BASE + 0x08)
+#define ST40_INTC_IPRC			SH4_WORD_REG(ST40_INTC_REGS_BASE + 0x0c)
+#define ST40_INTC_IPRD			SH4_WORD_REG(ST40_INTC_REGS_BASE + 0x10)
+
+/* Interrupt Controller control registers (all ST40 variants) */
+#define ST40_INTC2_INTPRI00		SH4_DWORD_REG(ST40_INTC2_REGS_BASE + 0x00)
+#define ST40_INTC2_INTPRI04		SH4_DWORD_REG(ST40_INTC2_REGS_BASE + 0x04)
+#define ST40_INTC2_INTPRI08		SH4_DWORD_REG(ST40_INTC2_REGS_BASE + 0x08)
+#define ST40_INTC2_INTREQ00		SH4_DWORD_REG(ST40_INTC2_REGS_BASE + 0x20)
+#define ST40_INTC2_INTREQ04		SH4_DWORD_REG(ST40_INTC2_REGS_BASE + 0x24)
+#define ST40_INTC2_INTREQ08		SH4_DWORD_REG(ST40_INTC2_REGS_BASE + 0x28)
+#define ST40_INTC2_INTMSK00		SH4_DWORD_REG(ST40_INTC2_REGS_BASE + 0x40)
+#define ST40_INTC2_INTMSK04		SH4_DWORD_REG(ST40_INTC2_REGS_BASE + 0x44)
+#define ST40_INTC2_INTMSK08		SH4_DWORD_REG(ST40_INTC2_REGS_BASE + 0x48)
+#define ST40_INTC2_INTMSKCLR00		SH4_DWORD_REG(ST40_INTC2_REGS_BASE + 0x60)
+#define ST40_INTC2_INTMSKCLR04		SH4_DWORD_REG(ST40_INTC2_REGS_BASE + 0x64)
+#define ST40_INTC2_INTMSKCLR08		SH4_DWORD_REG(ST40_INTC2_REGS_BASE + 0x68)
+#define ST40_INTC2_INTC2MODE		SH4_DWORD_REG(ST40_INTC2_REGS_BASE + 0x80)
+
+/* Interrupt Level Controller control registers (all ST40 variants) */
+#define ST40_ILC_INPUT_INTERRUPT(n)	SH4_DWORD_REG(ST40_ILC_REGS_BASE + (0x0080 + ((n) * 4)))
+#define ST40_ILC_STATUS(n)		SH4_DWORD_REG(ST40_ILC_REGS_BASE + (0x0200 + ((n) * 4)))
+#define ST40_ILC_CLEAR_STATUS(n)	SH4_DWORD_REG(ST40_ILC_REGS_BASE + (0x0280 + ((n) * 4)))
+#define ST40_ILC_ENABLE(n)		SH4_DWORD_REG(ST40_ILC_REGS_BASE + (0x0400 + ((n) * 4)))
+#define ST40_ILC_CLEAR_ENABLE(n)	SH4_DWORD_REG(ST40_ILC_REGS_BASE + (0x0480 + ((n) * 4)))
+#define ST40_ILC_SET_ENABLE(n)		SH4_DWORD_REG(ST40_ILC_REGS_BASE + (0x0500 + ((n) * 4)))
+#define ST40_ILC_WAKEUP_ENABLE(n)	SH4_DWORD_REG(ST40_ILC_REGS_BASE + (0x0600 + ((n) * 4)))
+#define ST40_ILC_WAKEUP_ACTIVE_LEVEL(n)	SH4_DWORD_REG(ST40_ILC_REGS_BASE + (0x0680 + ((n) * 4)))
+
+/* Serial Communication Interfaces control registers (all ST40 variants) */
+#define ST40_SCIF_SCSMR(n)		SH4_WORD_REG(ST40_SCIF##n##_REGS_BASE + 0x00)
+#define ST40_SCIF_SCBRR(n)		SH4_BYTE_REG(ST40_SCIF##n##_REGS_BASE + 0x04)
+#define ST40_SCIF_SCSCR(n)		SH4_WORD_REG(ST40_SCIF##n##_REGS_BASE + 0x08)
+#define ST40_SCIF_SCFTDR(n)		SH4_BYTE_REG(ST40_SCIF##n##_REGS_BASE + 0x0c)
+#define ST40_SCIF_SCFSR(n)		SH4_WORD_REG(ST40_SCIF##n##_REGS_BASE + 0x10)
+#define ST40_SCIF_SCFRDR(n)		SH4_BYTE_REG(ST40_SCIF##n##_REGS_BASE + 0x14)
+#define ST40_SCIF_SCFCR(n)		SH4_WORD_REG(ST40_SCIF##n##_REGS_BASE + 0x18)
+#define ST40_SCIF_SCFDR(n)		SH4_WORD_REG(ST40_SCIF##n##_REGS_BASE + 0x1c)
+#define ST40_SCIF_SCSPTR(n)		SH4_WORD_REG(ST40_SCIF##n##_REGS_BASE + 0x20)
+#define ST40_SCIF_SCLSR(n)		SH4_WORD_REG(ST40_SCIF##n##_REGS_BASE + 0x24)
+
+/* Clock Generator control registers (all ST40 variants) */
+#define ST40_CLOCKGEN_PLL1CR1(n)	SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x00)
+#define ST40_CLOCKGEN_PLL1CR2(n)	SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x08)
+#define ST40_CLOCKGEN_PLL2CR(n)		SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x10)
+#define ST40_CLOCKGEN_STBREQCR(n)	SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x18)
+#define ST40_CLOCKGEN_STBREQCR_SET(n)	SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x20)
+#define ST40_CLOCKGEN_STBREQCR_CLR(n)	SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x28)
+#define ST40_CLOCKGEN_STBACKCR(n)	SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x30)
+#define ST40_CLOCKGEN_CLK4CR(n)		SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x38)
+#define ST40_CLOCKGEN_CPG_BYPASS(n)	SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x40)
+#define ST40_CLOCKGEN_PLL2_MUXCR(n)	SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x48)
+#define ST40_CLOCKGEN_CLK1CR(n)		SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x50)
+#define ST40_CLOCKGEN_CLK2CR(n)		SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x58)
+#define ST40_CLOCKGEN_CLK3CR(n)		SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x60)
+#define ST40_CLOCKGEN_CLK_SELCR(n)	SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x68)
+
+#define ST40_CLOCKGEN_CLK_RATIO(n) ST40_CLOCKGEN_PLL2_MUXCR(n)
+#define ST40_CLOCKGEN_CLKDDRCR(n) ST40_CLOCKGEN_CLK_SELCR(n)
+
+/* Direct Memeory Access Controller control registers (all ST40 variants) */
+#define ST40_DMAC_CHAN0_IDENTITY	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x00)
+#define ST40_DMAC_CHAN0_ENABLE		SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x08)
+#define ST40_DMAC_CHAN0_DISABLE		SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x10)
+#define ST40_DMAC_CHAN0_STATUS		SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x18)
+#define ST40_DMAC_CHAN0_ACTION		SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x20)
+#define ST40_DMAC_CHAN0_POINTER		SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x28)
+#define ST40_DMAC_CHAN0_SUBBASE		SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x30)
+#define ST40_DMAC_CHAN0_SUBENABLE	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x38)
+#define ST40_DMAC_CHAN0_SUBDISABLE	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x40)
+#define ST40_DMAC_CHAN0_SUBINT_ENB	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x48)
+#define ST40_DMAC_CHAN0_SUBINT_DIS	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x50)
+#define ST40_DMAC_CHAN0_SUBINT_STAT	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x58)
+#define ST40_DMAC_CHAN0_SUNINT_ACT	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x60)
+#define ST40_DMAC_CHAN0_CONTROL		SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x80)
+#define ST40_DMAC_CHAN0_COUNT		SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x88)
+#define ST40_DMAC_CHAN0_SAR		SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x90)
+#define ST40_DMAC_CHAN0_DAR		SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x98)
+
+#define ST40_DMAC_CHANX_IDENTITY(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0x00)
+#define ST40_DMAC_CHANX_ENABLE(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0x08)
+#define ST40_DMAC_CHANX_DISABLE(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0x10)
+#define ST40_DMAC_CHANX_STATUS(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0x18)
+#define ST40_DMAC_CHANX_ACTION(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0x20)
+#define ST40_DMAC_CHANX_POINTER(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0x28)
+#define ST40_DMAC_CHANX_REQUEST(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0x30)
+#define ST40_DMAC_CHANX_CONTROL(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0x80)
+#define ST40_DMAC_CHANX_COUNT(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0x88)
+#define ST40_DMAC_CHANX_SAR(n)		SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0x90)
+#define ST40_DMAC_CHANX_DAR(n)		SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0x98)
+#define ST40_DMAC_CHANX_NEXT_PTR(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0xa0)
+#define ST40_DMAC_CHANX_SRC_LENGTH(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0xa8)
+#define ST40_DMAC_CHANX_SRC_STRIDE(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0xb0)
+#define ST40_DMAC_CHANX_DST_LENGTH(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0xb8)
+#define ST40_DMAC_CHANX_DST_STRIDE(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0xc0)
+
+#define ST40_DMAC_CHAN1_IDENTITY	ST40_DMAC_CHANX_IDENTITY(0x200)
+#define ST40_DMAC_CHAN1_ENABLE		ST40_DMAC_CHANX_ENABLE(0x200)
+#define ST40_DMAC_CHAN1_DISABLE		ST40_DMAC_CHANX_DISABLE(0x200)
+#define ST40_DMAC_CHAN1_STATUS		ST40_DMAC_CHANX_STATUS(0x200)
+#define ST40_DMAC_CHAN1_ACTION		ST40_DMAC_CHANX_ACTION(0x200)
+#define ST40_DMAC_CHAN1_POINTER		ST40_DMAC_CHANX_POINTER(0x200)
+#define ST40_DMAC_CHAN1_REQUEST		ST40_DMAC_CHANX_REQUEST(0x200)
+#define ST40_DMAC_CHAN1_CONTROL		ST40_DMAC_CHANX_CONTROL(0x200)
+#define ST40_DMAC_CHAN1_COUNT		ST40_DMAC_CHANX_COUNT(0x200)
+#define ST40_DMAC_CHAN1_SAR		ST40_DMAC_CHANX_SAR(0x200)
+#define ST40_DMAC_CHAN1_DAR		ST40_DMAC_CHANX_DAR(0x200)
+#define ST40_DMAC_CHAN1_NEXT_PTR	ST40_DMAC_CHANX_NEXT_PTR(0x200)
+#define ST40_DMAC_CHAN1_SRC_LENGTH	ST40_DMAC_CHANX_SRC_LENGTH(0x200)
+#define ST40_DMAC_CHAN1_SRC_STRIDE	ST40_DMAC_CHANX_SRC_STRIDE(0x200)
+#define ST40_DMAC_CHAN1_DST_LENGTH	ST40_DMAC_CHANX_DST_LENGTH(0x200)
+#define ST40_DMAC_CHAN1_DST_STRIDE	ST40_DMAC_CHANX_DST_STRIDE(0x200)
+
+#define ST40_DMAC_CHAN2_IDENTITY	ST40_DMAC_CHANX_IDENTITY(0x300)
+#define ST40_DMAC_CHAN2_ENABLE		ST40_DMAC_CHANX_ENABLE(0x300)
+#define ST40_DMAC_CHAN2_DISABLE		ST40_DMAC_CHANX_DISABLE(0x300)
+#define ST40_DMAC_CHAN2_STATUS		ST40_DMAC_CHANX_STATUS(0x300)
+#define ST40_DMAC_CHAN2_ACTION		ST40_DMAC_CHANX_ACTION(0x300)
+#define ST40_DMAC_CHAN2_POINTER		ST40_DMAC_CHANX_POINTER(0x300)
+#define ST40_DMAC_CHAN2_REQUEST		ST40_DMAC_CHANX_REQUEST(0x300)
+#define ST40_DMAC_CHAN2_CONTROL		ST40_DMAC_CHANX_CONTROL(0x300)
+#define ST40_DMAC_CHAN2_COUNT		ST40_DMAC_CHANX_COUNT(0x300)
+#define ST40_DMAC_CHAN2_SAR		ST40_DMAC_CHANX_SAR(0x300)
+#define ST40_DMAC_CHAN2_DAR		ST40_DMAC_CHANX_DAR(0x300)
+#define ST40_DMAC_CHAN2_NEXT_PTR	ST40_DMAC_CHANX_NEXT_PTR(0x300)
+#define ST40_DMAC_CHAN2_SRC_LENGTH	ST40_DMAC_CHANX_SRC_LENGTH(0x300)
+#define ST40_DMAC_CHAN2_SRC_STRIDE	ST40_DMAC_CHANX_SRC_STRIDE(0x300)
+#define ST40_DMAC_CHAN2_DST_LENGTH	ST40_DMAC_CHANX_DST_LENGTH(0x300)
+#define ST40_DMAC_CHAN2_DST_STRIDE	ST40_DMAC_CHANX_DST_STRIDE(0x300)
+
+#define ST40_DMAC_CHAN3_IDENTITY	ST40_DMAC_CHANX_IDENTITY(0x400)
+#define ST40_DMAC_CHAN3_ENABLE		ST40_DMAC_CHANX_ENABLE(0x400)
+#define ST40_DMAC_CHAN3_DISABLE		ST40_DMAC_CHANX_DISABLE(0x400)
+#define ST40_DMAC_CHAN3_STATUS		ST40_DMAC_CHANX_STATUS(0x400)
+#define ST40_DMAC_CHAN3_ACTION		ST40_DMAC_CHANX_ACTION(0x400)
+#define ST40_DMAC_CHAN3_POINTER		ST40_DMAC_CHANX_POINTER(0x400)
+#define ST40_DMAC_CHAN3_REQUEST		ST40_DMAC_CHANX_REQUEST(0x400)
+#define ST40_DMAC_CHAN3_CONTROL		ST40_DMAC_CHANX_CONTROL(0x400)
+#define ST40_DMAC_CHAN3_COUNT		ST40_DMAC_CHANX_COUNT(0x400)
+#define ST40_DMAC_CHAN3_SAR		ST40_DMAC_CHANX_SAR(0x400)
+#define ST40_DMAC_CHAN3_DAR		ST40_DMAC_CHANX_DAR(0x400)
+#define ST40_DMAC_CHAN3_NEXT_PTR	ST40_DMAC_CHANX_NEXT_PTR(0x400)
+#define ST40_DMAC_CHAN3_SRC_LENGTH	ST40_DMAC_CHANX_SRC_LENGTH(0x400)
+#define ST40_DMAC_CHAN3_SRC_STRIDE	ST40_DMAC_CHANX_SRC_STRIDE(0x400)
+#define ST40_DMAC_CHAN3_DST_LENGTH	ST40_DMAC_CHANX_DST_LENGTH(0x400)
+#define ST40_DMAC_CHAN3_DST_STRIDE	ST40_DMAC_CHANX_DST_STRIDE(0x400)
+
+#define ST40_DMAC_CHAN4_IDENTITY	ST40_DMAC_CHANX_IDENTITY(0x500)
+#define ST40_DMAC_CHAN4_ENABLE		ST40_DMAC_CHANX_ENABLE(0x500)
+#define ST40_DMAC_CHAN4_DISABLE		ST40_DMAC_CHANX_DISABLE(0x500)
+#define ST40_DMAC_CHAN4_STATUS		ST40_DMAC_CHANX_STATUS(0x500)
+#define ST40_DMAC_CHAN4_ACTION		ST40_DMAC_CHANX_ACTION(0x500)
+#define ST40_DMAC_CHAN4_POINTER		ST40_DMAC_CHANX_POINTER(0x500)
+#define ST40_DMAC_CHAN4_REQUEST		ST40_DMAC_CHANX_REQUEST(0x500)
+#define ST40_DMAC_CHAN4_CONTROL		ST40_DMAC_CHANX_CONTROL(0x500)
+#define ST40_DMAC_CHAN4_COUNT		ST40_DMAC_CHANX_COUNT(0x500)
+#define ST40_DMAC_CHAN4_SAR		ST40_DMAC_CHANX_SAR(0x500)
+#define ST40_DMAC_CHAN4_DAR		ST40_DMAC_CHANX_DAR(0x500)
+#define ST40_DMAC_CHAN4_NEXT_PTR	ST40_DMAC_CHANX_NEXT_PTR(0x500)
+#define ST40_DMAC_CHAN4_SRC_LENGTH	ST40_DMAC_CHANX_SRC_LENGTH(0x500)
+#define ST40_DMAC_CHAN4_SRC_STRIDE	ST40_DMAC_CHANX_SRC_STRIDE(0x500)
+#define ST40_DMAC_CHAN4_DST_LENGTH	ST40_DMAC_CHANX_DST_LENGTH(0x500)
+#define ST40_DMAC_CHAN4_DST_STRIDE	ST40_DMAC_CHANX_DST_STRIDE(0x500)
+
+#define ST40_DMAC_VCR_STATUS		SH4_DWORD_REG(ST40_DMAC_REGS_BASE + 0x00)
+#define ST40_DMAC_VCR_VERSION		SH4_DWORD_REG(ST40_DMAC_REGS_BASE + 0x08)
+#define ST40_DMAC_ENABLE		SH4_DWORD_REG(ST40_DMAC_REGS_BASE + 0x10)
+#define ST40_DMAC_DISABLE		SH4_DWORD_REG(ST40_DMAC_REGS_BASE + 0x18)
+#define ST40_DMAC_STATUS		SH4_DWORD_REG(ST40_DMAC_REGS_BASE + 0x20)
+#define ST40_DMAC_INTERRUPT		SH4_DWORD_REG(ST40_DMAC_REGS_BASE + 0x28)
+#define ST40_DMAC_ERROR			SH4_DWORD_REG(ST40_DMAC_REGS_BASE + 0x30)
+#define ST40_DMAC_DEFINED		SH4_DWORD_REG(ST40_DMAC_REGS_BASE + 0x38)
+#define ST40_DMAC_HANDSHAKE		SH4_DWORD_REG(ST40_DMAC_REGS_BASE + 0x40)
+
+/* Parallel I/O control registers (all ST40 variants) */
+#define ST40_PIO_POUT(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x00)
+#define ST40_PIO_PIN(n)		SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x10)
+#define ST40_PIO_PC0(n)		SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x20)
+#define ST40_PIO_PC1(n)		SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x30)
+#define ST40_PIO_PC2(n)		SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x40)
+#define ST40_PIO_PCOMP(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x50)
+#define ST40_PIO_PMASK(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x60)
+
+/* PIO pseudo registers */
+#define ST40_PIO_SET_POUT(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x04)
+#define ST40_PIO_CLEAR_POUT(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x08)
+#define ST40_PIO_SET_PC0(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x24)
+#define ST40_PIO_CLEAR_PC0(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x28)
+#define ST40_PIO_SET_PC1(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x34)
+#define ST40_PIO_CLEAR_PC1(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x38)
+#define ST40_PIO_SET_PC2(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x44)
+#define ST40_PIO_CLEAR_PC2(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x48)
+#define ST40_PIO_SET_PCOMP(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x54)
+#define ST40_PIO_CLEAR_PCOMP(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x58)
+#define ST40_PIO_SET_PMASK(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x64)
+#define ST40_PIO_CLEAR_PMASK(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x68)
+
+/* Local Memory Interface control registers (all ST40 variants).
+   Define ST40_LMI_VERSION for standard LMIs and ST40_LMIGP_VERSION for GP LMIs.
+ */
+#if !(defined(ST40_LMI_VERSION) || defined(ST40_LMIGP_VERSION))
+/* For variants which do not define which LMI they have we define
+   ST40_LMI_VERSION 2 as the default.
+ */
+#define ST40_LMI_VERSION 2
+#endif
+#if defined(ST40_LMI_VERSION)
+#define ST40_LMI_VCR_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000000)
+#define ST40_LMI_VCR_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000004)
+#define ST40_LMI_VCR(n)		SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000000)
+#define ST40_LMI_MIM_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000008)
+#define ST40_LMI_MIM_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x00000c)
+#define ST40_LMI_MIM(n)		SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000008)
+#define ST40_LMI_SCR_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000010)
+#define ST40_LMI_SCR_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000014)
+#define ST40_LMI_SCR(n)		SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000010)
+#define ST40_LMI_STR_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000018)
+#define ST40_LMI_STR_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x00001c)
+#define ST40_LMI_STR(n)		SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000018)
+#define ST40_LMI_PBS_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000020)
+#define ST40_LMI_PBS_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000024)
+#define ST40_LMI_PBS(n)		SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000020)
+#define ST40_LMI_COC_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000028)
+#define ST40_LMI_COC_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x00002c)
+#define ST40_LMI_COC(n)		SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000028)
+#define ST40_LMI_SDRA0_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000030)
+#define ST40_LMI_SDRA0_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000034)
+#define ST40_LMI_SDRA0(n)	SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000030)
+#define ST40_LMI_SDRA1_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000038)
+#define ST40_LMI_SDRA1_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x00003c)
+#define ST40_LMI_SDRA1(n)	SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000038)
+#define ST40_LMI_CIC_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000040)
+#define ST40_LMI_CIC_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000044)
+#define ST40_LMI_CIC(n)		SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000040)
+#if (ST40_LMI_VERSION > 2)
+#define ST40_LMI_SDMR0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000048)
+#define ST40_LMI_SDMR1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000050)
+#else
+#define ST40_LMI_SDMR0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x800000)
+#define ST40_LMI_SDMR1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x900000)
+#endif
+#elif defined(ST40_LMIGP_VERSION)
+#define ST40_LMI_VCR_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000000)
+#define ST40_LMI_VCR_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000004)
+#define ST40_LMI_VCR(n)		SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000000)
+#define ST40_LMI_MIM_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000008)
+#define ST40_LMI_MIM_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x00000c)
+#define ST40_LMI_MIM(n)		SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000008)
+#define ST40_LMI_SCR_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000010)
+#define ST40_LMI_SCR_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000014)
+#define ST40_LMI_SCR(n)		SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000010)
+#define ST40_LMI_STR_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000018)
+#define ST40_LMI_STR_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x00001c)
+#define ST40_LMI_STR(n)		SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000018)
+#define ST40_LMI_GCC_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000028)
+#define ST40_LMI_GCC_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x00002c)
+#define ST40_LMI_GCC(n)		SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000028)
+#define ST40_LMI_SDRA0_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000030)
+#define ST40_LMI_SDRA0_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000034)
+#define ST40_LMI_SDRA0(n)	SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000030)
+#define ST40_LMI_SDRA1_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000038)
+#define ST40_LMI_SDRA1_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x00003c)
+#define ST40_LMI_SDRA1(n)	SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000038)
+#define ST40_LMI_CCO_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000040)
+#define ST40_LMI_CCO_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000044)
+#define ST40_LMI_CCO(n)		SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000040)
+#define ST40_LMI_SDMR0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000048)
+#define ST40_LMI_SDMR1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000050)
+#endif
+
+/* Enhanced Flash Memory Interface control registers (all ST40 variants) */
+#define ST40_EMI_VCR_0			SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0000)
+#define ST40_EMI_VCR_1			SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0004)
+#define ST40_EMI_VCR			SH4_GWORD_REG(ST40_EMI_REGS_BASE + 0x0000)
+#define ST40_EMI_STATUSCFG		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0010)
+#define ST40_EMI_STATUSLOCK		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0018)
+#define ST40_EMI_LOCK			SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0020)
+#define ST40_EMI_GENCFG			SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0028)
+#define ST40_EMI_SDRAMNOPGEN		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0030)
+#define ST40_EMI_SDRAMMODEREG		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0038)
+#define ST40_EMI_SDRAMINIT		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0040)
+#define ST40_EMI_REFRESHINIT		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0048)
+#define ST40_EMI_FLASHCLKSEL		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0050)
+#define ST40_EMI_SDRAMCLKSEL		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0058)
+#define ST40_EMI_MPXCLKSEL		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0060)
+#define ST40_EMI_CLKENABLE		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0068)
+#define ST40_EMI_BANK0_EMICONFIGDATA0	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0100)
+#define ST40_EMI_BANK0_EMICONFIGDATA1	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0108)
+#define ST40_EMI_BANK0_EMICONFIGDATA2	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0110)
+#define ST40_EMI_BANK0_EMICONFIGDATA3	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0118)
+#define ST40_EMI_BANK1_EMICONFIGDATA0	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0140)
+#define ST40_EMI_BANK1_EMICONFIGDATA1	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0148)
+#define ST40_EMI_BANK1_EMICONFIGDATA2	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0150)
+#define ST40_EMI_BANK1_EMICONFIGDATA3	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0158)
+#define ST40_EMI_BANK2_EMICONFIGDATA0	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0180)
+#define ST40_EMI_BANK2_EMICONFIGDATA1	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0188)
+#define ST40_EMI_BANK2_EMICONFIGDATA2	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0190)
+#define ST40_EMI_BANK2_EMICONFIGDATA3	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0198)
+#define ST40_EMI_BANK3_EMICONFIGDATA0	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x01c0)
+#define ST40_EMI_BANK3_EMICONFIGDATA1	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x01c8)
+#define ST40_EMI_BANK3_EMICONFIGDATA2	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x01d0)
+#define ST40_EMI_BANK3_EMICONFIGDATA3	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x01d8)
+#define ST40_EMI_BANK4_EMICONFIGDATA0	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0200)
+#define ST40_EMI_BANK4_EMICONFIGDATA1	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0208)
+#define ST40_EMI_BANK4_EMICONFIGDATA2	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0210)
+#define ST40_EMI_BANK4_EMICONFIGDATA3	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0218)
+#define ST40_EMI_BANK5_EMICONFIGDATA0	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0240)
+#define ST40_EMI_BANK5_EMICONFIGDATA1	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0248)
+#define ST40_EMI_BANK5_EMICONFIGDATA2	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0250)
+#define ST40_EMI_BANK5_EMICONFIGDATA3	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0258)
+#define ST40_EMI_BANK_ENABLE		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0280)
+
+#define ST40_EMI_BANK0_BASEADDRESS	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0800)
+#define ST40_EMI_BANK1_BASEADDRESS	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0810)
+#define ST40_EMI_BANK2_BASEADDRESS	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0820)
+#define ST40_EMI_BANK3_BASEADDRESS	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0830)
+#define ST40_EMI_BANK4_BASEADDRESS	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0840)
+#define ST40_EMI_BANK5_BASEADDRESS	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0850)
+#define ST40_EMI_BANKNUMBER		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0860)
+
+/* Peripheral Component Interconnect control registers (all ST40 variants) */
+/* PCI Local Registers */
+#define ST40_PCI_VCR_STATUS	SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000000)
+#define ST40_PCI_VCR_VERSION	SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000008)
+#define ST40_PCI_CR		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000010)
+#define ST40_PCI_LSR0		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000014)
+#define ST40_PCI_LAR0		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x00001c)
+#define ST40_PCI_INT		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000024)
+#define ST40_PCI_INTM		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000028)
+#define ST40_PCI_AIR		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x00002c)
+#define ST40_PCI_CIR		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000030)
+#define ST40_PCI_AINT		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000040)
+#define ST40_PCI_AINTM		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000044)
+#define ST40_PCI_BMIR		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000048)
+#define ST40_PCI_PAR		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x00004c)
+#define ST40_PCI_MBR		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000050)
+#define ST40_PCI_IOBR		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000054)
+#define ST40_PCI_PINT		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000058)
+#define ST40_PCI_PINTM		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x00005c)
+#define ST40_PCI_MBMR		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000070)
+#define ST40_PCI_IOBMR		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000074)
+
+/* PCI Local Configuration Registers */
+#define ST40_PCI_WCBAR		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x00007c)
+#define ST40_PCI_LOCCFG_UNLOCK	SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000034)
+#define ST40_PCI_RBARR0		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000100)
+#define ST40_PCI_RSR0		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000104)
+#define ST40_PCI_RLAR0		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000108)
+#define ST40_PCI_RBARR1		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000110)
+#define ST40_PCI_RSR1		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000114)
+#define ST40_PCI_RLAR1		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000118)
+#define ST40_PCI_RBARR2		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000120)
+#define ST40_PCI_RSR2		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000124)
+#define ST40_PCI_RLAR2		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000128)
+#define ST40_PCI_RBARR3		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000130)
+#define ST40_PCI_RSR3		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000134)
+#define ST40_PCI_RLAR3		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000138)
+#define ST40_PCI_RBARR4		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000140)
+#define ST40_PCI_RSR4		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000144)
+#define ST40_PCI_RLAR4		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000148)
+#define ST40_PCI_RBARR5		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000150)
+#define ST40_PCI_RSR5		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000154)
+#define ST40_PCI_RLAR5		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000158)
+#define ST40_PCI_RBARR6		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000160)
+#define ST40_PCI_RSR6		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000164)
+#define ST40_PCI_RLAR6		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000168)
+#define ST40_PCI_RBARR7		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000170)
+#define ST40_PCI_RSR7		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000174)
+#define ST40_PCI_RLAR7		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000178)
+
+/* PCI Configuration Space Registers (CSR) */
+#define ST40_PCI_VID		SH4_WORD_REG(ST40_PCI_REGS_BASE + 0x010000)
+#define ST40_PCI_DID		SH4_WORD_REG(ST40_PCI_REGS_BASE + 0x010002)
+#define ST40_PCI_CMD		SH4_WORD_REG(ST40_PCI_REGS_BASE + 0x010004)
+#define ST40_PCI_STATUS		SH4_WORD_REG(ST40_PCI_REGS_BASE + 0x010006)
+#define ST40_PCI_RID_CLASS	SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x010008)
+#define ST40_PCI_CLS		SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x01000c)
+#define ST40_PCI_MLT		SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x01000d)
+#define ST40_PCI_HDR		SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x01000e)
+#define ST40_PCI_BIST		SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x01000f)
+#define ST40_PCI_MBAR0		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x010010)
+#define ST40_PCI_IBAR		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x010018)
+#define ST40_PCI_SVID		SH4_WORD_REG(ST40_PCI_REGS_BASE + 0x01002c)
+#define ST40_PCI_SID		SH4_WORD_REG(ST40_PCI_REGS_BASE + 0x01002e)
+#define ST40_PCI_CP		SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x010034)
+#define ST40_PCI_INTLINE	SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x01003c)
+#define ST40_PCI_INTPIN		SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x01003d)
+#define ST40_PCI_MINGNT		SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x01003e)
+#define ST40_PCI_MAXLAT		SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x01003f)
+#define ST40_PCI_TRDYTIME	SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x010040)
+#define ST40_PCI_RETRYTIME	SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x010041)
+#define ST40_PCI_CID		SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x0100dc)
+#define ST40_PCI_NIP		SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x0100dd)
+#define ST40_PCI_PMC		SH4_WORD_REG(ST40_PCI_REGS_BASE + 0x0100de)
+#define ST40_PCI_PMCSR		SH4_WORD_REG(ST40_PCI_REGS_BASE + 0x0100e0)
+#define ST40_PCI_PMCSR_BSE	SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x0100e2)
+#define ST40_PCI_PCDD		SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x0100e3)
+
+/* External MicroProcessor Interface control registers (all ST40 variants) */
+#define ST40_EMPI_VCR_STATUS	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0000)
+#define ST40_EMPI_VCR_VERSION	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0008)
+#define ST40_EMPI_SYSTEM	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0010)
+#define ST40_EMPI_ISTATUS	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0018)
+#define ST40_EMPI_IMASK		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0020)
+#define ST40_EMPI_MPXCFG	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0028)
+#define ST40_EMPI_DMAINV	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0030)
+#define ST40_EMPI_DMACFG0	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0080)
+#define ST40_EMPI_DMACFG1	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0088)
+#define ST40_EMPI_DMACFG2	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0090)
+#define ST40_EMPI_DMACFG3	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0098)
+#define ST40_EMPI_DSTATUS0	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0100)
+#define ST40_EMPI_DSTATUS1	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0108)
+#define ST40_EMPI_DSTATUS2	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0110)
+#define ST40_EMPI_DSTATUS3	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0118)
+#define ST40_EMPI_RBAR0		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0200)
+#define ST40_EMPI_RSR0		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0208)
+#define ST40_EMPI_RLAR0		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0210)
+#define ST40_EMPI_RBAR1		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0220)
+#define ST40_EMPI_RSR1		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0228)
+#define ST40_EMPI_RLAR1		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0230)
+#define ST40_EMPI_RBAR2		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0240)
+#define ST40_EMPI_RSR2		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0248)
+#define ST40_EMPI_RLAR2		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0250)
+#define ST40_EMPI_RBAR3		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0260)
+#define ST40_EMPI_RSR3		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0268)
+#define ST40_EMPI_RLAR3		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0270)
+#define ST40_EMPI_RBAR4		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0280)
+#define ST40_EMPI_RSR4		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0288)
+#define ST40_EMPI_RLAR4		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0290)
+#define ST40_EMPI_RBAR5		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x02a0)
+#define ST40_EMPI_RSR5		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x02a8)
+#define ST40_EMPI_RLAR5		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x02b0)
+#define ST40_EMPI_RBAR6		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x02c0)
+#define ST40_EMPI_RSR6		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x02c8)
+#define ST40_EMPI_RLAR6		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x02d0)
+#define ST40_EMPI_RBAR7		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x02e0)
+#define ST40_EMPI_RSR7		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x02e8)
+#define ST40_EMPI_RLAR7		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x02f0)
+
+/* MPX Arbiter control registers (all ST40 variants) */
+#define ST40_MPXARB_VCR		SH4_DWORD_REG(ST40_MPXARB_REGS_BASE + 0x0000)
+#define ST40_MPXARB_CONTROL	SH4_DWORD_REG(ST40_MPXARB_REGS_BASE + 0x0010)
+#define ST40_MPXARB_DLLCONTROL	SH4_DWORD_REG(ST40_MPXARB_REGS_BASE + 0x4000)
+#define ST40_MPXARB_DLLSTATUS	SH4_DWORD_REG(ST40_MPXARB_REGS_BASE + 0x4010)
+
+/* Mailbox control registers (all ST40 variants) */
+#define ST40_MAILBOX_ID_VER(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0000)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_STATUS_REG1(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0004)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_STATUS_REG2(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0008)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_STATUS_REG3(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x000c)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_STATUS_REG4(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0010)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_STATUS_REG1_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0024)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_STATUS_REG2_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0028)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_STATUS_REG3_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x002c)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_STATUS_REG4_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0030)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_STATUS_REG1_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0044)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_STATUS_REG2_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0048)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_STATUS_REG3_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x004c)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_STATUS_REG4_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0050)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_ENABLE_REG1(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0064)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_ENABLE_REG2(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0068)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_ENABLE_REG3(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x006c)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_ENABLE_REG4(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0070)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_ENABLE_REG1_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0084)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_ENABLE_REG2_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0088)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_ENABLE_REG3_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x008c)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_ENABLE_REG4_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0090)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_ENABLE_REG1_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x00a4)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_ENABLE_REG2_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x00a8)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_ENABLE_REG3_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x00ac)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_ENABLE_REG4_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x00b0)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_STATUS_REG1(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0104)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_STATUS_REG2(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0108)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_STATUS_REG3(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x010c)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_STATUS_REG4(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0110)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_STATUS_REG1_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0124)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_STATUS_REG2_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0128)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_STATUS_REG3_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x012c)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_STATUS_REG4_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0130)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_STATUS_REG1_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0144)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_STATUS_REG2_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0148)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_STATUS_REG3_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x014c)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_STATUS_REG4_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0150)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_ENABLE_REG1(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0164)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_ENABLE_REG2(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0168)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_ENABLE_REG3(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x016c)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_ENABLE_REG4(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0170)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_ENABLE_REG1_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0184)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_ENABLE_REG2_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0188)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_ENABLE_REG3_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x018c)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_ENABLE_REG4_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0190)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_ENABLE_REG1_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x01a4)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_ENABLE_REG2_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x01a8)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_ENABLE_REG3_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x01ac)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_ENABLE_REG4_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x01b0)
+#define ST40_MAILBOX_LOCK0(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0200)
+#define ST40_MAILBOX_LOCK1(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0204)
+#define ST40_MAILBOX_LOCK2(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0208)
+#define ST40_MAILBOX_LOCK3(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x020c)
+#define ST40_MAILBOX_LOCK4(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0210)
+#define ST40_MAILBOX_LOCK5(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0214)
+#define ST40_MAILBOX_LOCK6(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0218)
+#define ST40_MAILBOX_LOCK7(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x021c)
+#define ST40_MAILBOX_LOCK8(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0220)
+#define ST40_MAILBOX_LOCK9(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0224)
+#define ST40_MAILBOX_LOCK10(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0228)
+#define ST40_MAILBOX_LOCK11(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x022c)
+#define ST40_MAILBOX_LOCK12(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0230)
+#define ST40_MAILBOX_LOCK13(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0234)
+#define ST40_MAILBOX_LOCK14(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0238)
+#define ST40_MAILBOX_LOCK15(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x023c)
+#define ST40_MAILBOX_LOCK16(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0240)
+#define ST40_MAILBOX_LOCK17(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0244)
+#define ST40_MAILBOX_LOCK18(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0248)
+#define ST40_MAILBOX_LOCK19(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x024c)
+#define ST40_MAILBOX_LOCK20(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0250)
+#define ST40_MAILBOX_LOCK21(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0254)
+#define ST40_MAILBOX_LOCK22(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0258)
+#define ST40_MAILBOX_LOCK23(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x025c)
+#define ST40_MAILBOX_LOCK24(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0260)
+#define ST40_MAILBOX_LOCK25(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0264)
+#define ST40_MAILBOX_LOCK26(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0268)
+#define ST40_MAILBOX_LOCK27(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x026c)
+#define ST40_MAILBOX_LOCK28(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0270)
+#define ST40_MAILBOX_LOCK29(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0274)
+#define ST40_MAILBOX_LOCK30(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0278)
+#define ST40_MAILBOX_LOCK31(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x027c)
+
+/* System configuration registers (all ST40 variants) */
+#define ST40_SYSCONF_VCR		SH4_DWORD_REG(ST40_SYSCONF_REGS_BASE + 0x00)
+#define ST40_SYSCONF_SYS_CON1_0		SH4_DWORD_REG(ST40_SYSCONF_REGS_BASE + 0x10)
+#define ST40_SYSCONF_SYS_CON1_1		SH4_DWORD_REG(ST40_SYSCONF_REGS_BASE + 0x14)
+#define ST40_SYSCONF_SYS_CON1		SH4_GWORD_REG(ST40_SYSCONF_REGS_BASE + 0x10)
+#define ST40_SYSCONF_SYS_CON2_0		SH4_DWORD_REG(ST40_SYSCONF_REGS_BASE + 0x18)
+#define ST40_SYSCONF_SYS_CON2_1		SH4_DWORD_REG(ST40_SYSCONF_REGS_BASE + 0x1c)
+#define ST40_SYSCONF_SYS_CON2		SH4_GWORD_REG(ST40_SYSCONF_REGS_BASE + 0x18)
+#define ST40_SYSCONF_CNV_STATUS		SH4_BYTE_REG(ST40_SYSCONF_REGS_BASE + 0x20)
+#define ST40_SYSCONF_CNV_SET		SH4_BYTE_REG(ST40_SYSCONF_REGS_BASE + 0x28)
+#define ST40_SYSCONF_CNV_CLEAR		SH4_BYTE_REG(ST40_SYSCONF_REGS_BASE + 0x30)
+#define ST40_SYSCONF_CNV_CONTROL	SH4_DWORD_REG(ST40_SYSCONF_REGS_BASE + 0x38)
+#define ST40_SYSCONF_SYS_STAT1_0	SH4_DWORD_REG(ST40_SYSCONF_REGS_BASE + 0x40)
+#define ST40_SYSCONF_SYS_STAT1_1	SH4_DWORD_REG(ST40_SYSCONF_REGS_BASE + 0x44)
+#define ST40_SYSCONF_SYS_STAT1		SH4_GWORD_REG(ST40_SYSCONF_REGS_BASE + 0x40)
+#define ST40_SYSCONF_SYS_STAT2_0	SH4_DWORD_REG(ST40_SYSCONF_REGS_BASE + 0x48)
+#define ST40_SYSCONF_SYS_STAT2_1	SH4_DWORD_REG(ST40_SYSCONF_REGS_BASE + 0x4c)
+#define ST40_SYSCONF_SYS_STAT2		SH4_GWORD_REG(ST40_SYSCONF_REGS_BASE + 0x48)
+
+/* Synchronous Serial Controller control registers (all ST40 variants) */
+#define ST40_SSC_BRG(n)			SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x0000)
+#define ST40_SSC_TBUF(n)		SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x0004)
+#define ST40_SSC_RBUF(n)		SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x0008)
+#define ST40_SSC_CTL(n)			SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x000c)
+#define ST40_SSC_IEN(n)			SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x0010)
+#define ST40_SSC_STA(n)			SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x0014)
+#define ST40_SSC_I2C(n)			SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x0018)
+#define ST40_SSC_SLAD(n)		SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x001c)
+#define ST40_SSC_REP_START_HOLD(n)	SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x0020)
+#define ST40_SSC_START_HOLD(n)		SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x0024)
+#define ST40_SSC_REP_START_SETUP(n)	SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x0028)
+#define ST40_SSC_DATA_SETUP(n)		SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x002c)
+#define ST40_SSC_STOP_SETUP(n)		SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x0030)
+#define ST40_SSC_BUS_FREE(n)		SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x0034)
+#define ST40_SSC_CLR_STA(n)		SH4_DWORD_REG(ST40_SSC##n##_REGS_BASE + 0x0080)
+#define ST40_SSC_AGFR(n)		SH4_DWORD_REG(ST40_SSC##n##_REGS_BASE + 0x0100)
+#define ST40_SSC_PRSC(n)		SH4_DWORD_REG(ST40_SSC##n##_REGS_BASE + 0x0104)
+
+/* Asynchronous Serial Controller control registers (all ST40 variants) */
+#define ST40_ASC_BAUDRATE(n)		SH4_DWORD_REG(ST40_ASC##n##_REGS_BASE + 0x00)
+#define ST40_ASC_TXBUFFER(n)		SH4_DWORD_REG(ST40_ASC##n##_REGS_BASE + 0x04)
+#define ST40_ASC_RXBUFFER(n)		SH4_DWORD_REG(ST40_ASC##n##_REGS_BASE + 0x08)
+#define ST40_ASC_CONTROL(n)		SH4_DWORD_REG(ST40_ASC##n##_REGS_BASE + 0x0c)
+#define ST40_ASC_INTENABLE(n)		SH4_DWORD_REG(ST40_ASC##n##_REGS_BASE + 0x10)
+#define ST40_ASC_STATUS(n)		SH4_DWORD_REG(ST40_ASC##n##_REGS_BASE + 0x14)
+#define ST40_ASC_GUARDTIME(n)		SH4_DWORD_REG(ST40_ASC##n##_REGS_BASE + 0x18)
+#define ST40_ASC_TIMEOUT(n)		SH4_DWORD_REG(ST40_ASC##n##_REGS_BASE + 0x1c)
+#define ST40_ASC_TXRESET(n)		SH4_DWORD_REG(ST40_ASC##n##_REGS_BASE + 0x20)
+#define ST40_ASC_RXRESET(n)		SH4_DWORD_REG(ST40_ASC##n##_REGS_BASE + 0x24)
+#define ST40_ASC_RETRIES(n)		SH4_DWORD_REG(ST40_ASC##n##_REGS_BASE + 0x28)
+
+#endif /* __ST40REG_H */
diff --git a/include/asm-sh/stb7100reg.h b/include/asm-sh/stb7100reg.h
new file mode 100644
index 0000000..42bb2b0
--- /dev/null
+++ b/include/asm-sh/stb7100reg.h
@@ -0,0 +1,176 @@
+/*
+ * Copyright (C) STMicroelectronics Ltd. 2005.
+ *
+ * All rights reserved.
+ */
+
+#ifndef __STB7100REG_H
+#define __STB7100REG_H
+
+#include "asm/sh4regtype.h"
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Peripheral versions
+ */
+
+#ifndef ST40_LMI_VERSION
+#define ST40_LMI_VERSION 3
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Base addresses for control register banks
+ */
+
+/* Generic SH4 control registers */
+#ifndef SH4_TMU_REGS_BASE
+#define SH4_TMU_REGS_BASE 0xffd80000
+#endif
+#ifndef SH4_RTC_REGS_BASE
+#define SH4_RTC_REGS_BASE 0xffc80000
+#endif
+
+/* Common ST40 control registers */
+#ifndef ST40_CPG_REGS_BASE
+#define ST40_CPG_REGS_BASE 0xffc00000
+#endif
+#ifndef ST40_INTC_REGS_BASE
+#define ST40_INTC_REGS_BASE 0xffd00000
+#endif
+#ifndef ST40_INTC2_REGS_BASE
+#define ST40_INTC2_REGS_BASE 0xfe080000
+#endif
+#ifndef ST40_SCIF1_REGS_BASE
+#define ST40_SCIF1_REGS_BASE 0xffe00000
+#endif
+#ifndef ST40_SCIF2_REGS_BASE
+#define ST40_SCIF2_REGS_BASE 0xffe80000
+#endif
+
+/* STb7100 control registers */
+#ifndef STB7100_SYSCONF_REGS_BASE
+#define STB7100_SYSCONF_REGS_BASE 0xb9001000
+#endif
+
+#ifndef STB7100_CLOCKGENA_REGS_BASE
+#define STB7100_CLOCKGENA_REGS_BASE 0xb9213000
+#endif
+
+/* System Architecture Volume 2: Bus Interfaces */
+#ifndef ST40_LMISYS_REGS_BASE
+#define ST40_LMISYS_REGS_BASE 0xaf000000
+#endif
+#ifndef ST40_LMIVID_REGS_BASE
+#define ST40_LMIVID_REGS_BASE 0xb7000000
+#endif
+#ifndef ST40_EMI_REGS_BASE
+#define ST40_EMI_REGS_BASE 0xba100000
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+#include "asm/st40reg.h"
+
+/*
+ * STb7100 control registers
+ */
+
+/* Clock Generator control registers (STb7100 variant) */
+#define STB7100_CLOCKGENA_LOCK			SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x00)
+#define STB7100_CLOCKGENA_MD_STATUS		SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x04)
+#define STB7100_CLOCKGENA_PLL0_CFG		SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x08)
+#define STB7100_CLOCKGENA_PLL0_STATUS		SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x10)
+#define STB7100_CLOCKGENA_PLL0_CLK1_CTRL	SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x14)
+#define STB7100_CLOCKGENA_PLL0_CLK2_CTRL	SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x18)
+#define STB7100_CLOCKGENA_PLL0_CLK3_CTRL	SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x1c)
+#define STB7100_CLOCKGENA_PLL0_CLK4_CTRL	SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x20)
+#define STB7100_CLOCKGENA_PLL1_CFG		SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x24)
+#define STB7100_CLOCKGENA_PLL1_STATUS		SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x2c)
+#define STB7100_CLOCKGENA_CLK_DIV		SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x30)
+#define STB7100_CLOCKGENA_CLOCK_ENABLE		SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x34)
+#define STB7100_CLOCKGENA_OUT_CTRL		SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x38)
+#define STB7100_CLOCKGENA_PLL1_BYPASS		SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x3c)
+
+/* System configuration registers (STb7100 variant) */
+#if defined(ST40_LITTLE_ENDIAN)
+#define STB7100_SYSCONF_DEVICEID_0	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0000)
+#define STB7100_SYSCONF_DEVICEID_1	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0004)
+#define STB7100_SYSCONF_DEVICEID	STB7100_SYSCONF_DEVICEID_0
+#elif defined(ST40_BIG_ENDIAN)
+#define STB7100_SYSCONF_DEVICEID_0	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0004)
+#define STB7100_SYSCONF_DEVICEID_1	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0000)
+#define STB7100_SYSCONF_DEVICEID	STB7100_SYSCONF_DEVICEID_0
+#else
+#error ST40_LITTLE_ENDIAN and ST40_BIG_ENDIAN undefined
+#endif
+#define STB7100_SYSCONF_SYS_STA00	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0008)
+#define STB7100_SYSCONF_SYS_STA01	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x000c)
+#define STB7100_SYSCONF_SYS_STA02	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0010)
+#define STB7100_SYSCONF_SYS_STA03	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0014)
+#define STB7100_SYSCONF_SYS_STA04	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0018)
+#define STB7100_SYSCONF_SYS_STA05	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x001c)
+#define STB7100_SYSCONF_SYS_STA06	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0020)
+#define STB7100_SYSCONF_SYS_STA07	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0024)
+#define STB7100_SYSCONF_SYS_STA08	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0028)
+#define STB7100_SYSCONF_SYS_STA09	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x002c)
+#define STB7100_SYSCONF_SYS_STA10	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0030)
+#define STB7100_SYSCONF_SYS_STA11	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0034)
+#define STB7100_SYSCONF_SYS_STA12	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0038)
+#define STB7100_SYSCONF_SYS_STA13	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x003c)
+#define STB7100_SYSCONF_SYS_STA14	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0040)
+#define STB7100_SYSCONF_SYS_CFG00	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0100)
+#define STB7100_SYSCONF_SYS_CFG01	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0104)
+#define STB7100_SYSCONF_SYS_CFG02	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0108)
+#define STB7100_SYSCONF_SYS_CFG03	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x010c)
+#define STB7100_SYSCONF_SYS_CFG04	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0110)
+#define STB7100_SYSCONF_SYS_CFG05	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0114)
+#define STB7100_SYSCONF_SYS_CFG06	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0118)
+#define STB7100_SYSCONF_SYS_CFG07	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x011c)
+#define STB7100_SYSCONF_SYS_CFG08	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0120)
+#define STB7100_SYSCONF_SYS_CFG09	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0124)
+#define STB7100_SYSCONF_SYS_CFG10	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0128)
+#define STB7100_SYSCONF_SYS_CFG11	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x012c)
+#define STB7100_SYSCONF_SYS_CFG12	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0130)
+#define STB7100_SYSCONF_SYS_CFG13	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0134)
+#define STB7100_SYSCONF_SYS_CFG14	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0138)
+#define STB7100_SYSCONF_SYS_CFG15	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x013c)
+#define STB7100_SYSCONF_SYS_CFG16	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0140)
+#define STB7100_SYSCONF_SYS_CFG17	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0144)
+#define STB7100_SYSCONF_SYS_CFG18	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0148)
+#define STB7100_SYSCONF_SYS_CFG19	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x014c)
+#define STB7100_SYSCONF_SYS_CFG20	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0150)
+#define STB7100_SYSCONF_SYS_CFG21	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0154)
+#define STB7100_SYSCONF_SYS_CFG22	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0158)
+#define STB7100_SYSCONF_SYS_CFG23	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x015c)
+#define STB7100_SYSCONF_SYS_CFG24	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0160)
+#define STB7100_SYSCONF_SYS_CFG25	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0164)
+#define STB7100_SYSCONF_SYS_CFG26	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0168)
+#define STB7100_SYSCONF_SYS_CFG27	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x016c)
+#define STB7100_SYSCONF_SYS_CFG28	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0170)
+#define STB7100_SYSCONF_SYS_CFG29	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0174)
+#define STB7100_SYSCONF_SYS_CFG30	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0178)
+#define STB7100_SYSCONF_SYS_CFG31	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x017c)
+#define STB7100_SYSCONF_SYS_CFG32	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0180)
+#define STB7100_SYSCONF_SYS_CFG33	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0184)
+#define STB7100_SYSCONF_SYS_CFG34	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0188)
+#define STB7100_SYSCONF_SYS_CFG35	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x018c)
+#define STB7100_SYSCONF_SYS_CFG36	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0190)
+#define STB7100_SYSCONF_SYS_CFG37	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0194)
+#define STB7100_SYSCONF_SYS_CFG38	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0198)
+#define STB7100_SYSCONF_SYS_CFG39	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x019c)
+
+#define STB7100_DEVID_7100_VAL		0x024
+#define STB7100_DEVID_7109_VAL		0x02c
+#define STB7100_DEVID_ID_SHIFT		12
+#define STB7100_DEVID_ID_MASK		0x3ff
+#define STB7100_DEVID_CUT_SHIFT		28
+#define STB7100_DEVID_CUT_MASK		0xf
+
+#define STB7100_DEVICEID_7100(ID) ((((ID) >> STB7100_DEVID_ID_SHIFT) & STB7100_DEVID_ID_MASK) == STB7100_DEVID_7100_VAL)
+#define STB7100_DEVICEID_7109(ID) ((((ID) >> STB7100_DEVID_ID_SHIFT) & STB7100_DEVID_ID_MASK) == STB7100_DEVID_7109_VAL)
+#define STB7100_DEVICEID_CUT(ID)  ((((ID) >> STB7100_DEVID_CUT_SHIFT) & STB7100_DEVID_CUT_MASK) + 1)
+
+#endif /* __STB7100REG_H */
diff --git a/include/asm-sh/stbus.h b/include/asm-sh/stbus.h
new file mode 100644
index 0000000..5c20efa
--- /dev/null
+++ b/include/asm-sh/stbus.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2007-2008 STMicroelectronics Limited
+ * David McKay <David.McKay@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __STBUS_H__
+#define __STBUS_H__
+
+/*--------------------------------------------------------------*
+ * These register are described in ADCS 7801572B.
+ *--------------------------------------------------------------*/
+
+/* Defines for the USB controller register offsets. */
+#define AHB2STBUS_WRAPPER_GLUE_BASE	(CFG_USB_BASE + 0x00000000)
+#define AHB2STBUS_OHCI_BASE		(CFG_USB_BASE + 0x000ffc00)
+#define AHB2STBUS_PROTOCOL_BASE		(CFG_USB_BASE + 0x000fff00)
+
+/* The transaction opcode is programmed in this register. */
+#define AHB2STBUS_STBUS_OPC		(AHB2STBUS_PROTOCOL_BASE + 0x00)
+#define AHB2STBUS_STBUS_OPC_4BIT	0x00
+#define AHB2STBUS_STBUS_OPC_8BIT	0x01
+#define AHB2STBUS_STBUS_OPC_16BIT	0x02
+#define AHB2STBUS_STBUS_OPC_32BIT	0x03
+#define AHB2STBUS_STBUS_OPC_64BIT	0x04
+
+/* The message length in number of packets is programmed in this register. */
+#define AHB2STBUS_MSGSIZE		(AHB2STBUS_PROTOCOL_BASE + 0x04)
+#define AHB2STBUS_MSGSIZE_DISABLE	0x0
+#define AHB2STBUS_MSGSIZE_2		0x1
+#define AHB2STBUS_MSGSIZE_4		0x2
+#define AHB2STBUS_MSGSIZE_8		0x3
+#define AHB2STBUS_MSGSIZE_16		0x4
+#define AHB2STBUS_MSGSIZE_32		0x5
+#define AHB2STBUS_MSGSIZE_64		0x6
+
+/* The chunk size in number of packets is programmed in this register. */
+#define AHB2STBUS_CHUNKSIZE		(AHB2STBUS_PROTOCOL_BASE + 0x08)
+#define AHB2STBUS_CHUNKSIZE_DISABLE	0x0
+#define AHB2STBUS_CHUNKSIZE_2		0x1
+#define AHB2STBUS_CHUNKSIZE_4		0x2
+#define AHB2STBUS_CHUNKSIZE_8		0x3
+#define AHB2STBUS_CHUNKSIZE_16		0x4
+#define AHB2STBUS_CHUNKSIZE_32		0x5
+#define AHB2STBUS_CHUNKSIZE_64		0x6
+
+/* AHB Strap options are programmed in this register. */
+#define AHB2STBUS_STRAP			(AHB2STBUS_WRAPPER_GLUE_BASE + 0x14)
+#define AHB2STBUS_STRAP_PLL		0x08	/* PLL_PWR_DWN */
+#define AHB2STBUS_STRAP_16_BIT		0x04	/* SS_WORD_IF */
+
+#endif	/* __STBUS_H__ */
diff --git a/include/asm-sh/string.h b/include/asm-sh/string.h
new file mode 100644
index 0000000..9b681b3
--- /dev/null
+++ b/include/asm-sh/string.h
@@ -0,0 +1,128 @@
+#ifndef __ASM_SH_STRING_H
+#define __ASM_SH_STRING_H
+
+/*
+ * Copyright (C) 1999 Niibe Yutaka
+ * But consider these trivial functions to be public domain.
+ */
+
+#define __HAVE_ARCH_STRCPY
+static __inline__ char *strcpy (char *__dest, const char *__src)
+{
+	register char *__xdest = __dest;
+	unsigned long __dummy;
+
+	__asm__ __volatile__ ("1:\n\t"
+			      "mov.b	@%1+, %2\n\t"
+			      "mov.b	%2, @%0\n\t"
+			      "cmp/eq	#0, %2\n\t"
+			      "bf/s	1b\n\t"
+			      " add	#1, %0\n\t":"=r" (__dest),
+			      "=r" (__src), "=&z" (__dummy)
+			      :"0" (__dest), "1" (__src)
+			      :"memory", "t");
+
+	return __xdest;
+}
+
+#define __HAVE_ARCH_STRNCPY
+static __inline__ char *strncpy (char *__dest, const char *__src, size_t __n)
+{
+	register char *__xdest = __dest;
+	unsigned long __dummy;
+
+	if (__n == 0)
+		return __xdest;
+
+	__asm__ __volatile__ ("1:\n"
+			      "mov.b	@%1+, %2\n\t"
+			      "mov.b	%2, @%0\n\t"
+			      "cmp/eq	#0, %2\n\t"
+			      "bt/s	2f\n\t"
+			      " cmp/eq	%5,%1\n\t"
+			      "bf/s	1b\n\t"
+			      " add	#1, %0\n"
+			      "2:":"=r"
+			      (__dest), "=r" (__src), "=&z" (__dummy)
+			      :"0" (__dest), "1" (__src), "r" (__src + __n)
+			      :"memory", "t");
+
+	return __xdest;
+}
+
+#define __HAVE_ARCH_STRCMP
+static __inline__ int strcmp (const char *__cs, const char *__ct)
+{
+	register int __res;
+	unsigned long __dummy;
+
+	__asm__ __volatile__ ("mov.b	@%1+, %3\n"
+			      "1:\n\t"
+			      "mov.b	@%0+, %2\n\t"
+			      "cmp/eq #0, %3\n\t"
+			      "bt	2f\n\t"
+			      "cmp/eq %2, %3\n\t"
+			      "bt/s	1b\n\t"
+			      " mov.b	@%1+, %3\n\t"
+			      "add	#-2, %1\n\t"
+			      "mov.b	@%1, %3\n\t"
+			      "sub	%3, %2\n"
+			      "2:":"=r" (__cs),
+			      "=r" (__ct), "=&r" (__res), "=&z" (__dummy)
+			      :"0" (__cs), "1" (__ct)
+			      :"t");
+
+	return __res;
+}
+
+#define __HAVE_ARCH_STRNCMP
+static __inline__ int strncmp (const char *__cs, const char *__ct, size_t __n)
+{
+	register int __res;
+	unsigned long __dummy;
+
+	if (__n == 0)
+		return 0;
+
+	__asm__ __volatile__ ("mov.b	@%1+, %3\n"
+			      "1:\n\t"
+			      "mov.b	@%0+, %2\n\t"
+			      "cmp/eq %6, %0\n\t"
+			      "bt/s	2f\n\t"
+			      " cmp/eq #0, %3\n\t"
+			      "bt/s	3f\n\t"
+			      " cmp/eq %3, %2\n\t"
+			      "bt/s	1b\n\t"
+			      " mov.b	@%1+, %3\n\t"
+			      "add	#-2, %1\n\t"
+			      "mov.b	@%1, %3\n"
+			      "2:\n\t"
+			      "sub	%3, %2\n"
+			      "3:":"=r"
+			      (__cs),
+			      "=r" (__ct), "=&r" (__res), "=&z" (__dummy)
+			      :"0" (__cs), "1" (__ct), "r" (__cs + __n)
+			      :"t");
+
+	return __res;
+}
+
+#define __HAVE_ARCH_MEMSET
+extern void *memset (void *__s, int __c, size_t __count);
+
+#define __HAVE_ARCH_MEMCPY
+extern void *memcpy (void *__to, __const__ void *__from, size_t __n);
+
+#define __HAVE_ARCH_MEMMOVE
+extern void *memmove (void *__dest, __const__ void *__src, size_t __n);
+
+#define __HAVE_ARCH_MEMCHR
+extern void *memchr (const void *__s, int __c, size_t __n);
+
+#define __HAVE_ARCH_STRLEN
+extern size_t strlen (const char *);
+
+/* Don't build bcopy at all ...  */
+#define __HAVE_ARCH_BCOPY
+
+#endif /* __ASM_SH_STRING_H */
diff --git a/include/asm-sh/stx7200reg.h b/include/asm-sh/stx7200reg.h
new file mode 100644
index 0000000..aa5a487
--- /dev/null
+++ b/include/asm-sh/stx7200reg.h
@@ -0,0 +1,314 @@
+/*
+ * Copyright (C) STMicroelectronics Ltd. 2007.
+ *
+ * All rights reserved.
+ */
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/bare/sh4reg/sti7200reg.h
+ */
+
+
+#ifndef __STX7200REG_H
+#define __STX7200REG_H
+
+#include "sh4regtype.h"
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Peripheral versions
+ */
+
+#ifndef ST40_LMIGP_VERSION
+#define ST40_LMIGP_VERSION 1
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Base addresses for control register banks.
+ */
+
+/* Generic SH4 control registers */
+#ifndef SH4_TMU_REGS_BASE
+#define SH4_TMU_REGS_BASE 0xffd80000
+#endif
+#ifndef SH4_RTC_REGS_BASE
+#define SH4_RTC_REGS_BASE 0xffc80000
+#endif
+
+/* Common ST40 control registers */
+#ifndef ST40_CPG_REGS_BASE
+#define ST40_CPG_REGS_BASE 0xffc00000
+#endif
+#ifndef ST40_INTC_REGS_BASE
+#define ST40_INTC_REGS_BASE 0xffd00000
+#endif
+#ifndef ST40_SCIF2_REGS_BASE
+#define ST40_SCIF2_REGS_BASE 0xffe80000
+#endif
+
+#ifndef ST40_ILC_REGS_BASE
+#define ST40_ILC_REGS_BASE 0xfd804000
+#endif
+
+/* STx7200 control registers */
+#ifndef STX7200_SYSCONF_REGS_BASE
+#define STX7200_SYSCONF_REGS_BASE 0xfd704000
+#endif
+
+#ifndef STX7200_CLOCKGENA_REGS_BASE
+#define STX7200_CLOCKGENA_REGS_BASE 0xfd700000
+#endif
+
+#ifndef STX7200_CLOCKGENB_REGS_BASE
+#define STX7200_CLOCKGENB_REGS_BASE (STX7200_CLOCKGENA_REGS_BASE + 0x1000)
+#endif
+
+#ifndef STX7200_CLOCKGENC_REGS_BASE
+#define STX7200_CLOCKGENC_REGS_BASE (STX7200_CLOCKGENA_REGS_BASE + 0x2000)
+#endif
+
+#ifndef STX7200_STBUS_NODE00_REGS_BASE
+#define STX7200_STBUS_NODE00_REGS_BASE 0xfdc05000
+#endif
+#ifndef STX7200_STBUS_NODE01_REGS_BASE
+#define STX7200_STBUS_NODE01_REGS_BASE 0xfdc05c00
+#endif
+#ifndef STX7200_STBUS_NODE04_REGS_BASE
+#define STX7200_STBUS_NODE04_REGS_BASE 0xfdc05600
+#endif
+#ifndef STX7200_STBUS_NODE08_REGS_BASE
+#define STX7200_STBUS_NODE08_REGS_BASE 0xfdc05a00
+#endif
+#ifndef STX7200_STBUS_NODE09_REGS_BASE
+#define STX7200_STBUS_NODE09_REGS_BASE 0xfdc06000
+#endif
+#ifndef STX7200_STBUS_NODE10_REGS_BASE
+#define STX7200_STBUS_NODE10_REGS_BASE 0xfdc06200
+#endif
+#ifndef STX7200_STBUS_NODE12_REGS_BASE
+#define STX7200_STBUS_NODE12_REGS_BASE 0xfdc05800
+#endif
+#ifndef STX7200_STBUS_NODE13_REGS_BASE
+#define STX7200_STBUS_NODE13_REGS_BASE 0xfdc05200
+#endif
+#ifndef STX7200_STBUS_NODE17_REGS_BASE
+#define STX7200_STBUS_NODE17_REGS_BASE 0xfdc05400
+#endif
+#ifndef STX7200_STBUS_NODE18_REGS_BASE
+#define STX7200_STBUS_NODE18_REGS_BASE 0xfdc05e00
+#endif
+#ifndef STX7200_STBUS_NODE20_REGS_BASE
+#define STX7200_STBUS_NODE20_REGS_BASE 0xfdc06400
+#endif
+
+/* System Architecture Volume 2: Bus Interfaces */
+#ifndef ST40_LMI0_REGS_BASE
+#define ST40_LMI0_REGS_BASE 0xfdd18000
+#endif
+#ifndef ST40_LMI1_REGS_BASE
+#define ST40_LMI1_REGS_BASE 0xfdd19000
+#endif
+#ifndef ST40_EMI_REGS_BASE
+#define ST40_EMI_REGS_BASE 0xfdf00000
+#endif
+
+/* System Architecture Volume 4: I/O Devices */
+#ifndef STX7200_COMMS_BASE
+#define STX7200_COMMS_BASE 0xfd000000
+#endif
+
+#ifndef ST40_PIO0_REGS_BASE
+#define ST40_PIO0_REGS_BASE (STX7200_COMMS_BASE + 0x00020000)
+#endif
+#ifndef ST40_PIO1_REGS_BASE
+#define ST40_PIO1_REGS_BASE (STX7200_COMMS_BASE + 0x00021000)
+#endif
+#ifndef ST40_PIO2_REGS_BASE
+#define ST40_PIO2_REGS_BASE (STX7200_COMMS_BASE + 0x00022000)
+#endif
+#ifndef ST40_PIO3_REGS_BASE
+#define ST40_PIO3_REGS_BASE (STX7200_COMMS_BASE + 0x00023000)
+#endif
+#ifndef ST40_PIO4_REGS_BASE
+#define ST40_PIO4_REGS_BASE (STX7200_COMMS_BASE + 0x00024000)
+#endif
+#ifndef ST40_PIO5_REGS_BASE
+#define ST40_PIO5_REGS_BASE (STX7200_COMMS_BASE + 0x00025000)
+#endif
+#ifndef ST40_PIO6_REGS_BASE
+#define ST40_PIO6_REGS_BASE (STX7200_COMMS_BASE + 0x00026000)
+#endif
+#ifndef ST40_PIO7_REGS_BASE
+#define ST40_PIO7_REGS_BASE (STX7200_COMMS_BASE + 0x00027000)
+#endif
+#ifndef ST40_ASC0_REGS_BASE
+#define ST40_ASC0_REGS_BASE (STX7200_COMMS_BASE + 0x00030000)
+#endif
+#ifndef ST40_ASC1_REGS_BASE
+#define ST40_ASC1_REGS_BASE (STX7200_COMMS_BASE + 0x00031000)
+#endif
+#ifndef ST40_ASC2_REGS_BASE
+#define ST40_ASC2_REGS_BASE (STX7200_COMMS_BASE + 0x00032000)
+#endif
+#ifndef ST40_ASC3_REGS_BASE
+#define ST40_ASC3_REGS_BASE (STX7200_COMMS_BASE + 0x00033000)
+#endif
+#ifndef ST40_SSC0_REGS_BASE
+#define ST40_SSC0_REGS_BASE (STX7200_COMMS_BASE + 0x00040000)
+#endif
+#ifndef ST40_SSC1_REGS_BASE
+#define ST40_SSC1_REGS_BASE (STX7200_COMMS_BASE + 0x00041000)
+#endif
+#ifndef ST40_SSC2_REGS_BASE
+#define ST40_SSC2_REGS_BASE (STX7200_COMMS_BASE + 0x00042000)
+#endif
+#ifndef ST40_SSC3_REGS_BASE
+#define ST40_SSC3_REGS_BASE (STX7200_COMMS_BASE + 0x00043000)
+#endif
+#ifndef ST40_SSC4_REGS_BASE
+#define ST40_SSC4_REGS_BASE (STX7200_COMMS_BASE + 0x00044000)
+#endif
+#ifndef ST40_MAILBOX0_REGS_BASE
+#define ST40_MAILBOX0_REGS_BASE 0xfd800000
+#endif
+#ifndef ST40_MAILBOX1_REGS_BASE
+#define ST40_MAILBOX1_REGS_BASE (ST40_MAILBOX0_REGS_BASE + 0x1000)
+#endif
+#ifndef ST40_MAILBOX2_REGS_BASE
+#define ST40_MAILBOX2_REGS_BASE (ST40_MAILBOX0_REGS_BASE + 0x2000)
+#endif
+#ifndef ST40_MAILBOX3_REGS_BASE
+#define ST40_MAILBOX3_REGS_BASE (ST40_MAILBOX0_REGS_BASE + 0x3000)
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+#include "st40reg.h"
+
+/*
+ * STx7200 control registers
+ */
+
+/* Clock Generator control registers (STx7200 variant) */
+#define STX7200_CLOCKGENA_PLL0_CFG		SH4_DWORD_REG(STX7200_CLOCKGENA_REGS_BASE + 0x00)
+#define STX7200_CLOCKGENA_PLL1_CFG		SH4_DWORD_REG(STX7200_CLOCKGENA_REGS_BASE + 0x04)
+#define STX7200_CLOCKGENA_PLL2_CFG		SH4_DWORD_REG(STX7200_CLOCKGENA_REGS_BASE + 0x08)
+#define STX7200_CLOCKGENA_MUX_CFG		SH4_DWORD_REG(STX7200_CLOCKGENA_REGS_BASE + 0x0c)
+#define STX7200_CLOCKGENA_DIV_CFG		SH4_DWORD_REG(STX7200_CLOCKGENA_REGS_BASE + 0x10)
+#define STX7200_CLOCKGENA_DIV2_CFG		SH4_DWORD_REG(STX7200_CLOCKGENA_REGS_BASE + 0x14)
+#define STX7200_CLOCKGENA_CLKOBS_MUX_CFG	SH4_DWORD_REG(STX7200_CLOCKGENA_REGS_BASE + 0x18)
+#define STX7200_CLOCKGENA_POWER_CFG		SH4_DWORD_REG(STX7200_CLOCKGENA_REGS_BASE + 0x1c)
+#define STX7200_CLOCKGENA_CLKOBS_MAX		SH4_DWORD_REG(STX7200_CLOCKGENA_REGS_BASE + 0x20)
+#define STX7200_CLOCKGENA_CLKOBS_RESULT		SH4_DWORD_REG(STX7200_CLOCKGENA_REGS_BASE + 0x24)
+#define STX7200_CLOCKGENA_CLKOBS_CTRL		SH4_DWORD_REG(STX7200_CLOCKGENA_REGS_BASE + 0x28)
+
+#define STX7200_CLOCKGENB_FS0_SETUP		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x00)
+#define STX7200_CLOCKGENB_FS1_SETUP		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x04)
+#define STX7200_CLOCKGENB_FS2_SETUP		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x08)
+#define STX7200_CLOCKGENB_FS0_CLK1_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x0c)
+#define STX7200_CLOCKGENB_FS0_CLK2_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x10)
+#define STX7200_CLOCKGENB_FS0_CLK3_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x14)
+#define STX7200_CLOCKGENB_FS0_CLK4_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x18)
+#define STX7200_CLOCKGENB_FS1_CLK1_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x1c)
+#define STX7200_CLOCKGENB_FS1_CLK2_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x20)
+#define STX7200_CLOCKGENB_FS1_CLK3_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x24)
+#define STX7200_CLOCKGENB_FS1_CLK4_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x28)
+#define STX7200_CLOCKGENB_FS2_CLK1_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x2c)
+#define STX7200_CLOCKGENB_FS2_CLK2_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x30)
+#define STX7200_CLOCKGENB_FS2_CLK3_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x34)
+#define STX7200_CLOCKGENB_FS2_CLK4_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x38)
+#define STX7200_CLOCKGENB_PLL0_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x3c)
+#define STX7200_CLOCKGENB_CLKRCV_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x40)
+#define STX7200_CLOCKGENB_IN_MUX_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x44)
+#define STX7200_CLOCKGENB_OUT_MUX_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x48)
+#define STX7200_CLOCKGENB_DIV_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x4c)
+#define STX7200_CLOCKGENB_DIV2_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x50)
+#define STX7200_CLOCKGENB_CLKOBS_MUX_CFG	SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x54)
+#define STX7200_CLOCKGENB_POWER_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x58)
+#define STX7200_CLOCKGENB_CLKOBS_MAX		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x5c)
+#define STX7200_CLOCKGENB_CLKOBS_RESULT		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x60)
+#define STX7200_CLOCKGENB_CLKOBS_CTRL		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x64)
+
+/* System configuration registers (STx7200 variant) */
+#define STX7200_SYSCONF_DEVICEID_0	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0000)
+#define STX7200_SYSCONF_DEVICEID_1	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0004)
+#define STX7200_SYSCONF_DEVICEID	SH4_GWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0000)
+#define STX7200_SYSCONF_SYS_STA00	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0008)
+#define STX7200_SYSCONF_SYS_STA01	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x000c)
+#define STX7200_SYSCONF_SYS_STA02	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0010)
+#define STX7200_SYSCONF_SYS_STA03	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0014)
+#define STX7200_SYSCONF_SYS_STA04	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0018)
+#define STX7200_SYSCONF_SYS_STA05	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x001c)
+#define STX7200_SYSCONF_SYS_STA06	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0020)
+#define STX7200_SYSCONF_SYS_STA07	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0024)
+#define STX7200_SYSCONF_SYS_STA08	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0028)
+#define STX7200_SYSCONF_SYS_STA09	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x002c)
+#define STX7200_SYSCONF_SYS_STA10	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0030)
+#define STX7200_SYSCONF_SYS_STA11	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0034)
+#define STX7200_SYSCONF_SYS_STA12	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0038)
+#define STX7200_SYSCONF_SYS_STA13	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x003c)
+#define STX7200_SYSCONF_SYS_STA14	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0040)
+#define STX7200_SYSCONF_SYS_STA15	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0044)
+#define STX7200_SYSCONF_SYS_CFG00	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0100)
+#define STX7200_SYSCONF_SYS_CFG01	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0104)
+#define STX7200_SYSCONF_SYS_CFG02	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0108)
+#define STX7200_SYSCONF_SYS_CFG03	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x010c)
+#define STX7200_SYSCONF_SYS_CFG04	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0110)
+#define STX7200_SYSCONF_SYS_CFG05	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0114)
+#define STX7200_SYSCONF_SYS_CFG06	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0118)
+#define STX7200_SYSCONF_SYS_CFG07	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x011c)
+#define STX7200_SYSCONF_SYS_CFG08	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0120)
+#define STX7200_SYSCONF_SYS_CFG09	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0124)
+#define STX7200_SYSCONF_SYS_CFG10	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0128)
+#define STX7200_SYSCONF_SYS_CFG11	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x012c)
+#define STX7200_SYSCONF_SYS_CFG12	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0130)
+#define STX7200_SYSCONF_SYS_CFG13	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0134)
+#define STX7200_SYSCONF_SYS_CFG14	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0138)
+#define STX7200_SYSCONF_SYS_CFG15	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x013c)
+#define STX7200_SYSCONF_SYS_CFG16	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0140)
+#define STX7200_SYSCONF_SYS_CFG17	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0144)
+#define STX7200_SYSCONF_SYS_CFG18	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0148)
+#define STX7200_SYSCONF_SYS_CFG19	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x014c)
+#define STX7200_SYSCONF_SYS_CFG20	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0150)
+#define STX7200_SYSCONF_SYS_CFG21	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0154)
+#define STX7200_SYSCONF_SYS_CFG22	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0158)
+#define STX7200_SYSCONF_SYS_CFG23	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x015c)
+#define STX7200_SYSCONF_SYS_CFG24	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0160)
+#define STX7200_SYSCONF_SYS_CFG25	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0164)
+#define STX7200_SYSCONF_SYS_CFG26	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0168)
+#define STX7200_SYSCONF_SYS_CFG27	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x016c)
+#define STX7200_SYSCONF_SYS_CFG28	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0170)
+#define STX7200_SYSCONF_SYS_CFG29	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0174)
+#define STX7200_SYSCONF_SYS_CFG30	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0178)
+#define STX7200_SYSCONF_SYS_CFG31	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x017c)
+#define STX7200_SYSCONF_SYS_CFG32	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0180)
+#define STX7200_SYSCONF_SYS_CFG33	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0184)
+#define STX7200_SYSCONF_SYS_CFG34	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0188)
+#define STX7200_SYSCONF_SYS_CFG35	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x018c)
+#define STX7200_SYSCONF_SYS_CFG36	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0190)
+#define STX7200_SYSCONF_SYS_CFG37	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0194)
+#define STX7200_SYSCONF_SYS_CFG38	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0198)
+#define STX7200_SYSCONF_SYS_CFG39	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x019c)
+#define STX7200_SYSCONF_SYS_CFG40	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01a0)
+#define STX7200_SYSCONF_SYS_CFG41	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01a4)
+#define STX7200_SYSCONF_SYS_CFG42	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01a8)
+#define STX7200_SYSCONF_SYS_CFG43	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01ac)
+#define STX7200_SYSCONF_SYS_CFG44	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01b0)
+#define STX7200_SYSCONF_SYS_CFG45	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01b4)
+#define STX7200_SYSCONF_SYS_CFG46	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01b8)
+#define STX7200_SYSCONF_SYS_CFG47	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01bc)
+
+#define STX7200_DEVID_7200_VAL		0x2C0
+#define STX7200_DEVID_ID_SHIFT		12
+#define STX7200_DEVID_ID_MASK		0x3ff
+#define STX7200_DEVID_CUT_SHIFT		28
+#define STX7200_DEVID_CUT_MASK		0xf
+
+#define STX7200_DEVICEID_7200(ID) ((((ID) >> STX7200_DEVID_ID_SHIFT) & STX7200_DEVID_ID_MASK) == STX7200_DEVID_7200_VAL)
+#define STX7200_DEVICEID_CUT(ID)  ((((ID) >> STX7200_DEVID_CUT_SHIFT) & STX7200_DEVID_CUT_MASK) + 1)
+
+#endif /* __STX7200REG_H */
diff --git a/include/asm-sh/system.h b/include/asm-sh/system.h
new file mode 100644
index 0000000..9891ab9
--- /dev/null
+++ b/include/asm-sh/system.h
@@ -0,0 +1,296 @@
+#ifndef __ASM_SH_SYSTEM_H
+#define __ASM_SH_SYSTEM_H
+
+/*
+ * Copyright (C) 1999, 2000  Niibe Yutaka  &  Kaz Kojima
+ */
+
+#include <linux/config.h>
+
+/* #include <linux/kernel.h> */
+
+/*
+ *	switch_to() should switch tasks to task nr n, first
+ */
+
+typedef struct
+{
+	unsigned long seg;
+} mm_segment_t;
+
+#ifdef CONFIG_SMP
+#error no SMP SuperH
+#else
+#define prepare_to_switch()	do { } while(0)
+#define switch_to(prev,next,last) do { \
+ register struct task_struct *__last; \
+ register unsigned long *__ts1 __asm__ ("r1") = &prev->thread.sp; \
+ register unsigned long *__ts2 __asm__ ("r2") = &prev->thread.pc; \
+ register unsigned long *__ts4 __asm__ ("r4") = (unsigned long *)prev; \
+ register unsigned long *__ts5 __asm__ ("r5") = (unsigned long *)next; \
+ register unsigned long *__ts6 __asm__ ("r6") = &next->thread.sp; \
+ register unsigned long __ts7 __asm__ ("r7") = next->thread.pc; \
+ __asm__ __volatile__ (".balign 4\n\t" \
+		       "stc.l	gbr, @-r15\n\t" \
+		       "sts.l	pr, @-r15\n\t" \
+		       "mov.l	r8, @-r15\n\t" \
+		       "mov.l	r9, @-r15\n\t" \
+		       "mov.l	r10, @-r15\n\t" \
+		       "mov.l	r11, @-r15\n\t" \
+		       "mov.l	r12, @-r15\n\t" \
+		       "mov.l	r13, @-r15\n\t" \
+		       "mov.l	r14, @-r15\n\t" \
+		       "mov.l	r15, @r1	! save SP\n\t" \
+		       "mov.l	@r6, r15	! change to new stack\n\t" \
+		       "mov.l	%0, @-r15	! push R0 onto new stack\n\t" \
+		       "mova	1f, %0\n\t" \
+		       "mov.l	%0, @r2	! save PC\n\t" \
+		       "mov.l	2f, %0\n\t" \
+		       "jmp	@%0		! call __switch_to\n\t" \
+		       " lds	r7, pr	!  with return to new PC\n\t" \
+		       ".balign	4\n"	\
+		       "2:\n\t" \
+		       ".long	" "__switch_to\n" \
+		       "1:\n\t" \
+		       "mov.l	@r15+, %0	! pop R0 from new stack\n\t" \
+		       "mov.l	@r15+, r14\n\t" \
+		       "mov.l	@r15+, r13\n\t" \
+		       "mov.l	@r15+, r12\n\t" \
+		       "mov.l	@r15+, r11\n\t" \
+		       "mov.l	@r15+, r10\n\t" \
+		       "mov.l	@r15+, r9\n\t" \
+		       "mov.l	@r15+, r8\n\t" \
+		       "lds.l	@r15+, pr\n\t" \
+		       "ldc.l	@r15+, gbr\n\t" \
+		       :"=&z" (__last) \
+		       :"0" (prev), \
+			"r" (__ts1), "r" (__ts2), \
+			"r" (__ts4), "r" (__ts5), "r" (__ts6), "r" (__ts7) \
+		       :"r3", "t"); \
+  last = __last; \
+} while (0)
+#endif
+
+#define nop() __asm__ __volatile__ ("nop")
+
+
+#define xchg(ptr,x) ((__typeof__(*(ptr)))__xchg((unsigned long)(x),(ptr),sizeof(*(ptr))))
+
+static __inline__ unsigned long tas (volatile int *m)
+{				/* #define tas(ptr) (xchg((ptr),1)) */
+	unsigned long retval;
+
+	__asm__ __volatile__ ("tas.b	@%1\n\t"
+			      "movt	%0":"=r" (retval):"r" (m):"t",
+			      "memory");
+	return retval;
+}
+
+extern void __xchg_called_with_bad_pointer (void);
+
+#define mb()	__asm__ __volatile__ ("": : :"memory")
+#define rmb()	mb()
+#define wmb()	__asm__ __volatile__ ("": : :"memory")
+
+#ifdef CONFIG_SMP
+#define smp_mb()	mb()
+#define smp_rmb()	rmb()
+#define smp_wmb()	wmb()
+#else
+#define smp_mb()	barrier()
+#define smp_rmb()	barrier()
+#define smp_wmb()	barrier()
+#endif
+
+#define set_mb(var, value)  do { var = value; mb(); } while (0)
+#define set_wmb(var, value) do { var = value; wmb(); } while (0)
+
+/* Interrupt Control */
+static __inline__ void __sti (void)
+{
+	unsigned long __dummy0, __dummy1;
+
+	__asm__ __volatile__ ("stc	sr, %0\n\t"
+			      "and	%1, %0\n\t"
+			      "stc	r6_bank, %1\n\t"
+			      "or	%1, %0\n\t"
+			      "ldc	%0, sr":"=&r"
+			      (__dummy0), "=r" (__dummy1)
+			      :"1" (~0x000000f0)
+			      :"memory");
+}
+
+static __inline__ void __cli (void)
+{
+	unsigned long __dummy;
+	__asm__ __volatile__ ("stc	sr, %0\n\t"
+			      "or	#0xf0, %0\n\t"
+			      "ldc	%0, sr":"=&z" (__dummy)
+			      :	/* no inputs */
+			      :"memory");
+}
+
+#define __save_flags(x) \
+	__asm__ __volatile__("stc sr, %0\n\t" \
+			     "and #0xf0, %0"  \
+			     : "=&z" (x) :/**/: "memory" )
+
+static __inline__ unsigned long __save_and_cli (void)
+{
+	unsigned long flags, __dummy;
+
+	__asm__ __volatile__ ("stc	sr, %1\n\t"
+			      "mov	%1, %0\n\t"
+			      "or	#0xf0, %0\n\t"
+			      "ldc	%0, sr\n\t"
+			      "mov	%1, %0\n\t"
+			      "and	#0xf0, %0":"=&z"
+			      (flags), "=&r" (__dummy)
+			      : /**/:"memory");
+	return flags;
+}
+
+#ifdef DEBUG_CLI_STI
+static __inline__ void __restore_flags (unsigned long x)
+{
+	if ((x & 0x000000f0) != 0x000000f0)
+		__sti ();
+	else {
+		unsigned long flags;
+		__save_flags (flags);
+
+		if (flags == 0) {
+			extern void dump_stack (void);
+			printk (KERN_ERR "BUG!\n");
+			dump_stack ();
+			__cli ();
+		}
+	}
+}
+#else
+#define __restore_flags(x) do { 			\
+	if ((x & 0x000000f0) != 0x000000f0)		\
+		__sti();				\
+} while (0)
+#endif
+
+#define really_restore_flags(x) do { 			\
+	if ((x & 0x000000f0) != 0x000000f0)		\
+		__sti();				\
+	else						\
+		__cli();				\
+} while (0)
+
+/*
+ * Jump to P2 area.
+ * When handling TLB or caches, we need to do it from P2 area.
+ */
+#define jump_to_P2()			\
+do {					\
+	unsigned long __dummy;		\
+	__asm__ __volatile__(		\
+		"mov.l	1f, %0\n\t"	\
+		"or	%1, %0\n\t"	\
+		"jmp	@%0\n\t"	\
+		" nop\n\t" 		\
+		".balign 4\n"		\
+		"1:	.long 2f\n"	\
+		"2:"			\
+		: "=&r" (__dummy)	\
+		: "r" (0x20000000));	\
+} while (0)
+
+/*
+ * Back to P1 area.
+ */
+#define back_to_P1()					\
+do {							\
+	unsigned long __dummy;				\
+	__asm__ __volatile__(				\
+		"nop;nop;nop;nop;nop;nop;nop\n\t"	\
+		"mov.l	1f, %0\n\t"			\
+		"jmp	@%0\n\t"			\
+		" nop\n\t"				\
+		".balign 4\n"				\
+		"1:	.long 2f\n"			\
+		"2:"					\
+		: "=&r" (__dummy));			\
+} while (0)
+
+#define __save_and_sti(x)       do { __save_flags(x); __sti(); } while(0);
+
+/* For spinlocks etc */
+#define local_irq_save(x)	x = __save_and_cli()
+#define local_irq_set(x)	__save_and_sti(x)
+#define local_irq_restore(x)	__restore_flags(x)
+#define local_irq_disable()	__cli()
+#define local_irq_enable()	__sti()
+
+#ifdef CONFIG_SMP
+
+extern void __global_cli (void);
+extern void __global_sti (void);
+extern unsigned long __global_save_flags (void);
+extern void __global_restore_flags (unsigned long);
+#define cli() __global_cli()
+#define sti() __global_sti()
+#define save_flags(x) ((x)=__global_save_flags())
+#define restore_flags(x) __global_restore_flags(x)
+#define save_and_sti(x) do { save_flags(x); sti(); } while(0);
+#else
+
+#define cli() __cli()
+#define sti() __sti()
+#define save_flags(x) __save_flags(x)
+#define save_and_cli(x) x = __save_and_cli()
+#define save_and_sti(x) __save_and_sti(x)
+#define restore_flags(x) __restore_flags(x)
+
+#endif
+
+static __inline__ unsigned long xchg_u32 (volatile int *m, unsigned long val)
+{
+	unsigned long flags, retval;
+
+	save_and_cli (flags);
+	retval = *m;
+	*m = val;
+	restore_flags (flags);
+	return retval;
+}
+
+static __inline__ unsigned long xchg_u8 (volatile unsigned char *m,
+					 unsigned long val)
+{
+	unsigned long flags, retval;
+
+	save_and_cli (flags);
+	retval = *m;
+	*m = val & 0xff;
+	restore_flags (flags);
+	return retval;
+}
+
+static __inline__ unsigned long __xchg (unsigned long x, volatile void *ptr,
+					int size)
+{
+	switch (size) {
+	case 4:
+		return xchg_u32 (ptr, x);
+		break;
+	case 1:
+		return xchg_u8 (ptr, x);
+		break;
+	}
+	__xchg_called_with_bad_pointer ();
+	return x;
+}
+
+/* XXX
+ * disable hlt during certain critical i/o operations
+ */
+#define HAVE_DISABLE_HLT
+void disable_hlt (void);
+void enable_hlt (void);
+
+#endif
diff --git a/include/asm-sh/termbits.h b/include/asm-sh/termbits.h
new file mode 100644
index 0000000..0aa52f1
--- /dev/null
+++ b/include/asm-sh/termbits.h
@@ -0,0 +1,173 @@
+#ifndef __ASM_SH_TERMBITS_H
+#define __ASM_SH_TERMBITS_H
+
+#include <linux/posix_types.h>
+
+typedef unsigned char cc_t;
+typedef unsigned int speed_t;
+typedef unsigned int tcflag_t;
+
+#define NCCS 19
+struct termios
+{
+	tcflag_t c_iflag;	/* input mode flags */
+	tcflag_t c_oflag;	/* output mode flags */
+	tcflag_t c_cflag;	/* control mode flags */
+	tcflag_t c_lflag;	/* local mode flags */
+	cc_t c_line;		/* line discipline */
+	cc_t c_cc[NCCS];	/* control characters */
+};
+
+/* c_cc characters */
+#define VINTR 0
+#define VQUIT 1
+#define VERASE 2
+#define VKILL 3
+#define VEOF 4
+#define VTIME 5
+#define VMIN 6
+#define VSWTC 7
+#define VSTART 8
+#define VSTOP 9
+#define VSUSP 10
+#define VEOL 11
+#define VREPRINT 12
+#define VDISCARD 13
+#define VWERASE 14
+#define VLNEXT 15
+#define VEOL2 16
+
+/* c_iflag bits */
+#define IGNBRK	0000001
+#define BRKINT	0000002
+#define IGNPAR	0000004
+#define PARMRK	0000010
+#define INPCK	0000020
+#define ISTRIP	0000040
+#define INLCR	0000100
+#define IGNCR	0000200
+#define ICRNL	0000400
+#define IUCLC	0001000
+#define IXON	0002000
+#define IXANY	0004000
+#define IXOFF	0010000
+#define IMAXBEL	0020000
+
+/* c_oflag bits */
+#define OPOST	0000001
+#define OLCUC	0000002
+#define ONLCR	0000004
+#define OCRNL	0000010
+#define ONOCR	0000020
+#define ONLRET	0000040
+#define OFILL	0000100
+#define OFDEL	0000200
+#define NLDLY	0000400
+#define   NL0	0000000
+#define   NL1	0000400
+#define CRDLY	0003000
+#define   CR0	0000000
+#define   CR1	0001000
+#define   CR2	0002000
+#define   CR3	0003000
+#define TABDLY	0014000
+#define   TAB0	0000000
+#define   TAB1	0004000
+#define   TAB2	0010000
+#define   TAB3	0014000
+#define   XTABS	0014000
+#define BSDLY	0020000
+#define   BS0	0000000
+#define   BS1	0020000
+#define VTDLY	0040000
+#define   VT0	0000000
+#define   VT1	0040000
+#define FFDLY	0100000
+#define   FF0	0000000
+#define   FF1	0100000
+
+/* c_cflag bit meaning */
+#define CBAUD	0010017
+#define  B0	0000000		/* hang up */
+#define  B50	0000001
+#define  B75	0000002
+#define  B110	0000003
+#define  B134	0000004
+#define  B150	0000005
+#define  B200	0000006
+#define  B300	0000007
+#define  B600	0000010
+#define  B1200	0000011
+#define  B1800	0000012
+#define  B2400	0000013
+#define  B4800	0000014
+#define  B9600	0000015
+#define  B19200	0000016
+#define  B38400	0000017
+#define EXTA B19200
+#define EXTB B38400
+#define CSIZE	0000060
+#define   CS5	0000000
+#define   CS6	0000020
+#define   CS7	0000040
+#define   CS8	0000060
+#define CSTOPB	0000100
+#define CREAD	0000200
+#define PARENB	0000400
+#define PARODD	0001000
+#define HUPCL	0002000
+#define CLOCAL	0004000
+#define CBAUDEX 0010000
+#define    B57600 0010001
+#define   B115200 0010002
+#define   B230400 0010003
+#define   B460800 0010004
+#define   B500000 0010005
+#define   B576000 0010006
+#define   B921600 0010007
+#define  B1000000 0010010
+#define  B1152000 0010011
+#define  B1500000 0010012
+#define  B2000000 0010013
+#define  B2500000 0010014
+#define  B3000000 0010015
+#define  B3500000 0010016
+#define  B4000000 0010017
+#define CIBAUD	  002003600000	/* input baud rate (not used) */
+#define CMSPAR	  010000000000	/* mark or space (stick) parity */
+#define CRTSCTS	  020000000000	/* flow control */
+
+/* c_lflag bits */
+#define ISIG	0000001
+#define ICANON	0000002
+#define XCASE	0000004
+#define ECHO	0000010
+#define ECHOE	0000020
+#define ECHOK	0000040
+#define ECHONL	0000100
+#define NOFLSH	0000200
+#define TOSTOP	0000400
+#define ECHOCTL	0001000
+#define ECHOPRT	0002000
+#define ECHOKE	0004000
+#define FLUSHO	0010000
+#define PENDIN	0040000
+#define IEXTEN	0100000
+
+/* tcflow() and TCXONC use these */
+#define	TCOOFF		0
+#define	TCOON		1
+#define	TCIOFF		2
+#define	TCION		3
+
+/* tcflush() and TCFLSH use these */
+#define	TCIFLUSH	0
+#define	TCOFLUSH	1
+#define	TCIOFLUSH	2
+
+/* tcsetattr uses these */
+#define	TCSANOW		0
+#define	TCSADRAIN	1
+#define	TCSAFLUSH	2
+
+#endif /* __ASM_SH_TERMBITS_H */
diff --git a/include/asm-sh/types.h b/include/asm-sh/types.h
new file mode 100644
index 0000000..46e4940
--- /dev/null
+++ b/include/asm-sh/types.h
@@ -0,0 +1,74 @@
+/*
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __ASM_SH_TYPES_H
+#define __ASM_SH_TYPES_H
+
+typedef unsigned short umode_t;
+
+/*
+ * __xx is ok: it doesn't pollute the POSIX namespace. Use these in the
+ * header files exported to user space
+ */
+
+typedef __signed__ char __s8;
+typedef unsigned char __u8;
+
+typedef __signed__ short __s16;
+typedef unsigned short __u16;
+
+typedef __signed__ int __s32;
+typedef unsigned int __u32;
+
+#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
+typedef __signed__ long long __s64;
+typedef unsigned long long __u64;
+#endif
+
+/*
+ * These aren't exported outside the kernel to avoid name space clashes
+ */
+#ifdef __KERNEL__
+
+typedef __signed__ char s8;
+typedef unsigned char u8;
+
+typedef __signed__ short s16;
+typedef unsigned short u16;
+
+typedef __signed__ int s32;
+typedef unsigned int u32;
+
+typedef __signed__ long long s64;
+typedef unsigned long long u64;
+
+#define BITS_PER_LONG 32
+
+/* Dma addresses are 32-bits wide.  */
+
+typedef u32 dma_addr_t;
+typedef u64 dma64_addr_t;
+
+#endif /* __KERNEL__ */
+
+#endif /* __ASM_SH_TYPES_H */
diff --git a/include/asm-sh/u-boot.h b/include/asm-sh/u-boot.h
new file mode 100644
index 0000000..22245a6
--- /dev/null
+++ b/include/asm-sh/u-boot.h
@@ -0,0 +1,59 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, <wd@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _U_BOOT_H_
+#define _U_BOOT_H_	1
+
+typedef struct bd_info
+{
+	int bi_baudrate;	/* serial console baudrate */
+	unsigned long bi_ip_addr;	/* IP Address */
+	unsigned char bi_enetaddr[6];	/* Ethernet adress */
+	unsigned long bi_arch_number;	/* unique id for this board */
+	unsigned long bi_boot_params;	/* where this board expects params */
+	unsigned long bi_memstart;	/* start of DRAM memory */
+	unsigned long bi_memsize;	/* size  of DRAM memory in bytes */
+	unsigned long bi_flashstart;	/* start of FLASH memory */
+	unsigned long bi_flashsize;	/* size  of FLASH memory */
+	unsigned long bi_flashoffset;	/* reserved area for startup monitor */
+#ifdef CONFIG_SH_STB7100
+	unsigned long bi_devid;
+	unsigned long bi_pll0frq;
+	unsigned long bi_pll1frq;
+	unsigned long bi_st40cpufrq;
+	unsigned long bi_st40busfrq;
+	unsigned long bi_st40perfrq;
+	unsigned long bi_st231frq;
+	unsigned long bi_stbusfrq;
+	unsigned long bi_emifrq;
+	unsigned long bi_lmifrq;
+#endif
+#ifdef CONFIG_SH_STX7200
+	unsigned long bi_devid;
+	unsigned long bi_emifrq;
+#endif
+} bd_t;
+#define bi_env_data bi_env->data
+#define bi_env_crc  bi_env->crc
+
+#endif /* _U_BOOT_H_ */
diff --git a/include/asm-sh/ubc.h b/include/asm-sh/ubc.h
new file mode 100644
index 0000000..a9003cf
--- /dev/null
+++ b/include/asm-sh/ubc.h
@@ -0,0 +1,72 @@
+#ifndef __ASM_SH_UBC_H
+#define __ASM_SH_UBC_H
+
+/* User Break Controller */
+
+#if defined(CONFIG_CPU_SUBTYPE_SH7709)
+#define UBC_TYPE_SH7729	(cpu_data->type == CPU_SH7729)
+#else
+#define UBC_TYPE_SH7729	0
+#endif
+
+#if defined(__sh3__)
+#define UBC_BARA                0xffffffb0
+#define UBC_BAMRA               0xffffffb4
+#define UBC_BBRA                0xffffffb8
+#define UBC_BASRA               0xffffffe4
+#define UBC_BARB                0xffffffa0
+#define UBC_BAMRB               0xffffffa4
+#define UBC_BBRB                0xffffffa8
+#define UBC_BASRB               0xffffffe8
+#define UBC_BDRB                0xffffff90
+#define UBC_BDMRB               0xffffff94
+#define UBC_BRCR                0xffffff98
+#elif defined(__SH4__)
+#define UBC_BARA		0xff200000
+#define UBC_BAMRA		0xff200004
+#define UBC_BBRA		0xff200008
+#define UBC_BASRA		0xff000014
+#define UBC_BARB		0xff20000c
+#define UBC_BAMRB		0xff200010
+#define UBC_BBRB		0xff200014
+#define UBC_BASRB		0xff000018
+#define UBC_BDRB		0xff200018
+#define UBC_BDMRB		0xff20001c
+#define UBC_BRCR		0xff200020
+#endif
+
+#define BAMR_ASID		(1 << 2)
+#define BAMR_NONE		0
+#define BAMR_10			0x1
+#define BAMR_12			0x2
+#define BAMR_ALL		0x3
+#define BAMR_16			0x8
+#define BAMR_20			0x9
+
+#define BBR_INST		(1 << 4)
+#define BBR_DATA		(2 << 4)
+#define BBR_READ		(1 << 2)
+#define BBR_WRITE		(2 << 2)
+#define BBR_BYTE		0x1
+#define BBR_HALF		0x2
+#define BBR_LONG		0x3
+#define BBR_QUAD		(1 << 6)	/* SH7750 */
+#define BBR_CPU			(1 << 6)	/* SH7709A,SH7729 */
+#define BBR_DMA			(2 << 6)	/* SH7709A,SH7729 */
+
+#define BRCR_CMFA		(1 << 15)
+#define BRCR_CMFB		(1 << 14)
+#define BRCR_PCTE		(1 << 11)
+#define BRCR_PCBA		(1 << 10)	/* 1: after execution */
+#define BRCR_DBEB		(1 << 7)
+#define BRCR_PCBB		(1 << 6)
+#define BRCR_SEQ		(1 << 3)
+#define BRCR_UBDE		(1 << 0)
+
+#ifndef __ASSEMBLY__
+/* arch/sh/kernel/ubc.S */
+extern void ubc_wakeup (void);
+extern void ubc_sleep (void);
+#endif
+
+#endif /* __ASM_SH_UBC_H */
diff --git a/include/common.h b/include/common.h
index 63ac8b0..72ca995 100644
--- a/include/common.h
+++ b/include/common.h
@@ -242,6 +242,11 @@ void	forceenv     (char *, char *);
 # include <asm/setup.h>
 # include <asm/u-boot-arm.h>	/* ARM version to be fixed! */
 #endif /* CONFIG_ARM */
+
+#ifdef CONFIG_STM_ST231
+# include <asm/setup.h>
+#endif /* CONFIG_STM_ST231 */
+
 #ifdef CONFIG_I386		/* x86 version to be fixed! */
 # include <asm/u-boot-i386.h>
 #endif /* CONFIG_I386 */
diff --git a/include/configs/cb101.h b/include/configs/cb101.h
new file mode 100644
index 0000000..954af02
--- /dev/null
+++ b/include/configs/cb101.h
@@ -0,0 +1,280 @@
+/*
+ * (C) Copyright 2007 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_2XX	/* its an SH4-202		*/
+
+/* This should really be replaced with something which uses bd->...	*/
+#define P_CLOCK_RATE	87500000	/* clock rate for CSP		*/
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH (uncached) via PMB */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI0 via PMB */
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI0 Physical Address */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI0 un-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH in P2 region */
+#define CFG_SDRAM_BASE		0x88000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x08000000	/* 128MB of LMI0 SDRAM */
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 kB for Monitor */
+#define CFG_MONITOR_BASE        CFG_FLASH_BASE
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1MB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128kB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD cb101
+
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 kB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 kB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) /* "_" XSTR(INPUT_CLOCK_RATE) */ "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_JFFS2
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+#define CONFIG_STM_ASC_SERIAL	1
+
+#define CONFIG_CONS_INDEX	0
+#define CFG_STM_ASC_BASE	0xfd033000ul	/* UART3 */
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/* are we using the internal ST MAC device ? */
+#define CONFIG_DRIVER_NETSTMAC
+
+#define CONFIG_STMAC_MAC0			/* Use MAC #0 */
+#define CFG_STM_STMAC_BASE	 0xfd500000ul	/* MAC #0 */
+#define CONFIG_STMAC_STE10XP			/* ST STE10xP */
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB0_BASE			0xfd200000	/* header */
+#	define CFG_USB1_BASE			0xfd300000	/* nearest RJ-45 */
+#	define CFG_USB2_BASE			0xfd400000	/* nearest edge */
+#	define CFG_USB_BASE			CFG_USB2_BASE
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+	/* The following macro should ONLY be defined, when using
+	 * STi7200 cut 1.x, without the RC-delay board fix applied. */
+#	define CONFIG_USB_STI7200_CUT1_SOFT_JTAG_RESET_WORKAROUND
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+/* SATA should work on cut 2 of the STi7200 */
+//#define CONFIG_SH_STB7100_SATA
+
+#ifdef CONFIG_SH_STB7100_SATA
+#	define CFG_PIO_MODE		4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#	define CFG_ATA_BASE_ADDR	0x????
+#	define CFG_ATA_IDE0_OFFSET	0x0
+#	define CFG_ATA_REG_OFFSET	0x0
+#	define CFG_ATA_DATA_OFFSET	0x0
+#	define CFG_ATA_STRIDE		0x4
+#	define CFG_ATA_ALT_OFFSET	0x8
+#endif	/* CONFIG_SH_STB7100_SATA */
+
+#if defined(CONFIG_SH_STB7100_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CFG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"CB101> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+/* M58LT256GT: 32Mbyte 259 blocks, 128K block size plus parameter block */
+#define CFG_FLASH_CFI_WIDTH	FLASH_CFI_16BIT
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+#define CONFIG_FLASH_PROTECT_SINGLE_CELL
+#define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#define CFG_MAX_FLASH_SECT	300	/* max number of sectors on one chip	*/
+#define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+
+
+/*-----------------------------------------------------------------------
+ * NVRAM organization
+ */
+
+/* Address and size of Primary Environment Sector	*/
+
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_OFFSET		CFG_MONITOR_LEN
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE		0x10000
+#define CFG_ENV_SECT_SIZE	0x20000
+
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH organization
+ */
+
+#define CFG_MAX_NAND_DEVICE	2
+#define NAND_MAX_CHIPS		CFG_MAX_NAND_DEVICE
+#define CFG_NAND0_BASE		0xA2000000	/* Physical 0x02000000 */
+#define CFG_NAND1_BASE		0xA3000000	/* Physical 0x03000000 */
+#define CFG_NAND_BASE_LIST	{ CFG_NAND0_BASE, CFG_NAND1_BASE }
+
+
+/*----------------------------------------------------------------------
+ * jffs2 support
+ */
+
+#if defined(CONFIG_CMD_JFFS2)
+#define CONFIG_JFFS2_NAND	/* JFFS2 support on NAND Flash */
+#define CONFIG_JFFS2_CMDLINE	/* mtdparts command line support */
+#define MTDPARTS_DEFAULT						\
+	"mtdparts="							\
+	"physmap-flash:"	/* First NOR flash device */		\
+		"256k(U-Boot)"		/* first partition */		\
+		",128k(Environment)"					\
+		",-(RestOfNor0)"	/* last partition */		\
+		";"		/* delimiter */				\
+	"gen_nand.1:"		/* First NAND flash device */		\
+		"32M(kernel-nand0)"	/* first partition */		\
+		",32M(root-nand0)"					\
+		",-(RestOfNand0)"	/* last partition */		\
+		";"		/* delimiter */				\
+	"gen_nand.2:"		/* Second NAND flash device */		\
+		"32M(kernel-nand1)"	/* first partition */		\
+		",32M(root-nand1)"					\
+		",-(RestOfNand1)"	/* last partition */
+#define MTDIDS_DEFAULT							\
+	"nor0=physmap-flash"	/* First NOR flash device */		\
+		","		/* delimiter */				\
+	"nand0=gen_nand.1"	/* First NAND flash device */		\
+		","		/* delimiter */				\
+	"nand1=gen_nand.2"	/* Second NAND flash device */
+#endif	/* CONFIG_CMD_JFFS2 */
+
+
+#endif	/* __CONFIG_H */
+
diff --git a/include/configs/hms1.h b/include/configs/hms1.h
new file mode 100644
index 0000000..11f9d67
--- /dev/null
+++ b/include/configs/hms1.h
@@ -0,0 +1,260 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_2XX	/* its an SH4-202		*/
+
+#define INPUT_CLOCK_RATE 27
+
+#define P_CLOCK_RATE	66000000	/* clock rate for CSP		*/
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#define CFG_SDRAM_BASE		0x84000000      /* SDRAM in P1 region         */
+#define CFG_SDRAM_SIZE		0x08000000
+#define CFG_FLASH_BASE		0xA0000000
+#define CFG_RESET_ADDRESS	0xA0000000
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 kB for Monitor */
+#define CFG_MONITOR_BASE	0xA0000000
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1MB kB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (2 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD HMS1
+
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 kB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 kB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0" \
+		"enableVpp=" \
+		  "mw b8022028 20;" \
+		  "mw b8022034 20;" \
+		  "mw b8022048 20;"	/* set PIO2[5] as OUTPUT */ \
+		  "mw b8022004 20\0"	/* set PIO2[5] = HIGH */ \
+		"disableVpp=" \
+		  "mw b8022028 20;" \
+		  "mw b8022034 20;" \
+		  "mw b8022048 20;"	/* set PIO2[5] as OUTPUT */ \
+		  "mw b8022008 20\0"	/* set PIO2[5] = LOW */
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_IDE
+#define CONFIG_CMD_JFFS2
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+#define CONFIG_STM_ASC_SERIAL	1
+
+#define CONFIG_CONS_INDEX	0
+#define CFG_STM_ASC_BASE	0xb8032000ul	/* UART2 */
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There is only 1 option for ethernet:
+ *    The on-board SMSC LAN9117 (combined MAC+PHY)
+ */
+
+#define CONFIG_DRIVER_SMC911X
+#define CONFIG_SMC911X_BASE	0xA1000000ul
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+
+/* #define CONFIG_ENV_OVERWRITE */
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+//#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB_BASE			0xb9100000
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+/* Choose one of the the following two: */
+//#define CONFIG_SH_STB7100_IDE
+#define CONFIG_SH_STB7100_SATA
+
+#ifdef CONFIG_SH_STB7100_IDE
+#	define CFG_PIO_MODE		4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#	define CFG_ATA_BASE_ADDR	0xA2800000
+#	define CFG_ATA_IDE0_OFFSET	0x00200000
+#	define CFG_ATA_REG_OFFSET	0
+#	define CFG_ATA_DATA_OFFSET	0
+#	define CFG_ATA_STRIDE		0x00020000
+#	define CFG_ATA_ALT_OFFSET	-0x0100000
+#endif	/* CONFIG_SH_STB7100_IDE */
+
+#ifdef CONFIG_SH_STB7100_SATA
+#	define CFG_PIO_MODE		4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#	define CFG_ATA_BASE_ADDR	0xB9209800
+#	define CFG_ATA_IDE0_OFFSET	0x0
+#	define CFG_ATA_REG_OFFSET	0x0
+#	define CFG_ATA_DATA_OFFSET	0x0
+#	define CFG_ATA_STRIDE		0x4
+#	define CFG_ATA_ALT_OFFSET	0x8
+#endif	/* CONFIG_SH_STB7100_SATA */
+
+#if defined(CONFIG_SH_STB7100_IDE)  ||	\
+    defined(CONFIG_SH_STB7100_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*----------------------------------------------------------------------
+ * jffs2 support
+ */
+
+#if defined(CONFIG_CMD_JFFS2)
+
+#define CFG_JFFS_CUSTOM_PART
+#define CFG_JFFS_SINGLE_PART	1
+
+#define CFG_JFFS2_FIRST_SECTOR 18  /* u-boot, env, kernel  */
+#define CFG_JFFS2_FIRST_BANK 0
+#define CFG_JFFS2_NUM_BANKS 1
+
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"HMS1> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			(P_CLOCK_RATE/1024)		/* HZ for timer ticks		*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* stb7100 mboard organised as 8MB flash with 128k blocks */
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+#define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#define CFG_MAX_FLASH_SECT	64	/* max number of sectors on one chip	*/
+#define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+
+
+/*-----------------------------------------------------------------------
+ * NVRAM organization
+ */
+
+/* Address and size of Primary Environment Sector	*/
+
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_OFFSET		CFG_MONITOR_LEN
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE		0x20000
+#define CFG_ENV_SECT_SIZE	0x20000
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/mb411.h b/include/configs/mb411.h
new file mode 100644
index 0000000..c1d077f
--- /dev/null
+++ b/include/configs/mb411.h
@@ -0,0 +1,275 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_2XX	/* its an SH4-202		*/
+
+#define INPUT_CLOCK_RATE 27
+
+#define P_CLOCK_RATE	66000000	/* clock rate for CSP		*/
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#define CFG_SDRAM_BASE		0x84000000      /* SDRAM in P1 region         */
+#define CFG_SDRAM_SIZE		0x02000000
+#define CFG_FLASH_BASE		0xA0000000
+#define CFG_RESET_ADDRESS	0xA0000000
+
+#define CFG_MONITOR_LEN		0x00020000	/* Reserve 128 kB for Monitor */
+#define CFG_MONITOR_BASE        0xA0000000
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1MB kB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (2 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD mb411
+
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 kB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 kB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_IDE
+#define CONFIG_CMD_JFFS2
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+#define CONFIG_STM_ASC_SERIAL	1
+
+#define CONFIG_CONS_INDEX	0
+
+#if (CONFIG_CONS_INDEX == 0)
+#define CFG_STM_ASC_BASE	0xb8032000ul	/* UART2 */
+#else
+#define CFG_STM_ASC_BASE	0xb8033000ul	/* UART3 */
+#endif
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 3 options for ethernet:
+ *    The on-board SMSC LAN91C111
+ *    for STb7109, the on-chip STMAC & on-board PHY
+ *    The DB641 STEM card - this has two ethernet devices Port0 and Port1
+ */
+
+#if 1
+	/* Config for SMSC LAN91C111 (combined MAC+PHY) */
+#	define CONFIG_DRIVER_SMC91111
+#	define CONFIG_SMC91111_BASE		0xa3e00300ul
+#elif 1
+	/* Config for on-chip STMAC + STE10xP PHY */
+#	define CONFIG_DRIVER_NETSTMAC
+#	define CFG_STM_STMAC_BASE		0xb8110000ul
+#	define CONFIG_STMAC_STE10XP
+#	define CONFIG_CMD_MII
+#else
+	/* Config for SMSC LAN9118 STEM card */
+#	define CONFIG_DRIVER_SMC911X
+#	if 1
+#		define CONFIG_SMC911X_BASE	0xA1000000ul /* PORT 0 */
+#	else
+#		define CONFIG_SMC911X_BASE	0xA1800000ul /* PORT 1 */
+#	endif
+#endif
+
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+
+/* #define CONFIG_ENV_OVERWRITE */
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+//#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB_BASE			0xb9100000
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+/* Choose one of the the following two: */
+#define CONFIG_SH_STB7100_IDE
+//#define CONFIG_SH_STB7100_SATA
+
+#ifdef CONFIG_SH_STB7100_IDE
+#	define CFG_PIO_MODE		4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#	define CFG_ATA_BASE_ADDR	0xA2800000
+#	define CFG_ATA_IDE0_OFFSET	0x00200000
+#	define CFG_ATA_REG_OFFSET	0
+#	define CFG_ATA_DATA_OFFSET	0
+#	define CFG_ATA_STRIDE		0x00020000
+#	define CFG_ATA_ALT_OFFSET	-0x0100000
+#endif	/* CONFIG_SH_STB7100_IDE */
+
+#ifdef CONFIG_SH_STB7100_SATA
+#	define CFG_PIO_MODE		4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#	define CFG_ATA_BASE_ADDR	0xB9209800
+#	define CFG_ATA_IDE0_OFFSET	0x0
+#	define CFG_ATA_REG_OFFSET	0x0
+#	define CFG_ATA_DATA_OFFSET	0x0
+#	define CFG_ATA_STRIDE		0x4
+#	define CFG_ATA_ALT_OFFSET	0x8
+#endif	/* CONFIG_SH_STB7100_SATA */
+
+#if defined(CONFIG_SH_STB7100_IDE)  ||	\
+    defined(CONFIG_SH_STB7100_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*----------------------------------------------------------------------
+ * jffs2 support
+ */
+
+#if defined(CONFIG_CMD_JFFS2)
+
+#define CFG_JFFS_CUSTOM_PART
+#define CFG_JFFS_SINGLE_PART	1
+
+#define CFG_JFFS2_FIRST_SECTOR 18  /* u-boot, env, kernel  */
+#define CFG_JFFS2_FIRST_BANK 0
+#define CFG_JFFS2_NUM_BANKS 1
+
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"MB411> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			(P_CLOCK_RATE/1024)		/* HZ for timer ticks		*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* STb7100 Mboard organised as 8MB flash with 128k blocks */
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+#define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#define CFG_MAX_FLASH_SECT	64	/* max number of sectors on one chip	*/
+#define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+
+
+/*-----------------------------------------------------------------------
+ * NVRAM organization
+ */
+
+/* Address and size of Primary Environment Sector	*/
+
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_OFFSET		CFG_MONITOR_LEN
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE		0x10000
+#define CFG_ENV_SECT_SIZE	0x20000
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/mb442.h b/include/configs/mb442.h
new file mode 100644
index 0000000..7616a00
--- /dev/null
+++ b/include/configs/mb442.h
@@ -0,0 +1,269 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_2XX	/* its an SH4-202		*/
+
+#ifndef INPUT_CLOCK_RATE
+#warning Assuming 30MHz clock input
+#define INPUT_CLOCK_RATE 30
+#endif
+
+#define P_CLOCK_RATE	66000000	/* clock rate for CSP		*/
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH (uncached) via PMB */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI-Sys via PMB */
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI-Sys Physical Address */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI-Sys un-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH in P2 region */
+#define CFG_SDRAM_BASE		0x84000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x04000000	/* 64MB of LMI-Sys SDRAM */
+
+#define CFG_MONITOR_LEN		0x00020000	/* Reserve 128 kB for Monitor */
+#define CFG_MONITOR_BASE        CFG_FLASH_BASE
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1MB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD mb442
+
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 kB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 kB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "_" XSTR(INPUT_CLOCK_RATE) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_IDE
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+#define CONFIG_STM_ASC_SERIAL	1
+
+#define CONFIG_CONS_INDEX	0
+
+#if (CONFIG_CONS_INDEX == 0)
+#define CFG_STM_ASC_BASE	0xb8032000ul	/* UART2 */
+#else
+#define CFG_STM_ASC_BASE	0xb8033000ul	/* UART3 */
+#endif
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 2 options for ethernet:
+ *    The on-board SMSC LAN91C111
+ *    for STb7109, the on-chip STMAC & on-board PHY
+ */
+
+#if 1
+	/* Config for SMSC LAN91C111 (combined MAC+PHY) */
+#	define CONFIG_DRIVER_SMC91111
+#ifdef CONFIG_SH_SE_MODE
+#	define CONFIG_SMC91111_BASE	0xb2000300ul
+#else	/* CONFIG_SH_SE_MODE */
+#	define CONFIG_SMC91111_BASE	0xa2000300ul
+#endif	/* CONFIG_SH_SE_MODE */
+#else
+	/* Config for on-chip STMAC + STE10xP PHY */
+#	define CONFIG_DRIVER_NETSTMAC
+#	define CFG_STM_STMAC_BASE	0xb8110000ul
+#	define CONFIG_STMAC_STE10XP
+#	define CONFIG_CMD_MII
+#endif
+
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+//#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB_BASE			0xb9100000
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+/* Choose one of the the following two: */
+//#define CONFIG_SH_STB7100_IDE
+#define CONFIG_SH_STB7100_SATA
+
+#ifdef CONFIG_SH_STB7100_IDE
+#	define CFG_PIO_MODE		4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#ifdef CONFIG_SH_SE_MODE
+#	define CFG_ATA_BASE_ADDR	0xB2800000
+#else	/* CONFIG_SH_SE_MODE */
+#	define CFG_ATA_BASE_ADDR	0xA2800000
+#endif	/* CONFIG_SH_SE_MODE */
+#	define CFG_ATA_IDE0_OFFSET	0x00200000
+#	define CFG_ATA_REG_OFFSET	0
+#	define CFG_ATA_DATA_OFFSET	0
+#	define CFG_ATA_STRIDE		0x00020000
+#	define CFG_ATA_ALT_OFFSET	-0x0100000
+#endif	/* CONFIG_SH_STB7100_IDE */
+
+#ifdef CONFIG_SH_STB7100_SATA
+#	define CFG_PIO_MODE		4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#	define CFG_ATA_BASE_ADDR	0xB9209800
+#	define CFG_ATA_IDE0_OFFSET	0x0
+#	define CFG_ATA_REG_OFFSET	0x0
+#	define CFG_ATA_DATA_OFFSET	0x0
+#	define CFG_ATA_STRIDE		0x4
+#	define CFG_ATA_ALT_OFFSET	0x8
+#endif	/* CONFIG_SH_STB7100_SATA */
+
+#if defined(CONFIG_SH_STB7100_IDE)  ||	\
+    defined(CONFIG_SH_STB7100_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"MB442> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_AUTO_COMPLETE       1
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* STb7100 reference board organised as 8MB flash with 128k blocks */
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+#define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#define CFG_MAX_FLASH_SECT	64	/* max number of sectors on one chip	*/
+#define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+
+
+/*-----------------------------------------------------------------------
+ * NVRAM organization
+ */
+
+/* Address and size of Primary Environment Sector	*/
+
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_OFFSET		CFG_MONITOR_LEN
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE		0x10000
+#define CFG_ENV_SECT_SIZE	0x20000
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/mb448.h b/include/configs/mb448.h
new file mode 100644
index 0000000..758c857
--- /dev/null
+++ b/include/configs/mb448.h
@@ -0,0 +1,243 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_2XX	/* its an SH4-202		*/
+
+#define P_CLOCK_RATE	66000000	/* clock rate for CSP		*/
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#define CFG_SDRAM_BASE		0x84000000      /* SDRAM in P1 region         */
+#define CFG_SDRAM_SIZE		0x02000000
+#define CFG_FLASH_BASE		0xA0000000
+#define CFG_RESET_ADDRESS	0xA0000000
+
+#define CFG_MONITOR_LEN		0x00020000	/* Reserve 128 kB for Monitor */
+#define CFG_MONITOR_BASE        0xA0000000
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1MB kB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (2 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD mb448
+
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 kB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 kB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "_" XSTR(INPUT_CLOCK_RATE) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_IDE
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+#define CONFIG_STM_ASC_SERIAL	1
+
+#define CONFIG_CONS_INDEX	0
+#define CFG_STM_ASC_BASE	0xb8032000ul	/* UART2 */
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 2 options for ethernet:
+ *    The on-board SMSC LAN91C111
+ *    the on-chip STMAC & on-board PHY
+ */
+
+#if 1
+	/* Config for SMSC LAN91C111 (combined MAC+PHY) */
+#	define CONFIG_DRIVER_SMC91111
+#	define CONFIG_SMC91111_BASE	0xa2000300ul
+#else
+	/* Config for on-chip STMAC + STE10xP PHY */
+#	define CONFIG_DRIVER_NETSTMAC
+#	define CFG_STM_STMAC_BASE	0xb8110000ul
+#	define CONFIG_STMAC_STE10XP
+#	define CONFIG_CMD_MII
+#endif
+
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+//#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB_BASE			0xb9100000
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+/* Choose one of the the following two: */
+//#define CONFIG_SH_STB7100_IDE
+#define CONFIG_SH_STB7100_SATA
+
+#ifdef CONFIG_SH_STB7100_IDE
+#	define CFG_PIO_MODE		4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#	define CFG_ATA_BASE_ADDR	0xA2800000
+#	define CFG_ATA_IDE0_OFFSET	0x00200000
+#	define CFG_ATA_REG_OFFSET	0
+#	define CFG_ATA_DATA_OFFSET	0
+#	define CFG_ATA_STRIDE		0x00020000
+#	define CFG_ATA_ALT_OFFSET	-0x0100000
+#endif	/* CONFIG_SH_STB7100_IDE */
+
+#ifdef CONFIG_SH_STB7100_SATA
+#	define CFG_PIO_MODE		4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#	define CFG_ATA_BASE_ADDR	0xB9209800
+#	define CFG_ATA_IDE0_OFFSET	0x0
+#	define CFG_ATA_REG_OFFSET	0x0
+#	define CFG_ATA_DATA_OFFSET	0x0
+#	define CFG_ATA_STRIDE		0x4
+#	define CFG_ATA_ALT_OFFSET	0x8
+#endif	/* CONFIG_SH_STB7100_SATA */
+
+#if defined(CONFIG_SH_STB7100_IDE)  ||	\
+    defined(CONFIG_SH_STB7100_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CFG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"MB448> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* STb7109E reference board organised as 8MB flash with 128k blocks */
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+#define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#define CFG_MAX_FLASH_SECT	64	/* max number of sectors on one chip	*/
+#define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+
+
+/*-----------------------------------------------------------------------
+ * NVRAM organization
+ */
+
+/* Address and size of Primary Environment Sector	*/
+
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_OFFSET		CFG_MONITOR_LEN
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE		0x10000
+#define CFG_ENV_SECT_SIZE	0x20000
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/mb519.h b/include/configs/mb519.h
new file mode 100644
index 0000000..d270113
--- /dev/null
+++ b/include/configs/mb519.h
@@ -0,0 +1,254 @@
+/*
+ * (C) Copyright 2007 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_2XX	/* its an SH4-202		*/
+
+/* This should really be replaced with something which uses bd->...	*/
+#define P_CLOCK_RATE	87500000	/* clock rate for CSP		*/
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH (uncached) via PMB */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI0 via PMB */
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI0 Physical Address */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI0 un-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH in P2 region */
+#define CFG_SDRAM_BASE		0x88000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x08000000	/* 128MB of LMI0 SDRAM */
+
+#define CFG_MONITOR_LEN		0x00020000	/* Reserve 128 kB for Monitor */
+#define CFG_MONITOR_BASE        CFG_FLASH_BASE
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1MB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128kB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD mb519
+
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 kB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 kB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "_" XSTR(INPUT_CLOCK_RATE) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+#define CONFIG_STM_ASC_SERIAL	1
+
+#define CONFIG_CONS_INDEX	0
+#define CFG_STM_ASC_BASE	0xfd032000ul	/* UART2 */
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 2 options for ethernet, both use the on-chip ST-MAC.
+ * The choice in PHYs are:
+ *    The on-board ST STE101P PHY.
+ *    External PHY connected via the MII off-board connector.
+ */
+
+/* are we using the internal ST MAC device ? */
+#define CONFIG_DRIVER_NETSTMAC
+
+/* choose which internal MAC to use */
+#if 1
+#	define CONFIG_STMAC_MAC0			/* Use MAC #0 */
+#else
+#	define CONFIG_STMAC_MAC1			/* Use MAC #1 */
+#endif
+
+/*
+ * Select the appropriate base address for the selected MAC.
+ * Also, choose which external PHY type to use.
+ */
+#if defined(CONFIG_STMAC_MAC0)
+#	define CFG_STM_STMAC_BASE	 0xfd500000ul	/* MAC #0 */
+#	define CONFIG_STMAC_STE10XP			/* ST STE10xP */
+#elif defined(CONFIG_STMAC_MAC1)
+#	define CFG_STM_STMAC_BASE	 0xfd510000ul	/* MAC #1 */
+#	define CONFIG_STMAC_LAN8700			/* SMSC LAN8700 */
+#endif
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+//#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB0_BASE			0xfd200000	/* middle */
+#	define CFG_USB1_BASE			0xfd300000	/* right */
+#	define CFG_USB2_BASE			0xfd400000	/* left */
+#	define CFG_USB_BASE			CFG_USB0_BASE
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+	/* The following macro should ONLY be defined, when using
+	 * STi7200 cut 1.x, without the RC-delay board fix applied. */
+#	define CONFIG_USB_STI7200_CUT1_SOFT_JTAG_RESET_WORKAROUND
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+/* SATA should work on cut 2 of the STi7200 */
+//#define CONFIG_SH_STB7100_SATA
+
+#ifdef CONFIG_SH_STB7100_SATA
+#	define CFG_PIO_MODE		4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#	define CFG_ATA_BASE_ADDR	0x????
+#	define CFG_ATA_IDE0_OFFSET	0x0
+#	define CFG_ATA_REG_OFFSET	0x0
+#	define CFG_ATA_DATA_OFFSET	0x0
+#	define CFG_ATA_STRIDE		0x4
+#	define CFG_ATA_ALT_OFFSET	0x8
+#endif	/* CONFIG_SH_STB7100_SATA */
+
+#if defined(CONFIG_SH_STB7100_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CFG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"MB519> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* M58LT256GT: 32Mbyte 259 blocks, 128K block size plus parameter block */
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+#define CONFIG_FLASH_PROTECT_SINGLE_CELL
+#define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#define CFG_MAX_FLASH_SECT	300	/* max number of sectors on one chip	*/
+#define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+
+
+/*-----------------------------------------------------------------------
+ * NVRAM organization
+ */
+
+/* Address and size of Primary Environment Sector	*/
+
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_OFFSET		CFG_MONITOR_LEN
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE		0x10000
+#define CFG_ENV_SECT_SIZE	0x20000
+
+#endif	/* __CONFIG_H */
diff --git a/include/linux/stat.h b/include/linux/stat.h
index 37f2924..397512d 100644
--- a/include/linux/stat.h
+++ b/include/linux/stat.h
@@ -68,7 +68,7 @@ struct stat {
 #endif	/* __PPC__ */
 
 #if defined (__ARM__) || defined (__I386__) || defined (__M68K__) || defined (__bfin__) ||\
-	defined (__microblaze__)
+	defined (__microblaze__) || defined (__SH4__)
 
 struct stat {
 	unsigned short st_dev;
diff --git a/include/part.h b/include/part.h
index 37b2b68..a84ea4d 100644
--- a/include/part.h
+++ b/include/part.h
@@ -42,12 +42,12 @@ typedef struct block_dev_desc {
 	char		product[20+1];	/* IDE Serial no, SCSI product */
 	char		revision[8+1];	/* firmware revision */
 	unsigned long	(*block_read)(int dev,
-				      unsigned long start,
-				      lbaint_t blkcnt,
+				      lbaint_t start,
+				      unsigned long blkcnt,
 				      void *buffer);
 	unsigned long	(*block_write)(int dev,
-				       unsigned long start,
-				       lbaint_t blkcnt,
+				       lbaint_t start,
+				       unsigned long blkcnt,
 				       const void *buffer);
 }block_dev_desc_t;
 
diff --git a/include/sh-sci.h b/include/sh-sci.h
new file mode 100644
index 0000000..083e8ae
--- /dev/null
+++ b/include/sh-sci.h
@@ -0,0 +1,362 @@
+/*
+ *  include/sh-sci.h
+ *
+ *  SuperH on-chip serial module support.  (SCI with no FIFO / with FIFO)
+ *  Copyright (C) 1999, 2000  Niibe Yutaka
+ *  Copyright (C) 2000  Greg Banks
+ *  Modified to support multiple serial ports. Stuart Menefy (May 2000).
+ *  Modified to support SH7300(SH-Mobile) SCIF. Takashi Kusuda (Jun 2003).
+ *  Modified for u-boot A.Sturges (Nov 2004)
+ *
+ */
+
+#include "common.h"
+
+#include <linux/config.h>
+
+/* Values for sci_port->type */
+#define PORT_SCI  0
+#define PORT_SCIF 1
+#define PORT_IRDA 1		/* XXX: temporary assignment */
+
+/* Offsets into the sci_port->irqs array */
+#define SCIx_ERI_IRQ 0
+#define SCIx_RXI_IRQ 1
+#define SCIx_TXI_IRQ 2
+
+/*                     ERI, RXI, TXI, BRI */
+#define SCI_IRQS      { 23,  24,  25,   0 }
+#define SH3_SCIF_IRQS { 56,  57,  59,  58 }
+#define SH3_IRDA_IRQS { 52,  53,  55,  54 }
+#define SH4_SCIF_IRQS { 40,  41,  43,  42 }
+#define STB1_SCIF1_IRQS {23, 24,  26,  25 }
+#define SH7300_SCIF0_IRQS {80,  80,  80,  80 }
+
+#if defined(CONFIG_CPU_SUBTYPE_SH7708)
+# define SCI_NPORTS 1
+# define SCI_INIT { \
+  { {}, PORT_SCI,  0xfffffe80, SCI_IRQS,      sci_init_pins_sci  } \
+}
+# define SCSPTR 0xffffff7c	/* 8 bit */
+# define SCSCR_INIT(port)          0x30	/* TIE=0,RIE=0,TE=1,RE=1 */
+# define SCI_ONLY
+#elif defined(CONFIG_CPU_SUBTYPE_SH7300)
+# define SCI_NPORTS 1
+# define SCI_INIT { \
+  { {}, PORT_SCIF,  0xA4430000, SH7300_SCIF0_IRQS, sci_init_pins_scif }, \
+}
+# define SCPCR  0xA4050116	/* 16 bit SCIF */
+# define SCPDR  0xA4050136	/* 16 bit SCIF */
+# define SCSCR_INIT(port)  0x0030	/* TIE=0,RIE=0,TE=1,RE=1 */
+# define SCIF_ONLY
+
+#elif defined(CONFIG_CPU_SUBTYPE_SH7707) || defined(CONFIG_CPU_SUBTYPE_SH7709)
+# define SCI_NPORTS 3
+# define SCI_INIT { \
+  { {}, PORT_SCI,  0xfffffe80, SCI_IRQS,      sci_init_pins_sci  }, \
+  { {}, PORT_SCIF, 0xA4000150, SH3_SCIF_IRQS, sci_init_pins_scif }, \
+  { {}, PORT_SCIF, 0xA4000140, SH3_IRDA_IRQS, sci_init_pins_irda }  \
+}
+# define SCPCR  0xA4000116	/* 16 bit SCI and SCIF */
+# define SCPDR  0xA4000136	/* 8  bit SCI and SCIF */
+# define SCSCR_INIT(port)          0x30	/* TIE=0,RIE=0,TE=1,RE=1 */
+# define SCI_AND_SCIF
+#elif defined(CONFIG_CPU_SUBTYPE_SH7750) || defined(CONFIG_CPU_SUBTYPE_SH7751)
+# define SCI_NPORTS 2
+# define SCI_INIT { \
+  { {}, PORT_SCI,  0xffe00000, SCI_IRQS,      sci_init_pins_sci  }, \
+  { {}, PORT_SCIF, 0xFFE80000, SH4_SCIF_IRQS, sci_init_pins_scif }  \
+}
+# define SCSPTR1 0xffe0001c	/* 8  bit SCI */
+# define SCSPTR2 0xFFE80020	/* 16 bit SCIF */
+# define SCIF_ORER 0x0001	/* overrun error bit */
+# define SCSCR_INIT(port) (((port)->type == PORT_SCI) ? \
+	0x30 /* TIE=0,RIE=0,TE=1,RE=1 */ : \
+	0x38 /* TIE=0,RIE=0,TE=1,RE=1,REIE=1 */ )
+# define SCI_AND_SCIF
+#elif defined(CONFIG_CPU_SUBTYPE_SH4_2XX)
+# define SCI_NPORTS 1
+# define SCI_INIT { \
+  { {}, PORT_SCIF, 0xFFE80000, SH4_SCIF_IRQS, sci_init_pins_scif }  \
+}
+# define SCSPTR2 0xFFE80020	/* 16 bit SCIF */
+# define SCIF_ORER 0x0001	/* overrun error bit */
+# define SCSCR_INIT(port) 0x38	/* TIE=0,RIE=0,TE=1,RE=1,REIE=1 */
+# define SCIF_ONLY
+#elif defined(CONFIG_CPU_SUBTYPE_SH4_1XX)
+# define SCI_NPORTS 2
+# define SCI_INIT { \
+  { {}, PORT_SCIF, 0xffe00000, STB1_SCIF1_IRQS, sci_init_pins_scif }, \
+  { {}, PORT_SCIF, 0xffe80000, SH4_SCIF_IRQS,   sci_init_pins_scif }  \
+}
+# define SCSPTR1 0xffe00020	/* 16 bit SCIF */
+# define SCSPTR2 0xffe80020	/* 16 bit SCIF */
+# define SCIF_ORER 0x0001	/* overrun error bit */
+# define SCSCR_INIT(port)          0x38	/* TIE=0,RIE=0,TE=1,RE=1,REIE=1 */
+# define SCIF_ONLY
+
+#else
+# error CPU subtype not defined
+#endif
+
+/* SCSCR */
+#define SCI_CTRL_FLAGS_TIE  0x80	/* all */
+#define SCI_CTRL_FLAGS_RIE  0x40	/* all */
+#define SCI_CTRL_FLAGS_TE   0x20	/* all */
+#define SCI_CTRL_FLAGS_RE   0x10	/* all */
+/*      SCI_CTRL_FLAGS_REIE 0x08  * 7750 SCIF */
+/*      SCI_CTRL_FLAGS_MPIE 0x08  * 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+/*      SCI_CTRL_FLAGS_TEIE 0x04  * 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+/*      SCI_CTRL_FLAGS_CKE1 0x02  * all */
+/*      SCI_CTRL_FLAGS_CKE0 0x01  * 7707 SCI/SCIF, 7708 SCI, 7709 SCI/SCIF, 7750 SCI */
+
+/* SCxSR SCI */
+#define SCI_TDRE  0x80		/* 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+#define SCI_RDRF  0x40		/* 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+#define SCI_ORER  0x20		/* 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+#define SCI_FER   0x10		/* 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+#define SCI_PER   0x08		/* 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+#define SCI_TEND  0x04		/* 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+/*      SCI_MPB   0x02  * 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+/*      SCI_MPBT  0x01  * 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+
+#define SCI_ERRORS ( SCI_PER | SCI_FER | SCI_ORER)
+
+/* SCxSR SCIF */
+#define SCIF_ER    0x0080	/* 7707 SCIF, 7709 SCIF, 7750 SCIF */
+#define SCIF_TEND  0x0040	/* 7707 SCIF, 7709 SCIF, 7750 SCIF */
+#define SCIF_TDFE  0x0020	/* 7707 SCIF, 7709 SCIF, 7750 SCIF */
+#define SCIF_BRK   0x0010	/* 7707 SCIF, 7709 SCIF, 7750 SCIF */
+#define SCIF_FER   0x0008	/* 7707 SCIF, 7709 SCIF, 7750 SCIF */
+#define SCIF_PER   0x0004	/* 7707 SCIF, 7709 SCIF, 7750 SCIF */
+#define SCIF_RDF   0x0002	/* 7707 SCIF, 7709 SCIF, 7750 SCIF */
+#define SCIF_DR    0x0001	/* 7707 SCIF, 7709 SCIF, 7750 SCIF */
+
+#if defined(CONFIG_CPU_SUBTYPE_SH7300)
+#define SCIF_ORER    0x0200
+#define SCIF_ERRORS ( SCIF_PER | SCIF_FER | SCIF_ER | SCIF_BRK | SCIF_ORER)
+#else
+#define SCIF_ERRORS ( SCIF_PER | SCIF_FER | SCIF_ER | SCIF_BRK)
+#endif
+
+#if defined(SCI_ONLY)
+# define SCxSR_TEND(port)		SCI_TEND
+# define SCxSR_ERRORS(port)		SCI_ERRORS
+# define SCxSR_RDxF(port)               SCI_RDRF
+# define SCxSR_TDxE(port)               SCI_TDRE
+# define SCxSR_ORER(port)		SCI_ORER
+# define SCxSR_FER(port)		SCI_FER
+# define SCxSR_PER(port)		SCI_PER
+# define SCxSR_BRK(port)		0x00
+# define SCxSR_RDxF_CLEAR(port)		0xbc
+# define SCxSR_ERROR_CLEAR(port)	0xc4
+# define SCxSR_TDxE_CLEAR(port)		0x78
+# define SCxSR_BREAK_CLEAR(port)   	0xc4
+#elif defined(SCIF_ONLY)
+# define SCxSR_TEND(port)		SCIF_TEND
+# define SCxSR_ERRORS(port)		SCIF_ERRORS
+# define SCxSR_RDxF(port)               SCIF_RDF
+# define SCxSR_TDxE(port)               SCIF_TDFE
+#if defined(CONFIG_CPU_SUBTYPE_SH7300)
+# define SCxSR_ORER(port)		SCIF_ORER
+#else
+# define SCxSR_ORER(port)		0x0000
+#endif
+# define SCxSR_FER(port)		SCIF_FER
+# define SCxSR_PER(port)		SCIF_PER
+# define SCxSR_BRK(port)		SCIF_BRK
+#if defined(CONFIG_CPU_SUBTYPE_SH7300)
+# define SCxSR_RDxF_CLEAR(port)         (sci_in(port,SCxSR)&0xfffc)
+# define SCxSR_ERROR_CLEAR(port)        (sci_in(port,SCxSR)&0xfd73)
+# define SCxSR_TDxE_CLEAR(port)         (sci_in(port,SCxSR)&0xffdf)
+# define SCxSR_BREAK_CLEAR(port)        (sci_in(port,SCxSR)&0xffe3)
+#else
+# define SCxSR_RDxF_CLEAR(port)		0x00fc
+# define SCxSR_ERROR_CLEAR(port)	0x0073
+# define SCxSR_TDxE_CLEAR(port)		0x00df
+# define SCxSR_BREAK_CLEAR(port)   	0x00e3
+#endif
+#else
+# define SCxSR_TEND(port)	 (((port)->type == PORT_SCI) ? SCI_TEND   : SCIF_TEND)
+# define SCxSR_ERRORS(port)	 (((port)->type == PORT_SCI) ? SCI_ERRORS : SCIF_ERRORS)
+# define SCxSR_RDxF(port)        (((port)->type == PORT_SCI) ? SCI_RDRF   : SCIF_RDF)
+# define SCxSR_TDxE(port)        (((port)->type == PORT_SCI) ? SCI_TDRE   : SCIF_TDFE)
+# define SCxSR_ORER(port)        (((port)->type == PORT_SCI) ? SCI_ORER   : 0x0000)
+# define SCxSR_FER(port)         (((port)->type == PORT_SCI) ? SCI_FER    : SCIF_FER)
+# define SCxSR_PER(port)         (((port)->type == PORT_SCI) ? SCI_PER    : SCIF_PER)
+# define SCxSR_BRK(port)         (((port)->type == PORT_SCI) ? 0x00       : SCIF_BRK)
+# define SCxSR_RDxF_CLEAR(port)	 (((port)->type == PORT_SCI) ? 0xbc : 0x00fc)
+# define SCxSR_ERROR_CLEAR(port) (((port)->type == PORT_SCI) ? 0xc4 : 0x0073)
+# define SCxSR_TDxE_CLEAR(port)  (((port)->type == PORT_SCI) ? 0x78 : 0x00df)
+# define SCxSR_BREAK_CLEAR(port) (((port)->type == PORT_SCI) ? 0xc4 : 0x00e3)
+#endif
+
+/* SCFCR */
+#define SCFCR_RFRST 0x0002
+#define SCFCR_TFRST 0x0004
+#define SCFCR_TCRST 0x4000
+#define SCFCR_MCE   0x0008
+
+#define SCI_MAJOR		204
+#define SCI_MINOR_START		8
+
+/* Generic serial flags */
+#define SCI_RX_THROTTLE		0x0000001
+
+#define SCI_MAGIC 0xbabeface
+
+/*
+ * Events are used to schedule things to happen at timer-interrupt
+ * time, instead of at rs interrupt time.
+ */
+#define SCI_EVENT_WRITE_WAKEUP	0
+
+struct sci_port
+{
+	struct
+	{
+	} dummy;
+	int type;
+	unsigned int base;
+	unsigned char irqs[4];	/* ERI, RXI, TXI, BRI */
+	void (*init_pins) (struct sci_port * port, unsigned int cflag);
+	unsigned int old_cflag;
+	unsigned long event;
+	int break_flag;
+};
+
+#define SCI_IN(size, offset)					\
+  unsigned int addr = port->base + (offset);			\
+  if ((size) == 8) { 						\
+    return ctrl_inb(addr);					\
+  } else {					 		\
+    return ctrl_inw(addr);					\
+  }
+#define SCI_OUT(size, offset, value)				\
+  unsigned int addr = port->base + (offset);			\
+  if ((size) == 8) { 						\
+    ctrl_outb(value, addr);					\
+  } else {							\
+    ctrl_outw(value, addr);					\
+  }
+
+#define CPU_SCIx_FNS(name, sci_offset, sci_size, scif_offset, scif_size)\
+  static inline unsigned int sci_##name##_in(struct sci_port* port)	\
+  {									\
+    if (port->type == PORT_SCI) { 					\
+      SCI_IN(sci_size, sci_offset)					\
+    } else {								\
+      SCI_IN(scif_size, scif_offset);		 			\
+    }									\
+  }									\
+  static inline void sci_##name##_out(struct sci_port* port, unsigned int value) \
+  {									\
+    if (port->type == PORT_SCI) {					\
+      SCI_OUT(sci_size, sci_offset, value)				\
+    } else {								\
+      SCI_OUT(scif_size, scif_offset, value);				\
+    }									\
+  }
+
+#define CPU_SCIF_FNS(name, scif_offset, scif_size)				\
+  static inline unsigned int sci_##name##_in(struct sci_port* port)	\
+  {									\
+    SCI_IN(scif_size, scif_offset);		 			\
+  }									\
+  static inline void sci_##name##_out(struct sci_port* port, unsigned int value) \
+  {									\
+    SCI_OUT(scif_size, scif_offset, value);				\
+  }
+
+#ifdef __sh3__
+#error
+#if defined(CONFIG_CPU_SUBTYPE_SH7300)
+#define SCIF_FNS(name, scif_offset, scif_size) \
+  CPU_SCIF_FNS(name, scif_offset, scif_size)
+#else
+#define SCIx_FNS(name, sh3_sci_offset, sh3_sci_size, sh4_sci_offset, sh4_sci_size, \
+		 sh3_scif_offset, sh3_scif_size, sh4_scif_offset, sh4_scif_size) \
+  CPU_SCIx_FNS(name, sh3_sci_offset, sh3_sci_size, sh3_scif_offset, sh3_scif_size)
+#define SCIF_FNS(name, sh3_scif_offset, sh3_scif_size, sh4_scif_offset, sh4_scif_size) \
+  CPU_SCIF_FNS(name, sh3_scif_offset, sh3_scif_size)
+#endif
+#else
+#define SCIx_FNS(name, sh3_sci_offset, sh3_sci_size, sh4_sci_offset, sh4_sci_size, \
+		 sh3_scif_offset, sh3_scif_size, sh4_scif_offset, sh4_scif_size) \
+  CPU_SCIx_FNS(name, sh4_sci_offset, sh4_sci_size, sh4_scif_offset, sh4_scif_size)
+#define SCIF_FNS(name, sh3_scif_offset, sh3_scif_size, sh4_scif_offset, sh4_scif_size) \
+  CPU_SCIF_FNS(name, sh4_scif_offset, sh4_scif_size)
+#endif
+
+#if defined(CONFIG_CPU_SUBTYPE_SH7300)
+SCIF_FNS (SCSMR, 0x00, 16)
+	SCIF_FNS (SCBRR, 0x04, 8)
+	SCIF_FNS (SCSCR, 0x08, 16)
+	SCIF_FNS (SCTDSR, 0x0c, 8)
+	SCIF_FNS (SCFER, 0x10, 16)
+	SCIF_FNS (SCxSR, 0x14, 16)
+	SCIF_FNS (SCFCR, 0x18, 16)
+	SCIF_FNS (SCFDR, 0x1c, 16)
+	SCIF_FNS (SCxTDR, 0x20, 8)
+	SCIF_FNS (SCxRDR, 0x24, 8)
+#else
+/*      reg      SCI/SH3   SCI/SH4  SCIF/SH3   SCIF/SH4  */
+/*      name     off  sz   off  sz   off  sz   off  sz   */
+SCIx_FNS (SCSMR, 0x00, 8, 0x00, 8, 0x00, 8, 0x00, 16)
+	SCIx_FNS (SCBRR, 0x02, 8, 0x04, 8, 0x02, 8, 0x04, 8)
+	SCIx_FNS (SCSCR, 0x04, 8, 0x08, 8, 0x04, 8, 0x08, 16)
+	SCIx_FNS (SCxTDR, 0x06, 8, 0x0c, 8, 0x06, 8, 0x0C, 8)
+	SCIx_FNS (SCxSR, 0x08, 8, 0x10, 8, 0x08, 16, 0x10, 16)
+	SCIx_FNS (SCxRDR, 0x0a, 8, 0x14, 8, 0x0A, 8, 0x14, 8)
+	SCIF_FNS (SCFCR, 0x0c, 8, 0x18, 16)
+	SCIF_FNS (SCFDR, 0x0e, 16, 0x1C, 16)
+	SCIF_FNS (SCSPTR, 0, 0, 0x20, 16)
+	SCIF_FNS (SCLSR, 0, 0, 0x24, 16)
+#endif
+#define sci_in(port, reg) sci_##reg##_in(port)
+#define sci_out(port, reg, value) sci_##reg##_out(port, value)
+/*
+ * Values for the BitRate Register (SCBRR)
+ *
+ * The values are actually divisors for a frequency which can
+ * be internal to the SH3 (14.7456MHz) or derived from an external
+ * clock source.  This driver assumes the internal clock is used;
+ * to support using an external clock source, config options or
+ * possibly command-line options would need to be added.
+ *
+ * Also, to support speeds below 2400 (why?) the lower 2 bits of
+ * the SCSMR register would also need to be set to non-zero values.
+ *
+ * -- Greg Banks 27Feb2000
+ *
+ * Answer: The SCBRR register is only eight bits, and the value in
+ * it gets larger with lower baud rates. At around 2400 (depending on
+ * the peripherial module clock) you run out of bits. However the
+ * lower two bits of SCSMR allow the module clock to be divided down,
+ * scaling the value which is needed in SCBRR.
+ *
+ * -- Stuart Menefy - 23 May 2000
+ *
+ * I meant, why would anyone bother with bitrates below 2400.
+ *
+ * -- Greg Banks - 7Jul2000
+ *
+ * You "speedist"!  How will I use my 110bps ASR-33 teletype with paper
+ * tape reader as a console!
+ *
+ * -- Mitch Davis - 15 Jul 2000
+ */
+#if defined(CONFIG_CPU_SUBTYPE_SH7300)
+#define SCBRR_VALUE(bps) ((P_CLOCK_RATE+16*bps)/(16*bps)-1)
+#else
+#define SCBRR_VALUE(bps) ((P_CLOCK_RATE+16*bps)/(32*bps)-1)
+#endif
+#define BPS_2400       SCBRR_VALUE(2400)
+#define BPS_4800       SCBRR_VALUE(4800)
+#define BPS_9600       SCBRR_VALUE(9600)
+#define BPS_19200      SCBRR_VALUE(19200)
+#define BPS_38400      SCBRR_VALUE(38400)
+#define BPS_57600      SCBRR_VALUE(57600)
+#define BPS_115200     SCBRR_VALUE(115200)
+#define BPS_230400     SCBRR_VALUE(230400)
+
diff --git a/lib_sh/Makefile b/lib_sh/Makefile
new file mode 100644
index 0000000..5ee9b8e
--- /dev/null
+++ b/lib_sh/Makefile
@@ -0,0 +1,45 @@
+#
+# (C) Copyright 2003-2004
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(ARCH).a
+
+AOBJS	= memchr.o memcpy.o memmove.o memset.o strlen.o cacheops.o div64.o
+
+COBJS	= board.o sh_linux.o time.o io_generic.o udivdi3.o
+
+OBJS	= $(AOBJS) $(COBJS)
+
+$(LIB):	.depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
+
diff --git a/lib_sh/board.c b/lib_sh/board.c
new file mode 100644
index 0000000..146bb9e
--- /dev/null
+++ b/lib_sh/board.c
@@ -0,0 +1,299 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <malloc.h>
+#include <version.h>
+#include <devices.h>
+#include <version.h>
+#include <net.h>
+#include <environment.h>
+#if defined(CONFIG_CMD_NAND)
+#include <nand.h>
+#endif
+
+extern ulong _uboot_end_data;
+extern ulong _uboot_end;
+
+ulong monitor_flash_len;
+
+#ifndef CONFIG_IDENT_STRING
+#define CONFIG_IDENT_STRING ""
+#endif
+
+const char version_string[] =
+	U_BOOT_VERSION" (" __DATE__ " - " __TIME__ ") - " CONFIG_IDENT_STRING ;
+
+/*
+ * Begin and End of memory area for malloc(), and current "brk"
+ */
+
+#define	TOTAL_MALLOC_LEN	CFG_MALLOC_LEN
+
+static ulong mem_malloc_start;
+static ulong mem_malloc_end;
+static ulong mem_malloc_brk;
+
+extern int soc_init (void); 	/* Detect/set SOC settings  */
+extern int board_init (void);   /* Set up board             */
+extern int timer_init (void);
+extern int checkboard (void);   /* Give info about board    */
+
+static void mem_malloc_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	ulong dest_addr = TEXT_BASE + gd->reloc_off;
+
+	mem_malloc_end = dest_addr;
+	mem_malloc_start = dest_addr - TOTAL_MALLOC_LEN;
+	mem_malloc_brk = mem_malloc_start;
+
+	memset ((void *) mem_malloc_start,
+		0, mem_malloc_end - mem_malloc_start);
+}
+
+void *sbrk (ptrdiff_t increment)
+{
+	ulong old = mem_malloc_brk;
+	ulong new = old + increment;
+
+	if ((new < mem_malloc_start) || (new > mem_malloc_end)) {
+		return (NULL);
+	}
+	mem_malloc_brk = new;
+	return ((void *) old);
+}
+
+static int init_func_ram (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+#ifdef	CONFIG_BOARD_TYPES
+	int board_type = gd->board_type;
+#endif
+
+	gd->ram_size = CFG_SDRAM_SIZE;
+	puts ("DRAM:  ");
+	print_size (gd->ram_size, "\n");
+
+	return (0);
+}
+
+static int display_banner (void)
+{
+
+	printf ("\n\n%s\n\n", version_string);
+	return (0);
+}
+
+static void display_flash_config (ulong size)
+{
+	puts ("Flash: ");
+	print_size (size, "\n");
+}
+
+
+static int init_baudrate (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	char tmp[64];		/* long enough for environment variables */
+	int i = getenv_r ("baudrate", tmp, sizeof (tmp));
+
+	gd->baudrate = (i > 0)
+		? (int) simple_strtoul (tmp, NULL, 10)
+		: CONFIG_BAUDRATE;
+
+	return (0);
+}
+
+void flashWriteEnable(void);
+
+/*
+ * All attempts to come up with a "common" initialization sequence
+ * that works for all boards and architectures failed: some of the
+ * requirements are just _too_ different. To get rid of the resulting
+ * mess of board dependend #ifdef'ed code we now make the whole
+ * initialization sequence configurable to the user.
+ *
+ * The requirements for any new initalization function is simple: it
+ * receives a pointer to the "global data" structure as it's only
+ * argument, and returns an integer return code, where 0 means
+ * "continue" and != 0 means "fatal error, hang the system".
+ */
+typedef int (init_fnc_t) (void);
+
+init_fnc_t *init_sequence[] = {
+	soc_init,
+	timer_init,
+	board_init,
+	env_init,		/* initialize environment */
+	init_baudrate,		/* initialze baudrate settings */
+	serial_init,		/* serial communications setup */
+	console_init_f,		/* Initial console             */
+	checkboard,
+	display_banner,		/* say that we are here */
+	init_func_ram,
+	NULL,
+};
+
+
+void start_sh4boot (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	bd_t *bd;
+	ulong addr;
+	init_fnc_t **init_fnc_ptr;
+	ulong size;
+
+	char *s, *e;
+	int i;
+
+	addr = TEXT_BASE;
+	/* Reserve memory for malloc() arena. */
+	addr -= TOTAL_MALLOC_LEN;
+	/* (permanently) allocate a Board Info struct
+	 * and a permanent copy of the "global" data
+	 */
+	addr -= sizeof (gd_t);
+	gd = (gd_t *) addr;
+	memset ((void *) gd, 0, sizeof (gd_t));
+	addr -= sizeof (bd_t);
+	bd = (bd_t *) addr;
+	gd->bd = bd;
+
+	/* Reserve memory for boot params.
+	 */
+
+	addr -= CFG_BOOTPARAMS_LEN;
+	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
+		if ((*init_fnc_ptr) () != 0) {
+			hang ();
+		}
+	}
+
+	gd->reloc_off = 0;
+	gd->flags |= GD_FLG_RELOC;	/* tell others: relocation done */
+
+	monitor_flash_len = (ulong) & _uboot_end_data - TEXT_BASE;
+
+	/* configure available FLASH banks */
+
+	flashWriteEnable();
+	size = flash_init ();
+	display_flash_config (size);
+
+	bd = gd->bd;
+	bd->bi_boot_params = addr;
+	bd->bi_memstart = CFG_SDRAM_BASE;	/* start of  DRAM memory */
+	bd->bi_memsize = gd->ram_size;	/* size  of  DRAM memory in bytes */
+	bd->bi_baudrate = gd->baudrate;	/* Console Baudrate */
+	bd->bi_flashstart = CFG_FLASH_BASE;
+	bd->bi_flashsize = size;
+#if CFG_MONITOR_BASE == CFG_FLASH_BASE
+	bd->bi_flashoffset = monitor_flash_len;	/* reserved area for U-Boot */
+#else
+	bd->bi_flashoffset = 0;
+#endif
+
+	/* initialize malloc() area */
+	mem_malloc_init ();
+
+#if defined(CONFIG_CMD_NAND)
+	puts ("NAND:  ");
+	nand_init();		/* go init the NAND */
+#endif
+
+	/* Allocate environment function pointers etc. */
+	env_relocate ();
+
+	/* board MAC address */
+	s = getenv ("ethaddr");
+	for (i = 0; i < 6; ++i) {
+		bd->bi_enetaddr[i] = (s ? simple_strtoul (s, &e, 16) : 0)
+			&& 0xff;
+		if (s)
+			s = (*e) ? e + 1 : e;
+	}
+
+	/* IP Address */
+	bd->bi_ip_addr = getenv_IPaddr ("ipaddr");
+
+#if defined(CONFIG_PCI)
+	/*
+	 * Do pci configuration
+	 */
+	pci_init ();
+#endif
+
+/** leave this here (after malloc(), environment and PCI are working) **/
+	/* Initialize devices */
+	devices_init ();
+
+	jumptable_init ();
+
+	/* Initialize the console (after the relocation and devices init) */
+	console_init_r ();
+
+/** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **/
+
+	/* Initialize from environment */
+	if ((s = getenv ("loadaddr")) != NULL) {
+		load_addr = simple_strtoul (s, NULL, 16);
+	}
+#if defined(CONFIG_CMD_NET)
+	if ((s = getenv ("bootfile")) != NULL) {
+		copy_filename (BootFile, s, sizeof (BootFile));
+	}
+#endif /* CONFIG_CMD_NET */
+
+#if defined(CONFIG_MISC_INIT_R)
+	/* miscellaneous platform dependent initialisations */
+	misc_init_r ();
+#endif
+
+#if defined(CONFIG_CMD_NET)
+#if defined(CONFIG_NET_MULTI)
+	puts ("Net:   ");
+#endif
+	eth_initialize(gd->bd);
+#endif
+
+	/* main_loop() can return to retry autoboot, if so just run it again. */
+	for (;;) {
+		main_loop ();
+	}
+
+	/* NOTREACHED - no way out of command loop except booting */
+}
+
+
+void hang (void)
+{
+	puts ("### ERROR ### Please RESET the board ###\n");
+	for (;;);
+}
diff --git a/lib_sh/cacheops.S b/lib_sh/cacheops.S
new file mode 100644
index 0000000..940d7c8
--- /dev/null
+++ b/lib_sh/cacheops.S
@@ -0,0 +1,156 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include "asm/regdef.h"
+#include "asm/addrspace.h"
+#include "asm/asmdefs.h"
+#include "asm/linkage.h"
+#include "asm/sh4reg.h"
+
+	.text
+
+	/*
+	 * void sh_cache_set_op (ulong op)
+	 * set bits in ccn.cr
+	 */
+ENTRY(sh_cache_set_op)
+	/* get ccn.cr address into r0 (0xff00001c) */
+	MOV_CONST32_R0	SH4_CCN_CCR
+	mov.l	@r0, r1
+	or	a0, r1
+	mov.l	r1, @r0
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	rts
+	  nop
+
+
+	/*
+	 * void sh_cache_clear_op (ulong op)
+	 * clears bits in ccn.cr
+	 */
+ENTRY(sh_cache_clear_op)
+	/* get ccn.cr address into r0 (0xff00001c) */
+	MOV_CONST32_R0	SH4_CCN_CCR
+	mov.l	@r0, r1
+	not	a0, a0	/* invert op */
+	and	a0, r1	/* clear bits */
+	mov.l	r1, @r0
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	rts
+	  nop
+
+
+#ifdef CONFIG_SH_SE_MODE
+/* Move the PC from one PMB region to another, by masking.
+Note: This macro will clobber r0.
+Usage: .SWITCH_PMB <opcode> <mask_reg>
+where	<opcode> should be the masking opcode: "and" or "or".
+	<mask_reg> register name, containing the mask to use. */
+.macro	SWITCH_PMB opcode:req, mask_reg:req
+	mova	1f, r0
+	\opcode	\mask_reg, r0
+	ldc	r0, spc		/* SPC = PC op mask */
+	stc	sr, r0
+	ldc	r0, ssr		/* SSR = SR */
+	rte			/* do it */
+	  nop
+.balign 4
+1:
+.endm
+
+	/*
+	 * void sh_toggle_pmb_cacheability (void)
+	 *
+	 * Toggles the cacheability for PMB #0
+	 *
+	 * We do this by changing the PC to run out of an
+	 * alised PMB entry (not #0), which is UN-cached.
+	 * From here we 'toggle' the cachability of PMB
+	 * array entry #0, then invalidate the ITLB.
+	 * Finally we switch back the PC to the region
+	 * we were originaly running from.
+	 *
+	 * We only toggle the UB and the C flags of the PMB array.
+	 *
+	 * Assumptions:
+	 * We assume that an un-cached PMB entry already exists
+	 * which is an alias to the PMB entry we are currenty
+	 * running in. We assume that the transition into
+	 * the UN-cached one can be acevied by setting bit #28
+	 * of the PC.  i.e. OR-ing it with 0x10000000.
+	 */
+ENTRY(sh_toggle_pmb_cacheability)
+	/* use PMB entry array #0 */
+	.set index, 0		/* PMB array #0 */
+
+	/* set PC mask as bit #28 */
+	.set mask, 0x10000000	/* 0x80000000 ^ 0x90000000 */
+
+	/* set bits to toggle: PMB[n].C and PMB[n].UB */
+	.set toggle, (SH4_PMB_C|SH4_PMB_UB)
+
+	/* switch PC, to run from an UN-cached PMB region */
+	MOV_CONST32_R0 mask	/* Mask */
+	mov	r0, r2
+	SWITCH_PMB or, r2	/* PC = PC | 0x10000000 */
+
+	/* now toggle the cacheability of indexed PMB entry */
+	MOV_CONST32_R0	(toggle)
+	mov	r0, r3
+	MOV_CONST32_R0	(P4SEG_PMB_DATA|(index<<8))
+	mov.l	@r0, r1		/* read it */
+	xor	r3, r1		/* xor it */
+	mov.l	r1, @r0		/* write it */
+
+	/* Invalidate the ITLB, by setting MMUCR.TI */
+	MOV_CONST32_R0 SH4_CCN_MMUCR
+	mov.l	@r0, r1
+	mov	#(SH4_MMUCR_TI), r3
+	or	r3, r1
+	mov.l	r1, @r0
+
+	/* switch PC, to run from original PMB region */
+	not	r2, r2		/* invert the mask */
+	SWITCH_PMB and, r2	/* PC = PC & !0x10000000 */
+
+	/* return to the caller */
+	rts
+	  nop
+#endif	/* CONFIG_SH_SE_MODE */
+
diff --git a/lib_sh/div64.S b/lib_sh/div64.S
new file mode 100644
index 0000000..836d99e
--- /dev/null
+++ b/lib_sh/div64.S
@@ -0,0 +1,46 @@
+/*
+ * unsigned long long __xdiv64_32(unsigned long long n, unsigned long d);
+ */
+
+#include "asm/linkage.h"
+
+.text
+ENTRY(__xdiv64_32)
+#ifdef  __LITTLE_ENDIAN__
+	mov	r4, r0
+	mov	r5, r1
+#else
+	mov	r4, r1
+	mov	r5, r0
+#endif
+	cmp/hs	r6, r1
+	bf.s	1f
+	 mov	#0, r2
+
+	mov	r1, r2
+	mov	#0, r3
+	div0u
+	.rept	32
+	rotcl	r2
+	div1	r6, r3
+	.endr
+	rotcl	r2
+	mul.l	r6, r2
+	sts	macl, r3
+	sub	r3, r1
+1:
+	div0u
+	.rept	32
+	rotcl	r0
+	div1	r6, r1
+	.endr
+#ifdef  __LITTLE_ENDIAN__
+	mov	r2, r1
+	rts
+	 rotcl	r0
+#else
+	rotcl	r0
+	mov	r0, r1
+	rts
+	 mov	r2, r0
+#endif
diff --git a/lib_sh/io_generic.c b/lib_sh/io_generic.c
new file mode 100644
index 0000000..79a13b9
--- /dev/null
+++ b/lib_sh/io_generic.c
@@ -0,0 +1,61 @@
+/*
+ * lib_sh/io_generic.c
+ *
+ * Copyright (C) 2000  Niibe Yutaka
+ *
+ * Generic I/O routine. These can be used where a machine specific version
+ * is not required.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ */
+
+#include <asm/io.h>
+
+void _insb (unsigned long port, void *buffer, unsigned long count)
+{
+	unsigned char *buf = buffer;
+	while (count--)
+		*buf++ = inb (port);
+}
+
+void _insw (unsigned long port, void *buffer, unsigned long count)
+{
+	unsigned short *buf = buffer;
+	while (count--)
+		*buf++ = inw (port);
+}
+
+void _insl (unsigned long port, void *buffer, unsigned long count)
+{
+	unsigned long *buf = buffer;
+	while (count--)
+		*buf++ = inl (port);
+}
+
+void _outsb (unsigned long port, const void *buffer,
+		    unsigned long count)
+{
+	const unsigned char *buf = buffer;
+	while (count--)
+		outb (*buf++, port);
+}
+
+void _outsw (unsigned long port, const void *buffer,
+		    unsigned long count)
+{
+	const unsigned short *buf = buffer;
+	while (count--)
+		outw (*buf++, port);
+}
+
+void _outsl (unsigned long port, const void *buffer,
+		    unsigned long count)
+{
+	const unsigned long *buf = buffer;
+	while (count--)
+		outl (*buf++, port);
+}
+
diff --git a/lib_sh/memchr.S b/lib_sh/memchr.S
new file mode 100644
index 0000000..801f834
--- /dev/null
+++ b/lib_sh/memchr.S
@@ -0,0 +1,27 @@
+/*
+ * lib_sh/memchr.S
+ *
+ * "memchr" implementation of SuperH
+ *
+ * Copyright (C) 1999  Niibe Yutaka
+ *
+ */
+
+/*
+ * void *memchr(const void *s, int c, size_t n);
+ */
+
+#include "asm/linkage.h"
+ENTRY(memchr)
+	tst	r6,r6
+	bt/s	2f
+	 exts.b	r5,r5
+1:	mov.b	@r4,r1
+	cmp/eq	r1,r5
+	bt/s	3f
+	 dt	r6
+	bf/s	1b
+	 add	#1,r4
+2:	mov	#0,r4
+3:	rts
+	 mov	r4,r0
diff --git a/lib_sh/memcpy.S b/lib_sh/memcpy.S
new file mode 100644
index 0000000..5a87b31
--- /dev/null
+++ b/lib_sh/memcpy.S
@@ -0,0 +1,228 @@
+/*
+ * lib_sh/memcpy.S
+ *
+ * "memcpy" implementation of SuperH
+ *
+ * Copyright (C) 1999  Niibe Yutaka
+ *
+ */
+
+/*
+ * void *memcpy(void *dst, const void *src, size_t n);
+ * No overlap between the memory of DST and of SRC are assumed.
+ */
+
+#include "asm/linkage.h"
+ENTRY(memcpy)
+	tst	r6,r6
+	bt/s	9f		! if n=0, do nothing
+	 mov	r4,r0
+	sub	r4,r5		! From here, r5 has the distance to r0
+	add	r6,r0		! From here, r0 points the end of copying point
+	mov	#12,r1
+	cmp/gt	r6,r1
+	bt/s	7f		! if it's too small, copy a byte at once
+	 add	#-1,r5
+	add	#1,r5
+	!			From here, r6 is free
+	!
+	!      r4   -->  [ ...  ] DST             [ ...  ] SRC
+	!	         [ ...  ]                 [ ...  ]
+	!	           :                        :
+	!      r0   -->  [ ...  ]       r0+r5 --> [ ...  ]
+	!
+	!
+	mov	r5,r1
+	mov	#3,r2
+	and	r2,r1
+	shll2	r1
+	mov	r0,r3		! Save the value on R0 to R3
+	mova	jmptable,r0
+	add	r1,r0
+	mov.l	@r0,r1
+	jmp	@r1
+	 mov	r3,r0		! and back to R0
+	.balign	4
+jmptable:
+	.long	case0
+	.long	case1
+	.long	case2
+	.long	case3
+
+	! copy a byte at once
+7:	mov	r4,r2
+	add	#1,r2
+8:
+	cmp/hi	r2,r0
+	mov.b	@(r0,r5),r1
+	bt/s	8b			! while (r0>r2)
+	 mov.b	r1,@-r0
+9:
+	rts
+	 nop
+
+case0:
+	!
+	!	GHIJ KLMN OPQR -->  GHIJ KLMN OPQR
+	!
+	! First, align to long word boundary
+	mov	r0,r3
+	and	r2,r3
+	tst	r3,r3
+	bt/s	2f
+	 add	#-4,r5
+	add	#3,r5
+1:	dt	r3
+	mov.b	@(r0,r5),r1
+	bf/s	1b
+	 mov.b	r1,@-r0
+	!
+	add	#-3,r5
+2:	! Second, copy a long word at once
+	mov	r4,r2
+	add	#7,r2
+3:	mov.l	@(r0,r5),r1
+	cmp/hi	r2,r0
+	bt/s	3b
+	 mov.l	r1,@-r0
+	!
+	! Third, copy a byte at once, if necessary
+	cmp/eq	r4,r0
+	bt/s	9b
+	 add	#3,r5
+	bra	8b
+	 add	#-6,r2
+
+case1:
+	!
+	!	GHIJ KLMN OPQR -->  ...G HIJK LMNO PQR.
+	!
+	! First, align to long word boundary
+	mov	r0,r3
+	and	r2,r3
+	tst	r3,r3
+	bt/s	2f
+	 add	#-1,r5
+1:	dt	r3
+	mov.b	@(r0,r5),r1
+	bf/s	1b
+	 mov.b	r1,@-r0
+	!
+2:	! Second, read a long word and write a long word at once
+	mov.l	@(r0,r5),r1
+	add	#-4,r5
+	mov	r4,r2
+	add	#7,r2
+	!
+#ifdef __LITTLE_ENDIAN__
+3:	mov	r1,r3		! RQPO
+	shll16	r3
+	shll8	r3		! Oxxx
+	mov.l	@(r0,r5),r1	! NMLK
+	mov	r1,r6
+	shlr8	r6		! xNML
+	or	r6,r3		! ONML
+	cmp/hi	r2,r0
+	bt/s	3b
+	 mov.l	r3,@-r0
+#else
+3:	mov	r1,r3		! OPQR
+	shlr16	r3
+	shlr8	r3		! xxxO
+	mov.l	@(r0,r5),r1	! KLMN
+	mov	r1,r6
+	shll8	r6		! LMNx
+	or	r6,r3		! LMNO
+	cmp/hi	r2,r0
+	bt/s	3b
+	 mov.l	r3,@-r0
+#endif
+	!
+	! Third, copy a byte at once, if necessary
+	cmp/eq	r4,r0
+	bt/s	9b
+	 add	#4,r5
+	bra	8b
+	 add	#-6,r2
+
+case2:
+	!
+	!	GHIJ KLMN OPQR -->  ..GH IJKL MNOP QR..
+	!
+	! First, align to word boundary
+	tst	#1,r0
+	bt/s	2f
+	 add	#-1,r5
+	mov.b	@(r0,r5),r1
+	mov.b	r1,@-r0
+	!
+2:	! Second, read a word and write a word at once
+	add	#-1,r5
+	mov	r4,r2
+	add	#3,r2
+	!
+3:	mov.w	@(r0,r5),r1
+	cmp/hi	r2,r0
+	bt/s	3b
+	 mov.w	r1,@-r0
+	!
+	! Third, copy a byte at once, if necessary
+	cmp/eq	r4,r0
+	bt/s	9b
+	 add	#1,r5
+	mov.b	@(r0,r5),r1
+	rts
+	 mov.b	r1,@-r0
+
+case3:
+	!
+	!	GHIJ KLMN OPQR -->  .GHI JKLM NOPQ R...
+	!
+	! First, align to long word boundary
+	mov	r0,r3
+	and	r2,r3
+	tst	r3,r3
+	bt/s	2f
+	 add	#-1,r5
+1:	dt	r3
+	mov.b	@(r0,r5),r1
+	bf/s	1b
+	 mov.b	r1,@-r0
+	!
+2:	! Second, read a long word and write a long word at once
+	add	#-2,r5
+	mov.l	@(r0,r5),r1
+	add	#-4,r5
+	mov	r4,r2
+	add	#7,r2
+	!
+#ifdef __LITTLE_ENDIAN__
+3:	mov	r1,r3		! RQPO
+	shll8	r3		! QPOx
+	mov.l	@(r0,r5),r1	! NMLK
+	mov	r1,r6
+	shlr16	r6
+	shlr8	r6		! xxxN
+	or	r6,r3		! QPON
+	cmp/hi	r2,r0
+	bt/s	3b
+	 mov.l	r3,@-r0
+#else
+3:	mov	r1,r3		! OPQR
+	shlr8	r3		! xOPQ
+	mov.l	@(r0,r5),r1	! KLMN
+	mov	r1,r6
+	shll16	r6
+	shll8	r6		! Nxxx
+	or	r6,r3		! NOPQ
+	cmp/hi	r2,r0
+	bt/s	3b
+	 mov.l	r3,@-r0
+#endif
+	!
+	! Third, copy a byte at once, if necessary
+	cmp/eq	r4,r0
+	bt/s	9b
+	 add	#6,r5
+	bra	8b
+	 add	#-6,r2
diff --git a/lib_sh/memmove.S b/lib_sh/memmove.S
new file mode 100644
index 0000000..7a99e22
--- /dev/null
+++ b/lib_sh/memmove.S
@@ -0,0 +1,255 @@
+/*
+ * lib_sh/memmove.S
+ *
+ * "memmove" implementation of SuperH
+ *
+ * Copyright (C) 1999  Niibe Yutaka
+ *
+ */
+
+/*
+ * void *memmove(void *dst, const void *src, size_t n);
+ * The memory areas may overlap.
+ */
+#include "asm/linkage.h"
+
+ENTRY(memmove)
+	! if dest > src, call memcpy (it copies in decreasing order)
+	cmp/hi	r5,r4
+	bf	1f
+	mov.l	2f,r0
+	jmp	@r0
+	 nop
+	.balign 4
+2:	.long	SYMBOL_NAME(memcpy)
+1:
+	sub	r5,r4		! From here, r4 has the distance to r0
+	tst	r6,r6
+	bt/s	9f		! if n=0, do nothing
+	 mov	r5,r0
+	add	r6,r5
+	mov	#12,r1
+	cmp/gt	r6,r1
+	bt/s	8f		! if it's too small, copy a byte at once
+	 add	#-1,r4
+	add	#1,r4
+	!
+	!                [ ...  ] DST             [ ...  ] SRC
+	!	         [ ...  ]                 [ ...  ]
+	!	           :                        :
+	!      r0+r4-->  [ ...  ]       r0    --> [ ...  ]
+	!	           :                        :
+	!	         [ ...  ]                 [ ...  ]
+	!			        r5    -->
+	!
+	mov	r4,r1
+	mov	#3,r2
+	and	r2,r1
+	shll2	r1
+	mov	r0,r3		! Save the value on R0 to R3
+	mova	jmptable,r0
+	add	r1,r0
+	mov.l	@r0,r1
+	jmp	@r1
+	 mov	r3,r0		! and back to R0
+	.balign	4
+jmptable:
+	.long	case0
+	.long	case1
+	.long	case2
+	.long	case3
+
+	! copy a byte at once
+8:	mov.b	@r0+,r1
+	cmp/hs	r5,r0
+	bf/s	8b			! while (r0<r5)
+	 mov.b	r1,@(r0,r4)
+	add	#1,r4
+9:
+	add	r4,r0
+	rts
+	 sub	r6,r0
+
+case_none:
+	bra	8b
+	 add	#-1,r4
+
+case0:
+	!
+	!	GHIJ KLMN OPQR -->  GHIJ KLMN OPQR
+	!
+	! First, align to long word boundary
+	mov	r0,r3
+	and	r2,r3
+	tst	r3,r3
+	bt/s	2f
+	 add	#-1,r4
+	mov	#4,r2
+	sub	r3,r2
+1:	dt	r2
+	mov.b	@r0+,r1
+	bf/s	1b
+	 mov.b	r1,@(r0,r4)
+	!
+2:	! Second, copy a long word at once
+	add	#-3,r4
+	add	#-3,r5
+3:	mov.l	@r0+,r1
+	cmp/hs	r5,r0
+	bf/s	3b
+	 mov.l	r1,@(r0,r4)
+	add	#3,r5
+	!
+	! Third, copy a byte at once, if necessary
+	cmp/eq	r5,r0
+	bt/s	9b
+	 add	#4,r4
+	bra	8b
+	 add	#-1,r4
+
+case3:
+	!
+	!	GHIJ KLMN OPQR -->  ...G HIJK LMNO PQR.
+	!
+	! First, align to long word boundary
+	mov	r0,r3
+	and	r2,r3
+	tst	r3,r3
+	bt/s	2f
+	 add	#-1,r4
+	mov	#4,r2
+	sub	r3,r2
+1:	dt	r2
+	mov.b	@r0+,r1
+	bf/s	1b
+	 mov.b	r1,@(r0,r4)
+	!
+2:	! Second, read a long word and write a long word at once
+	add	#-2,r4
+	mov.l	@(r0,r4),r1
+	add	#-7,r5
+	add	#-4,r4
+	!
+#ifdef __LITTLE_ENDIAN__
+	shll8	r1
+3:	mov	r1,r3		! JIHG
+	shlr8	r3		! xJIH
+	mov.l	@r0+,r1		! NMLK
+	mov	r1,r2
+	shll16	r2
+	shll8	r2		! Kxxx
+	or	r2,r3		! KJIH
+	cmp/hs	r5,r0
+	bf/s	3b
+	 mov.l	r3,@(r0,r4)
+#else
+	shlr8	r1
+3:	mov	r1,r3		! GHIJ
+	shll8	r3		! HIJx
+	mov.l	@r0+,r1		! KLMN
+	mov	r1,r2
+	shlr16	r2
+	shlr8	r2		! xxxK
+	or	r2,r3		! HIJK
+	cmp/hs	r5,r0
+	bf/s	3b
+	 mov.l	r3,@(r0,r4)
+#endif
+	add	#7,r5
+	!
+	! Third, copy a byte at once, if necessary
+	cmp/eq	r5,r0
+	bt/s	9b
+	 add	#7,r4
+	add	#-3,r0
+	bra	8b
+	 add	#-1,r4
+
+case2:
+	!
+	!	GHIJ KLMN OPQR -->  ..GH IJKL MNOP QR..
+	!
+	! First, align to word boundary
+	tst	#1,r0
+	bt/s	2f
+	 add	#-1,r4
+	mov.b	@r0+,r1
+	mov.b	r1,@(r0,r4)
+	!
+2:	! Second, read a word and write a word at once
+	add	#-1,r4
+	add	#-1,r5
+	!
+3:	mov.w	@r0+,r1
+	cmp/hs	r5,r0
+	bf/s	3b
+	 mov.w	r1,@(r0,r4)
+	add	#1,r5
+	!
+	! Third, copy a byte at once, if necessary
+	cmp/eq	r5,r0
+	bt/s	9b
+	 add	#2,r4
+	mov.b	@r0,r1
+	mov.b	r1,@(r0,r4)
+	bra	9b
+	 add	#1,r0
+
+case1:
+	!
+	!	GHIJ KLMN OPQR -->  .GHI JKLM NOPQ R...
+	!
+	! First, align to long word boundary
+	mov	r0,r3
+	and	r2,r3
+	tst	r3,r3
+	bt/s	2f
+	 add	#-1,r4
+	mov	#4,r2
+	sub	r3,r2
+1:	dt	r2
+	mov.b	@r0+,r1
+	bf/s	1b
+	 mov.b	r1,@(r0,r4)
+	!
+2:	! Second, read a long word and write a long word at once
+	mov.l	@(r0,r4),r1
+	add	#-7,r5
+	add	#-4,r4
+	!
+#ifdef __LITTLE_ENDIAN__
+	shll16	r1
+	shll8	r1
+3:	mov	r1,r3		! JIHG
+	shlr16	r3
+	shlr8	r3		! xxxJ
+	mov.l	@r0+,r1		! NMLK
+	mov	r1,r2
+	shll8	r2		! MLKx
+	or	r2,r3		! MLKJ
+	cmp/hs	r5,r0
+	bf/s	3b
+	 mov.l	r3,@(r0,r4)
+#else
+	shlr16	r1
+	shlr8	r1
+3:	mov	r1,r3		! GHIJ
+	shll16	r3
+	shll8	r3		! Jxxx
+	mov.l	@r0+,r1		! KLMN
+	mov	r1,r2
+	shlr8	r2		! xKLM
+	or	r2,r3		! JKLM
+	cmp/hs	r5,r0
+	bf/s	3b		! while(r0<r5)
+	 mov.l	r3,@(r0,r4)
+#endif
+	add	#7,r5
+	!
+	! Third, copy a byte at once, if necessary
+	cmp/eq	r5,r0
+	bt/s	9b
+	 add	#5,r4
+	add	#-3,r0
+	bra	8b
+	 add	#-1,r4
diff --git a/lib_sh/memset.S b/lib_sh/memset.S
new file mode 100644
index 0000000..3b705b6
--- /dev/null
+++ b/lib_sh/memset.S
@@ -0,0 +1,58 @@
+/*
+ * lib_sh/memset.S
+ *
+ * "memset" implementation of SuperH
+ *
+ * Copyright (C) 1999  Niibe Yutaka
+ *
+ */
+
+/*
+ *            void *memset(void *s, int c, size_t n);
+ */
+
+#include "asm/linkage.h"
+
+ENTRY(memset)
+	tst	r6,r6
+	bt/s	5f		! if n=0, do nothing
+	 add	r6,r4
+	mov	#12,r0
+	cmp/gt	r6,r0
+	bt/s	4f		! if it's too small, set a byte at once
+	 mov	r4,r0
+	and	#3,r0
+	cmp/eq	#0,r0
+	bt/s	2f		! It's aligned
+	 sub	r0,r6
+1:
+	dt	r0
+	bf/s	1b
+	 mov.b	r5,@-r4
+2:				! make VVVV
+	swap.b	r5,r0		!   V0
+	or	r0,r5		!   VV
+	swap.w	r5,r0		! VV00
+	or	r0,r5		! VVVV
+	!
+	mov	r6,r0
+	shlr2	r0
+	shlr	r0		! r0 = r6 >> 3
+3:
+	dt	r0
+	mov.l	r5,@-r4		! set 8-byte at once
+	bf/s	3b
+	 mov.l	r5,@-r4
+	!
+	mov	#7,r0
+	and	r0,r6
+	tst	r6,r6
+	bt	5f
+	! fill bytes
+4:
+	dt	r6
+	bf/s	4b
+	 mov.b	r5,@-r4
+5:
+	rts
+	 mov	r4,r0
diff --git a/lib_sh/sh_linux.c b/lib_sh/sh_linux.c
new file mode 100644
index 0000000..2cc484e
--- /dev/null
+++ b/lib_sh/sh_linux.c
@@ -0,0 +1,338 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/cache.h>
+#include <asm/io.h>
+#include <asm/sh4reg.h>
+#include "asm/addrspace.h"
+
+#ifdef CONFIG_SHOW_BOOT_PROGRESS
+# include <status_led.h>
+# define SHOW_BOOT_PROGRESS(arg)	show_boot_progress(arg)
+#else
+# define SHOW_BOOT_PROGRESS(arg)
+#endif
+
+int gunzip (void *, int, unsigned char *, int *);
+
+extern image_header_t header;	/* from cmd_bootm.c */
+
+extern int do_reset (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[]);
+
+#define PAGE_OFFSET 0x1000
+
+#define MOUNT_ROOT_RDONLY	((unsigned long *) (param+0x000))
+#define RAMDISK_FLAGS		((unsigned long *) (param+0x004))
+#define ORIG_ROOT_DEV		((unsigned long *) (param+0x008))
+#define LOADER_TYPE		((unsigned long *) (param+0x00c))
+#define INITRD_START		((unsigned long *) (param+0x010))
+#define INITRD_SIZE		((unsigned long *) (param+0x014))
+#define SE_MODE			((const unsigned long *) (param+0x018))
+/* ... */
+#define COMMAND_LINE		((char *) (param+0x100))
+
+
+extern void sh_cache_set_op(ulong);
+extern void flashWriteDisable(void);
+#ifdef CONFIG_SH_SE_MODE
+extern void sh_toggle_pmb_cacheability(void);
+#endif	/* CONFIG_SH_SE_MODE */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CURRENT_SE_MODE 32	/* 32-bit (Space Enhanced) Mode */
+#define	PMB_ADDR(i)	((volatile unsigned long*)(P4SEG_PMB_ADDR+((i)<<8)))
+#else
+#define CURRENT_SE_MODE 29	/* 29-bit (Traditional) Mode */
+#endif	/* CONFIG_SH_SE_MODE */
+
+void do_bootm_linux (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[],
+		     ulong addr, ulong * len_ptr, int verify)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	ulong len = 0, checksum;
+	ulong initrd_start;
+	ulong data, param;
+	void (*theKernel) (void);
+	image_header_t *hdr = &header;
+	char *commandline = getenv ("bootargs");
+	char extra[128];	/* Extra command line args */
+	extra[0] = 0;
+#ifdef CONFIG_SH_SE_MODE
+	size_t i;
+#endif	/* CONFIG_SH_SE_MODE */
+
+	theKernel = (void (*)(void)) ntohl (hdr->ih_ep);
+	param = ntohl (hdr->ih_load);
+
+	/*
+	 * Check if there is an initrd image
+	 */
+	if (argc >= 3) {
+		SHOW_BOOT_PROGRESS (9);
+
+		addr = simple_strtoul (argv[2], NULL, 16);
+
+		/* Copy header so we can blank CRC field for re-calculation */
+		memcpy (&header, (char *) addr, sizeof (image_header_t));
+
+		if (ntohl (hdr->ih_magic) != IH_MAGIC) {
+			printf ("Bad Magic Number\n");
+			SHOW_BOOT_PROGRESS (-10);
+			do_reset (cmdtp, flag, argc, argv);
+		}
+
+		data = (ulong) & header;
+		len = sizeof (image_header_t);
+
+		checksum = ntohl (hdr->ih_hcrc);
+		hdr->ih_hcrc = 0;
+
+		if (crc32 (0, (unsigned char *) data, len) != checksum) {
+			printf ("Bad Header Checksum\n");
+			SHOW_BOOT_PROGRESS (-11);
+			do_reset (cmdtp, flag, argc, argv);
+		}
+
+		SHOW_BOOT_PROGRESS (10);
+
+		print_image_hdr (hdr);
+
+		data = addr + sizeof (image_header_t);
+		len = ntohl (hdr->ih_size);
+
+		if (verify) {
+			ulong csum = 0;
+
+			printf ("   Verifying Checksum ... ");
+			csum = crc32 (0, (unsigned char *) data, len);
+			if (csum != ntohl (hdr->ih_dcrc)) {
+				printf ("Bad Data CRC\n");
+				SHOW_BOOT_PROGRESS (-12);
+				do_reset (cmdtp, flag, argc, argv);
+			}
+			printf ("OK\n");
+		}
+
+		SHOW_BOOT_PROGRESS (11);
+
+		if ((hdr->ih_os != IH_OS_LINUX) ||
+		    (hdr->ih_arch != IH_CPU_SH) ||
+		    (hdr->ih_type != IH_TYPE_RAMDISK)) {
+			printf ("No Linux SH Ramdisk Image\n");
+			SHOW_BOOT_PROGRESS (-13);
+			do_reset (cmdtp, flag, argc, argv);
+		}
+
+
+		/*
+		 * Now check if we have a multifile image
+		 */
+	} else if ((hdr->ih_type == IH_TYPE_MULTI) && (len_ptr[1])) {
+		ulong tail = ntohl (len_ptr[0]) % 4;
+		int i;
+
+		SHOW_BOOT_PROGRESS (13);
+
+		/* skip kernel length and terminator */
+		data = (ulong) (&len_ptr[2]);
+		/* skip any additional image length fields */
+		for (i = 1; len_ptr[i]; ++i)
+			data += 4;
+		/* add kernel length, and align */
+		data += ntohl (len_ptr[0]);
+		if (tail) {
+			data += 4 - tail;
+		}
+
+		len = ntohl (len_ptr[1]);
+
+	} else {
+		/*
+		 * no initrd image
+		 */
+		SHOW_BOOT_PROGRESS (14);
+
+		data = 0;
+	}
+
+#ifdef	DEBUG
+	if (!data) {
+		printf ("No initrd\n");
+	}
+#endif
+
+	if (data) {
+		/*
+		 * Copy ramdisk image into place
+		 * data points to start of image
+		 * len gives length of image
+		 * we will copy image onto end of kernel aligned on a page
+		 * boundary
+		 *
+		 */
+		ulong sp;
+	      asm ("mov r15, %0": "=r" (sp):);
+				/* read stack pointer */
+		debug ("## Current stack ends at 0x%08lX ", sp);
+
+		sp -= 2048;	/* just to be sure */
+		if (sp > (CFG_SDRAM_BASE + CFG_BOOTMAPSZ))
+			sp = (CFG_SDRAM_BASE + CFG_BOOTMAPSZ);
+		sp &= ~0xF;
+		initrd_start = (sp - len) & ~(4096 - 1);
+
+		SHOW_BOOT_PROGRESS (12);
+
+		debug ("## initrd at 0x%08lX ... 0x%08lX (len=%ld=0x%lX)\n",
+		       data, data + len - 1, len, len);
+
+		printf ("   Loading Ramdisk to %08lx, length %08lx ... ",
+			initrd_start, len);
+#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+		{
+			size_t l = len;
+			void *to = (void *) initrd_start;
+			void *from = (void *) data;
+
+			while (l > 0) {
+				size_t tail = (l > CHUNKSZ) ? CHUNKSZ : l;
+				WATCHDOG_RESET ();
+				memmove (to, from, tail);
+				to += tail;
+				from += tail;
+				l -= tail;
+			}
+		}
+#else /* !(CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG) */
+		memmove ((void *) initrd_start, (void *) data, len);
+#endif /* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */
+		puts ("OK\n");
+
+
+		*LOADER_TYPE = 1;
+		*INITRD_START = (initrd_start - (param - PAGE_OFFSET)) ;	/* passed of offset from memory base */
+		*INITRD_SIZE = len;
+	} else {
+		*LOADER_TYPE = 0;
+		*INITRD_START = 0;
+		*INITRD_SIZE = 0;
+	}
+
+	SHOW_BOOT_PROGRESS (15);
+
+	/* try and detect if the kernel is incomptable with U-boot */
+	if ((*SE_MODE & 0xFFFFFF00) != 0x53453F00)	/* 'SE?.' */
+	{
+		printf("\nWarning: Unable to determine if kernel is built for 29- or 32-bit mode!\n");
+	}
+	else if ((*SE_MODE & 0xFF) != CURRENT_SE_MODE)
+	{
+		printf("\n"
+			"Error: A %2u-bit Kernel is incomptable with this %2u-bit U-Boot!\n"
+			"Please re-configure and re-build vmlinux or u-boot.\n"
+			"Aborting the Boot process - Boot FAILED.  (SE_MODE=0x%08x)\n",
+			CURRENT_SE_MODE,
+			CURRENT_SE_MODE ^ 0x3d,
+			*SE_MODE);
+		return;
+	}
+
+#ifdef DEBUG
+	printf ("## Transferring control to Linux (at address %08lx) initrd =  %08lx ...\n",
+		(ulong) theKernel, *INITRD_START);
+#endif
+
+	strcpy (COMMAND_LINE, commandline);
+	if (*extra)
+		strcpy (COMMAND_LINE + strlen (commandline), extra);
+
+	/* linux_params_init (gd->bd->bi_boot_params, commandline); */
+
+	printf ("\nStarting kernel %s - 0x%08x - %d ...\n\n", COMMAND_LINE,
+		*INITRD_START, *INITRD_SIZE);
+
+	/*
+	 * Flush the operand caches, to ensure that there is no unwritten
+	 * data residing only in the caches, before the kernel invalidates
+	 * them.
+	 */
+	sh_flush_cache_all();
+
+	/* Invalidate both instruction and data caches */
+	sh_cache_set_op(SH4_CCR_OCI|SH4_CCR_ICI);
+
+	/*
+	 * remove Vpp from the FLASH, so that no further writes can occur.
+	 */
+	flashWriteDisable();
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Before we can jump into the kernel, we need to invalidate all
+	 * (bar one) of the PMB array entries we are currently using.
+	 * Failure to do this, can result in the kernel creating a
+	 * new PMB entry with an overlapping virtual address, which
+	 * when accessed may result in a ITLBMULTIHIT or OTLBMULTIHIT
+	 * exception being raised.
+	 * We also need to enter the kernel running out of an UNCACHED
+	 * PMB entry. To perform this mode switch, we actually need to
+	 * have 2 PMB entries (#0, #1) both valid for the duration of
+	 * this mode switching. However, we invalidate all the others,
+	 * prior to this mode switch. Only after the mode switch, can
+	 * we then invaludate PMB[1], leaving just one (uncached) PMB
+	 * still valid - the one mapping the kernel itself (PMB[0]).
+	 * Note: after this point, U-boot may lose access to 
+	 * peripherals, including the serial console - so we can not
+	 * safely call puts(), printf(), etc. from this point onwards.
+	 */
+	/* set PMB[n].V = 0, for n == 2..15 */
+	for(i=2; i<16; i++)
+	{
+		*PMB_ADDR(i) = 0;	/* PMB[i].V = 0 */
+	}
+
+	/*
+	 * Now run out of the UN-cached PMB array #0.
+	 * For 32-bit mode, our contract with the kernel requires
+	 * that the kernel starts running out of an uncached PMB mapping.
+	 */
+	sh_toggle_pmb_cacheability();
+
+	/* now invalidate PMB entry #1, leaving just PMB #0 valid */
+	*PMB_ADDR(1) = 0;	/* PMB[1].V = 0 */
+
+	/*
+	 * we need to ensure that the ITLB is flushed, and not
+	 * harbouring any mappings from the recently invalidated
+	 * PMB entires.
+	 */
+	 *(volatile unsigned long*)SH4_CCN_MMUCR |= SH4_MMUCR_TI;
+#endif	/* CONFIG_SH_SE_MODE */
+
+	/* now, finally, we pass control to the kernel itself ... */
+	theKernel ();
+}
diff --git a/lib_sh/strlen.S b/lib_sh/strlen.S
new file mode 100644
index 0000000..9737892
--- /dev/null
+++ b/lib_sh/strlen.S
@@ -0,0 +1,71 @@
+/*
+ * lib_sh/strlen.S
+ *
+ * "strlen" implementation of SuperH
+ *
+ * Copyright (C) 1999  Kaz Kojima
+ *
+ */
+
+/* size_t strlen (const char *s)  */
+
+#include "asm/linkage.h"
+ENTRY(strlen)
+	mov	r4,r0
+	and	#3,r0
+	tst	r0,r0
+	bt/s	1f
+	 mov	#0,r2
+
+	add	#-1,r0
+	shll2	r0
+	shll	r0
+	braf	r0
+	 nop
+
+	mov.b	@r4+,r1
+	tst	r1,r1
+	bt	8f
+	add	#1,r2
+
+	mov.b	@r4+,r1
+	tst	r1,r1
+	bt	8f
+	add	#1,r2
+
+	mov.b	@r4+,r1
+	tst	r1,r1
+	bt	8f
+	add	#1,r2
+
+1:
+	mov	#0,r3
+2:
+	mov.l	@r4+,r1
+	cmp/str	r3,r1
+	bf/s	2b
+	 add	#4,r2
+
+	add	#-4,r2
+#ifndef __LITTLE_ENDIAN__
+	swap.b	r1,r1
+	swap.w	r1,r1
+	swap.b	r1,r1
+#endif
+	extu.b	r1,r0
+	tst	r0,r0
+	bt/s	8f
+	 shlr8	r1
+	add	#1,r2
+	extu.b	r1,r0
+	tst	r0,r0
+	bt/s	8f
+	 shlr8	r1
+	add	#1,r2
+	extu.b	r1,r0
+	tst	r0,r0
+	bt	8f
+	add	#1,r2
+8:
+	rts
+	 mov	r2,r0
diff --git a/lib_sh/time.c b/lib_sh/time.c
new file mode 100644
index 0000000..cf6d5ad
--- /dev/null
+++ b/lib_sh/time.c
@@ -0,0 +1,92 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#if defined(CONFIG_SH_STB7100)
+#include <asm/stb7100reg.h>
+#elif defined(CONFIG_SH_STX7200)
+#include <asm/stx7200reg.h>
+#else
+#error Missing Device Defintions!
+#endif
+
+#define TMU_TICKS_PER_SEC CFG_HZ
+#define TMU_START0 0x01
+#define TMU_MAX_COUNTER (~0UL)
+#define TMU_INPUT 0x0006
+
+#define TMU_OFF() *SH4_TMU_TSTR = 0;
+#define TMU_ON() *SH4_TMU_TSTR = *SH4_TMU_TSTR | 1;
+#define TMU_CLEAR() *SH4_TMU_TCOR0 = TMU_MAX_COUNTER; *SH4_TMU_TCNT0 = TMU_MAX_COUNTER;
+#define TMU_SET(v) *SH4_TMU_TCNT0 = (v ^ TMU_MAX_COUNTER);
+#define TMU_GET()  (*SH4_TMU_TCNT0 ^ TMU_MAX_COUNTER)
+
+/* RTC clock not connected on this board use pclock */
+int timer_init (void)
+{
+	TMU_OFF ();
+	/* Take clock from PCLOCK/1024 */
+	*SH4_TMU_TCR0 = *SH4_TMU_TCR0 & 0xfff8;
+	*SH4_TMU_TCR0 = *SH4_TMU_TCR0 | 0x4;
+	*SH4_TMU_TCOR0 = TMU_MAX_COUNTER;
+	TMU_ON ();
+	return 0;
+}
+void reset_timer (void)
+{
+	TMU_OFF ();
+	TMU_CLEAR ();
+	TMU_ON ();
+}
+
+ulong get_timer (ulong base)
+{
+  ulong now = TMU_GET();
+	return ((int)now - base) < 0 ? (TMU_MAX_COUNTER - (base - now)) : (now - base);
+}
+
+void set_timer (ulong t)
+{
+	TMU_SET (t);
+}
+
+void udelay (unsigned long usec)
+{
+  ulong tmo;
+  ulong start = TMU_GET ();
+  if (usec > 1000000)
+    tmo = ((usec/100000) * CFG_HZ) / 10;
+  else if (usec > 1000)
+    tmo = ((usec/100) * CFG_HZ) / 10000;
+  else
+    tmo = (usec * CFG_HZ) / 1000000;
+  while (get_timer(start) < tmo)
+		/*NOP*/;
+}
+
+ulong get_tbclk (void)
+{
+	return CFG_HZ;
+}
diff --git a/lib_sh/udivdi3.c b/lib_sh/udivdi3.c
new file mode 100644
index 0000000..68f038b
--- /dev/null
+++ b/lib_sh/udivdi3.c
@@ -0,0 +1,16 @@
+/*
+ * Simple __udivdi3 function which doesn't use FPU.
+ */
+
+#include <linux/types.h>
+
+extern u64 __xdiv64_32(u64 n, u32 d);
+extern void panic(const char * fmt, ...);
+
+u64 __udivdi3(u64 n, u64 d)
+{
+	if (d & ~0xffffffff)
+		panic("Need true 64-bit/64-bit division");
+	return __xdiv64_32(n, (u32)d);
+}
+
diff --git a/net/eth.c b/net/eth.c
index 1b56a35..4d1dd21 100644
--- a/net/eth.c
+++ b/net/eth.c
@@ -518,7 +518,7 @@ extern int emac4xx_miiphy_initialize(bd_t *bis);
 extern int mcf52x2_miiphy_initialize(bd_t *bis);
 extern int ns7520_miiphy_initialize(bd_t *bis);
 extern int dm644x_eth_miiphy_initialize(bd_t *bis);
-
+extern int stmac_miiphy_initialize(bd_t *bis);
 
 int eth_initialize(bd_t *bis)
 {
@@ -542,6 +542,9 @@ int eth_initialize(bd_t *bis)
 #if defined(CONFIG_DRIVER_TI_EMAC)
 	dm644x_eth_miiphy_initialize(bis);
 #endif
+#if defined(CONFIG_DRIVER_NETSTMAC)
+	stmac_miiphy_initialize(bis);
+#endif
 	return 0;
 }
 #endif
diff --git a/sh_config.mk b/sh_config.mk
new file mode 100644
index 0000000..b1998e7
--- /dev/null
+++ b/sh_config.mk
@@ -0,0 +1,29 @@
+#
+# (C) Copyright 2004
+# Andy Sturges, STMicroelectronics, andy.sturges@st.com
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+# Update this for each release
+
+SH_IDENT_STRING="\"stm23-2008-03-19\""	# QQQ: Have spec file fill this in automatically ?
+
+PLATFORM_CPPFLAGS += -DCONFIG_SH4 -D__SH4__ -DCONFIG_IDENT_STRING=$(SH_IDENT_STRING)
+PLATFORM_LDFLAGS  += -n
diff --git a/tools/mkimage.c b/tools/mkimage.c
index 2125130..9c8d9b9 100644
--- a/tools/mkimage.c
+++ b/tools/mkimage.c
@@ -91,6 +91,7 @@ table_entry_t arch_name[] = {
     {	IH_CPU_PPC,		"ppc",		"PowerPC",	},
     {	IH_CPU_S390,		"s390",		"IBM S390",	},
     {	IH_CPU_SH,		"sh",		"SuperH",	},
+    {	IH_CPU_ST200,		"st200",	"STMicroelectronics ST200",	},
     {	IH_CPU_SPARC,		"sparc",	"SPARC",	},
     {	IH_CPU_SPARC64,		"sparc64",	"SPARC 64 Bit",	},
     {	IH_CPU_BLACKFIN,	"blackfin",	"Blackfin",	},
--- u-boot-1.3.1.orig/lib_generic/sha1.c	2008-04-01 13:28:16.000000000 +0100
+++ u-boot-1.3.1/lib_generic/sha1.c	2008-04-01 13:29:18.000000000 +0100
@@ -29,7 +29,12 @@
 #define _CRT_SECURE_NO_DEPRECATE 1
 #endif
 
+#ifdef USE_HOSTCC
+#include <string.h>
+#else
 #include <linux/string.h>
+#endif
+
 #include "sha1.h"
 
 /*
--- u-boot-1.3.1.orig/drivers/net/stm-stmac.c	2008-04-07 10:20:02.000000000 +0100
+++ u-boot-1.3.1/drivers/net/stm-stmac.c	2008-04-07 10:20:55.000000000 +0100
@@ -368,8 +368,8 @@
 	stmac_mii_poll_busy ();
 
 	/* Set the MII address register to write */
-	STMAC_WRITE (mii_addr, MAC_MII_DATA);
-	STMAC_WRITE (value, MAC_MII_ADDR);
+	STMAC_WRITE (value, MAC_MII_DATA);
+	STMAC_WRITE (mii_addr, MAC_MII_ADDR);
 
 	stmac_mii_poll_busy ();
 
diff --git a/MAKEALL b/MAKEALL
index 0b7ffc6..c4bf635 100755
--- a/MAKEALL
+++ b/MAKEALL
@@ -674,6 +674,8 @@ LIST_sh="		\
 	hms1_128	\
 	mb519		\
 	mb519se		\
+	mb618		\
+	mb618se		\
 	cb101		\
 	cb101se		\
 "
diff --git a/Makefile b/Makefile
index d6a2ab6..4c94e22 100644
--- a/Makefile
+++ b/Makefile
@@ -2704,7 +2704,6 @@ mb448_config :		unconfig
 	@ >include/config.h
 	@echo "#define CONFIG_SH_STB7100   1" >>include/config.h
 	@echo "#define CONFIG_SH_MB448     1" >>include/config.h
-	@echo "#define INPUT_CLOCK_RATE    27" >>include/config.h
 	@./mkconfig -a mb448 sh sh mb448 "" stb7100
 
 hms1_config \
@@ -2727,6 +2726,17 @@ mb519se_config :		unconfig
 	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/mb519/config.tmp)
 	@./mkconfig -a mb519 sh sh mb519 "" stx7200
 
+mb618_config \
+mb618se_config :		unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_SH_STX7111   1" >>include/config.h
+	@echo "#define CONFIG_SH_MB618     1" >>include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/mb618/config.tmp)
+	@./mkconfig -a mb618 sh sh mb618 "" stx7111
+
 cb101_config \
 cb101se_config :		unconfig
 	@ >include/config.h
diff --git a/board/cb101/cb101.c b/board/cb101/cb101.c
index 7c8a90f..45908bd 100644
--- a/board/cb101/cb101.c
+++ b/board/cb101/cb101.c
@@ -29,8 +29,6 @@
 #include <asm/io.h>
 #include <asm/pio.h>
 
-void stx7200_reset(void);
-
 void flashWriteEnable(void)
 {
 	/*  Enable vpp for writing to flash */
@@ -175,10 +173,3 @@ int checkboard (void)
 
 	return 0;
 }
-
-int do_reset (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
-{
-	stx7200_reset();
-	/*NOTREACHED*/ return (0);
-}
-
diff --git a/board/hms1/hms1.c b/board/hms1/hms1.c
index 654a4a6..b6b22b1 100644
--- a/board/hms1/hms1.c
+++ b/board/hms1/hms1.c
@@ -32,7 +32,6 @@
 #include <jffs2/jffs2.h>
 #endif
 
-void stb7100_reset(void);
 void stb7100_clocks(void);
 
 #define EPLD_ATAPI *(volatile unsigned char *)(0xa3900000)
@@ -107,12 +106,6 @@ int checkboard (void)
 	return 0;
 }
 
-int do_reset (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
-{
-	stb7100_reset();
-	 /*NOTREACHED*/ return (0);
-}
-
 #if defined CFG_JFFS_CUSTOM_PART
 
 /*
diff --git a/board/mb411/mb411.c b/board/mb411/mb411.c
index c6a38e4..f91e107 100644
--- a/board/mb411/mb411.c
+++ b/board/mb411/mb411.c
@@ -32,7 +32,6 @@
 #include <jffs2/jffs2.h>
 #endif
 
-void stb7100_reset(void);
 void stb7100_clocks(void);
 
 #define EPLD_FLASH *(volatile unsigned char *)(0xa3400000)
@@ -114,11 +113,6 @@ int checkboard (void)
 	return 0;
 }
 
-int do_reset (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
-{
-	stb7100_reset();
-	 /*NOTREACHED*/ return (0);
-}
 
 #if defined CFG_JFFS_CUSTOM_PART
 
diff --git a/board/mb442/mb442.c b/board/mb442/mb442.c
index be0459e..cf4837c 100644
--- a/board/mb442/mb442.c
+++ b/board/mb442/mb442.c
@@ -28,7 +28,6 @@
 #include <asm/io.h>
 #include <asm/pio.h>
 
-void stb7100_reset(void);
 void stb7100_clocks(void);
 
 void flashWriteEnable(void)
@@ -129,9 +128,3 @@ int checkboard (void)
 
 	return 0;
 }
-
-int do_reset (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
-{
-	stb7100_reset();
-	 /*NOTREACHED*/ return (0);
-}
diff --git a/board/mb448/mb448.c b/board/mb448/mb448.c
index f804886..76580e1 100644
--- a/board/mb448/mb448.c
+++ b/board/mb448/mb448.c
@@ -28,7 +28,6 @@
 #include <asm/io.h>
 #include <asm/pio.h>
 
-void stb7100_reset(void);
 void stb7100_clocks(void);
 
 #define EPLD_FLASH *(volatile unsigned char *)(0xa3400000)
@@ -120,9 +119,3 @@ int checkboard (void)
 
 	return 0;
 }
-
-int do_reset (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
-{
-	stb7100_reset();
-	 /*NOTREACHED*/ return (0);
-}
diff --git a/board/mb519/mb519.c b/board/mb519/mb519.c
index f6eec93..08d1b21 100644
--- a/board/mb519/mb519.c
+++ b/board/mb519/mb519.c
@@ -28,8 +28,6 @@
 #include <asm/io.h>
 #include <asm/pio.h>
 
-void stx7200_reset(void);
-
 #ifdef CONFIG_SH_SE_MODE
 #define EPLD_BASE		0xb5000000	/* Phys 0x05000000 */
 #else
@@ -143,9 +141,3 @@ int checkboard (void)
 
 	return 0;
 }
-
-int do_reset (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
-{
-	stx7200_reset();
-	/*NOTREACHED*/ return (0);
-}
diff --git a/board/mb618/Makefile b/board/mb618/Makefile
new file mode 100644
index 0000000..ff0f69a
--- /dev/null
+++ b/board/mb618/Makefile
@@ -0,0 +1,44 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+AOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o sconsole.o nand.o
+
+OBJS	= $(COBJS) $(AOBJS)
+
+$(LIB):	.depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/mb618/config.mk b/board/mb618/config.mk
new file mode 100644
index 0000000..ed07dd4
--- /dev/null
+++ b/board/mb618/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2008 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB618 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x93F00000	29-bit mode (Traditional Mode)
+#	0x87F00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 127MB in P1 (cachable)
+TEXT_BASE = 0x93F00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/mb618/init-mb618.S b/board/mb618/init-mb618.S
new file mode 100644
index 0000000..7518a9c
--- /dev/null
+++ b/board/mb618/init-mb618.S
@@ -0,0 +1,404 @@
+#include "asm/stx7111reg.h"
+#include "../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb618.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+.balign 32
+
+
+__memory_setup_table:
+
+	/* ----- STx7111 Clocks ----- */
+
+	/* Clockgen A initial setup */
+
+	/* Set PLL0 clock to 450MHz */
+	/* PLL0 of clockgenA = PLL1600 */
+
+	/* Set CLOCKGENA PLL0 into BYPASS... */
+//QQQ	OR32(STX7111_CLOCKGENA_PLL0_CFG, 0x00100000)
+
+	/* Power down CLOCKGENA PLL0... */
+//QQQ	OR32(STX7111_CLOCKGENA_POWER_CFG, 0x00000001)
+
+	/* Configure CLOCKGENA PLL0... */
+	UPDATE32(STX7111_CLOCKGENA_PLL0_CFG, 0xfff80000, (0xf << 8) | (0x01 & 0x7))
+
+	/* Enable CLOCKGENA PLL0... */
+	UPDATE32(STX7111_CLOCKGENA_POWER_CFG, 0xfffffffe, 0)
+
+	/* Wait for CLOCKGENA PLL0 to lock... */
+	WHILE_NE32(STX7111_CLOCKGENA_PLL0_CFG, 0x80000000, 0x80000000)
+
+	/* Clear CLOCKGENA PLL0 from BYPASS... */
+//QQQ	UPDATE32(STX7111_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+
+	/* Set PLL1 clock to 800MHz */
+	/* PLL1 of clockgenA = PLL800 */
+
+	/* Set CLOCKGENA PLL1 into BYPASS... */
+//QQQ	OR32(STX7111_CLOCKGENA_PLL1_CFG, 0x00100000)
+
+	/* Power down CLOCKGENA PLL1... */
+//QQQ	OR32(STX7111_CLOCKGENA_POWER_CFG, 0x00000002)
+
+	/* Configure CLOCKGENA PLL1... */
+	UPDATE32(STX7111_CLOCKGENA_PLL1_CFG, 0xfff80000, (0x0 << 16) | (0x28 << 8) | (0x03))
+
+	/* Enable CLOCKGENA PLL1... */
+	UPDATE32(STX7111_CLOCKGENA_POWER_CFG, 0xfffffffd, 0)
+
+	/* Wait for CLOCKGENA PLL1 to lock... */
+	WHILE_NE32(STX7111_CLOCKGENA_PLL1_CFG, 0x80000000, 0x80000000)
+
+	/* Clear CLOCKGENA PLL1 from BYPASS... */
+//QQQ	UPDATE32(STX7111_CLOCKGENA_PLL1_CFG, 0xffefffff, 0)
+
+	/* Set dividers clocks */
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV0_CFG, 0x00000001)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV1_CFG, 0x00000001)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV2_CFG, 0x00000001)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV3_CFG, 0x00000103)
+	POKE32(STX7111_CLOCKGENA_PLL0LS_DIV4_CFG, 0x00010100)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV5_CFG, 0x00000307)
+	POKE32(STX7111_CLOCKGENA_PLL0LS_DIV6_CFG, 0x00010100)
+	POKE32(STX7111_CLOCKGENA_PLL0LS_DIV7_CFG, 0x00010100)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV8_CFG, 0x00000103)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV9_CFG, 0x00000103)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV10_CFG, 0x00000103)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV11_CFG, 0x00000103)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV12_CFG, 0x00000103)
+	POKE32(STX7111_CLOCKGENA_PLL0LS_DIV13_CFG, 0x00000811)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV14_CFG, 0x0000050B)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV15_CFG, 0x00000307)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV16_CFG, 0x00000103)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV17_CFG, 0x00000103)
+
+	/* Set clock sources */
+	POKE32(STX7111_CLOCKGENA_CLKOPSRC_SWITCH_CFG, 0xA6AA59AA)
+	POKE32(STX7111_CLOCKGENA_CLKOPSRC_SWITCH_CFG2, 0x0000000A)
+
+	/* Clockgen D (LMI) initial setup (lmi2xfreq = 540) */
+	/* Power down PLL... */
+	OR32(STX7111_SYSCONF_SYS_CFG11, 0x00001000)
+
+	/* Configure PLL... */
+	UPDATE32(STX7111_SYSCONF_SYS_CFG11, 0xfffff001, (0x01 << 9) | (0x12 << 1))
+
+	/* Enable CLOCKGENA PLL1... */
+	UPDATE32(STX7111_SYSCONF_SYS_CFG11, 0xffffefff, 0)
+
+	/* Wait for CLOCKGENA PLL1 to lock... (polarity inverted on lock bit) */
+	WHILE_NE32(STX7111_SYSCONF_SYS_STA03, 0x00000001, 0)
+
+
+	/* ----- STX7111 SysConf ----- */
+	/* PLI_CLOCK_ENABLE set to 0 */
+	OR32(STX7111_SYSCONF_SYS_CFG04, ~(1 << 2))
+
+	/* LMI sub-sys & pl exit from reset */
+	OR32(STX7111_SYSCONF_SYS_CFG11, (0x00000001 | 1 << 27))
+
+	/* Delay ~ 200 microseconds (assume 30MHz CPU clock) */
+	DELAY(200 * 30)
+
+	/* PLI_CLOCK_ENABLE set to 1 */
+	OR32(STX7111_SYSCONF_SYS_CFG04, (1 << 2))
+
+	/* Check both DLL on LMI0 are locked */
+	WHILE_NE32(STX7111_SYSCONF_SYS_STA03, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
+
+	/* Adjust proga, progb, zoutproga, and receiver mode for LMI0 */
+	POKE32(STX7111_SYSCONF_SYS_CFG12, (0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10)))
+
+	/* Enable AutoPrecharge */
+	POKE32(STX7111_SYSCONF_SYS_CFG38, 0x000FFE0C)
+
+	/* Force DLL1 and DLL2 command of LMI0 */
+	POKE32(STX7111_SYSCONF_SYS_CFG13, 0x00000000)
+	POKE32(STX7111_SYSCONF_SYS_CFG14, 0x00000000)
+
+	/* Set cfg55 */
+#ifndef LMI_16BITS_MODE
+#define LMI_16BITS_MODE 0
+#endif
+	POKE32(STX7111_SYSCONF_SYS_CFG55, 0x03fc2004 | (LMI_16BITS_MODE << 10) | ((0x7 & 0x7) << 7))
+
+	/* PDL offsets */
+	POKE32(STX7111_SYSCONF_SYS_CFG42, 0x07D7EBF5)
+	POKE32(STX7111_SYSCONF_SYS_CFG43, 0x000001F5)
+
+	/* ----- STX7111 EMI configuration ----- */
+
+//#define APRIL_2008_FILES	/* Define if using targetpacks from April'08 vintage */
+#ifdef APRIL_2008_FILES
+
+	POKE32(ST40_EMI_BANK_ENABLE, 0x00000005)
+
+	/* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
+	POKE32(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE32(ST40_EMI_BANK1_BASEADDRESS, 0x00000010)
+	POKE32(ST40_EMI_BANK2_BASEADDRESS, 0x00000012)
+	POKE32(ST40_EMI_BANK3_BASEADDRESS, 0x00000014)
+	POKE32(ST40_EMI_BANK4_BASEADDRESS, 0x0000001C)
+
+	/* Bank 0 - On-board 32MBytes Flash at address 0x00000000 -> 0x01ffffff */
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+
+	/* Bank 1 - STEM 8 MBytes 0x04000000 -> 0x047fffff */
+	POKE32(ST40_EMI_BANK1_EMICONFIGDATA0, 0x002016d1)
+	POKE32(ST40_EMI_BANK1_EMICONFIGDATA1, 0x9d222200)
+	POKE32(ST40_EMI_BANK1_EMICONFIGDATA2, 0x9d220044)
+	POKE32(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000)
+
+	/* Bank 2 - DVB-CI at address 0x04000000 -> 0x04FFFFFF */
+	POKE32(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
+	POKE32(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
+	POKE32(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
+	POKE32(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+
+	/* Bank 3 - 32MB Boards register and either DVBCI notCe2 or
+		STEM notCS1 (16MB + 16MB split bank) 0x05000000 -> 0x06ffffff
+	 */
+	POKE32(ST40_EMI_BANK3_EMICONFIGDATA0, 0x002016d1)
+	POKE32(ST40_EMI_BANK3_EMICONFIGDATA1, 0x9d222200)
+	POKE32(ST40_EMI_BANK3_EMICONFIGDATA2, 0x9d220044)
+	POKE32(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
+
+	/* Bank 4 - EPLD Registers at address 0x07000000 -> 0x07FFFFFF */
+	POKE32(ST40_EMI_BANK4_EMICONFIGDATA0, 0x002016d1)
+	POKE32(ST40_EMI_BANK4_EMICONFIGDATA1, 0x9d222200)
+	POKE32(ST40_EMI_BANK4_EMICONFIGDATA2, 0x9d220044)
+	POKE32(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)
+
+	/* Program other EMI registers */
+	POKE32(ST40_EMI_GENCFG, 0x00000010)
+
+#else	/* else, pre- APRIL_2008_FILES */
+
+	POKE32(ST40_EMI_BANK_ENABLE, 0x00000005)
+
+	/* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
+	POKE32(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE32(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
+	POKE32(ST40_EMI_BANK2_BASEADDRESS, 0x0000000c)
+	POKE32(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
+	POKE32(ST40_EMI_BANK4_BASEADDRESS, 0x00000012)
+
+	/* Bank 0 - On-board 32MBytes Flash at address 0x00000000 -> 0x01ffffff */
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+
+	/* Bank 1 - Not configured */
+
+	/* Bank 2 - 16MB DVB-CI at address 0x03000000 -> 0x03FFFFFF */
+	POKE32(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
+	POKE32(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
+	POKE32(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
+	POKE32(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+
+	/* Bank 3 - EPLD Registers at address 0x04000000 -> 0x04FFFFFF */
+	POKE32(ST40_EMI_BANK3_EMICONFIGDATA0, 0x002016d1)
+	POKE32(ST40_EMI_BANK3_EMICONFIGDATA1, 0x9d222200)
+	POKE32(ST40_EMI_BANK3_EMICONFIGDATA2, 0x9d220044)
+	POKE32(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
+
+	/* Bank 4 - 8MB STEM at address 0x04800000 -> 0x04ffffff */
+	POKE32(ST40_EMI_BANK4_EMICONFIGDATA0, 0x002016d1)
+	POKE32(ST40_EMI_BANK4_EMICONFIGDATA1, 0x9d222200)
+	POKE32(ST40_EMI_BANK4_EMICONFIGDATA2, 0x9d220044)
+	POKE32(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)
+
+	/* Program other EMI registers */
+	POKE32(ST40_EMI_GENCFG, 0x00000000)
+#endif	/* APRIL_2008_FILES */
+
+	/* ----- STX7111 LMI0 configuration ----- */
+
+	/* Configuring LMI0 for DDR2 SDRAM Elpida EDE5116AHBG-8E-E
+	 # Refresh interval compute (from Ignazio, 11jan08)
+	 # 300 MHz --->  T=3.4ns => MIM[28:16]=2038 ((2294-256)+ACo-3.4ns<+AH4-7.8us)
+	 # 330 MHz --->  T=3.1ns => MIM[28:16]=2260 ((2516-256)+ACo-3.1ns<+AH4-7.8us)
+	 # 360 MHz --->  T=2.8ns => MIM[28:16]=2529 ((2785-256)+ACo-2.8ns<+AH4-7.8us)
+	 # 400 MHz --->  T=2.5ns => MIM[28:16]=2864 ((3120-256)+ACo-2.5ns=7.8us)
+	 */
+#if LMI_16BITS_MODE == 0
+	POKE32(ST40_LMI_MIM_0(), (2038 << 16) | 0x0000017b)
+#else
+	POKE32(ST40_LMI_MIM_0(), (2038 << 16) | 0x0000013b)
+#endif
+	/* Note: refresh is enabled in later steps */
+
+	POKE32(ST40_LMI_MIM_1(), 0xffff0000)
+
+	/* SDRAM Timing Register
+	 # lmi.LMI_STR_0.poke(0x4c2db41b)
+	 # FCh, 19/mar/08: change according to Raffaele G feebacks
+	 #		1-cycle additional delay between RD and WR
+	 */
+	POKE32(ST40_LMI_STR_0(), 0xcc2db41b)
+	POKE32(ST40_LMI_STR_1(), 0x002202d6)
+
+	/* SDRAM Array Attribute Register
+	 # Upper LMI addr=0x0C000000 + 128Mbytes=0x14000000, 13x10
+	 */
+#if LMI_16BITS_MODE == 0
+	POKE32(ST40_LMI_SDRA0_0(), 0x14000a20)
+#else
+	POKE32(ST40_LMI_SDRA0_0(), 0x10000a20)
+#endif
+
+	/* SDRAM Array Attribute Register
+	 # Upper LMI addr=0x0C000000 + 128Mbytes=0x14000000, 13x10
+	 */
+#if LMI_16BITS_MODE == 0
+	POKE32(ST40_LMI_SDRA1_0(), 0x14000a20)
+#else
+	POKE32(ST40_LMI_SDRA1_0(), 0x10000a20)
+#endif
+
+	/* SDRAM Control Register */
+	/* Delay ~ 200 milliseconds (assume 450MHz CPU clock) */
+	DELAY(200000 * 450)
+
+	/* Enable clock with NOP command */
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020023)
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+
+	/* Precharge all */
+	POKE32(ST40_LMI_SCR_0(), 0x00020022)
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+
+	/* Issue EMRS2 */
+	POKE32(ST40_LMI_SDMR0(), 0x00010000)
+
+	/* Issue EMRS3 */
+	POKE32(ST40_LMI_SDMR0(), 0x00018000)
+
+	/* Issue EMRS1 to enable DLL */
+	POKE32(ST40_LMI_SDMR0(), 0x00008004)
+
+	/* Issue MRS with DLL reset, CAS 5, Write recovery 5, Sequentiel, Burst lengh 8
+	 # lmi.LMI_SDMR0_0.poke(0x00000953)
+	 # FCh, 19/mar/08: change according to Raffaele G feebacks
+	 */
+	POKE32(ST40_LMI_SDMR0(), 0x00000b53)
+
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+
+	/* Precharge all */
+	POKE32(ST40_LMI_SCR_0(), 0x00020022)
+	/* 2 CBR (auto refresh) */
+	POKE32(ST40_LMI_SCR_0(), 0x00020024)
+	POKE32(ST40_LMI_SCR_0(), 0x00020024)
+
+	/* Issue MRS with CAS 5, Write recovery 5, Sequentiel, Burst lengh 8
+	 # lmi.LMI_SDMR0_0.poke(0x00000853)
+	 # FCh, 19/mar/08: change according to Raffaele G feebacks
+	 */
+	POKE32(ST40_LMI_SDMR0(), 0x00000a53)
+
+	/* Issue EMRS1 for OCD calibration default */
+	/* lmi.LMI_SDMR0_0.poke(0x000007c4) */
+
+	/* Issue EMRS1 for OCD calibration exit */
+	/* lmi.LMI_SDMR0_0.poke(0x00000444) */
+
+	/* Enable auto refresh
+	 # lmi.LMI_MIM_0.poke(0x0c30037b)
+	 # FCh, 12/feb/08: cleaner to modify only refresh bit
+	 */
+	OR32(ST40_LMI_MIM_0(), (1 << 9))
+
+	/* DQS recovery mechanism (1=enabled)
+	 # lmi.LMI_MIM_0.poke(lmi.LMI_MIM_0.peek() | (1 << 5))
+	 # FCh, 14/jan/08, NO DQS recovery
+	 */
+	UPDATE32(ST40_LMI_MIM_0(), ~(1 << 5), 0)
+
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+
+	POKE32(ST40_LMI_GCC_0(), 0x00000000)
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE_LONG(STX7111_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	UPDATE_LONG(STX7111_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+	POKE_LONG(ST40_LMI_SDRA0_0(), 0x48000a00)
+	POKE_LONG(ST40_LMI_SDRA1_0(), 0x48000a00)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/mb618/mb618.c b/board/mb618/mb618.c
new file mode 100644
index 0000000..919de04
--- /dev/null
+++ b/board/mb618/mb618.c
@@ -0,0 +1,179 @@
+/*
+ * (C) Copyright 2008 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stx7111reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+#define PIO_BASE  0xfd020000	/* Base of PIO block in COMMs block */
+
+#ifdef CONFIG_SH_SE_MODE
+#define EPLD_BASE		0xb4000000	/* Phys 0x04000000 */
+#else
+#define EPLD_BASE		0xa4000000
+#endif	/* CONFIG_SH_SE_MODE */
+
+static inline void epld_write(unsigned long value, unsigned long offset)
+{
+	/* 8-bit write to EPLD registers */
+	writeb(value, EPLD_BASE + offset);
+}
+
+static inline unsigned long epld_read(unsigned long offset)
+{
+	/* 8-bit read from EPLD registers */
+	return readb(EPLD_BASE + offset);
+}
+
+void flashWriteEnable(void)
+{
+	/* Enable Vpp for writing to flash */
+	STPIO_SET_PIN(PIO_PORT(3), 4, 1);
+}
+
+void flashWriteDisable(void)
+{
+	/* Disable Vpp for writing to flash */
+	STPIO_SET_PIN(PIO_PORT(3), 4, 0);
+}
+
+static void configPIO(void)
+{
+	/* Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
+	SET_PIO_ASC(PIO_PORT(5), 0, 1, 2, 3);  /* UART3 - AS1 */
+
+	/* Setup up Vpp for NOR FLASH */
+	SET_PIO_PIN(PIO_PORT(3), 4, STPIO_OUT);
+}
+
+extern int board_init(void)
+{
+	configPIO();
+
+	return 0;
+}
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+static void mb618_phy_reset05(void)
+{
+	/* Bring the PHY out of reset in MII mode */
+	epld_write(0x4 | 0, 0);
+	epld_write(0x4 | 1, 0);
+}
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+/*
+ * We have several EPLD versions to cope with, with slightly different memory
+ * maps and features:
+ *
+ * version 04:
+ * off  read        reset
+ *  0   Status      undef  (unused)
+ *  4   Ctrl        20     (unused)
+ *  8   Test        33
+ *  c   Ident       0      (should be 1 but broken)
+ * (note writes are broken)
+ *
+ * version 05:
+ * off  read     write       reset
+ *  0   Ident    Ctrl        45
+ *  4   Test     Test        55
+ *  8   IntStat  IntMaskSet  -
+ *  c   IntMask  IntMaskClr  0
+ */
+static int mb618_init_epld(void)
+{
+	unsigned char epld_reg;
+	int test_offset = -1;
+	int version_offset = -1;
+	int version = -1;
+
+	epld_reg = epld_read(0x4);
+	switch (epld_reg) {
+	case 0x20:
+		/*
+		 * Probably the Ctrl reg of a 04 EPLD. Look for the default
+		 * value in the test reg (we can't do a test as it is broken).
+		 */
+		epld_reg = epld_read(0x8);
+		if (epld_reg == 0x33)
+			version = 4;
+		break;
+	case 0x55:
+		/* Probably the Test reg of the 05 or later EPLD */
+		test_offset = 4;
+		version_offset = 0;
+		break;
+	}
+
+	if (test_offset > 0) {
+		epld_write(0x63, test_offset);
+		epld_reg = epld_read(test_offset);
+		if (epld_reg != (unsigned char)(~0x63)) {
+			printf("Failed mb618 EPLD test (off %02x, res %02x)\n",
+			       test_offset, epld_reg);
+			return 1;
+		}
+
+		/* Assume we can trust the version register */
+		version = epld_read(version_offset) & 0xf;
+	}
+
+	if (version < 0) {
+		printf("Unable to determine mb618 EPLD version\n");
+		return 1;
+	}
+
+	printf("mb618 EPLD version %02d\n", version);
+
+	switch (version) {
+	case 5:
+		/* We need to control the PHY reset in software */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+		mb618_phy_reset05();
+#endif
+		break;
+	}
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STx7111-Mboard (MB618)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	/*
+	 * initialize the EPLD.
+	 */
+	return mb618_init_epld();
+}
diff --git a/board/mb618/nand.c b/board/mb618/nand.c
new file mode 100644
index 0000000..6196ba0
--- /dev/null
+++ b/board/mb618/nand.c
@@ -0,0 +1,93 @@
+/*
+ * (C) Copyright 2006 DENX Software Engineering
+ * (C) Copyright 2008 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+
+#if defined(CONFIG_CMD_NAND)
+
+#include <nand.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stx7111reg.h>
+
+
+/*
+ * hardware specific access to control-lines
+ *	CL -> Emi_Addr(17)
+ *	AL -> Emi_Addr(18)
+ *	nCE is handled by EMI (not s/w controlable)
+ */
+static void mb618_hwcontrol(struct mtd_info *mtdinfo, int cmd)
+{
+	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
+
+	switch(cmd) {
+
+	case NAND_CTL_SETCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 17));
+		break;
+
+	case NAND_CTL_CLRCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 17));
+		break;
+
+	case NAND_CTL_SETALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 18));
+		break;
+
+	case NAND_CTL_CLRALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 18));
+		break;
+	}
+}
+
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+extern int board_nand_init(struct nand_chip *nand)
+{
+	nand->hwcontrol = mb618_hwcontrol;
+	nand->eccmode = NAND_ECC_SOFT;
+	nand->chip_delay = 25;
+	nand->options = NAND_NO_AUTOINCR;
+	return 0;
+}
+#endif	/* CONFIG_CMD_NAND */
+
diff --git a/board/mb618/sconsole.c b/board/mb618/sconsole.c
new file mode 100644
index 0000000..af92525
--- /dev/null
+++ b/board/mb618/sconsole.c
@@ -0,0 +1,129 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+
+#include "sconsole.h"
+
+#if 0
+void (*sconsole_putc) (char) = 0;
+void (*sconsole_puts) (const char *) = 0;
+int (*sconsole_getc) (void) = 0;
+int (*sconsole_tstc) (void) = 0;
+void (*sconsole_setbrg) (void) = 0;
+#endif
+
+#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
+int serial_init (void)
+{
+	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+	sb->pos = 0;
+	sb->size = 0;
+	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
+
+	return (0);
+}
+
+void serial_putc (char c)
+{
+	if (sconsole_putc) {
+		(*sconsole_putc) (c);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		if (c) {
+			sb->data[sb->pos++] = c;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+void serial_puts (const char *s)
+{
+	if (sconsole_puts) {
+		(*sconsole_puts) (s);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		while (*s) {
+			sb->data[sb->pos++] = *s++;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+int serial_getc (void)
+{
+	if (sconsole_getc) {
+		return (*sconsole_getc) ();
+	} else {
+		return 0;
+	}
+}
+
+int serial_tstc (void)
+{
+	if (sconsole_tstc) {
+		return (*sconsole_tstc) ();
+	} else {
+		return 0;
+	}
+}
+
+void serial_setbrg (void)
+{
+	if (sconsole_setbrg) {
+		(*sconsole_setbrg) ();
+	}
+}
+
+void sconsole_flush (void)
+{
+	if (sconsole_putc) {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+		unsigned int end = sb->pos < sb->size
+			? sb->pos + sb->max_size - sb->size
+			: sb->pos - sb->size;
+
+		while (sb->size) {
+			(*sconsole_putc) (sb->data[end++]);
+			if (end == sb->max_size) {
+				end = 0;
+			}
+			sb->size--;
+		}
+	}
+}
+#endif
diff --git a/board/mb618/sconsole.h b/board/mb618/sconsole.h
new file mode 100644
index 0000000..1666f21
--- /dev/null
+++ b/board/mb618/sconsole.h
@@ -0,0 +1,47 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SCONSOLE_H_
+#define _SCONSOLE_H_
+
+#include <config.h>
+
+typedef struct sconsole_buffer_s
+{
+	unsigned long size;
+	unsigned long max_size;
+	unsigned long pos;
+	char data[1];
+} sconsole_buffer_t;
+
+#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
+
+extern void (*sconsole_putc) (char);
+extern void (*sconsole_puts) (const char *);
+extern int (*sconsole_getc) (void);
+extern int (*sconsole_tstc) (void);
+extern void (*sconsole_setbrg) (void);
+
+extern void sconsole_flush (void);
+
+#endif
diff --git a/board/mb618/u-boot.lds b/board/mb618/u-boot.lds
new file mode 100644
index 0000000..3a1e91b
--- /dev/null
+++ b/board/mb618/u-boot.lds
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2007 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(sh4)
+ENTRY(_start)
+
+SECTIONS
+{
+	.text ALIGN(0x4):
+	{
+		__text_start = .;
+		cpu/sh/start.o (.text)
+		*(.text)
+		__text_end = .;
+	}
+
+	.rodata ALIGN(0x4):
+	{
+		__rodata_start = .;
+		*(.rodata)
+		__rodata_end = .;
+	}
+
+	.data ALIGN(0x4):
+	{
+		__data_start = .;
+		*(.data)
+		__data_end = .;
+	}
+
+	.u_boot_cmd ALIGN(0x4):
+	{
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	_uboot_end_data = .;
+
+	.bss ALIGN(0x4):
+	{
+		__bss_start = .;
+		*(.bss)
+		__bss_end = .;
+	}
+	_uboot_end = .;
+}
diff --git a/common/cmd_bdinfo.c b/common/cmd_bdinfo.c
index 228ebfc..2de20c2 100644
--- a/common/cmd_bdinfo.c
+++ b/common/cmd_bdinfo.c
@@ -275,6 +275,8 @@ int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 
 #if defined(CONFIG_SH_STB7100)
 #include <asm/stb7100reg.h>
+#elif defined(CONFIG_SH_STX7111)
+#include <asm/stx7111reg.h>
 #elif defined(CONFIG_SH_STX7200)
 #include <asm/stx7200reg.h>
 #else
@@ -320,6 +322,13 @@ int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	printf ("EMI       = %3d MHz\n", bd->bi_emifrq);
 	printf ("LMI       = %3d MHz\n", bd->bi_lmifrq);
 #endif
+#ifdef CONFIG_SH_STX7111
+	if (STX7111_DEVICEID_7111(bd->bi_devid))
+		printf("\nSTx7111 version %ld.x\n", STX7111_DEVICEID_CUT(bd->bi_devid));
+	else
+		printf("\nUnknown device\n");
+	printf ("EMI       = %3d MHz\n", bd->bi_emifrq);
+#endif
 #ifdef CONFIG_SH_STX7200
 	if (STX7200_DEVICEID_7200(bd->bi_devid))
 		printf("\nSTx7200 version %ld.x\n", STX7200_DEVICEID_CUT(bd->bi_devid));
diff --git a/common/cmd_mem.c b/common/cmd_mem.c
index a994211..1953be1 100644
--- a/common/cmd_mem.c
+++ b/common/cmd_mem.c
@@ -710,8 +710,8 @@ int do_mem_mtest (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 		pattern = 0;
 	}
 
-#if defined(CFG_ALT_MEMTEST)
 	printf ("Testing %08x ... %08x:\n", (uint)start, (uint)end);
+#if defined(CFG_ALT_MEMTEST)
 	PRINTF("%s:%d: start 0x%p end 0x%p\n",
 		__FUNCTION__, __LINE__, start, end);
 
diff --git a/cpu/sh/start.S b/cpu/sh/start.S
index 6907056..11e370b 100644
--- a/cpu/sh/start.S
+++ b/cpu/sh/start.S
@@ -1,7 +1,8 @@
 /*
- * (C) Copyright 2004 STMicroelectronics.
+ * (C) Copyright 2004-2008 STMicroelectronics.
  *
  * Andy Sturges <andy.sturges@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -30,6 +31,8 @@
 
 #if defined(CONFIG_SH_STB7100)
 #include <asm/stb7100reg.h>
+#elif defined(CONFIG_SH_STX7111)
+#include <asm/stx7111reg.h>
 #elif defined(CONFIG_SH_STX7200)
 #include <asm/stx7200reg.h>
 #else
@@ -51,14 +54,14 @@ _start:
 	/* disable the watchdog timer */
 	MOV_CONST32_R0 ST40_CPG_WTCSR
 	mov	r0, r1
-	MOV_CONST16_R0 0xA500
+	MOV_CONST16_R0 0xA500	/* WTCSR.TME=0 */
 	mov.w   r0, @r1
 
 	/*
 	 * Determine if we are in the correct location ? (i.e. RAM)
 	 *  r8 == 1 in RAM, assume initialization already done by GDB.
 	 *  r8 == 0 in FLASH, need to relocate, set up memory, etc...
-	 *  r9 == where we actualy ARE       (PIC relocate source).
+	 *  r9 == where we actually ARE      (PIC relocate source).
 	 * r10 == were we WANT to be [BEGIN] (PIC relocate target).
 	 * r11 == were we WANT to be [END]   (PIC relocate target).
 	 *
@@ -69,7 +72,7 @@ _start:
 	MOV_CONST32_R0 0x1fffffff	/* set up P0 mask  */
 	mov	r0, r4
 	mova	_start_offset, r0	/* Load source address in r9 */
-	mov	r0, r9			/* i.e. where we actualy ARE */
+	mov	r0, r9			/* i.e. where we actually ARE */
 	mov.l	@r9, r10
 	sub	r10, r9
 #ifndef CONFIG_SH_SE_MODE
@@ -112,23 +115,34 @@ _start:
 #if defined(CONFIG_SH_STB7100)
 	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI-Sys UN-cached */
 	SH4_SET_PMB 1 0x90 0x40 128 0 0 1	/* LMI-Sys UN-cached */
-	SH4_SET_PMB 2 0xa0 0x00  16 0 0 1	/* FLASH   UN-cached */
-	SH4_SET_PMB 3 0xb2 0x02  16 0 0 1	/* OFF-chip  Peripherals UN-cached */
-	SH4_SET_PMB 4 0xb8 0x18  64 0 0 1	/* ON-chip   Peripherals UN-cached */
-	SH4_SET_PMB 5 0xbc 0x1c  64 0 0 1	/* ST40 core Peripherals UN-cached */
+	SH4_SET_PMB 2 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 3 0xa8 0x00  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 4 0xb2 0x02  16 0 0 1	/* OFF-chip  Peripherals UN-cached */
+	SH4_SET_PMB 5 0xb8 0x18  64 0 0 1	/* ON-chip   Peripherals UN-cached */
+	SH4_SET_PMB 6 0xbc 0x1c  64 0 0 1	/* ST40 core Peripherals UN-cached */
 #elif defined(CONFIG_SH_STX7200)
 	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 UN-cached */
 	SH4_SET_PMB 1 0x90 0x40 128 0 0 1	/* LMI0 UN-cached */
 	SH4_SET_PMB 2 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
 	SH4_SET_PMB 3 0xa1 0x01  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 4 0xa8 0x00  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 5 0xa9 0x01  16		/* NOR FLASH CACHED */
 #if defined(CONFIG_SH_MB519)			/* MB519 */
-	SH4_SET_PMB 4 0xb5 0x05  16 0 0 1	/* EPLD UN-cached */
+	SH4_SET_PMB 6 0xb5 0x05  16 0 0 1	/* EPLD UN-cached */
 #elif defined(CONFIG_SH_CB101)			/* CB101 */
-	SH4_SET_PMB 4 0xa2 0x02  16 0 0 1	/* NAND FLASH UN-cached */
-	SH4_SET_PMB 5 0xa3 0x03  16 0 0 1	/* NAND FLASH UN-cached */
+	SH4_SET_PMB 6 0xa2 0x02  16 0 0 1	/* NAND FLASH UN-cached */
+	SH4_SET_PMB 7 0xa3 0x03  16 0 0 1	/* NAND FLASH UN-cached */
 #else
 	#error Do not know which board we are using for PMB setup.
 #endif	/* defined(CONFIG_SH_MBxxx) */
+#elif defined(CONFIG_SH_STX7111) && defined(CONFIG_SH_MB618)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI UN-cached */
+	SH4_SET_PMB 1 0x90 0x40 128 0 0 1	/* LMI UN-cached */
+	SH4_SET_PMB 2 0xa0 0x00  16 0 0 1	/* NOR/NAND FLASH UN-cached */
+	SH4_SET_PMB 3 0xa1 0x01  16 0 0 1	/* NOR/NAND FLASH UN-cached */
+	SH4_SET_PMB 4 0xa8 0x00  16		/* NOR/NAND FLASH CACHED */
+	SH4_SET_PMB 5 0xa9 0x01  16		/* NOR/NAND FLASH CACHED */
+	SH4_SET_PMB 6 0xb4 0x04  16 0 0 1	/* EPLD UN-cached */
 #else
 	#error Do not know which chip we are using for PMB setup.
 #endif	/* defined(CONFIG_SH_STxxx) */
@@ -161,19 +175,31 @@ _start:
 	 * enable SE (32-bit) mode, if we need to.
 	 */
 #ifdef CONFIG_SH_SE_MODE
-	/* enable SE mode */
-	/* QQQ: for SH4-300, we will need different code here!  */
+#ifdef CONFIG_CPU_SUBTYPE_SH4_2XX	/* it is an SH4-200 */
+	/* enable SE mode & invalidate the UTLB/ITLB */
 	MOV_CONST32_R0 SH4_CCN_MMUCR
 	mov	#(SH4_MMUCR_TI|SH4_MMUCR_SE), r1
-	mov.l	r1, @r0
-	nop
-	nop
-	nop
-	nop
-	nop
-	nop
-	nop
-	nop
+	mov.l	r1, @r0			/* MMUCR.TI = MMUCR.SE = 1 */
+#else					/* it is an SH4-300 */
+	/* invalidate the UTLB/ITLB, first. */
+	MOV_CONST32_R0 SH4_CCN_MMUCR
+	mov	#(SH4_MMUCR_TI), r1
+	mov.l	r1, @r0			/* MMUCR.TI = 1 */
+	/* then, enable SE mode */
+	MOV_CONST32_R0 SH4_PASCR_SE
+	mov	r0, r1
+	MOV_CONST32_R0 SH4_CCN_PASCR
+	mov.l	r1, @r0			/* PASCR.SE = 1 */
+#endif	/* CONFIG_CPU_SUBTYPE_SH4_2XX */
+	/* ensure MMU coherency, by issuing an RTE instruction */
+	/* this idiom works for all SH4-x00 series cores */
+	mova	relocate, r0
+	ldc	r0, spc		/* SPC = address of relocate */
+	stc	sr, r0
+	ldc	r0, ssr		/* SSR = SR */
+	rte			/* do it */
+	  nop
+.balign 4
 #endif	/* CONFIG_SH_SE_MODE */
 
 	/*
@@ -182,7 +208,7 @@ _start:
 relocate:
 	mov	#0x1f, r0
 	not	r0, r0			/* mask = 0xffffffe0 */
-	mov	r9, r1			/* where we actualy ARE */
+	mov	r9, r1			/* where we actually ARE */
 	and	r0, r1			/* ensure source is 32-byte cache aligned */
 	mov	r10, r2			/* were we WANT to be: START off */
 	and	r0, r2			/* ensure destination is 32-byte cache aligned */
@@ -205,13 +231,13 @@ relocate:
 	mov.l	r0, @(28,r2)
 	ocbp	@r2			/* flush one line */
 	add	#32, r1			/* next line */
-	pref	@r1			/* pre-featch next line */
+	pref	@r1			/* pre-fetch next line */
 	add	#32, r2			/* next line */
 	cmp/hi	r2, r3			/* while (r2<=r3) ... */
 	bt	1b
 
 	/*
-	 * now jump to absolute (non-PIC) address environent.
+	 * now jump to absolute (non-PIC) address environment.
 	 */
 	mov.l	hyperspace_addr, r1
 	jmp	@r1		/* never returns */
@@ -222,7 +248,7 @@ hyperspace:
 	/*
 	 * At this point:
 	 *	We can stop using PIC, and use absolute code.
-	 *	The EMI/LMI initialization has been complated.
+	 *	The EMI/LMI initialization has been completed.
 	 */
 
 #ifdef CONFIG_SH_SE_MODE
diff --git a/cpu/sh/stb7100/stb7100.c b/cpu/sh/stb7100/stb7100.c
index 7891c5c..8407357 100644
--- a/cpu/sh/stb7100/stb7100.c
+++ b/cpu/sh/stb7100/stb7100.c
@@ -149,15 +149,6 @@ int soc_init(void)
   return 0;
 }
 
-void stb7100_reset(void)
-{
-	ulong sr;
-	asm ("stc sr, %0":"=r" (sr));
-	sr |= (1 << 28);	/* set block bit */
-	asm ("ldc %0, sr": :"r" (sr));
-	asm volatile ("trapa #0");
-}
-
 #if defined(CONFIG_SH_STB7100_SATA)
 
 #define SATA_AHB2STBUS_BASE			0xB9209000
diff --git a/cpu/sh/stx7111/Makefile b/cpu/sh/stx7111/Makefile
new file mode 100644
index 0000000..8a78032
--- /dev/null
+++ b/cpu/sh/stx7111/Makefile
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2008 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(SOC).a
+
+OBJS	= stx7111.o
+SOBJS	=
+
+all:	.depend $(LIB)
+
+$(LIB):	$(SOBJS) $(OBJS)
+	$(AR) crv $@ $(SOBJS) $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/cpu/sh/stx7111/stx7111.c b/cpu/sh/stx7111/stx7111.c
new file mode 100644
index 0000000..eb746f2
--- /dev/null
+++ b/cpu/sh/stx7111/stx7111.c
@@ -0,0 +1,190 @@
+/*
+ * (C) Copyright 2008 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stx7111reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stbus.h>
+#include <ata.h>
+
+#define PIO_BASE  ST40_PIO0_REGS_BASE
+
+static void stx7111_clocks(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	/*
+	 * FIXME
+	 * Gross hack to get the serial port working.
+	 * See the defintion of PCLK in drivers/stm-asc.c
+	 * for where this is used.
+	 */
+	bd->bi_emifrq = 100;
+}
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+
+#define ETHERNET_INTERFACE_ON	(1ul<<16)
+#define PHY_CLK_EXT		(1ul<<19)
+#define MAC_SPEED_SEL           (1ul<<20)
+#define PHY_INTF_SEL_MASK	(0x7ul<<24)
+#define ENMII			(1ul<<27)
+
+/* Remaining bits define pad functions, default appears to work */
+
+int stmac_default_pbl(void)
+{
+	return 32;
+}
+
+#ifdef CONFIG_STMAC_STE101P_RMII	/* QQQ */
+void stx7111_mac_speed(int speed)
+{
+	unsigned long sysconf = *STX7111_SYSCONF_SYS_CFG07;
+
+	/* MAC_SPEED_SEL = 0|1 */
+	if (speed == 100)
+		sysconf |= MAC_SPEED_SEL;
+	else if (speed == 10)
+		sysconf &= ~MAC_SPEED_SEL;
+
+	*STX7111_SYSCONF_SYS_CFG07 = sysconf;
+}
+#endif	/* CONFIG_STMAC_STE101P_RMII */
+
+/* ETH MAC pad configuration */
+static void stmac_eth_hw_setup(void)
+{
+	const unsigned long en_mii  = 1;
+	const unsigned long sel     = 0;
+	const unsigned long ext_clk = 0;
+
+	unsigned long sysconf = *STX7111_SYSCONF_SYS_CFG07;
+
+	/* Ethernet ON */
+	sysconf |= ETHERNET_INTERFACE_ON;
+
+	/* PHY EXT CLOCK: 0: provided by STX7111; 1: external */
+	if (ext_clk)
+		sysconf |= PHY_CLK_EXT;
+	else
+		sysconf &= ~PHY_CLK_EXT;
+
+	/* Default GMII/MII slection */
+	sysconf &= ~PHY_INTF_SEL_MASK;
+	sysconf |= ((sel<<24) & PHY_INTF_SEL_MASK);
+
+	/* MII mode */
+	if (en_mii)
+		sysconf |= ENMII;
+	else
+		sysconf &= ~ENMII;
+
+	*STX7111_SYSCONF_SYS_CFG07 = sysconf;
+}
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+int soc_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	stx7111_clocks();
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+	stmac_eth_hw_setup();
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+	bd->bi_devid = *STX7111_SYSCONF_DEVICEID_0;
+
+	/*  Make sure reset period is shorter than WDT timeout */
+	*STX7111_SYSCONF_SYS_CFG09 = (*STX7111_SYSCONF_SYS_CFG09 & 0xFF000000) | 0x000A8C;
+
+	return 0;
+}
+
+
+#if defined(CONFIG_USB_OHCI_NEW)
+extern void stx7111_usb_init(void)
+{
+	unsigned long reg, req_reg;
+
+	/* Power on the USB */
+	reg = readl(STX7111_SYSCONF_SYS_CFG32);
+	reg &= ~(1ul<<4); /* USB_POWER_DOWN_REQ = 0 */
+	writel(reg, STX7111_SYSCONF_SYS_CFG32);
+
+	/* Work around for USB over-current detection chip being
+	 * active low, and the 7111 being active high.
+	 * Note this is an undocumented bit, which apparently enables
+	 * an inverter on the overcurrent signal.
+	 */
+	reg = readl(STX7111_SYSCONF_SYS_CFG06);
+	reg |= 1ul<<29;
+	writel(reg, STX7111_SYSCONF_SYS_CFG06);
+
+	/* USB oc */
+	SET_PIO_PIN(PIO_PORT(5), 6, STPIO_IN);
+	/* USB power */
+	SET_PIO_PIN(PIO_PORT(5), 7, STPIO_ALT_OUT);
+	STPIO_SET_PIN(PIO_PORT(5), 7, 1);
+
+	/* Set strap mode */
+#define STRAP_MODE	AHB2STBUS_STRAP_16_BIT
+	reg = readl(AHB2STBUS_STRAP);
+#if STRAP_MODE == 0
+	reg &= ~AHB2STBUS_STRAP_16_BIT;
+#else
+	reg |= STRAP_MODE;
+#endif
+	writel(reg, AHB2STBUS_STRAP);
+
+	/* Start PLL */
+	reg = readl(AHB2STBUS_STRAP);
+	writel(reg | AHB2STBUS_STRAP_PLL, AHB2STBUS_STRAP);
+	udelay(100000);	/* QQQ: can this delay be shorter ? */
+	writel(reg & (~AHB2STBUS_STRAP_PLL), AHB2STBUS_STRAP);
+	udelay(100000);	/* QQQ: can this delay be shorter ? */
+
+	req_reg =
+		(1<<21) |  /* Turn on read-ahead */
+		(5<<16) |  /* Opcode is store/load 32 */
+		(0<<15) |  /* Turn off write posting */
+		(1<<14) |  /* Enable threshold */
+		(3<<9)  |  /* 2**3 Packets in a chunk */
+		(0<<4)  |  /* No messages */
+		(8<<0);    /* Threshold is 256 */
+
+	do {
+		writel(req_reg, AHB2STBUS_STBUS_CONFIG);
+		reg = readl(AHB2STBUS_STBUS_CONFIG);
+	} while ((reg & 0x7FFFFFFF) != req_reg);
+}
+
+#endif /* defined(CONFIG_USB_OHCI_NEW) */
+
diff --git a/cpu/sh/stx7200/stx7200.c b/cpu/sh/stx7200/stx7200.c
index 0912ecf..44dffc5 100644
--- a/cpu/sh/stx7200/stx7200.c
+++ b/cpu/sh/stx7200/stx7200.c
@@ -124,15 +124,6 @@ int soc_init(void)
 	return 0;
 }
 
-void stx7200_reset(void)
-{
-	ulong sr;
-	asm ("stc sr, %0":"=r" (sr));
-	sr |= (1 << 28);	/* set block bit */
-	asm ("ldc %0, sr": :"r" (sr));
-	asm volatile ("trapa #0");
-}
-
 
 #if defined(CONFIG_USB_OHCI_NEW)
 
diff --git a/cpu/sh/usb.c b/cpu/sh/usb.c
index 3ab525c..979b264 100644
--- a/cpu/sh/usb.c
+++ b/cpu/sh/usb.c
@@ -27,6 +27,8 @@
 
 #if defined(CONFIG_SH_STB7100)
 extern void stb7100_usb_init(void);
+#elif defined(CONFIG_SH_STX7111)
+extern void stx7111_usb_init(void);
 #elif defined(CONFIG_SH_STX7200)
 extern void stx7200_usb_init(void);
 #else
@@ -39,6 +41,8 @@ extern int usb_cpu_init(void)
 {
 #if defined(CONFIG_SH_STB7100)
 	stb7100_usb_init();
+#elif defined(CONFIG_SH_STX7111)
+	stx7111_usb_init();
 #elif defined(CONFIG_SH_STX7200)
 	stx7200_usb_init();
 #endif
diff --git a/drivers/mtd/cfi_flash.c b/drivers/mtd/cfi_flash.c
index ad401b8..0ad82e7 100644
--- a/drivers/mtd/cfi_flash.c
+++ b/drivers/mtd/cfi_flash.c
@@ -498,7 +498,7 @@ int flash_erase (flash_info_t * info, int s_first, int s_last)
 			    (info, sect, info->erase_blk_tout, "erase")) {
 				rcode = 1;
 			} else {
-				flash_write_cmd (info, sect, 0, FLASH_CMD_RESET);
+				flash_write_cmd (info, sect, 0, info->cmd_reset);
 				putc ('.');
 			}
 		}
@@ -732,7 +732,7 @@ int flash_real_protect (flash_info_t * info, long sector, int prot)
 			}
 		}
 	}
-	flash_write_cmd (info, sector, 0, FLASH_CMD_RESET);
+	flash_write_cmd (info, sector, 0, info->cmd_reset);
 	return retcode;
 }
 
@@ -1317,6 +1317,9 @@ ulong flash_get_size (ulong base, int banknum)
 			}
 		}
 
+		/* go back into CFI mode */
+		flash_write_cmd (info, 0, 0, FLASH_CMD_CFI);
+
 		info->sector_count = sect_cnt;
 		/* multiply the size by the number of chips */
 		info->size = (1 << flash_read_uchar (info, FLASH_OFFSET_SIZE)) * size_ratio;
@@ -1369,7 +1372,7 @@ static int flash_write_cfiword (flash_info_t * info, ulong dest,
 
 	/* put the flash in read mode */
 	sector = find_sector (info, dest);
-	flash_write_cmd (info, sector, 0, FLASH_CMD_RESET);
+	flash_write_cmd (info, sector, 0, info->cmd_reset);
 
 	/* Check if Flash is (sufficiently) erased */
 	switch (info->portwidth) {
@@ -1428,7 +1431,7 @@ static int flash_write_cfiword (flash_info_t * info, ulong dest,
 
 	retcode = flash_full_status_check (info, sector,
 					info->write_tout, "write");
-	flash_write_cmd (info, sector, 0, FLASH_CMD_RESET);
+	flash_write_cmd (info, sector, 0, info->cmd_reset);
 	return retcode;
 }
 
diff --git a/drivers/net/stm-stmac.c b/drivers/net/stm-stmac.c
index f5b1102..332fb63 100644
--- a/drivers/net/stm-stmac.c
+++ b/drivers/net/stm-stmac.c
@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2006  STMicroelectronics Limited
+ *  Copyright (c) 2006-2008  STMicroelectronics Limited
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -17,11 +17,12 @@
  * MA 02111-1307 USA
  *
  * author(s): Andy Sturges (andy.sturges@st.com)
+ *            Sean McGoogan <Sean.McGoogan@st.com>
  */
 
 #include <common.h>
 
-#ifdef CONFIG_DRIVER_NETSTMAC
+#if defined(CONFIG_DRIVER_NETSTMAC) || defined(CONFIG_DRIVER_NET_STM_GMAC)
 
 #include <command.h>
 #include <asm/addrspace.h>
@@ -34,26 +35,18 @@
 #if defined(CONFIG_CMD_NET)
 
 /* #define DEBUG */
-
 #ifdef DEBUG
-#define PRINTK(args...) printf(args)
+#	define PRINTK(args...) printf(args)
 #else
-#define PRINTK(args...)
+#	define PRINTK(args...)
 #endif
 
-/* This structure is common for both receive and transmit DMA descriptors.
- * A descriptor should not be used for storing more than one frame. */
-struct stmac_dma_des_t
-{
-	unsigned int des0;	/* Status */
-	unsigned int des1;	/* Ctrl bits, Buffer 2 length, Buffer 1 length */
-	void *des2;		/* Buffer 1 Address Pointer */
-	void *des3;		/* Buffer 2 Address Pointer or the next Descriptor */
-};
-
-typedef struct stmac_dma_des_t stmac_dma_des;
-
-/* Use single dma descriptors */
+/* prefix to use for diagnostics */
+#ifdef CONFIG_DRIVER_NETSTMAC
+#	define STMAC	"STM-MAC: "
+#else
+#	define STMAC	"STM-GMAC: "
+#endif /* CONFIG_DRIVER_NETSTMAC */
 
 #define CONFIG_DMA_RX_SIZE 8
 #define CONFIG_DMA_TX_SIZE 1	/* Only ever use 1 tx buffer */
@@ -72,30 +65,32 @@ static unsigned int stmac_mii_read (int phy_addr, int reg);
 static void stmac_set_mac_mii_cap (int full_duplex, unsigned int speed);
 
 /* DMA structure */
-
 struct dma_t
 {
-	uchar _dummy1[L1_CACHE_BYTES];
 	stmac_dma_des desc_rx[CONFIG_DMA_RX_SIZE];
 	stmac_dma_des desc_tx[CONFIG_DMA_TX_SIZE];
 	uchar rx_buff[CONFIG_DMA_RX_SIZE * (PKTSIZE_ALIGN)];
-	uchar _dummy2[L1_CACHE_BYTES];
-} dma;
+	uchar _dummy[L1_CACHE_BYTES];
+} __attribute__ ((aligned (L1_CACHE_BYTES))) dma;
 
-static uchar *rx_packets[CONFIG_DMA_RX_SIZE];
+static void *rx_packets[CONFIG_DMA_RX_SIZE];
 
 extern int stmac_default_pbl(void);
 
+#define likely(x)	__builtin_expect(!!(x), 1)
+#define unlikely(x)	__builtin_expect(!!(x), 0)
+
 /* ----------------------------------------------------------------------------
 				 Phy interface
    ---------------------------------------------------------------------------*/
 
 #if defined(CONFIG_STMAC_STE10XP)	/* ST STE10xP */
 
-/* STE101P phy identifier values */
+/* STE100P phy identifier values */
 #define STE100P_PHY_HI_ID       0x1c04
 #define STE100P_PHY_LO_ID       0x0011
 
+/* STE101P phy identifier values */
 #define STE101P_PHY_HI_ID       0x0006
 #define STE101P_PHY_LO_ID_REVA  0x1c51
 #define STE101P_PHY_LO_ID_REVB  0x1c52
@@ -174,20 +169,20 @@ static int stmac_phy_negotiate (int phy_addr)
 
 		/* Restart auto-negotiation if remote fault */
 		if (status & BMSR_RFAULT) {
-			printf ("PHY remote fault detected\n");
+			printf (STMAC "PHY remote fault detected\n");
 			/* Restart auto-negotiation */
-			printf ("PHY restarting auto-negotiation\n");
+			printf (STMAC "PHY restarting auto-negotiation\n");
 			stmac_mii_write (phy_addr, MII_BMCR,
 					 BMCR_ANENABLE | BMCR_ANRESTART);
 		}
 	}
 
 	if (!(status & BMSR_ANEGCOMPLETE)) {
-		printf ("PHY auto-negotiate timed out\n");
+		printf (STMAC "PHY auto-negotiate timed out\n");
 	}
 
 	if (status & BMSR_RFAULT) {
-		printf ("PHY remote fault detected\n");
+		printf (STMAC "PHY remote fault detected\n");
 	}
 
 	return (1);
@@ -202,7 +197,7 @@ static unsigned int stmac_phy_check_speed (int phy_addr)
 	/* Read Status register */
 	status = stmac_mii_read (phy_addr, MII_BMSR);
 
-	printf ("STMAC: ");
+	printf (STMAC);
 
 	/* Check link status.  If 0, default to 100 Mbps. */
 	if ((status & BMSR_LSTATUS) == 0) {
@@ -253,17 +248,17 @@ static unsigned int stmac_phy_get_addr (void)
 		    ((id2 == STE101P_PHY_LO_ID_REVB) ||
 		     (id2 == STE101P_PHY_LO_ID_REVA))) {
 			stmac_phy_id = id1;
-			printf ("STMAC: STE101P found\n");
+			printf (STMAC "STE101P found\n");
 		} else if ((id1 == STE100P_PHY_HI_ID) &&
 			   (id2 == STE100P_PHY_LO_ID)) {
 			stmac_phy_id = id1;
-			printf ("STMAC: STE100P found\n");
+			printf (STMAC "STE100P found\n");
 		}
 #elif defined(CONFIG_STMAC_LAN8700)
 		if ((id1 == LAN8700_PHY_HI_ID) &&
 		    (id2 == LAN8700_PHY_LO_ID)) {
 			stmac_phy_id = id1;
-			printf ("STMAC: SMSC LAN8700 found\n");
+			printf (STMAC "SMSC LAN8700 found\n");
 		}
 #endif	/* CONFIG_STMAC_LAN8700 */
 
@@ -284,7 +279,7 @@ static int stmac_phy_init (void)
 
 	/* Now reset the PHY we just found */
 	if (miiphy_reset (miidevice, eth_phy_addr)< 0) {
-		PRINTK ("PHY reset failed!");
+		PRINTK (STMAC "PHY reset failed!\n");
 		return -1;
 	}
 
@@ -299,7 +294,7 @@ static int stmac_phy_init (void)
 #error Need to define PHY
 #endif
 	if (value != eth_phy_addr) {
-		printf ("PHY address mismatch with hardware (hw %d != %d)\n",
+		printf (STMAC "PHY address mismatch with hardware (hw %d != %d)\n",
 			value,
 			eth_phy_addr);
 	}
@@ -351,7 +346,7 @@ static int stmac_mii_poll_busy (void)
 			return 1;
 		}
 	}
-	printf ("stmac_mii_busy timeout\n");
+	printf (STMAC "stmac_mii_busy timeout\n");
 	return (0);
 }
 
@@ -362,8 +357,8 @@ static void stmac_mii_write (int phy_addr, int reg, int value)
 	/* Select register */
 	mii_addr =
 		((phy_addr & MAC_MII_ADDR_PHY_MASK) << MAC_MII_ADDR_PHY_SHIFT)
-		| ((reg & MAC_MII_ADDR_REG_MASK) << MAC_MII_ADDR_REG_SHIFT) |
-		MAC_MII_ADDR_WRITE;
+		| ((reg & MAC_MII_ADDR_REG_MASK) << MAC_MII_ADDR_REG_SHIFT)
+		| MAC_MII_ADDR_WRITE | MAC_MII_ADDR_BUSY;
 
 	stmac_mii_poll_busy ();
 
@@ -373,7 +368,10 @@ static void stmac_mii_write (int phy_addr, int reg, int value)
 
 	stmac_mii_poll_busy ();
 
+#if defined(CONFIG_STMAC_STE10XP)	/* ST STE10xP PHY */
+	/* QQQ: is the following actually needed ? */
 	(void) stmac_mii_read (phy_addr, reg);
+#endif	/* CONFIG_STMAC_STE10XP */
 }
 
 static unsigned int stmac_mii_read (int phy_addr, int reg)
@@ -382,7 +380,8 @@ static unsigned int stmac_mii_read (int phy_addr, int reg)
 
 	mii_addr =
 		((phy_addr & MAC_MII_ADDR_PHY_MASK) << MAC_MII_ADDR_PHY_SHIFT)
-		| ((reg & MAC_MII_ADDR_REG_MASK) << MAC_MII_ADDR_REG_SHIFT);
+		| ((reg & MAC_MII_ADDR_REG_MASK) << MAC_MII_ADDR_REG_SHIFT)
+		| MAC_MII_ADDR_BUSY;
 
 	/* Select register */
 	stmac_mii_poll_busy ();
@@ -413,6 +412,38 @@ static int stmac_miiphy_write (char *devname, unsigned char addr, unsigned char
 				 MAC CORE Interface
    ---------------------------------------------------------------------------*/
 
+#ifdef DEBUG
+static void gmac_dump_regs(void)
+{
+	int i;
+	const char fmt[] =
+		"\tReg No. %2d (offset 0x%03x): 0x%08x\n";
+	const char header[] =
+		"\t----------------------------------------------\n"
+		"\t  %s registers (base addr = 0x%8x)\n"
+		"\t----------------------------------------------\n";
+
+	printf (header, "MAC CORE", (unsigned int)CFG_STM_STMAC_BASE);
+	for (i = 0; i < 18; i++) {
+		int offset = i * 4;
+		printf(fmt, i, offset, STMAC_READ (offset));
+	}
+
+	printf (header, "MAC DMA", (unsigned int)CFG_STM_STMAC_BASE);
+	for (i = 0; i < 9; i++) {
+		int offset = i * 4;
+		printf (fmt, i, (DMA_BUS_MODE + offset),
+			STMAC_READ (DMA_BUS_MODE + offset));
+	}
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+	printf ("\tSTBus bridge register (0x%08x) = 0x%08x\n",
+		(unsigned int)(CFG_STM_STMAC_BASE + STBUS_BRIDGE_OFFSET),
+		STMAC_READ (STBUS_BRIDGE_OFFSET));
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+}
+#endif	/* DEBUG */
+
 static void stmac_set_mac_addr (unsigned char *Addr)
 {
 	unsigned long data;
@@ -421,8 +452,6 @@ static void stmac_set_mac_addr (unsigned char *Addr)
 	STMAC_WRITE (data, MAC_ADDR_HIGH);
 	data = (Addr[3] << 24) | (Addr[2] << 16) | (Addr[1] << 8) | Addr[0];
 	STMAC_WRITE (data, MAC_ADDR_LOW);
-
-	return;
 }
 
 static int stmac_get_mac_addr (unsigned char *addr)
@@ -451,11 +480,16 @@ static void stmac_mac_enable (void)
 {
 	unsigned int value = (unsigned int) STMAC_READ (MAC_CONTROL);
 
-	PRINTK ("MAC RX/TX enabled\n");
+	PRINTK (STMAC "MAC RX/TX enabled\n");
+
+	/* set: TE (transmitter enable), RE (receive enable) */
+	value |= (MAC_CONTROL_TE | MAC_CONTROL_RE);
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+	/* and RA (receive all mode) */
+//	value |= MAC_CONTROL_RA;	/* QQQ: suspect we can delete this */
+#endif	/* CONFIG_DRIVER_NETSTMAC */
 
-	/* set: TE (transmitter enable, bit 3), RE (receive enable, bit 2)
-	   and RA (receive all mode, bit 31) */
-	value |= (MAC_CONTROL_RA | MAC_CONTROL_TE | MAC_CONTROL_RE);
 	STMAC_WRITE (value, MAC_CONTROL);
 	return;
 }
@@ -464,9 +498,14 @@ static void stmac_mac_disable (void)
 {
 	unsigned int value = (unsigned int) STMAC_READ (MAC_CONTROL);
 
-	PRINTK ("%s: MAC RX/TX disabled\n", __FUNCTION__);
+	PRINTK (STMAC "MAC RX/TX disabled\n");
+
+	value &= ~(MAC_CONTROL_TE | MAC_CONTROL_RE);
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+//	value &= ~MAC_CONTROL_RA;	/* QQQ: suspect we can delete this */
+#endif	/* CONFIG_DRIVER_NETSTMAC */
 
-	value &= ~(MAC_CONTROL_RA | MAC_CONTROL_TE | MAC_CONTROL_RE);
 	STMAC_WRITE (value, MAC_CONTROL);
 	return;
 }
@@ -475,9 +514,12 @@ static void stmac_set_rx_mode (void)
 {
 	unsigned int value = (unsigned int) STMAC_READ (MAC_CONTROL);
 
-	PRINTK ("STMAC: perfect filtering mode.\n");
+#ifdef CONFIG_DRIVER_NETSTMAC
+	PRINTK (STMAC "MAC address perfect filtering only mode\n");
 	value &= ~(MAC_CONTROL_PM | MAC_CONTROL_PR | MAC_CONTROL_IF |
 		   MAC_CONTROL_HO | MAC_CONTROL_HP);
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+
 	STMAC_WRITE (0x0, MAC_HASH_HIGH);
 	STMAC_WRITE (0x0, MAC_HASH_LOW);
 
@@ -488,22 +530,55 @@ static void stmac_set_rx_mode (void)
 
 static void stmac_set_mac_mii_cap (int full_duplex, unsigned int speed)
 {
-	unsigned int flow = (unsigned int) STMAC_READ (MAC_FLOW_CONTROL),
-		ctrl = (unsigned int) STMAC_READ (MAC_CONTROL);
+	unsigned int flow = (unsigned int) STMAC_READ (MAC_FLOW_CONTROL);
+	unsigned int ctrl = (unsigned int) STMAC_READ (MAC_CONTROL);
 
-	PRINTK ("%s\n", __FUNCTION__);
+	PRINTK (STMAC "%s(full_duplex=%d, speed=%u)\n", __FUNCTION__, full_duplex, speed);
 
 	if (!(full_duplex)) {	/* Half Duplex */
+#ifdef CONFIG_DRIVER_NETSTMAC
 		flow &= ~(MAC_FLOW_CONTROL_FCE | MAC_FLOW_CONTROL_PT_MASK |
 			  MAC_FLOW_CONTROL_PCF);
 		ctrl &= ~MAC_CONTROL_F;
 		ctrl |= MAC_CONTROL_DRO;
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+		flow &= ~(MAC_FLOW_CONTROL_TFE | MAC_FLOW_CONTROL_PT_MASK |
+			  MAC_FLOW_CONTROL_RFE);
+		ctrl &= ~MAC_CONTROL_DM;
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
 	} else {		/* Full Duplex */
-		flow |= MAC_FLOW_CONTROL_FCE | MAC_FLOW_CONTROL_PCF |
-			(MAX_PAUSE_TIME << MAC_FLOW_CONTROL_PT_SHIFT);
+#ifdef CONFIG_DRIVER_NETSTMAC
 		ctrl |= MAC_CONTROL_F;
 		ctrl &= ~MAC_CONTROL_DRO;
+		flow |= MAC_FLOW_CONTROL_FCE | MAC_FLOW_CONTROL_PCF;
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+		ctrl |= MAC_CONTROL_DM;
+		flow |= MAC_FLOW_CONTROL_TFE | MAC_FLOW_CONTROL_RFE;
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+		flow |= (MAX_PAUSE_TIME << MAC_FLOW_CONTROL_PT_SHIFT);
+	}
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+	/* use MII */
+	ctrl &= ~MAC_CONTROL_PS;
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+	switch (speed) {
+	case 1000:		/* Gigabit */
+		ctrl &= ~MAC_CONTROL_PS;
+		break;
+	case 100:		/* 100Mbps */
+		ctrl |= MAC_CONTROL_PS | MAC_CONTROL_FES;
+		break;
+	case 10:		/* 10Mbps */
+		ctrl |= MAC_CONTROL_PS;
+		ctrl &= ~MAC_CONTROL_FES;
+		break;
 	}
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
 
 	STMAC_WRITE (flow, MAC_FLOW_CONTROL);
 	STMAC_WRITE (ctrl, MAC_CONTROL);
@@ -516,16 +591,23 @@ static void stmac_set_mac_mii_cap (int full_duplex, unsigned int speed)
 /* This function provides the initial setup of the MAC controller */
 static void stmac_mac_core_init (void)
 {
-	unsigned int value = 0;
+	unsigned int value;
 
 	/* Set the MAC control register with our default value */
 	value = (unsigned int) STMAC_READ (MAC_CONTROL);
-	value |= MAC_CONTROL_HBD | MAC_CONTROL_PM;
+	value |= MAC_CORE_INIT;
 	STMAC_WRITE (value, MAC_CONTROL);
 
-	/* Change the MAX_FRAME bits in the MMC control register. */
-	STMAC_WRITE (((MAX_ETH_FRAME_SIZE << MMC_CONTROL_MAX_FRM_SHIFT) &
-		      MMC_CONTROL_MAX_FRM_MASK), MMC_CONTROL);
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+	/* STBus Bridge Configuration */
+	STMAC_WRITE(STBUS_BRIDGE_MAGIC, STBUS_BRIDGE_OFFSET);
+
+	/* Freeze MMC counters */
+	STMAC_WRITE(MMC_COUNTER_FREEZE, MMC_CONTROL);
+
+	/* Mask all interrupts */
+	STMAC_WRITE(~0u, MAC_INT_MASK);
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
 
 	return;
 }
@@ -533,41 +615,47 @@ static void stmac_mac_core_init (void)
 /* ----------------------------------------------------------------------------
  *  			DESCRIPTORS functions
  * ---------------------------------------------------------------------------*/
-static void display_dma_desc_ring (volatile stmac_dma_des * p, int size)
+
+#ifdef DEBUG
+static void display_dma_desc_ring (volatile const stmac_dma_des * p, int size)
 {
 	int i;
 	for (i = 0; i < size; i++)
 		printf ("\t%d [0x%x]: "
-			"desc0=0x%x desc1=0x%x buffer1=0x%x\n", i,
-			(unsigned int) &p[i].des0, p[i].des0,
-			p[i].des1, (unsigned int) p[i].des2);
+			"desc0=0x%08x, desc1=0x%08x, buffer1=0x%08x\n",
+			i, (unsigned int) &p[i].des01.u.des0,
+			p[i].des01.u.des0, p[i].des01.u.des1, p[i].des2);
 }
+#endif	/* DEBUG */
 
-static void init_desc_owner (volatile stmac_dma_des * head, unsigned int size,
-			     unsigned int owner)
+static void init_rx_desc (volatile stmac_dma_des * p,
+	unsigned int ring_size, void **buffers)
 {
 	int i;
-	volatile stmac_dma_des *p = head;
 
-	for (i = 0; i < size; i++) {
-		p->des0 = owner;
+	for (i = 0; i < ring_size; i++) {
+		p->des01.u.des0 = p->des01.u.des1 = 0;
+		p->des01.rx.own = 1;
+		p->des01.rx.buffer1_size = PKTSIZE_ALIGN;
+		p->des01.rx.disable_ic = 1;
+		if (i == ring_size - 1)
+			p->des01.rx.end_ring = 1;
+		p->des2 = ((void *) (PHYSADDR (buffers[i])));
+		p->des3 = NULL;
 		p++;
 	}
 	return;
 }
 
-static void init_dma_ring (volatile stmac_dma_des * p, uchar ** phy,
-			   unsigned int ring_size, unsigned int own_bit)
+static void init_tx_desc (volatile stmac_dma_des * p, unsigned int ring_size)
 {
 	int i;
+
 	for (i = 0; i < ring_size; i++) {
-		p->des0 = own_bit;
-		p->des1 = (!(own_bit) ? 0 :
-			   ((PKTSIZE_ALIGN) << DES1_RBS1_SIZE_SHIFT));
-		if (i == ring_size - 1) {
-			p->des1 |= DES1_CONTROL_TER;
-		}
-		p->des2 = (!(own_bit) ? 0 : ((void *) (PHYSADDR (phy[i]))));
+		p->des01.u.des0 = p->des01.u.des1 = 0;
+		if (i == ring_size - 1)
+			p->des01.tx.end_ring = 1;
+		p->des2 = NULL;
 		p->des3 = NULL;
 		p++;
 	}
@@ -582,10 +670,9 @@ static void init_dma_desc_rings (void)
 {
 	int i;
 
-	PRINTK ("allocate and init the DMA RX/TX lists\n");
+	PRINTK (STMAC "allocate and init the DMA RX/TX lists\n");
 
 	/* Clean out uncached buffers */
-
 	flush_cache ((unsigned long)&dma, sizeof (struct dma_t));
 
 	/* Allocate memory for the DMA RX/TX buffer descriptors */
@@ -594,22 +681,24 @@ static void init_dma_desc_rings (void)
 
 	cur_rx = 0;
 
-	if ((dma_rx == NULL) || (dma_tx == NULL)) {
-		printf ("%s:ERROR allocating the DMA Tx/Rx desc\n",
-			__FUNCTION__);
+	if ((dma_rx == NULL) || (dma_tx == NULL) ||
+	    (((u32)dma_rx % L1_CACHE_BYTES) != 0) ||
+	    (((u32)dma_tx % L1_CACHE_BYTES) != 0)) {
+		printf (STMAC "ERROR allocating the DMA Tx/Rx desc\n");
 		return;
 	}
 
 	for (i = 0; i < CONFIG_DMA_RX_SIZE; i++)
-		rx_packets[i] = (uchar*)P2SEGADDR (dma.rx_buff + (PKTSIZE_ALIGN * i));
+		rx_packets[i] = (void *) P2SEGADDR (dma.rx_buff + (PKTSIZE_ALIGN * i));
 
-	init_dma_ring (dma_rx, rx_packets, CONFIG_DMA_RX_SIZE, OWN_BIT);
-	init_dma_ring (dma_tx, 0, CONFIG_DMA_TX_SIZE, 0);
+	/* Initialize the contents of the DMA buffers */
+	init_rx_desc (dma_rx, CONFIG_DMA_RX_SIZE, rx_packets);
+	init_tx_desc (dma_tx, CONFIG_DMA_TX_SIZE);
 
 #ifdef DEBUG
-	printf (" - RX descriptor ring:\n");
+	printf (STMAC "RX descriptor ring:\n");
 	display_dma_desc_ring (dma_rx, CONFIG_DMA_RX_SIZE);
-	printf (" - TX descriptor ring:\n");
+	printf (STMAC "TX descriptor ring:\n");
 	display_dma_desc_ring (dma_tx, CONFIG_DMA_TX_SIZE);
 #endif
 
@@ -665,7 +754,7 @@ static void stmac_dma_stop_tx (void)
 	unsigned int value;
 
 	value = (unsigned int) STMAC_READ (DMA_CONTROL);
-	value |= ~DMA_CONTROL_ST;
+	value &= ~DMA_CONTROL_ST;
 	STMAC_WRITE (value, DMA_CONTROL);
 
 	return;
@@ -686,7 +775,7 @@ static void stmac_dma_stop_rx (void)
 	unsigned int value;
 
 	value = (unsigned int) STMAC_READ (DMA_CONTROL);
-	value |= ~DMA_CONTROL_SR;
+	value &= ~DMA_CONTROL_SR;
 	STMAC_WRITE (value, DMA_CONTROL);
 
 	return;
@@ -697,8 +786,6 @@ static void stmac_eth_stop_tx (void)
 
 	stmac_dma_stop_tx ();
 
-	init_desc_owner (dma_tx, CONFIG_DMA_TX_SIZE, 0);
-
 	return;
 }
 
@@ -710,10 +797,7 @@ static void stmac_eth_stop_tx (void)
 static int stmac_dma_init (void)
 {
 
-	PRINTK ("STM-STMAC: DMA Core setup\n");
-
-	/* DMA SW reset */
-	stmac_dma_reset ();
+	PRINTK (STMAC "DMA Core setup\n");
 
 	/* Enable Application Access by writing to DMA CSR0 */
 	STMAC_WRITE (DMA_BUS_MODE_DEFAULT |
@@ -724,78 +808,155 @@ static int stmac_dma_init (void)
 	STMAC_WRITE (0, DMA_INTR_ENA);
 
 	/* The base address of the RX/TX descriptor */
-
 	STMAC_WRITE (PHYSADDR (dma_tx), DMA_TX_BASE_ADDR);
 	STMAC_WRITE (PHYSADDR (dma_rx), DMA_RCV_BASE_ADDR);
 
 	return (0);
 }
 
-static int check_tx_error_summary (uint status)
+static int check_tx_error_summary (const stmac_dma_des * const p)
 {
+	int ret = 0;	/* assume there are no errors */
 
-	PRINTK ("TDES0: 0x%x\n", status);
-
-	if (status & TDES0_STATUS_ES) {
-		printf ("STMAC: DMA tx ERROR: ");
-
-		if (status & TDES0_STATUS_UF) {
-			printf ("Underflow Error\n");
-			goto out_error;
+	if (unlikely(p->des01.tx.error_summary)) {
+		if (unlikely(p->des01.tx.loss_carrier)) {
+			PRINTK(STMAC "TX: loss_carrier error\n");
+		}
+		if (unlikely(p->des01.tx.no_carrier)) {
+			PRINTK(STMAC "TX: no_carrier error\n");
 		}
-		if (status & TDES0_STATUS_EX_DEF) {
-			printf ("Ex Deferrals\n");
-			goto set_collision;
+		if (unlikely(p->des01.tx.late_collision)) {
+			PRINTK(STMAC "TX: late_collision error\n");
 		}
-		if (status & TDES0_STATUS_EX_COL) {
-			printf ("Ex Collisions\n");
-			goto set_collision;
+		if (unlikely(p->des01.tx.excessive_collisions)) {
+			PRINTK(STMAC "TX: excessive_collisions\n");
 		}
-		if (status & TDES0_STATUS_LATE_COL) {
-			printf ("Late Collision\n");
-			goto set_collision;
+		if (unlikely(p->des01.tx.excessive_deferral)) {
+			PRINTK(STMAC "TX: excessive_deferral\n");
 		}
-		if (status & TDES0_STATUS_NO_CARRIER) {
-			printf ("No Carrier\n");
-			goto out_error;
+		if (unlikely(p->des01.tx.underflow_error)) {
+			PRINTK(STMAC "TX: underflow error\n");
 		}
-		if (status & TDES0_STATUS_LOSS_CARRIER) {
-			printf ("Loss of Carrier\n");
-			goto out_error;
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+		if (unlikely(p->des01.tx.jabber_timeout)) {
+			PRINTK(STMAC "TX: jabber_timeout error\n");
 		}
+		if (unlikely(p->des01.tx.frame_flushed)) {
+			PRINTK(STMAC "TX: frame_flushed error\n");
+		}
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+		ret = -1;
 	}
 
-	return (0);
+	if (unlikely(p->des01.tx.deferred)) {
+		PRINTK(STMAC "TX: deferred\n");
+		ret = -1;
+	}
+#ifdef CONFIG_DRIVER_NETSTMAC
+	if (unlikely(p->des01.tx.heartbeat_fail)) {
+		PRINTK(STMAC "TX: heartbeat_fail\n");
+		ret = -1;
+	}
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+	if (unlikely(p->des01.tx.payload_error)) {
+		PRINTK(STMAC "TX Addr/Payload csum error\n");
+		ret = -1;
+	}
+	if (unlikely(p->des01.tx.ip_header_error)) {
+		PRINTK(STMAC "TX IP header csum error\n");
+		ret = -1;
+	}
+	if (p->des01.tx.vlan_frame) {
+		PRINTK(STMAC "TX: VLAN frame\n");
+	}
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
 
-      set_collision:
-      out_error:
+#ifdef DEBUG
+	if (ret != 0) {
+		printf(STMAC "%s() returning %d\n", __FUNCTION__, ret);
+	}
+#endif
 
-	return (-1);
+	return (ret);
 }
 
-/* When a frame is received the status is written into TDESC0 of the descriptor
- * having the LS bit set. */
-static int check_rx_error_summary (unsigned int status)
+static int check_rx_error_summary (const stmac_dma_des * const p)
 {
-	if (status & RDES0_STATUS_ES) {
-		printf ("STMAC: DMA rx ERROR: ");
-		if (status & RDES0_STATUS_DE)
-			printf ("descriptor error\n");
-		if (status & RDES0_STATUS_PFE)
-			printf ("partial frame error\n");
-		if (status & RDES0_STATUS_RUNT_FRM)
-			printf ("runt Frame\n");
-		if (status & RDES0_STATUS_TL)
-			printf ("frame too long\n");
-		if (status & RDES0_STATUS_COL_SEEN) {
-			printf ("collision seen\n");
+	int ret = 0;	/* assume there are no errors */
+
+	if (unlikely(p->des01.rx.error_summary)) {
+		if (unlikely(p->des01.rx.descriptor_error)) {
+			/* frame doesn't fit within the current descriptor. */
+			PRINTK(STMAC "RX: descriptor error\n");
+		}
+		if (unlikely(p->des01.rx.crc_error)) {
+			PRINTK(STMAC "RX: CRC error\n");
+		}
+#ifdef CONFIG_DRIVER_NETSTMAC
+		if (unlikely(p->des01.rx.partial_frame_error)) {
+			PRINTK(STMAC "RX: partial_frame_error\n");
+		}
+		if (unlikely(p->des01.rx.runt_frame)) {
+			PRINTK(STMAC "RX: runt_frame\n");
 		}
-		if (status & RDES0_STATUS_CE)
-			printf ("CRC Error\n");
+		if (unlikely(p->des01.rx.frame_too_long)) {
+			PRINTK(STMAC "RX: frame_too_long\n");
+		}
+		if (unlikely(p->des01.rx.collision)) {
+			PRINTK(STMAC "RX: collision\n");
+		}
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+		if (unlikely(p->des01.rx.overflow_error)) {
+			PRINTK(STMAC "RX: Overflow error\n");
+		}
+		if (unlikely(p->des01.rx.late_collision)) {
+			PRINTK(STMAC "RX: late_collision\n");
+		}
+		if (unlikely(p->des01.rx.receive_watchdog)) {
+			PRINTK(STMAC "RX: receive_watchdog error\n");
+		}
+		if (unlikely(p->des01.rx.error_gmii)) {
+			PRINTK(STMAC "RX: GMII error\n");
+		}
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+		ret = -1;
+	}
 
-		return (-1);
+	if (unlikely(p->des01.rx.length_error)) {
+		PRINTK(STMAC "RX: length_error error\n");
+		ret = -1;
 	}
-	return (0);
+	if (unlikely(p->des01.rx.dribbling)) {
+		PRINTK(STMAC "RX: dribbling error\n");
+		ret = -1;
+	}
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+	if (unlikely(p->des01.rx.filtering_fail)) {
+		PRINTK(STMAC "RX: filtering_fail error\n");
+		ret = -1;
+	}
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+#ifdef CONFIG_DRIVER_NETSTMAC
+	if (unlikely(p->des01.rx.last_descriptor == 0)) {
+		PRINTK(STMAC "RX: Oversized Ethernet "
+			"frame spanned multiple buffers\n");
+		ret = -1;
+	}
+	if (unlikely(p->des01.rx.mii_error)) {
+		PRINTK(STMAC "RX: MII error\n");
+		ret = -1;
+	}
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+
+#ifdef DEBUG
+	if (ret != 0) {
+		printf(STMAC "%s() returning %d\n", __FUNCTION__, ret);
+	}
+#endif
+
+	return (ret);
 }
 
 static int stmac_eth_tx (volatile uchar * data, int len)
@@ -803,29 +964,34 @@ static int stmac_eth_tx (volatile uchar * data, int len)
 	volatile stmac_dma_des *p = dma_tx;
 	uint now = get_timer (0);
 	uint status = 0;
+	u32 end_ring;
 
-	while ((p->des0 & OWN_BIT)
+	while (p->des01.tx.own
 	       && (get_timer (now) < CONFIG_STMAC_TX_TIMEOUT)) {
 		;
 	}
 
-	if (p->des0 & OWN_BIT) {
-		printf ("STMAC: tx timeout - no desc available\n");
+	if (p->des01.tx.own) {
+		printf (STMAC "tx timeout - no desc available\n");
 		return -1;
 	}
 
-	flush_cache ((ulong) data, len);	/* Make sure data in memory */
-	p->des2 = (stmac_dma_des *) PHYSADDR (data);
-
-	/* Clean and set the descriptor 1 */
+	/* Make sure data is in real memory */
+	flush_cache ((ulong) data, len);
+	p->des2 = (void *) PHYSADDR (data);
 
-	p->des1 = ((TDES1_CONTROL_IC | TDES1_CONTROL_FS | TDES1_CONTROL_LS) |
-		   ((p->des1 & DES1_CONTROL_TER) ? DES1_CONTROL_TER : 0) |
-		   ((len << DES1_RBS1_SIZE_SHIFT) & DES1_RBS1_SIZE_MASK));
-	p->des0 = OWN_BIT;
+	/* Clean and set the TX descriptor */
+	end_ring = p->des01.tx.end_ring;
+	p->des01.u.des0 = p->des01.u.des1 = 0;
+	p->des01.tx.interrupt = 1;
+	p->des01.tx.first_segment = 1;
+	p->des01.tx.last_segment = 1;
+	p->des01.tx.end_ring = end_ring;
+	p->des01.tx.buffer1_size = len;
+	p->des01.tx.own = 1;
 
 #ifdef DEBUG
-	PRINTK ("\nSTMAC: TX (cur_tx = %d)\n", cur_tx);
+	PRINTK ("\n" STMAC "TX %s(data=0x%08x, len=%d)\n", __FUNCTION__, data, len);
 	display_dma_desc_ring (dma_tx, CONFIG_DMA_TX_SIZE);
 #endif
 
@@ -840,72 +1006,77 @@ static int stmac_eth_tx (volatile uchar * data, int len)
 			break;
 	}
 	if (!(status & DMA_STATUS_TI)) {
-		printf ("STMAC: tx timeout\n");
+		printf (STMAC "tx timeout\n");
 	}
-	check_tx_error_summary (status);
 
-	return (0);
+	return check_tx_error_summary ((stmac_dma_des *)p);
 }
 
 /* Receive function */
 static void stmac_eth_rx (void)
 {
-	int frame_len = 0, pos;
+	int frame_len = 0;
 	volatile stmac_dma_des *drx;
 
-	pos = cur_rx;
-	drx = dma_rx + pos;
+	/* select the RX descriptor to use */
+	drx = dma_rx + cur_rx;
 
-	if ((pos < 0) || (pos >= CONFIG_DMA_RX_SIZE)) {
-		printf ("STMAC %s: [dma drx = 0x%x, pos=%d]\n", __FUNCTION__,
-			(unsigned int) drx, pos);
+	if ((cur_rx < 0) || (cur_rx >= CONFIG_DMA_RX_SIZE)) {
+		printf (STMAC "%s: [dma drx = 0x%x, cur_rx=%d]\n", __FUNCTION__,
+			(unsigned int) drx, cur_rx);
+#ifdef DEBUG
 		display_dma_desc_ring (dma_rx, CONFIG_DMA_RX_SIZE);
+#endif	/* DEBUG */
 	}
 
-	if (!(drx->des0 & OWN_BIT) && (drx->des0 & RDES0_STATUS_LS)) {
-		unsigned int status = drx->des0;
-#ifdef  DEBUG
-		PRINTK ("RX descriptor ring:\n");
+	if (!(drx->des01.rx.own) && (drx->des01.rx.last_descriptor)) {
+#ifdef DEBUG
+		PRINTK (STMAC "RX descriptor ring:\n");
 		display_dma_desc_ring (dma_rx, CONFIG_DMA_RX_SIZE);
 #endif
 
 		/* Check if the frame was not successfully received */
-		if (check_rx_error_summary (status) < 0) {
-			drx->des0 = OWN_BIT;
-		} else if ((status & RDES0_STATUS_FS)
-			   && (status & RDES0_STATUS_LS)) {
+		if (check_rx_error_summary ((stmac_dma_des *)drx) < 0) {
+			drx->des01.rx.own = 1;
+		} else if (drx->des01.rx.first_descriptor
+			   && drx->des01.rx.last_descriptor) {
 
 			/* FL (frame length) indicates the length in byte including
 			 * the CRC */
-			frame_len =
-				(status & RDES0_STATUS_FL_MASK) >>
-				RDES0_STATUS_FL_SHIFT;
-
+			frame_len = drx->des01.rx.frame_length;
 			if ((frame_len >= 0) && (frame_len <= PKTSIZE_ALIGN)) {
-				memcpy ((void*)NetRxPackets[0], rx_packets[pos],
+#ifdef DEBUG
+				const unsigned char *p = rx_packets[cur_rx];
+				printf("\nRX[%d]:  0x%08x ", cur_rx, p);
+				printf("DA=%02x:%02x:%02x:%02x:%02x:%02x",
+					p[0], p[1], p[2], p[3], p[4], p[5]);
+				p+=6;
+				printf(" SA=%02x:%02x:%02x:%02x:%02x:%02x",
+					p[0], p[1], p[2], p[3], p[4], p[5]);
+				p+=6;
+				printf(" Type=%04x\n", p[0]<<8|p[1]);
+#endif
+				memcpy ((void*)NetRxPackets[0], rx_packets[cur_rx],
 					frame_len);
 				NetReceive (NetRxPackets[0], frame_len);
 			} else {
-				printf ("%s: Framelen %d too long\n",
+				printf (STMAC "%s: Framelen %d too long\n",
 					__FUNCTION__, frame_len);
 			}
-
-			drx->des0 = OWN_BIT;
-
+			drx->des01.rx.own = 1;
 #ifdef DEBUG
-			PRINTK ("%s: frame received \n", __FUNCTION__);
+			PRINTK (STMAC "%s: frame received \n", __FUNCTION__);
 #endif
 		} else {
-			printf ("%s: very long frame received\n",
+			printf (STMAC "%s: very long frame received\n",
 				__FUNCTION__);
 		}
 
-		if (drx->des1 & DES1_CONTROL_TER)
-			pos = 0;
+		/* advance to the next RX descriptor (for next time) */
+		if (drx->des01.rx.end_ring)
+			cur_rx = 0;	/* wrap, to first */
 		else
-			pos++;
-		/* drx = dma_rx + pos; */
-		cur_rx = pos;
+			cur_rx++;	/* advance to next */
 
 	} else {
 		STMAC_WRITE (1, DMA_RCV_POLL_DEMAND);	/* request input */
@@ -980,15 +1151,21 @@ static int stmac_reset_eth (bd_t * bd)
 {
 	int err;
 
-	err = stmac_get_ethaddr (bd);	/* set smc_mac_addr, and sync it with u-boot globals */
+	/* MAC Software reset */
+	stmac_dma_reset ();		/* Must be done early  */
+
+	/* set smc_mac_addr, and sync it with u-boot globals */
+	err = stmac_get_ethaddr (bd);
 
 	if (err < 0) {
-		memset (bd->bi_enetaddr, 0, 6);	/* hack to make error stick! upper code will abort if not set */
-		return (-1);	/* upper code ignores this, but NOT bi_enetaddr */
+		/* hack to make error stick! upper code will abort if not set */
+		memset (bd->bi_enetaddr, 0, 6);
+		/* upper code ignores return value, but NOT bi_enetaddr */
+		return (-1);
 	}
 
 	if (stmac_phy_init () < 0) {
-		printf ("Phy not detected\n");
+		printf (STMAC "Phy not detected\n");
 		return -1;
 	}
 
@@ -1004,6 +1181,10 @@ static int stmac_reset_eth (bd_t * bd)
 	stmac_dma_start_rx ();
 	stmac_dma_start_tx ();
 
+#ifdef DEBUG
+	gmac_dump_regs ();
+#endif
+
 	STMAC_WRITE (1, DMA_RCV_POLL_DEMAND);	/* request input */
 
 	return (0);
@@ -1017,7 +1198,7 @@ extern int eth_init (bd_t * bd)
 
 extern void eth_halt (void)
 {
-	PRINTK ("%s\n", __FUNCTION__);
+	PRINTK (STMAC "%s\n", __FUNCTION__);
 
 	/* Reset the TX/RX processes */
 	stmac_dma_stop_rx ();
@@ -1027,14 +1208,12 @@ extern void eth_halt (void)
 	stmac_mac_disable ();
 
 	/* Free buffers */
-
 	free_dma_desc_resources ();
 }
 
 /* Get a data block via Ethernet */
 extern int eth_rx (void)
 {
-	PRINTK ("%s: status 0x%x\n", __FUNCTION__, status);
 	stmac_eth_rx ();
 	return 1;
 }
@@ -1042,11 +1221,22 @@ extern int eth_rx (void)
 /* Send a data block via Ethernet. */
 extern int eth_send (volatile void *packet, int length)
 {
-	stmac_eth_tx (packet, length);
-	return 1;
+#ifdef DEBUG
+	const unsigned char *p = packet;
+	printf("TX   :  0x%08x ", p);
+	printf("DA=%02x:%02x:%02x:%02x:%02x:%02x",
+		p[0], p[1], p[2], p[3], p[4], p[5]);
+	p+=6;
+	printf(" SA=%02x:%02x:%02x:%02x:%02x:%02x",
+		p[0], p[1], p[2], p[3], p[4], p[5]);
+	p+=6;
+	printf(" Type=%04x\n", p[0]<<8|p[1]);
+#endif
+
+	return stmac_eth_tx (packet, length);
 }
 
-#endif /* COMMANDS & CFG_NET */
+#endif /* CONFIG_CMD_NET */
 
 extern int stmac_miiphy_initialize(bd_t *bis)
 {
@@ -1056,4 +1246,5 @@ extern int stmac_miiphy_initialize(bd_t *bis)
 	return 0;
 }
 
-#endif /* CONFIG_DRIVER_NETSTMAC */
+#endif /* CONFIG_DRIVER_NETSTMAC || CONFIG_DRIVER_NET_STM_GMAC */
+
diff --git a/drivers/net/stm-stmac.h b/drivers/net/stm-stmac.h
index f3619d0..11ecf5b 100644
--- a/drivers/net/stm-stmac.h
+++ b/drivers/net/stm-stmac.h
@@ -1,334 +1,451 @@
+/*
+ *  Copyright (c) 2006-2008  STMicroelectronics Limited
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * author(s): Andy Sturges (andy.sturges@st.com)
+ *            Sean McGoogan <Sean.McGoogan@st.com>
+ *            Giuseppe Cavallaro <peppe.cavallaro@st.com>
+ */
+
 
 /*----------------------------------------------------------------------------
- *	 			MAC BLOCK defines
+ *			CORE MAC Block
  *---------------------------------------------------------------------------*/
-/* MAC CSR offset */
-#define MAC_CONTROL               0x00000000  /* MAC Control */
-#define MAC_ADDR_HIGH             0x00000004  /* MAC Address High */
-#define MAC_ADDR_LOW              0x00000008  /* MAC Address Low */
-#define MAC_HASH_HIGH             0x0000000c  /* Multicast Hash Table High */
-#define MAC_HASH_LOW              0x00000010  /* Multicast Hash Table Low */
-#define MAC_MII_ADDR              0x00000014  /* MII Address */
-#define MAC_MII_DATA              0x00000018  /* MII Data */
-#define MAC_FLOW_CONTROL          0x0000001c  /* Flow Control */
-#define MAC_VLAN1                 0x00000020  /* VLAN1 Tag */
-#define MAC_VLAN2                 0x00000024  /* VLAN2 Tag */
-#define MAC_WAKEUP_FILTER         0x00000028  /* Wake-up Frame Filter */
-#define MAC_WAKEUP_CONTROL_STATUS 0x0000002c  /* Wake-up Control And Status */
-
-
-/* MAC CTRL defines */
-#define MAC_CONTROL_RA            0x80000000  /* Receive All Mode */
-#define MAC_CONTROL_BLE           0x40000000  /* Endian Mode */
-#define MAC_CONTROL_HBD           0x10000000  /* Heartbeat Disable */
-#define MAC_CONTROL_PS            0x08000000  /* Port Select */
-#define MAC_CONTROL_DRO           0x00800000  /* Disable Receive Own */
-#define MAC_CONTROL_EXT_LOOPBACK  0x00400000  /* Reserved (ext loopback?) */
-#define MAC_CONTROL_OM            0x00200000  /* Loopback Operating Mode */
-#define MAC_CONTROL_F             0x00100000  /* Full Duplex Mode */
-#define MAC_CONTROL_PM            0x00080000  /* Pass All Multicast */
-#define MAC_CONTROL_PR            0x00040000  /* Promiscuous Mode */
-#define MAC_CONTROL_IF            0x00020000  /* Inverse Filtering */
-#define MAC_CONTROL_PB            0x00010000  /* Pass Bad Frames */
-#define MAC_CONTROL_HO            0x00008000  /* Hash Only Filtering Mode */
-#define MAC_CONTROL_HP            0x00002000  /* Hash/Perfect Filtering Mode */
-#define MAC_CONTROL_LCC           0x00001000  /* Late Collision Control */
-#define MAC_CONTROL_DBF           0x00000800  /* Disable Broadcast Frames */
-#define MAC_CONTROL_DRTY          0x00000400  /* Disable Retry */
-#define MAC_CONTROL_ASTP          0x00000100  /* Automatic Pad Stripping */
-#define MAC_CONTROL_BOLMT_10      0x00000000  /* Back Off Limit 10 */
-#define MAC_CONTROL_BOLMT_8       0x00000040  /* Back Off Limit 8 */
-#define MAC_CONTROL_BOLMT_4       0x00000080  /* Back Off Limit 4 */
-#define MAC_CONTROL_BOLMT_1       0x000000c0  /* Back Off Limit 1 */
-#define MAC_CONTROL_DC            0x00000020  /* Deferral Check */
-#define MAC_CONTROL_TE            0x00000008  /* Transmitter Enable */
-#define MAC_CONTROL_RE            0x00000004  /* Receiver Enable */
-
-/* MAC FLOW CTRL defines */
-#define MAC_FLOW_CONTROL_PT_MASK  0xffff0000  /* Pause Time Mask */
-#define MAC_FLOW_CONTROL_PT_SHIFT 16
-#define MAC_FLOW_CONTROL_PCF      0x00000004  /* Pass Control Frames */
-#define MAC_FLOW_CONTROL_FCE      0x00000002  /* Flow Control Enable */
-#define MAC_FLOW_CONTROL_PAUSE    0x00000001  /* Flow Control Busy ... */
-
-/* MII ADDR  defines */
-#define MAC_MII_ADDR_WRITE        0x00000002  /* MII Write */
-#define MAC_MII_ADDR_BUSY         0x00000001  /* MII Busy */
-#define MAC_MII_ADDR_PHY_MASK     0x0000001f  /* MII PHY address mask */
-#define MAC_MII_ADDR_PHY_SHIFT    11          /* MII PHY address shift */
-#define MAC_MII_ADDR_REG_MASK     0x0000001f  /* MII register mask */
-#define MAC_MII_ADDR_REG_SHIFT    6           /* MII register shift */
-
-/* MAC Management Counters register */
-#define MMC_CONTROL               0x00000100  /* MMC Control */
-#define MMC_HIGH_INTR             0x00000104  /* MMC High Interrupt */
-#define MMC_LOW_INTR              0x00000108  /* MMC Low Interrupt */
-#define MMC_HIGH_INTR_MASK        0x0000010c  /* MMC High Interrupt Mask */
-#define MMC_LOW_INTR_MASK         0x00000110  /* MMC Low Interrupt Mask */
-
-#define MMC_CONTROL_MAX_FRM_MASK  0x0003ff8   /* Maximum Frame Size */
-#define MMC_CONTROL_MAX_FRM_SHIFT 3
-#define MMC_CONTROL_MAX_FRAME 	  0x7FF
+
+/* STMAC Control & Status Register (CSR) offsets */
+#ifdef CONFIG_DRIVER_NETSTMAC
+#define MAC_CONTROL			0x00000000	/* MAC Control */
+#define MAC_ADDR_HIGH			0x00000004	/* MAC Address High */
+#define MAC_ADDR_LOW			0x00000008	/* MAC Address Low */
+#define MAC_HASH_HIGH			0x0000000c	/* Multicast Hash Table High */
+#define MAC_HASH_LOW			0x00000010	/* Multicast Hash Table Low */
+#define MAC_MII_ADDR			0x00000014	/* MII Address */
+#define MAC_MII_DATA			0x00000018	/* MII Data */
+#define MAC_FLOW_CONTROL		0x0000001c	/* Flow Control */
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+/* GMAC Control & Status Register (CSR) offsets */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+#define MAC_CONTROL			0x00000000	/* MAC Configuration */
+//#define MAC_FRAME_FILTER		0x00000004	/* Frame Filter */
+#define MAC_HASH_HIGH			0x00000008	/* Multicast Hash Table High */
+#define MAC_HASH_LOW			0x0000000c	/* Multicast Hash Table Low */
+#define MAC_MII_ADDR			0x00000010	/* MII Address */
+#define MAC_MII_DATA			0x00000014	/* MII Data */
+#define MAC_FLOW_CONTROL		0x00000018	/* Flow Control */
+#define MAC_INT_MASK			0x0000003c	/* Interrupt Mask Register */
+#define MAC_ADDR_HIGH			0x00000040	/* MAC Address 0 High */
+#define MAC_ADDR_LOW			0x00000044	/* MAC Address 0 Low */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+/* STMAC Control Register defines */
+#ifdef CONFIG_DRIVER_NETSTMAC
+#define MAC_CONTROL_RA			0x80000000	/* Receive All Mode */
+//#define MAC_CONTROL_BLE		0x40000000	/* Endian Mode */
+#define MAC_CONTROL_HBD			0x10000000	/* Heartbeat Disable */
+#define MAC_CONTROL_PS			0x08000000	/* Port Select 0:MIII, 1:ENDEC */
+#define MAC_CONTROL_DRO			0x00800000	/* Disable Receive Own */
+//#define MAC_CONTROL_EXT_LOOPBACK	0x00400000	/* Reserved (ext loopback?) */
+//#define MAC_CONTROL_OM		0x00200000	/* Loopback Operating Mode */
+#define MAC_CONTROL_F			0x00100000	/* Full Duplex Mode */
+#define MAC_CONTROL_PM			0x00080000	/* Pass All Multicast */
+#define MAC_CONTROL_PR			0x00040000	/* Promiscuous Mode */
+#define MAC_CONTROL_IF			0x00020000	/* Inverse Filtering */
+//#define MAC_CONTROL_PB		0x00010000	/* Pass Bad Frames */
+#define MAC_CONTROL_HO			0x00008000	/* Hash Only Filtering Mode */
+#define MAC_CONTROL_HP			0x00002000	/* Hash/Perfect Filtering Mode */
+//#define MAC_CONTROL_LCC		0x00001000	/* Late Collision Control */
+//#define MAC_CONTROL_DBF		0x00000800	/* Disable Broadcast Frames */
+//#define MAC_CONTROL_DRTY		0x00000400	/* Disable Retry */
+//#define MAC_CONTROL_ASTP		0x00000100	/* Automatic Pad Stripping */
+//#define MAC_CONTROL_BOLMT_10		0x00000000	/* Back Off Limit 10 */
+//#define MAC_CONTROL_BOLMT_8		0x00000040	/* Back Off Limit 8 */
+//#define MAC_CONTROL_BOLMT_4		0x00000080	/* Back Off Limit 4 */
+//#define MAC_CONTROL_BOLMT_1		0x000000c0	/* Back Off Limit 1 */
+//#define MAC_CONTROL_DC		0x00000020	/* Deferral Check */
+#define MAC_CONTROL_TE			0x00000008	/* Transmitter Enable */
+#define MAC_CONTROL_RE			0x00000004	/* Receiver Enable */
+#define MAC_CORE_INIT			(MAC_CONTROL_HBD)
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+/* GMAC Control Register defines */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+//#define MAC_CONTROL_TC		0x01000000	/* Transmit Conf. in RGMII/SGMII */
+//#define MAC_CONTROL_WD		0x00800000	/* Disable Watchdog on Receive */
+#define MAC_CONTROL_JD			0x00400000	/* Jabber disable */
+//#define MAC_CONTROL_BE		0x00200000	/* Frame Burst Enable */
+//#define MAC_CONTROL_JE		0x00100000	/* Jumbo Frame */
+//#define MAC_CONTROL_DCRS		0x00010000	/* Disable Carrier Sense During TX */
+#define MAC_CONTROL_PS			0x00008000	/* Port Select 0:GMI, 1:MII */
+#define MAC_CONTROL_FES			0x00004000	/* Speed 0:10, 1:100 */
+//#define MAC_CONTROL_DO		0x00002000	/* Disable RX Own */
+//#define MAC_CONTROL_LM		0x00001000	/* Loop-back Mode */
+#define MAC_CONTROL_DM			0x00000800	/* Duplex Mode */
+#define MAC_CONTROL_IPC			0x00000400	/* Checksum Offload */
+//#define MAC_CONTROL_DR		0x00000200	/* Disable Retry */
+//#define MAC_CONTROL_LUD		0x00000100	/* Link Up/Down */
+#define MAC_CONTROL_ACS			0x00000080	/* Automatic Pad Stripping */
+//#define MAC_CONTROL_DC		0x00000010	/* Deferral Check */
+#define MAC_CONTROL_TE			0x00000008	/* Transmitter Enable */
+#define MAC_CONTROL_RE			0x00000004	/* Receiver Enable */
+#define MAC_CORE_INIT	(MAC_CONTROL_JD | MAC_CONTROL_PS | MAC_CONTROL_ACS | MAC_CONTROL_IPC)
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+/* MAC Flow Control Register defines */
+#define MAC_FLOW_CONTROL_PT_MASK	0xffff0000	/* Pause Time Mask */
+#define MAC_FLOW_CONTROL_PT_SHIFT	16		/* Pause Time Shift */
+//#define GMAC_FLOW_CTRL_FCB_BPA	0x00000001	/* Flow Control Busy ... */
+/* STMAC Flow Control Register defines */
+#ifdef CONFIG_DRIVER_NETSTMAC
+#define MAC_FLOW_CONTROL_PCF		0x00000004	/* Pass Control Frames */
+#define MAC_FLOW_CONTROL_FCE		0x00000002	/* Flow Control Enable */
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+/* GMAC Flow Control Register defines */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+#define MAC_FLOW_CONTROL_RFE		0x00000004	/* RX Flow Control Enable */
+#define MAC_FLOW_CONTROL_TFE		0x00000002	/* TX Flow Control Enable */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+/* MII Address defines */
+#define MAC_MII_ADDR_PHY_MASK		0x0000001f	/* MII PHY Address Mask */
+#define MAC_MII_ADDR_PHY_SHIFT		11		/* MII PHY Address Shift */
+#define MAC_MII_ADDR_REG_MASK		0x0000001f	/* MII Register Mask */
+#define MAC_MII_ADDR_REG_SHIFT		6		/* MII Register Shift */
+#define MAC_MII_ADDR_WRITE		0x00000002	/* MII Write */
+#define MAC_MII_ADDR_BUSY		0x00000001	/* MII Busy */
+
 
 /*----------------------------------------------------------------------------
- * 				DMA BLOCK defines
+ *			MAC Management Counters (MMC) Block
  *---------------------------------------------------------------------------*/
-/* DMA CRS Control and Status Register Mapping */
-#define DMA_BUS_MODE              0x00001000  /* Bus Mode */
-#define DMA_XMT_POLL_DEMAND       0x00001004  /* Transmit Poll Demand */
-#define DMA_RCV_POLL_DEMAND       0x00001008  /* Received Poll Demand */
-#define DMA_RCV_BASE_ADDR         0x0000100c  /* Receive List Base */
-#define DMA_TX_BASE_ADDR          0x00001010  /* Transmit List Base */
-#define DMA_STATUS                0x00001014  /* Status Register */
-#define DMA_CONTROL               0x00001018  /* Control (Operational Mode) */
-#define DMA_INTR_ENA              0x0000101c  /* Interrupt Enable */
-#define DMA_MISSED_FRAME_CTR      0x00001020  /* Missed Frame Counter */
-#define DMA_CUR_TX_BUF_ADDR       0x00001050  /* Current Host Transmit Buffer */
-#define DMA_CUR_RX_BUF_ADDR       0x00001054  /* Current Host Receive Buffer */
-
-/*  DMA Bus Mode register defines */
-#define DMA_BUS_MODE_DBO          0x00100000  /* Descriptor Byte Ordering */
-#define DMA_BUS_MODE_PBL_MASK     0x00003f00  /* Programmable Burst Length */
-#define DMA_BUS_MODE_PBL_SHIFT    8
-#define DMA_BUS_MODE_BLE          0x00000080  /* Big Endian/Little Endian */
-#define DMA_BUS_MODE_DSL_MASK     0x0000007c  /* Descriptor Skip Length */
-#define DMA_BUS_MODE_DSL_SHIFT    2           /*       (in DWORDS)      */
-#define DMA_BUS_MODE_BAR_BUS      0x00000002  /* Bar-Bus Arbitration */
-#define DMA_BUS_MODE_SFT_RESET    0x00000001  /* Software Reset */
-#define DMA_BUS_MODE_DEFAULT      0x00000000
-
-/* DMA Status register defines */
-#define DMA_STATUS_EB_MASK        0x00380000  /* Error Bits Mask */
-#define DMA_STATUS_EB_TX_ABORT    0x00080000  /* Error Bits - TX Abort */
-#define DMA_STATUS_EB_RX_ABORT    0x00100000  /* Error Bits - RX Abort */
-#define DMA_STATUS_TS_MASK        0x00700000  /* Transmit Process State */
-#define DMA_STATUS_TS_SHIFT       20
-#define DMA_STATUS_RS_MASK        0x000e0000  /* Receive Process State */
-#define DMA_STATUS_RS_SHIFT       17
-#define DMA_STATUS_NIS            0x00010000  /* Normal Interrupt Summary */
-#define DMA_STATUS_AIS            0x00008000  /* Abnormal Interrupt Summary */
-#define DMA_STATUS_ERI            0x00004000  /* Early Receive Interrupt */
-#define DMA_STATUS_FBI            0x00002000  /* Fatal Bus Error Interrupt */
-#define DMA_STATUS_ETI            0x00000400  /* Early Transmit Interrupt */
-#define DMA_STATUS_RWT            0x00000200  /* Receive Watchdog Timeout */
-#define DMA_STATUS_RPS            0x00000100  /* Receive Process Stopped */
-#define DMA_STATUS_RU             0x00000080  /* Receive Buffer Unavailable */
-#define DMA_STATUS_RI             0x00000040  /* Receive Interrupt */
-#define DMA_STATUS_UNF            0x00000020  /* Transmit Underflow */
-#define DMA_STATUS_OVF            0x00000010  /* Receive Overflow */
-#define DMA_STATUS_TJT            0x00000008  /* Transmit Jabber Timeout */
-#define DMA_STATUS_TU             0x00000004  /* Transmit Buffer Unavailable */
-#define DMA_STATUS_TPS            0x00000002  /* Transmit Process Stopped */
-#define DMA_STATUS_TI             0x00000001  /* Transmit Interrupt */
-
-/* DMA Control register defines */
-#define DMA_CONTROL_SF            0x00200000  /* Store And Forward */
-#define DMA_CONTROL_TTC_MASK      0x0001c000  /* Transmit Threshold Control */
-#define DMA_CONTROL_TTC_32        0x00000000  /* Threshold is 32 DWORDS */
-#define DMA_CONTROL_TTC_64        0x00004000  /* Threshold is 64 DWORDS */
-#define DMA_CONTROL_TTC_128       0x00008000  /* Threshold is 128 DWORDS */
-#define DMA_CONTROL_TTC_256       0x0000c000  /* Threshold is 256 DWORDS */
-#define DMA_CONTROL_TTC_18        0x00010000  /* Threshold is 18 DWORDS */
-#define DMA_CONTROL_TTC_24        0x00014000  /* Threshold is 24 DWORDS */
-#define DMA_CONTROL_TTC__32_      0x00018000  /* Threshold is 32 DWORDS */
-#define DMA_CONTROL_TTC_40        0x0001c000  /* Threshold is 40 DWORDS */
-#define DMA_CONTROL_ST            0x00002000  /* Start/Stop Transmission */
-#define DMA_CONTROL_SE            0x00000008  /* Stop On Empty */
-#define DMA_CONTROL_OSF           0x00000004  /* Operate On 2nd Frame */
-#define DMA_CONTROL_SR            0x00000002  /* Start/Stop Receive */
-
-/* DMA Interrupt Enable register defines */
-#define DMA_INTR_ENA_NIE          0x00010000  /* Normal Interrupt Summary */
-#define DMA_INTR_ENA_AIE          0x00008000  /* Abnormal Interrupt Summary */
-#define DMA_INTR_ENA_ERE          0x00004000  /* Early Receive */
-#define DMA_INTR_ENA_FBE          0x00002000  /* Fatal Bus Error */
-#define DMA_INTR_ENA_ETE          0x00000400  /* Early Transmit */
-#define DMA_INTR_ENA_RWE          0x00000200  /* Receive Watchdog */
-#define DMA_INTR_ENA_RSE          0x00000100  /* Receive Stopped */
-#define DMA_INTR_ENA_RUE          0x00000080  /* Receive Buffer Unavailable */
-#define DMA_INTR_ENA_RIE          0x00000040  /* Receive Interrupt */
-#define DMA_INTR_ENA_UNE          0x00000020  /* Underflow */
-#define DMA_INTR_ENA_OVE          0x00000010  /* Receive Overflow */
-#define DMA_INTR_ENA_TJE          0x00000008  /* Transmit Jabber */
-#define DMA_INTR_ENA_TUE          0x00000004  /* Transmit Buffer Unavailable */
-#define DMA_INTR_ENA_TSE          0x00000002  /* Transmit Stopped */
-#define DMA_INTR_ENA_TIE          0x00000001  /* Transmit Interrupt */
-/* DMA default interrupt mask */
-#define DMA_INTR_DEFAULT_MASK 	(DMA_INTR_ENA_NIE | DMA_INTR_ENA_AIE | \
-				DMA_INTR_ENA_FBE | DMA_INTR_ENA_RWE | \
-				DMA_INTR_ENA_RSE | DMA_INTR_ENA_RUE | \
-				DMA_INTR_ENA_RIE | DMA_INTR_ENA_UNE | \
-				DMA_INTR_ENA_OVE | DMA_INTR_ENA_TJE | \
-				DMA_INTR_ENA_TUE | DMA_INTR_ENA_TSE | \
-				/*DMA_INTR_ENA_ERE | DMA_INTR_ENA_ETE | */ \
-				DMA_INTR_ENA_TIE)
-
-/* STMAC110 DMA Missed Frame Counter register defines */
-#define DMA_MISSED_FRAME_OVE      0x10000000  /* FIFO Overflow Overflow */
-#define DMA_MISSED_FRAME_OVE_CNTR 0x0ffe0000  /* Overflow Frame Counter */
-#define DMA_MISSED_FRAME_OVE_M    0x00010000  /* Missed Frame Overflow */
-#define DMA_MISSED_FRAME_M_CNTR   0x0000ffff  /* Missed Frame Couinter */
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+/* MAC Management Counters Register offsets */
+#define MMC_CONTROL			0x00000100	/* MMC Control */
+
+/* MAC Management Counters Register defines */
+#define MMC_COUNTER_FREEZE		0x00000008	/* Freeze the Counters */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
 
 /*----------------------------------------------------------------------------
- * 		    	    Descriptor defines
+ *			DMA Block
  *---------------------------------------------------------------------------*/
-/* Common fields */
-#define OWN_BIT			0x80000000  /* Own Bit (owned by hardware) */
-#define DES1_CONTROL_CH		0x01000000  /* Second Address Chained */
-#define DES1_CONTROL_TER	0x02000000  /* End of Ring */
-#define DES1_RBS2_SIZE_MASK	0x003ff800  /* Buffer 2 Size Mask */
-#define DES1_RBS2_SIZE_SHIFT	11          /* Buffer 2 Size Shift */
-#define DES1_RBS1_SIZE_MASK	0x000007ff  /* Buffer 1 Size Mask */
-#define DES1_RBS1_SIZE_SHIFT	0           /* Buffer 1 Size Shift */
-
-/* Receive Descriptor */
-#define RDES0_STATUS_FILTER_FAIL  0x40000000  /* Filtering Fail */
-#define RDES0_STATUS_FL_MASK      0x3fff0000  /* Frame Length Mask */
-#define RDES0_STATUS_FL_SHIFT     16          /* Frame Length Shift */
-#define RDES0_STATUS_ES           0x00008000  /* Error Summary */
-#define RDES0_STATUS_DE           0x00004000  /* Descriptor Error */
-#define RDES0_STATUS_PFE          0x00002000  /* Partial Frame Error */
-#define RDES0_STATUS_LENGTH_ERROR 0x00001000  /* Length Error */
-#define RDES0_STATUS_RUNT_FRM     0x00000800  /* Runt Frame */
-#define RDES0_STATUS_MULTICST_FRM 0x00000400  /* Multicast Frame */
-#define RDES0_STATUS_FS           0x00000200  /* First Descriptor */
-#define RDES0_STATUS_LS           0x00000100  /* Last Descriptor */
-#define RDES0_STATUS_TL           0x00000080  /* Frame Too Long */
-#define RDES0_STATUS_COL_SEEN     0x00000040  /* Collision Seen */
-#define RDES0_STATUS_FRM_TYPE     0x00000020  /* Frame Type */
-#define RDES0_STATUS_RX_WATCHDOG  0x00000010  /* Receive Watchdog */
-#define RDES0_STATUS_MII_ERR      0x00000008  /* Report on MII Error */
-#define RDES0_STATUS_DRIBBLE      0x00000004  /* Dribbling Bit */
-#define RDES0_STATUS_CE           0x00000002  /* CRC Error */
-#define RDES0_STATUS_0            0x00000000  /* Always tied to zero */
-
-#define RDES1_CONTROL_DIOC        0x80000000  /* Disable Intr On Completion */
-
-/* Transmit Descriptor */
-#define TDES0_STATUS_ES		  0x00008000  /* Error Summary */
-#define TDES0_STATUS_LOSS_CARRIER 0x00000800  /* Loss of Carrier */
-#define TDES0_STATUS_NO_CARRIER   0x00000400  /* No Carrier */
-#define TDES0_STATUS_LATE_COL     0x00000200  /* Late Collision */
-#define TDES0_STATUS_EX_COL       0x00000100  /* Excessive Collisions */
-#define TDES0_STATUS_HRTBT_FAIL   0x00000080  /* Heartbeat Fail */
-#define TDES0_STATUS_COLCNT_MASK  0x00000078  /* Collision Count Mask */
-#define TDES0_STATUS_COLCNT_SHIFT 3           /* Collision Count Shift */
-#define TDES0_STATUS_EX_DEF       0x00000004  /* Excessive Deferrals */
-#define TDES0_STATUS_UF           0x00000002  /* Underflow Error */
-#define TDES0_STATUS_DF           0x00000001  /* Deferred */
-
-#define TDES1_CONTROL_IC          0x80000000  /* Interrupt on Completion */
-#define TDES1_CONTROL_LS          0x40000000  /* Last Segment */
-#define TDES1_CONTROL_FS          0x20000000  /* First Segment */
-#define TDES1_CONTROL_AC          0x04000000  /* Add CRC Disable */
-#define TDES1_CONTROL_DPD         0x00800000  /* Disable Padding */
 
-#define STMAC_READ(REG)		readl(CFG_STM_STMAC_BASE+(REG))
-#define STMAC_WRITE(V, REG)	writel(V, CFG_STM_STMAC_BASE+(REG))
+/* DMA Control & Status Register (CSR) offsets */
+#define DMA_BUS_MODE			0x00001000	/* Bus Mode */
+#define DMA_XMT_POLL_DEMAND		0x00001004	/* Transmit Poll Demand */
+#define DMA_RCV_POLL_DEMAND		0x00001008	/* Receive Poll Demand */
+#define DMA_RCV_BASE_ADDR		0x0000100c	/* Receive List Base Address */
+#define DMA_TX_BASE_ADDR		0x00001010	/* Transmit List Base Address */
+#define DMA_STATUS			0x00001014	/* Status Register */
+#define DMA_CONTROL			0x00001018	/* Control (Operational Mode) */
+#define DMA_INTR_ENA			0x0000101c	/* Interrupt Enable */
+//#define DMA_CUR_TX_BUF_ADDR		0x00001050	/* Current Host Transmit Buffer */
+//#define DMA_CUR_RX_BUF_ADDR		0x00001054	/* Current Host Receive Buffer */
+
+/* DMA Bus Mode Register defines */
+//#define DMA_BUS_MODE_DBO		0x00100000	/* Descriptor Byte Ordering */
+//#define DMA_BUS_MODE_PBL_MASK		0x00003f00	/* Programmable Burst Length Mask */
+#define DMA_BUS_MODE_PBL_SHIFT		8		/* Programmable Burst Length Shift */
+//#define DMA_BUS_MODE_BLE		0x00000080	/* Big Endian/Little Endian */
+//#define DMA_BUS_MODE_DSL_MASK		0x0000007c	/* Descriptor Skip Length Mask */
+//#define DMA_BUS_MODE_DSL_SHIFT	2		/*       (in DWORDS)           */
+//#define DMA_BUS_MODE_BAR_BUS		0x00000002	/* Bar-Bus Arbitration */
+#define DMA_BUS_MODE_SFT_RESET		0x00000001	/* Software Reset */
+#define DMA_BUS_MODE_DEFAULT		0x00000000
+
+/* DMA Status Register defines */
+//#define DMA_STATUS_EB_MASK		0x00380000	/* Error Bits Mask */
+//#define DMA_STATUS_EB_TX_ABORT	0x00080000	/* Error Bits - TX Abort */
+//#define DMA_STATUS_EB_RX_ABORT	0x00100000	/* Error Bits - RX Abort */
+//#define DMA_STATUS_TS_MASK		0x00700000	/* Transmit Process State */
+//#define DMA_STATUS_TS_SHIFT		20
+//#define DMA_STATUS_RS_MASK		0x000e0000	/* Receive Process State */
+//#define DMA_STATUS_RS_SHIFT		17
+//#define DMA_STATUS_NIS		0x00010000	/* Normal Interrupt Summary */
+//#define DMA_STATUS_AIS		0x00008000	/* Abnormal Interrupt Summary */
+//#define DMA_STATUS_ERI		0x00004000	/* Early Receive Interrupt */
+//#define DMA_STATUS_FBI		0x00002000	/* Fatal Bus Error Interrupt */
+//#define DMA_STATUS_ETI		0x00000400	/* Early Transmit Interrupt */
+//#define DMA_STATUS_RWT		0x00000200	/* Receive Watchdog Timeout */
+//#define DMA_STATUS_RPS		0x00000100	/* Receive Process Stopped */
+//#define DMA_STATUS_RU			0x00000080	/* Receive Buffer Unavailable */
+//#define DMA_STATUS_RI			0x00000040	/* Receive Interrupt */
+//#define DMA_STATUS_UNF		0x00000020	/* Transmit Underflow */
+//#define DMA_STATUS_OVF		0x00000010	/* Receive Overflow */
+//#define DMA_STATUS_TJT		0x00000008	/* Transmit Jabber Timeout */
+//#define DMA_STATUS_TU			0x00000004	/* Transmit Buffer Unavailable */
+//#define DMA_STATUS_TPS		0x00000002	/* Transmit Process Stopped */
+#define DMA_STATUS_TI			0x00000001	/* Transmit Interrupt */
+
+/* DMA Control (Operation Mode) Register defines */
+#define DMA_CONTROL_ST			0x00002000	/* Start/Stop Transmission */
+#define DMA_CONTROL_SR			0x00000002	/* Start/Stop Receive */
 
-/* MII interface defns */
 
+/*----------------------------------------------------------------------------
+ *			MII defines
+ *---------------------------------------------------------------------------*/
+
+/* MII Register Offsets */
+#define MII_BMCR			0x00		/* Basic Mode Control Register */
+#define MII_BMSR			0x01		/* Basic Mode Status Register */
+#define MII_PHYSID1			0x02		/* PHY Identifier #1 */
+#define MII_PHYSID2			0x03		/* PHY Identifier #2 */
+#define MII_ADVERTISE			0x04		/* AN Advertisement Control Register */
+#define MII_LPA				0x05		/* AN Link Partner Ability Register */
+//#define MII_EXPANSION			0x06		/* AN Expansion Register */
+
+/* Basic Mode Control Register defines */
+//#define BMCR_SPEED1000		0x0040		/* MSB of Speed (1000) */
+//#define BMCR_CTST			0x0080		/* Collision Test */
+//#define BMCR_FULLDPLX			0x0100		/* Full Duplex */
+#define BMCR_ANRESTART			0x0200		/* Auto-Negotiation Restart */
+//#define BMCR_ISOLATE			0x0400		/* Disconnect from the MII */
+//#define BMCR_PDOWN			0x0800		/* Power-down */
+#define BMCR_ANENABLE			0x1000		/* Enable Auto-Negotiation */
+//#define BMCR_SPEED100			0x2000		/* Select 100Mbps */
+//#define BMCR_LOOPBACK			0x4000		/* Enable Loop-back Mode */
+//#define BMCR_RESET			0x8000		/* Software Reset */
+
+/* Basic Mode Status Register defines */
+//#define BMSR_ERCAP			0x0001		/* Extended Capabilities Registers */
+//#define BMSR_JCD			0x0002		/* Jabber Detected */
+#define BMSR_LSTATUS			0x0004		/* Link Status */
+//#define BMSR_ANEGCAPABLE		0x0008		/* Able to do Auto-Negotiation */
+#define BMSR_RFAULT			0x0010		/* Remote Fault Detected */
+#define BMSR_ANEGCOMPLETE		0x0020		/* Auto-Negotiation Complete */
+#define BMSR_10HALF			0x0800		/* Can do 10Mbps, Half-Duplex */
+#define BMSR_10FULL			0x1000		/* Can do 10Mbps, Full-Duplex */
+#define BMSR_100HALF			0x2000		/* Can do 100Mbps, Half-Duplex */
+#define BMSR_100FULL			0x4000		/* Can do 100Mbps, Full-Duplex */
+#define BMSR_100BASE4			0x8000		/* Can do 100Mbps, 4k Packets */
+
+/* Auto-Negotiate Advertisement Control Register defines */
+//#define ADVERTISE_SLCT		0x001f		/* Selector Bits */
+//#define ADVERTISE_CSMA		0x0001		/* Only Selector Supported */
+#define ADVERTISE_10HALF		0x0020		/* Try for 10Mbps Half-Duplex */
+#define ADVERTISE_10FULL		0x0040		/* Try for 10Mbps Full-Duplex */
+#define ADVERTISE_100HALF		0x0080		/* Try for 100Mbps Half-Duplex */
+#define ADVERTISE_100FULL		0x0100		/* Try for 100Mbps Full-Duplex */
+#define ADVERTISE_100BASE4		0x0200		/* Try for 100Mbps 4k Packets */
+//#define ADVERTISE_RFAULT		0x2000		/* Say we can Detect Faults */
+//#define ADVERTISE_LPACK		0x4000		/* Ack Link Partners Response */
+//#define ADVERTISE_NPAGE		0x8000		/* Next Page Capable */
+//#define ADVERTISE_FULL (ADVERTISE_100FULL | ADVERTISE_10FULL | ADVERTISE_CSMA)
+//#define ADVERTISE_ALL (ADVERTISE_10HALF | ADVERTISE_10FULL | ADVERTISE_100HALF | ADVERTISE_100FULL)
+
+/* Auto-Negotiate Link Partner Ability Register defines */
+//#define LPA_SLCT			0x001f		/* Same as Advertise Selector */
+//#define LPA_10HALF			0x0020		/* Can do 10Mbps Half-Duplex */
+#define LPA_10FULL			0x0040		/* Can do 10Mbps Full-Duplex */
+#define LPA_100HALF			0x0080		/* Can do 100Mbps Half-Duplex */
+#define LPA_100FULL			0x0100		/* Can do 100Mbps Full-Duplex */
+//#define LPA_100BASE4			0x0200		/* Can do 100Mbps 4k Packets */
+//#define LPA_RFAULT			0x2000		/* Link Partner Faulted */
+//#define LPA_LPACK			0x4000		/* Link Partner Acknowledged */
+//#define LPA_NPAGE			0x8000		/* Next Page Capable */
+//#define LPA_DUPLEX			(LPA_10FULL | LPA_100FULL)
+//#define LPA_100			(LPA_100FULL | LPA_100HALF | LPA_100BASE4)
+
+
+/*----------------------------------------------------------------------------
+ *			Descriptor Structure
+ *---------------------------------------------------------------------------*/
+
+/* This structure is common for both receive and transmit DMA descriptors.
+ * A descriptor should not be used for storing more than one frame.
+ *
+ * NOTE: the 'enhanced' structures are used the GMAC, whereas
+ * the 10/100 STMAC uses the older (non-enhanced) structures.
+ * */
+struct stmac_dma_des_t
+{
+	/* Receive descriptor */
+	union {
+		struct {
+			u32 des0;	/* RDES0 or TDES0 */
+			u32 des1;	/* RDES1 or TDES1 */
+		} u;
+#ifdef CONFIG_DRIVER_NETSTMAC
+		struct {
+			/* RDES0 */
+			u32 reserved1:1;
+			u32 crc_error:1;
+			u32 dribbling:1;
+			u32 mii_error:1;
+			u32 receive_watchdog:1;
+			u32 frame_type:1;
+			u32 collision:1;
+			u32 frame_too_long:1;
+			u32 last_descriptor:1;
+			u32 first_descriptor:1;
+			u32 multicast_frame:1;
+			u32 runt_frame:1;
+			u32 length_error:1;
+			u32 partial_frame_error:1;
+			u32 descriptor_error:1;
+			u32 error_summary:1;
+			u32 frame_length:14;
+			u32 filtering_fail:1;
+			u32 own:1;
+			/* RDES1 */
+			u32 buffer1_size:11;
+			u32 buffer2_size:11;
+			u32 reserved2:2;
+			u32 second_address_chained:1;
+			u32 end_ring:1;
+			u32 reserved3:5;
+			u32 disable_ic:1;
+		} rx;
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+		struct {
+			/* RDES0 */
+			u32 payload_csum_error:1;
+			u32 crc_error:1;
+			u32 dribbling:1;
+			u32 error_gmii:1;
+			u32 receive_watchdog:1;
+			u32 frame_type:1;
+			u32 late_collision:1;
+			u32 ipc_csum_error:1;
+			u32 last_descriptor:1;
+			u32 first_descriptor:1;
+			u32 vlan_tag:1;
+			u32 overflow_error:1;
+			u32 length_error:1;
+			u32 source_filter_fail:1;
+			u32 descriptor_error:1;
+			u32 error_summary:1;
+			u32 frame_length:14;
+			u32 filtering_fail:1;
+			u32 own:1;
+			/* RDES1 */
+			u32 buffer1_size:13;
+			u32 reserved1:1;
+			u32 second_address_chained:1;
+			u32 end_ring:1;
+			u32 buffer2_size:13;
+			u32 reserved2:2;
+			u32 disable_ic:1;
+		} rx;		/* -- enhanced -- */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+#ifdef CONFIG_DRIVER_NETSTMAC
+		struct {
+			/* TDES0 */
+			u32 deferred:1;
+			u32 underflow_error:1;
+			u32 excessive_deferral:1;
+			u32 collision_count:4;
+			u32 heartbeat_fail:1;
+			u32 excessive_collisions:1;
+			u32 late_collision:1;
+			u32 no_carrier:1;
+			u32 loss_carrier:1;
+			u32 reserved1:3;
+			u32 error_summary:1;
+			u32 reserved2:15;
+			u32 own:1;
+			/* TDES1 */
+			u32 buffer1_size:11;
+			u32 buffer2_size:11;
+			u32 reserved3:1;
+			u32 disable_padding:1;
+			u32 second_address_chained:1;
+			u32 end_ring:1;
+			u32 crc_disable:1;
+			u32 reserved4:2;
+			u32 first_segment:1;
+			u32 last_segment:1;
+			u32 interrupt:1;
+		} tx;
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+		struct {
+			/* TDES0 */
+			u32 deferred:1;
+			u32 underflow_error:1;
+			u32 excessive_deferral:1;
+			u32 collision_count:4;
+			u32 vlan_frame:1;
+			u32 excessive_collisions:1;
+			u32 late_collision:1;
+			u32 no_carrier:1;
+			u32 loss_carrier:1;
+			u32 payload_error:1;
+			u32 frame_flushed:1;
+			u32 jabber_timeout:1;
+			u32 error_summary:1;
+			u32 ip_header_error:1;
+			u32 time_stamp_status:1;
+			u32 reserved1:2;
+			u32 second_address_chained:1;
+			u32 end_ring:1;
+			u32 checksum_insertion:2;
+			u32 reserved2:1;
+			u32 time_stamp_enable:1;
+			u32 disable_padding:1;
+			u32 crc_disable:1;
+			u32 first_segment:1;
+			u32 last_segment:1;
+			u32 interrupt:1;
+			u32 own:1;
+			/* TDES1 */
+			u32 buffer1_size:13;
+			u32 reserved3:3;
+			u32 buffer2_size:13;
+			u32 reserved4:3;
+		} tx;		/* -- enhanced -- */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+	} des01;
+	void * des2;
+	void * des3;
+};
+
+typedef struct stmac_dma_des_t stmac_dma_des;
+
+
+/*----------------------------------------------------------------------------
+ *			Miscellaneous defines
+ *---------------------------------------------------------------------------*/
+
+/* MAC Register Accessors */
+#define STMAC_READ(REG)		readl(CFG_STM_STMAC_BASE+(REG))
+#define STMAC_WRITE(V, REG)	writel((V), CFG_STM_STMAC_BASE+(REG))
+
+/* max delay to wait after performing a MII Register read/write */
 #ifndef CONFIG_STMAC_MII_POLL_BUSY_DELAY
-#define CONFIG_STMAC_MII_POLL_BUSY_DELAY 1000
+#define CONFIG_STMAC_MII_POLL_BUSY_DELAY 1000		/* ticks */
 #endif
 
+/* max delay to wait for a PHY Auto-Negotiate to take */
 #ifndef CONFIG_STMAC_AUTONEG_TIMEOUT
-#define CONFIG_STMAC_AUTONEG_TIMEOUT  (10*CFG_HZ) /* ticks */
+#define CONFIG_STMAC_AUTONEG_TIMEOUT	(10*CFG_HZ)	/* 10 seconds */
 #endif
 
+/* max delay to wait for a TX to take */
 #ifndef CONFIG_STMAC_TX_TIMEOUT
-#define CONFIG_STMAC_TX_TIMEOUT  (5*CFG_HZ) /* ticks */
+#define CONFIG_STMAC_TX_TIMEOUT		(5*CFG_HZ)	/* 5 seconds */
 #endif
 
-#define MII_BMCR            0x00        /* Basic mode control register */
-#define MII_BMSR            0x01        /* Basic mode status register  */
-#define MII_PHYSID1         0x02        /* PHYS ID 1                   */
-#define MII_PHYSID2         0x03        /* PHYS ID 2                   */
-#define MII_ADVERTISE       0x04        /* Advertisement control reg   */
-#define MII_LPA             0x05        /* Link partner ability reg    */
-#define MII_EXPANSION       0x06        /* Expansion register          */
-
-#if defined(CONFIG_STMAC_STE10XP)
-#define MII_DCOUNTER        0x12        /* Disconnect counter          */
-#define MII_FCSCOUNTER      0x13        /* False carrier counter       */
-#define MII_NWAYTEST        0x14        /* N-way auto-neg test reg     */
-#define MII_RERRCOUNTER     0x15        /* Receive error counter       */
-#define MII_SREVISION       0x16        /* Silicon revision            */
-#define MII_RESV1           0x17        /* Reserved...                 */
-#define MII_LBRERROR        0x18        /* Lpback, rx, bypass error    */
-#define MII_PHYADDR         0x19        /* PHY address                 */
-#define MII_RESV2           0x1a        /* Reserved...                 */
-#define MII_TPISTATUS       0x1b        /* TPI status for 10mbps       */
-#define MII_NCONFIG         0x1c        /* Network interface config    */
-#endif	/* CONFIG_STMAC_STE10XP */
-
-/* Basic mode control register. */
-#define BMCR_RESV               0x003f  /* Unused...                   */
-#define BMCR_SPEED1000          0x0040  /* MSB of Speed (1000)         */
-#define BMCR_CTST               0x0080  /* Collision test              */
-#define BMCR_FULLDPLX           0x0100  /* Full duplex                 */
-#define BMCR_ANRESTART          0x0200  /* Auto negotiation restart    */
-#define BMCR_ISOLATE            0x0400  /* Disconnect DP83840 from MII */
-#define BMCR_PDOWN              0x0800  /* Powerdown the DP83840       */
-#define BMCR_ANENABLE           0x1000  /* Enable auto negotiation     */
-#define BMCR_SPEED100           0x2000  /* Select 100Mbps              */
-#define BMCR_LOOPBACK           0x4000  /* TXD loopback bits           */
-#define BMCR_RESET              0x8000  /* Reset                       */
-
-/* Basic mode status register. */
-#define BMSR_ERCAP              0x0001  /* Ext-reg capability          */
-#define BMSR_JCD                0x0002  /* Jabber detected             */
-#define BMSR_LSTATUS            0x0004  /* Link status                 */
-#define BMSR_ANEGCAPABLE        0x0008  /* Able to do auto-negotiation */
-#define BMSR_RFAULT             0x0010  /* Remote fault detected       */
-#define BMSR_ANEGCOMPLETE       0x0020  /* Auto-negotiation complete   */
-#define BMSR_RESV               0x07c0  /* Unused...                   */
-#define BMSR_10HALF             0x0800  /* Can do 10mbps, half-duplex  */
-#define BMSR_10FULL             0x1000  /* Can do 10mbps, full-duplex  */
-#define BMSR_100HALF            0x2000  /* Can do 100mbps, half-duplex */
-#define BMSR_100FULL            0x4000  /* Can do 100mbps, full-duplex */
-#define BMSR_100BASE4           0x8000  /* Can do 100mbps, 4k packets  */
-
-
-/* Advertisement control register. */
-#define ADVERTISE_SLCT          0x001f  /* Selector bits               */
-#define ADVERTISE_CSMA          0x0001  /* Only selector supported     */
-#define ADVERTISE_10HALF        0x0020  /* Try for 10mbps half-duplex  */
-#define ADVERTISE_10FULL        0x0040  /* Try for 10mbps full-duplex  */
-#define ADVERTISE_100HALF       0x0080  /* Try for 100mbps half-duplex */
-#define ADVERTISE_100FULL       0x0100  /* Try for 100mbps full-duplex */
-#define ADVERTISE_100BASE4      0x0200  /* Try for 100mbps 4k packets  */
-#define ADVERTISE_RESV          0x1c00  /* Unused...                   */
-#define ADVERTISE_RFAULT        0x2000  /* Say we can detect faults    */
-#define ADVERTISE_LPACK         0x4000  /* Ack link partners response  */
-#define ADVERTISE_NPAGE         0x8000  /* Next page bit               */
-
-#define ADVERTISE_FULL (ADVERTISE_100FULL | ADVERTISE_10FULL | \
-                        ADVERTISE_CSMA)
-#define ADVERTISE_ALL (ADVERTISE_10HALF | ADVERTISE_10FULL | \
-                       ADVERTISE_100HALF | ADVERTISE_100FULL)
-
-/* Link partner ability register. */
-#define LPA_SLCT                0x001f  /* Same as advertise selector  */
-#define LPA_10HALF              0x0020  /* Can do 10mbps half-duplex   */
-#define LPA_10FULL              0x0040  /* Can do 10mbps full-duplex   */
-#define LPA_100HALF             0x0080  /* Can do 100mbps half-duplex  */
-#define LPA_100FULL             0x0100  /* Can do 100mbps full-duplex  */
-#define LPA_100BASE4            0x0200  /* Can do 100mbps 4k packets   */
-#define LPA_RESV                0x1c00  /* Unused...                   */
-#define LPA_RFAULT              0x2000  /* Link partner faulted        */
-#define LPA_LPACK               0x4000  /* Link partner acked us       */
-#define LPA_NPAGE               0x8000  /* Next page bit               */
-
-#define LPA_DUPLEX              (LPA_10FULL | LPA_100FULL)
-#define LPA_100                 (LPA_100FULL | LPA_100HALF | LPA_100BASE4)
-
-/* Allocate DMA coherent memory */
-
-#ifdef CONFIG_SH4
-#define DMA_ALLOC(LEN) P2SEGADDR(malloc(LEN))
-#define DMA_FREE(P) free(P)
-#else
-#define DMA_ALLOC(LEN) malloc(LEN)
-#define DMA_FREE(P) free(P)
-#endif
+/* Recommended STBus Bridge Values for GMAC */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+#define STBUS_BRIDGE_OFFSET		0x00007000
+#define STBUS_BRIDGE_MAGIC		0x25C608	/* from validation */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+
diff --git a/drivers/serial/stm-asc.c b/drivers/serial/stm-asc.c
index de241ca..4075e66 100644
--- a/drivers/serial/stm-asc.c
+++ b/drivers/serial/stm-asc.c
@@ -84,7 +84,7 @@
 /*---- Values for the BAUDRATE Register -----------------------*/
 
 
-#if defined(CONFIG_SH_STB7100) || defined(CONFIG_SH_STX7200)
+#if defined(CONFIG_SH_STB7100) || defined(CONFIG_SH_STX7111) || defined(CONFIG_SH_STX7200)
 #define PCLK			(gd->bd->bi_emifrq*1000000)
 #define BAUDRATE_VAL_M0(bps)	(PCLK / (16 * (bps)))
 #define BAUDRATE_VAL_M1(bps)    ( (((bps * (1 << 14))+ (1<<13)) / (PCLK/(1 << 6))))
diff --git a/fs/cramfs/cramfs.c b/fs/cramfs/cramfs.c
index 369d1f1..8f9a4a8 100644
--- a/fs/cramfs/cramfs.c
+++ b/fs/cramfs/cramfs.c
@@ -44,8 +44,23 @@ struct cramfs_super super;
 
 /* CPU address space offset calculation macro, struct part_info offset is
  * device address space offset, so we need to shift it by a device start address. */
+/*
+ * FIXME FIXME FIXME FIXME FIXME FIXME FIXME FIXME
+ * if CFG_NO_FLASH is set, then we have probably NOT got any NOR flash
+ * present, hence 'flash_info' will not exist. This will result in
+ * this code faling to link, as the PART_OFFSET macro assumes it
+ * does exist. We bodge this issue, but defining this macro to
+ * just use an arbirary address - however this will BREAK the
+ * CRMAFS code, so it is a quick hack, and not a proper solution.
+ * We will need a proper solution for this, if CRAMFS is required.
+ */
+#ifdef CFG_NO_FLASH
+#warning CRAMFS is BROKEN if CFG_NO_FLASH is defined!
+#define PART_OFFSET(x)	(0x00000000)	/* will at least compile! */
+#else
 extern flash_info_t flash_info[];
 #define PART_OFFSET(x)	(x->offset + flash_info[x->dev->id->num].start[0])
+#endif	/* CFG_NO_FLASH */
 
 static int cramfs_read_super (struct part_info *info)
 {
diff --git a/include/asm-sh/cache.h b/include/asm-sh/cache.h
index 85cb449..dd26994 100644
--- a/include/asm-sh/cache.h
+++ b/include/asm-sh/cache.h
@@ -20,7 +20,8 @@
 #	define DCACHE_SETS		512
 #	define DCACHE_WAYS		1
 #	define DCACHE_LINESZ		L1_CACHE_BYTES
-#elif defined(CONFIG_CPU_SUBTYPE_SH4_2XX)	/* it's an SH4-200 */
+#elif defined(CONFIG_CPU_SUBTYPE_SH4_2XX)	/* it's an SH4-200 */	\
+   || defined(CONFIG_CPU_SUBTYPE_SH4_3XX)	/* it's an SH4-300 */
 #	define DCACHE_SIZE		32768
 #	define DCACHE_WAY_INCR		(DCACHE_SIZE >> 1)
 #	define DCACHE_ENTRY_SHIFT	5
diff --git a/include/asm-sh/io.h b/include/asm-sh/io.h
index 5e92b50..bd61dd5 100644
--- a/include/asm-sh/io.h
+++ b/include/asm-sh/io.h
@@ -55,6 +55,7 @@
        defined(CONFIG_SH_MB448)	|| \
        defined(CONFIG_SH_HMS1)	|| \
        defined(CONFIG_SH_MB519)	|| \
+       defined(CONFIG_SH_MB618)	|| \
        defined(CONFIG_SH_CB101)
 #  include "asm/io_stb1eval.h"
 #else
diff --git a/include/asm-sh/sh4reg.h b/include/asm-sh/sh4reg.h
index 59fa7f9..2c128de 100644
--- a/include/asm-sh/sh4reg.h
+++ b/include/asm-sh/sh4reg.h
@@ -54,6 +54,7 @@
 #define SH4_CCN_QACR1	SH4_DWORD_REG(0xff00003c)
 #define SH4_CCN_CVR	SH4_DWORD_REG(0xff000040)
 #define SH4_CCN_PRR	SH4_DWORD_REG(0xff000044)
+#define SH4_CCN_PASCR	SH4_DWORD_REG(0xff000070)
 
 /* Some bits in the CCN.CCR register */
 #define SH4_CCR_OCE	(1<<0)
@@ -69,6 +70,9 @@
 #define	SH4_MMUCR_TI	(1<<2)		/* MMUCR.TI */
 #define	SH4_MMUCR_SE	(1<<4)		/* MMUCR.SE */
 
+/* Some bits in the CCN.PASCR register */
+#define	SH4_PASCR_SE	(1<<31)		/* PASCR.SE */
+
 
 /* User Break Controller control registers (common to all SH4 variants) */
 #define SH4_UBC_BARA	SH4_DWORD_REG(0xff200000)
diff --git a/include/asm-sh/st40reg.h b/include/asm-sh/st40reg.h
index 724b178..c8798d3 100644
--- a/include/asm-sh/st40reg.h
+++ b/include/asm-sh/st40reg.h
@@ -64,6 +64,8 @@
 #define ST40_CPG_WTCSR			SH4_WORD_REG(ST40_CPG_REGS_BASE + 0x0c)
 #define ST40_CPG_WTCSR_R		SH4_BYTE_REG(ST40_CPG_REGS_BASE + 0x0c)
 #define ST40_CPG_STBCR2			SH4_BYTE_REG(ST40_CPG_REGS_BASE + 0x10)
+#define ST40_CPG_WTCSR2			SH4_WORD_REG(ST40_CPG_REGS_BASE + 0x1c)
+#define ST40_CPG_WTCSR2_R		SH4_BYTE_REG(ST40_CPG_REGS_BASE + 0x1c)
 #define ST40_CPG_FRQCR2			SH4_WORD_REG(ST40_CPG_REGS_BASE + 0xc0)
 
 /* Interrupt controller registers (all ST40 variants) */
diff --git a/include/asm-sh/stbus.h b/include/asm-sh/stbus.h
index 5c20efa..c88a45d 100644
--- a/include/asm-sh/stbus.h
+++ b/include/asm-sh/stbus.h
@@ -31,9 +31,10 @@
 
 /* Defines for the USB controller register offsets. */
 #define AHB2STBUS_WRAPPER_GLUE_BASE	(CFG_USB_BASE + 0x00000000)
-#define AHB2STBUS_OHCI_BASE		(CFG_USB_BASE + 0x000ffc00)
 #define AHB2STBUS_PROTOCOL_BASE		(CFG_USB_BASE + 0x000fff00)
 
+#if defined(CONFIG_SH_STB7000) || defined(CONFIG_SH_STX7200)
+
 /* The transaction opcode is programmed in this register. */
 #define AHB2STBUS_STBUS_OPC		(AHB2STBUS_PROTOCOL_BASE + 0x00)
 #define AHB2STBUS_STBUS_OPC_4BIT	0x00
@@ -62,6 +63,13 @@
 #define AHB2STBUS_CHUNKSIZE_32		0x5
 #define AHB2STBUS_CHUNKSIZE_64		0x6
 
+#elif defined(CONFIG_SH_STX7111)
+
+/* No documentation for this */
+#define AHB2STBUS_STBUS_CONFIG		(AHB2STBUS_PROTOCOL_BASE + 0x04)
+
+#endif
+
 /* AHB Strap options are programmed in this register. */
 #define AHB2STBUS_STRAP			(AHB2STBUS_WRAPPER_GLUE_BASE + 0x14)
 #define AHB2STBUS_STRAP_PLL		0x08	/* PLL_PWR_DWN */
diff --git a/include/asm-sh/stx7111reg.h b/include/asm-sh/stx7111reg.h
new file mode 100644
index 0000000..4833c16
--- /dev/null
+++ b/include/asm-sh/stx7111reg.h
@@ -0,0 +1,332 @@
+/*
+ * Copyright (C) STMicroelectronics Ltd. 2008.
+ *
+ * All rights reserved.
+ */
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/bare/sh4reg/sti7111reg.h
+ */
+
+
+#ifndef __STX7111REG_H
+#define __STX7111REG_H
+
+#include "sh4regtype.h"
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Peripheral versions
+ */
+
+#ifndef ST40_LMIGP_VERSION
+#define ST40_LMIGP_VERSION 1
+#endif
+#ifndef ST40_NAND_CONTROLLER_VERSION
+#define ST40_NAND_CONTROLLER_VERSION 1
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Base addresses for control register banks.
+ */
+
+/* Generic SH4 control registers */
+#ifndef SH4_TMU_REGS_BASE
+#define SH4_TMU_REGS_BASE 0xffd80000
+#endif
+
+/* Common ST40 control registers */
+#ifndef ST40_CPG_REGS_BASE
+#define ST40_CPG_REGS_BASE 0xffc00000
+#endif
+#ifndef ST40_INTC_REGS_BASE
+#define ST40_INTC_REGS_BASE 0xffd00000
+#endif
+#ifndef ST40_SCIF2_REGS_BASE
+#define ST40_SCIF2_REGS_BASE 0xffe80000
+#endif
+
+#ifndef STX7111_COMMS_BASE
+#define STX7111_COMMS_BASE 0xfd000000
+#endif
+
+#ifndef ST40_ILC_REGS_BASE
+#define ST40_ILC_REGS_BASE STX7111_COMMS_BASE
+#endif
+
+/* STx7111 control registers */
+#ifndef STX7111_SYSCONF_REGS_BASE
+#define STX7111_SYSCONF_REGS_BASE 0xfe001000
+#endif
+
+#ifndef STX7111_CLOCKGENA_REGS_BASE
+#define STX7111_CLOCKGENA_REGS_BASE 0xfe213000
+#endif
+
+#ifndef STX7111_CLOCKGENB_REGS_BASE
+#define STX7111_CLOCKGENB_REGS_BASE 0xfe000000
+#endif
+
+/* System Architecture Volume 2: Bus Interfaces */
+#ifndef ST40_LMI_REGS_BASE
+#define ST40_LMI_REGS_BASE 0xfe901000
+#endif
+#ifndef ST40_EMI_REGS_BASE
+#define ST40_EMI_REGS_BASE 0xfe700000
+#endif
+
+/* System Architecture Volume 4: I/O Devices */
+#ifndef ST40_PIO0_REGS_BASE
+#define ST40_PIO0_REGS_BASE (STX7111_COMMS_BASE + 0x00020000)
+#endif
+#ifndef ST40_PIO1_REGS_BASE
+#define ST40_PIO1_REGS_BASE (STX7111_COMMS_BASE + 0x00021000)
+#endif
+#ifndef ST40_PIO2_REGS_BASE
+#define ST40_PIO2_REGS_BASE (STX7111_COMMS_BASE + 0x00022000)
+#endif
+#ifndef ST40_PIO3_REGS_BASE
+#define ST40_PIO3_REGS_BASE (STX7111_COMMS_BASE + 0x00023000)
+#endif
+#ifndef ST40_PIO4_REGS_BASE
+#define ST40_PIO4_REGS_BASE (STX7111_COMMS_BASE + 0x00024000)
+#endif
+#ifndef ST40_PIO5_REGS_BASE
+#define ST40_PIO5_REGS_BASE (STX7111_COMMS_BASE + 0x00025000)
+#endif
+#ifndef ST40_PIO6_REGS_BASE
+#define ST40_PIO6_REGS_BASE (STX7111_COMMS_BASE + 0x00026000)
+#endif
+#ifndef ST40_ASC0_REGS_BASE
+#define ST40_ASC0_REGS_BASE (STX7111_COMMS_BASE + 0x00030000)
+#endif
+#ifndef ST40_ASC1_REGS_BASE
+#define ST40_ASC1_REGS_BASE (STX7111_COMMS_BASE + 0x00031000)
+#endif
+#ifndef ST40_ASC2_REGS_BASE
+#define ST40_ASC2_REGS_BASE (STX7111_COMMS_BASE + 0x00032000)
+#endif
+#ifndef ST40_ASC3_REGS_BASE
+#define ST40_ASC3_REGS_BASE (STX7111_COMMS_BASE + 0x00033000)
+#endif
+#ifndef ST40_SSC0_REGS_BASE
+#define ST40_SSC0_REGS_BASE (STX7111_COMMS_BASE + 0x00040000)
+#endif
+#ifndef ST40_SSC1_REGS_BASE
+#define ST40_SSC1_REGS_BASE (STX7111_COMMS_BASE + 0x00041000)
+#endif
+#ifndef ST40_SSC2_REGS_BASE
+#define ST40_SSC2_REGS_BASE (STX7111_COMMS_BASE + 0x00042000)
+#endif
+#ifndef ST40_SSC3_REGS_BASE
+#define ST40_SSC3_REGS_BASE (STX7111_COMMS_BASE + 0x00043000)
+#endif
+#ifndef ST40_MAILBOX0_REGS_BASE
+#define ST40_MAILBOX0_REGS_BASE 0xfe211000
+#endif
+#ifndef ST40_MAILBOX1_REGS_BASE
+#define ST40_MAILBOX1_REGS_BASE (ST40_MAILBOX0_REGS_BASE + 0x1000)
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+#include "st40reg.h"
+
+/*
+ * STx7111 control registers
+ */
+
+/* Clock Generator control registers (STx7111 variant) */
+#define STX7111_CLOCKGENA_PLL0_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x00)
+#define STX7111_CLOCKGENA_PLL1_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x04)
+#define STX7111_CLOCKGENA_POWER_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x10)
+#define STX7111_CLOCKGENA_CLKOPSRC_SWITCH_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x14)
+#define STX7111_CLOCKGENA_CLKOPSRC_SWITCH_CFG2	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x24)
+#define STX7111_CLOCKGENA_CLKOBS_MUX1_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x30)
+#define STX7111_CLOCKGENA_CLKOBS_MUX2_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x48)
+#define STX7111_CLOCKGENA_OSC_DIV0_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x800)
+#define STX7111_CLOCKGENA_OSC_DIV1_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x804)
+#define STX7111_CLOCKGENA_OSC_DIV2_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x808)
+#define STX7111_CLOCKGENA_OSC_DIV3_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x80c)
+#define STX7111_CLOCKGENA_OSC_DIV4_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x810)
+#define STX7111_CLOCKGENA_OSC_DIV5_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x814)
+#define STX7111_CLOCKGENA_OSC_DIV6_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x818)
+#define STX7111_CLOCKGENA_OSC_DIV7_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x81c)
+#define STX7111_CLOCKGENA_OSC_DIV8_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x820)
+#define STX7111_CLOCKGENA_OSC_DIV9_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x824)
+#define STX7111_CLOCKGENA_OSC_DIV10_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x828)
+#define STX7111_CLOCKGENA_OSC_DIV11_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x82c)
+#define STX7111_CLOCKGENA_OSC_DIV12_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x830)
+#define STX7111_CLOCKGENA_OSC_DIV13_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x834)
+#define STX7111_CLOCKGENA_OSC_DIV14_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x838)
+#define STX7111_CLOCKGENA_OSC_DIV15_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x83c)
+#define STX7111_CLOCKGENA_OSC_DIV16_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x840)
+#define STX7111_CLOCKGENA_OSC_DIV17_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x844)
+#define STX7111_CLOCKGENA_PLL0HS_DIV0_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x900)
+#define STX7111_CLOCKGENA_PLL0HS_DIV1_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x904)
+#define STX7111_CLOCKGENA_PLL0HS_DIV2_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x908)
+#define STX7111_CLOCKGENA_PLL0HS_DIV3_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x90c)
+#define STX7111_CLOCKGENA_PLL0LS_DIV4_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa10)
+#define STX7111_CLOCKGENA_PLL0LS_DIV5_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa14)
+#define STX7111_CLOCKGENA_PLL0LS_DIV6_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa18)
+#define STX7111_CLOCKGENA_PLL0LS_DIV7_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa1c)
+#define STX7111_CLOCKGENA_PLL0LS_DIV8_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa20)
+#define STX7111_CLOCKGENA_PLL0LS_DIV9_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa24)
+#define STX7111_CLOCKGENA_PLL0LS_DIV10_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa28)
+#define STX7111_CLOCKGENA_PLL0LS_DIV11_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa2c)
+#define STX7111_CLOCKGENA_PLL0LS_DIV12_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa30)
+#define STX7111_CLOCKGENA_PLL0LS_DIV13_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa34)
+#define STX7111_CLOCKGENA_PLL0LS_DIV14_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa38)
+#define STX7111_CLOCKGENA_PLL0LS_DIV15_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa3c0)
+#define STX7111_CLOCKGENA_PLL0LS_DIV16_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa40)
+#define STX7111_CLOCKGENA_PLL0LS_DIV17_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa44)
+#define STX7111_CLOCKGENA_PLL1_DIV0_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb00)
+#define STX7111_CLOCKGENA_PLL1_DIV1_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb04)
+#define STX7111_CLOCKGENA_PLL1_DIV2_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb08)
+#define STX7111_CLOCKGENA_PLL1_DIV3_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb0c)
+#define STX7111_CLOCKGENA_PLL1_DIV4_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb10)
+#define STX7111_CLOCKGENA_PLL1_DIV5_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb14)
+#define STX7111_CLOCKGENA_PLL1_DIV6_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb18)
+#define STX7111_CLOCKGENA_PLL1_DIV7_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb1c)
+#define STX7111_CLOCKGENA_PLL1_DIV8_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb20)
+#define STX7111_CLOCKGENA_PLL1_DIV9_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb24)
+#define STX7111_CLOCKGENA_PLL1_DIV10_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb28)
+#define STX7111_CLOCKGENA_PLL1_DIV11_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb2c)
+#define STX7111_CLOCKGENA_PLL1_DIV12_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb30)
+#define STX7111_CLOCKGENA_PLL1_DIV13_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb34)
+#define STX7111_CLOCKGENA_PLL1_DIV14_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb38)
+#define STX7111_CLOCKGENA_PLL1_DIV15_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb3c)
+#define STX7111_CLOCKGENA_PLL1_DIV16_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb40)
+#define STX7111_CLOCKGENA_PLL1_DIV17_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb44)
+
+#define STX7111_CLOCKGENB_FS0_CTRL		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x14)
+#define STX7111_CLOCKGENB_FS0_MD1		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x18)
+#define STX7111_CLOCKGENB_FS0_PE1		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x1c)
+#define STX7111_CLOCKGENB_FS0_EN_PRG1		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x20)
+#define STX7111_CLOCKGENB_FS0_SDIV1		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x24)
+#define STX7111_CLOCKGENB_FS0_MD2		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x28)
+#define STX7111_CLOCKGENB_FS0_PE2		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x2c)
+#define STX7111_CLOCKGENB_FS0_EN_PRG2		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x30)
+#define STX7111_CLOCKGENB_FS0_SDIV2		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x34)
+#define STX7111_CLOCKGENB_FS0_MD3		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x38)
+#define STX7111_CLOCKGENB_FS0_PE3		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x3c)
+#define STX7111_CLOCKGENB_FS0_EN_PRG3		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x40)
+#define STX7111_CLOCKGENB_FS0_SDIV3		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x44)
+#define STX7111_CLOCKGENB_FS0_CLOCKOUT_CTRL	SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x58)
+#define STX7111_CLOCKGENB_FS1_CTRL		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x5c)
+#define STX7111_CLOCKGENB_FS1_MD1		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x60)
+#define STX7111_CLOCKGENB_FS1_PE1		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x64)
+#define STX7111_CLOCKGENB_FS1_EN_PRG1		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x68)
+#define STX7111_CLOCKGENB_FS1_SDIV1		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x6c)
+#define STX7111_CLOCKGENB_FS1_MD2		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x70)
+#define STX7111_CLOCKGENB_FS1_PE2		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x74)
+#define STX7111_CLOCKGENB_FS1_EN_PRG2		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x78)
+#define STX7111_CLOCKGENB_FS1_SDIV2		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x7c)
+#define STX7111_CLOCKGENB_FS1_MD3		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x80)
+#define STX7111_CLOCKGENB_FS1_PE3		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x84)
+#define STX7111_CLOCKGENB_FS1_EN_PRG3		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x88)
+#define STX7111_CLOCKGENB_FS1_SDIV3		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x8c)
+#define STX7111_CLOCKGENB_FS1_MD4		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x90)
+#define STX7111_CLOCKGENB_FS1_PE4		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x94)
+#define STX7111_CLOCKGENB_FS1_EN_PRG4		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x98)
+#define STX7111_CLOCKGENB_FS1_SDIV4		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x9c)
+#define STX7111_CLOCKGENB_FS1_CLOCKOUT_CTRL	SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0xa0)
+#define STX7111_CLOCKGENB_DISPLAY_CFG		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0xa4)
+#define STX7111_CLOCKGENB_FS_SELECT		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0xa8)
+#define STX7111_CLOCKGENB_POWER_DOWN		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0xac)
+#define STX7111_CLOCKGENB_POWER_ENABLE		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0xb0)
+#define STX7111_CLOCKGENB_OUT_CTRL		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0xb4)
+#define STX7111_CLOCKGENB_CRISTAL_SEL		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0xb8)
+
+/* System configuration registers (STx7111 variant) */
+#define STX7111_SYSCONF_DEVICEID_0		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0000)
+#define STX7111_SYSCONF_DEVICEID_1		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0004)
+#define STX7111_SYSCONF_DEVICEID		SH4_GWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0000)
+#define STX7111_SYSCONF_SYS_STA00		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0008)
+#define STX7111_SYSCONF_SYS_STA01		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x000c)
+#define STX7111_SYSCONF_SYS_STA02		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0010)
+#define STX7111_SYSCONF_SYS_STA03		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0014)
+#define STX7111_SYSCONF_SYS_STA04		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0018)
+#define STX7111_SYSCONF_SYS_STA05		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x001c)
+#define STX7111_SYSCONF_SYS_STA06		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0020)
+#define STX7111_SYSCONF_SYS_STA07		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0024)
+#define STX7111_SYSCONF_SYS_STA08		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0028)
+#define STX7111_SYSCONF_SYS_STA09		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x002c)
+#define STX7111_SYSCONF_SYS_STA10		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0030)
+#define STX7111_SYSCONF_SYS_STA11		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0034)
+#define STX7111_SYSCONF_SYS_STA12		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0038)
+#define STX7111_SYSCONF_SYS_STA13		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x003c)
+#define STX7111_SYSCONF_SYS_STA14		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0040)
+#define STX7111_SYSCONF_SYS_STA15		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0044)
+#define STX7111_SYSCONF_SYS_CFG00		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0100)
+#define STX7111_SYSCONF_SYS_CFG01		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0104)
+#define STX7111_SYSCONF_SYS_CFG02		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0108)
+#define STX7111_SYSCONF_SYS_CFG03		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x010c)
+#define STX7111_SYSCONF_SYS_CFG04		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0110)
+#define STX7111_SYSCONF_SYS_CFG05		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0114)
+#define STX7111_SYSCONF_SYS_CFG06		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0118)
+#define STX7111_SYSCONF_SYS_CFG07		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x011c)
+#define STX7111_SYSCONF_SYS_CFG08		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0120)
+#define STX7111_SYSCONF_SYS_CFG09		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0124)
+#define STX7111_SYSCONF_SYS_CFG10		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0128)
+#define STX7111_SYSCONF_SYS_CFG11		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x012c)
+#define STX7111_SYSCONF_SYS_CFG12		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0130)
+#define STX7111_SYSCONF_SYS_CFG13		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0134)
+#define STX7111_SYSCONF_SYS_CFG14		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0138)
+#define STX7111_SYSCONF_SYS_CFG15		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x013c)
+#define STX7111_SYSCONF_SYS_CFG16		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0140)
+#define STX7111_SYSCONF_SYS_CFG17		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0144)
+#define STX7111_SYSCONF_SYS_CFG18		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0148)
+#define STX7111_SYSCONF_SYS_CFG19		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x014c)
+#define STX7111_SYSCONF_SYS_CFG20		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0150)
+#define STX7111_SYSCONF_SYS_CFG21		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0154)
+#define STX7111_SYSCONF_SYS_CFG22		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0158)
+#define STX7111_SYSCONF_SYS_CFG23		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x015c)
+#define STX7111_SYSCONF_SYS_CFG24		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0160)
+#define STX7111_SYSCONF_SYS_CFG25		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0164)
+#define STX7111_SYSCONF_SYS_CFG26		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0168)
+#define STX7111_SYSCONF_SYS_CFG27		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x016c)
+#define STX7111_SYSCONF_SYS_CFG28		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0170)
+#define STX7111_SYSCONF_SYS_CFG29		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0174)
+#define STX7111_SYSCONF_SYS_CFG30		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0178)
+#define STX7111_SYSCONF_SYS_CFG31		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x017c)
+#define STX7111_SYSCONF_SYS_CFG32		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0180)
+#define STX7111_SYSCONF_SYS_CFG33		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0184)
+#define STX7111_SYSCONF_SYS_CFG34		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0188)
+#define STX7111_SYSCONF_SYS_CFG35		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x018c)
+#define STX7111_SYSCONF_SYS_CFG36		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0190)
+#define STX7111_SYSCONF_SYS_CFG37		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0194)
+#define STX7111_SYSCONF_SYS_CFG38		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0198)
+#define STX7111_SYSCONF_SYS_CFG39		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x019c)
+#define STX7111_SYSCONF_SYS_CFG40		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01a0)
+#define STX7111_SYSCONF_SYS_CFG41		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01a4)
+#define STX7111_SYSCONF_SYS_CFG42		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01a8)
+#define STX7111_SYSCONF_SYS_CFG43		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01ac)
+#define STX7111_SYSCONF_SYS_CFG44		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01b0)
+#define STX7111_SYSCONF_SYS_CFG45		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01b4)
+#define STX7111_SYSCONF_SYS_CFG46		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01b8)
+#define STX7111_SYSCONF_SYS_CFG47		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01bc)
+#define STX7111_SYSCONF_SYS_CFG48		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01c0)
+#define STX7111_SYSCONF_SYS_CFG49		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01c4)
+#define STX7111_SYSCONF_SYS_CFG50		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01c8)
+#define STX7111_SYSCONF_SYS_CFG51		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01cc)
+#define STX7111_SYSCONF_SYS_CFG52		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01d0)
+#define STX7111_SYSCONF_SYS_CFG53		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01d4)
+#define STX7111_SYSCONF_SYS_CFG54		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01d8)
+#define STX7111_SYSCONF_SYS_CFG55		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01dc)
+
+/* Device ID values, masks & predicates */
+#define STX7111_DEVID_7111_VAL		0x03B
+#define STX7111_DEVID_ID_SHIFT		12
+#define STX7111_DEVID_ID_MASK		0x3ff
+#define STX7111_DEVID_CUT_SHIFT		28
+#define STX7111_DEVID_CUT_MASK		0xf
+
+#define STX7111_DEVICEID_7111(ID) ((((ID) >> STX7111_DEVID_ID_SHIFT) & STX7111_DEVID_ID_MASK) == STX7111_DEVID_7111_VAL)
+#define STX7111_DEVICEID_CUT(ID)  ((((ID) >> STX7111_DEVID_CUT_SHIFT) & STX7111_DEVID_CUT_MASK) + 1)
+
+#endif /* __STX7111REG_H */
diff --git a/include/asm-sh/u-boot.h b/include/asm-sh/u-boot.h
index 22245a6..cfd97a2 100644
--- a/include/asm-sh/u-boot.h
+++ b/include/asm-sh/u-boot.h
@@ -48,7 +48,7 @@ typedef struct bd_info
 	unsigned long bi_emifrq;
 	unsigned long bi_lmifrq;
 #endif
-#ifdef CONFIG_SH_STX7200
+#if defined(CONFIG_SH_STX7111) || defined(CONFIG_SH_STX7200)
 	unsigned long bi_devid;
 	unsigned long bi_emifrq;
 #endif
diff --git a/include/configs/cb101.h b/include/configs/cb101.h
index 954af02..0572129 100644
--- a/include/configs/cb101.h
+++ b/include/configs/cb101.h
@@ -80,7 +80,7 @@
 #endif
 
 #define CONFIG_EXTRA_ENV_SETTINGS \
-		"board=" XSTR(BOARD) /* "_" XSTR(INPUT_CLOCK_RATE) */ "\0" \
+		"board=" XSTR(BOARD) "\0" \
 		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
 		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
 		"monitor_sec=" MONITOR_SECTORS "\0" \
@@ -110,9 +110,10 @@
  * Serial console info
  */
 
+/* we are using the internal ST ASC UART */
 #define CONFIG_STM_ASC_SERIAL	1
 
-#define CONFIG_CONS_INDEX	0
+/* choose which UART to use */
 #define CFG_STM_ASC_BASE	0xfd033000ul	/* UART3 */
 
 /*---------------------------------------------------------------
@@ -216,23 +217,9 @@
 #define CONFIG_FLASH_PROTECT_SINGLE_CELL
 #define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
 #define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
-#define CFG_MAX_FLASH_SECT	300	/* max number of sectors on one chip	*/
+#define CFG_MAX_FLASH_SECT	259	/* max number of sectors on one chip	*/
 #define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
 
-
-/*-----------------------------------------------------------------------
- * NVRAM organization
- */
-
-/* Address and size of Primary Environment Sector	*/
-
-#define CFG_ENV_IS_IN_FLASH	1
-#define CFG_ENV_OFFSET		CFG_MONITOR_LEN
-#define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
-#define CFG_ENV_SIZE		0x10000
-#define CFG_ENV_SECT_SIZE	0x20000
-
-
 /*-----------------------------------------------------------------------
  * NAND FLASH organization
  */
@@ -243,9 +230,18 @@
 #define CFG_NAND1_BASE		0xA3000000	/* Physical 0x03000000 */
 #define CFG_NAND_BASE_LIST	{ CFG_NAND0_BASE, CFG_NAND1_BASE }
 
+/*-----------------------------------------------------------------------
+ * Addresss, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_OFFSET		CFG_MONITOR_LEN
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE		0x10000
+#define CFG_ENV_SECT_SIZE	0x20000
 
 /*----------------------------------------------------------------------
- * jffs2 support
+ * JFFS2 support
  */
 
 #if defined(CONFIG_CMD_JFFS2)
@@ -275,6 +271,5 @@
 	"nand1=gen_nand.2"	/* Second NAND flash device */
 #endif	/* CONFIG_CMD_JFFS2 */
 
-
 #endif	/* __CONFIG_H */
 
diff --git a/include/configs/hms1.h b/include/configs/hms1.h
index 11f9d67..6cf3054 100644
--- a/include/configs/hms1.h
+++ b/include/configs/hms1.h
@@ -112,9 +112,10 @@
  * Serial console info
  */
 
+/* we are using the internal ST ASC UART */
 #define CONFIG_STM_ASC_SERIAL	1
 
-#define CONFIG_CONS_INDEX	0
+/* choose which UART to use */
 #define CFG_STM_ASC_BASE	0xb8032000ul	/* UART2 */
 
 /*---------------------------------------------------------------
@@ -198,7 +199,7 @@
 #endif
 
 /*----------------------------------------------------------------------
- * jffs2 support
+ * JFFS2 support
  */
 
 #if defined(CONFIG_CMD_JFFS2)
@@ -233,7 +234,7 @@
 #define CONFIG_CMDLINE_EDITING
 
 /*-----------------------------------------------------------------------
- * FLASH organization
+ * NOR FLASH organization
  */
 
 /* stb7100 mboard organised as 8MB flash with 128k blocks */
@@ -244,13 +245,10 @@
 #define CFG_MAX_FLASH_SECT	64	/* max number of sectors on one chip	*/
 #define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
 
-
 /*-----------------------------------------------------------------------
- * NVRAM organization
+ * Addresss, size, & location of U-boot's Environment Sector
  */
 
-/* Address and size of Primary Environment Sector	*/
-
 #define CFG_ENV_IS_IN_FLASH	1
 #define CFG_ENV_OFFSET		CFG_MONITOR_LEN
 #define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
diff --git a/include/configs/mb411.h b/include/configs/mb411.h
index c1d077f..5214aaa 100644
--- a/include/configs/mb411.h
+++ b/include/configs/mb411.h
@@ -102,14 +102,14 @@
  * Serial console info
  */
 
+/* we are using the internal ST ASC UART */
 #define CONFIG_STM_ASC_SERIAL	1
 
-#define CONFIG_CONS_INDEX	0
-
-#if (CONFIG_CONS_INDEX == 0)
-#define CFG_STM_ASC_BASE	0xb8032000ul	/* UART2 */
+/* choose which UART to use */
+#if 1
+#	define CFG_STM_ASC_BASE		0xb8032000ul	/* UART2 */
 #else
-#define CFG_STM_ASC_BASE	0xb8033000ul	/* UART3 */
+#	define CFG_STM_ASC_BASE		0xb8033000ul	/* UART3 */
 #endif
 
 /*---------------------------------------------------------------
@@ -213,7 +213,7 @@
 #endif
 
 /*----------------------------------------------------------------------
- * jffs2 support
+ * JFFS2 support
  */
 
 #if defined(CONFIG_CMD_JFFS2)
@@ -248,7 +248,7 @@
 #define CONFIG_CMDLINE_EDITING
 
 /*-----------------------------------------------------------------------
- * FLASH organization
+ * NOR FLASH organization
  */
 
 /* STb7100 Mboard organised as 8MB flash with 128k blocks */
@@ -259,13 +259,10 @@
 #define CFG_MAX_FLASH_SECT	64	/* max number of sectors on one chip	*/
 #define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
 
-
 /*-----------------------------------------------------------------------
- * NVRAM organization
+ * Addresss, size, & location of U-boot's Environment Sector
  */
 
-/* Address and size of Primary Environment Sector	*/
-
 #define CFG_ENV_IS_IN_FLASH	1
 #define CFG_ENV_OFFSET		CFG_MONITOR_LEN
 #define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
diff --git a/include/configs/mb442.h b/include/configs/mb442.h
index 7616a00..f45a06b 100644
--- a/include/configs/mb442.h
+++ b/include/configs/mb442.h
@@ -112,14 +112,14 @@
  * Serial console info
  */
 
+/* we are using the internal ST ASC UART */
 #define CONFIG_STM_ASC_SERIAL	1
 
-#define CONFIG_CONS_INDEX	0
-
-#if (CONFIG_CONS_INDEX == 0)
-#define CFG_STM_ASC_BASE	0xb8032000ul	/* UART2 */
+/* choose which UART to use */
+#if 1
+#	define CFG_STM_ASC_BASE		0xb8032000ul	/* UART2 */
 #else
-#define CFG_STM_ASC_BASE	0xb8033000ul	/* UART3 */
+#	define CFG_STM_ASC_BASE		0xb8033000ul	/* UART3 */
 #endif
 
 /*---------------------------------------------------------------
@@ -242,7 +242,7 @@
 #define CONFIG_AUTO_COMPLETE       1
 
 /*-----------------------------------------------------------------------
- * FLASH organization
+ * NOR FLASH organization
  */
 
 /* STb7100 reference board organised as 8MB flash with 128k blocks */
@@ -253,13 +253,10 @@
 #define CFG_MAX_FLASH_SECT	64	/* max number of sectors on one chip	*/
 #define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
 
-
 /*-----------------------------------------------------------------------
- * NVRAM organization
+ * Addresss, size, & location of U-boot's Environment Sector
  */
 
-/* Address and size of Primary Environment Sector	*/
-
 #define CFG_ENV_IS_IN_FLASH	1
 #define CFG_ENV_OFFSET		CFG_MONITOR_LEN
 #define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
diff --git a/include/configs/mb448.h b/include/configs/mb448.h
index 758c857..e00a455 100644
--- a/include/configs/mb448.h
+++ b/include/configs/mb448.h
@@ -33,6 +33,8 @@
 #define CONFIG_SH4	1		/* This is an SH4 CPU		*/
 #define CONFIG_CPU_SUBTYPE_SH4_2XX	/* its an SH4-202		*/
 
+#define INPUT_CLOCK_RATE 27
+
 #define P_CLOCK_RATE	66000000	/* clock rate for CSP		*/
 
 /*-----------------------------------------------------------------------
@@ -71,7 +73,7 @@
 #endif
 
 #define CONFIG_EXTRA_ENV_SETTINGS \
-		"board=" XSTR(BOARD) "_" XSTR(INPUT_CLOCK_RATE) "\0" \
+		"board=" XSTR(BOARD) "\0" \
 		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
 		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
 		"monitor_sec=" MONITOR_SECTORS "\0" \
@@ -99,9 +101,10 @@
  * Serial console info
  */
 
+/* we are using the internal ST ASC UART */
 #define CONFIG_STM_ASC_SERIAL	1
 
-#define CONFIG_CONS_INDEX	0
+/* choose which UART to use */
 #define CFG_STM_ASC_BASE	0xb8032000ul	/* UART2 */
 
 /*---------------------------------------------------------------
@@ -216,7 +219,7 @@
 #define CONFIG_CMDLINE_EDITING
 
 /*-----------------------------------------------------------------------
- * FLASH organization
+ * NOR FLASH organization
  */
 
 /* STb7109E reference board organised as 8MB flash with 128k blocks */
@@ -227,13 +230,10 @@
 #define CFG_MAX_FLASH_SECT	64	/* max number of sectors on one chip	*/
 #define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
 
-
 /*-----------------------------------------------------------------------
- * NVRAM organization
+ * Addresss, size, & location of U-boot's Environment Sector
  */
 
-/* Address and size of Primary Environment Sector	*/
-
 #define CFG_ENV_IS_IN_FLASH	1
 #define CFG_ENV_OFFSET		CFG_MONITOR_LEN
 #define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
diff --git a/include/configs/mb519.h b/include/configs/mb519.h
index d270113..c022c44 100644
--- a/include/configs/mb519.h
+++ b/include/configs/mb519.h
@@ -80,7 +80,7 @@
 #endif
 
 #define CONFIG_EXTRA_ENV_SETTINGS \
-		"board=" XSTR(BOARD) "_" XSTR(INPUT_CLOCK_RATE) "\0" \
+		"board=" XSTR(BOARD) "\0" \
 		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
 		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
 		"monitor_sec=" MONITOR_SECTORS "\0" \
@@ -108,9 +108,10 @@
  * Serial console info
  */
 
+/* we are using the internal ST ASC UART */
 #define CONFIG_STM_ASC_SERIAL	1
 
-#define CONFIG_CONS_INDEX	0
+/* choose which UART to use */
 #define CFG_STM_ASC_BASE	0xfd032000ul	/* UART2 */
 
 /*---------------------------------------------------------------
@@ -226,7 +227,7 @@
 #define CONFIG_CMDLINE_EDITING
 
 /*-----------------------------------------------------------------------
- * FLASH organization
+ * NOR FLASH organization
  */
 
 /* M58LT256GT: 32Mbyte 259 blocks, 128K block size plus parameter block */
@@ -235,16 +236,13 @@
 #define CONFIG_FLASH_PROTECT_SINGLE_CELL
 #define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
 #define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
-#define CFG_MAX_FLASH_SECT	300	/* max number of sectors on one chip	*/
+#define CFG_MAX_FLASH_SECT	259	/* max number of sectors on one chip	*/
 #define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
 
-
 /*-----------------------------------------------------------------------
- * NVRAM organization
+ * Addresss, size, & location of U-boot's Environment Sector
  */
 
-/* Address and size of Primary Environment Sector	*/
-
 #define CFG_ENV_IS_IN_FLASH	1
 #define CFG_ENV_OFFSET		CFG_MONITOR_LEN
 #define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
diff --git a/include/configs/mb618.h b/include/configs/mb618.h
new file mode 100644
index 0000000..08e422c
--- /dev/null
+++ b/include/configs/mb618.h
@@ -0,0 +1,294 @@
+/*
+ * (C) Copyright 2008 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
+
+/* This should really be replaced with something which uses bd->...	*/
+#define P_CLOCK_RATE	87500000	/* clock rate for CSP		*/
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH (uncached) via PMB */
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI Physical Address */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI    Cached addr via PMB */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI UN-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH in P2 region */
+#define CFG_SDRAM_BASE		0x8C000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x08000000	/* 128MB of LMI SDRAM */
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 kB for Monitor */
+#define CFG_MONITOR_BASE        CFG_FLASH_BASE
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1MB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128kB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD mb618
+
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 kB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 kB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/* we are using the internal ST ASC UART */
+#define CONFIG_STM_ASC_SERIAL	1
+
+/* choose which UART to use */
+#if 1
+#	define CFG_STM_ASC_BASE		0xfd032000ul	/* UART2 */
+#else
+#	define CFG_STM_ASC_BASE		0xfd033000ul	/* UART3 */
+#endif
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 2 options for ethernet, both use the on-chip ST-GMAC.
+ * The choice in PHYs are:
+ *    The on-board SMSC LAN8700
+ *    External PHY connected via the MII off-board connector.
+ */
+
+/* are we using the internal ST GMAC device ? */
+#define CONFIG_DRIVER_NET_STM_GMAC
+
+/*
+ * Select the appropriate base address for the GMAC.
+ * Also, choose which PHY to use.
+ */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+#	define CFG_STM_STMAC_BASE	 0xfd110000ul	/* MAC = STM GMAC0 */
+#	define CONFIG_STMAC_LAN8700			/* PHY = SMSC LAN8700 */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB_BASE			0xfe100000
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+#if defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CFG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"MB618> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* Whether the hardware supports NOR or NAND Flash depends on J34.
+ * One ONE of these may be present at any one time. Each hides the other.
+ * In position 1-2 CSA selects NAND, in position 2-3 is selects NOR.
+ * Note that J30A must also be in position 2-3 to select the
+ * on-board Flash (for either the on-board NOR or NAND flash).
+ *
+ * i.e.		ON-board NOR FLASH:	J30A:2-3, J34:2-3
+ *	 	ON-board NAND FLASH:	J30A:2-3, J34:1-2
+ */
+//#define CONFIG_CMD_NAND		/* define for NAND flash */
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+/* M58LT256GT: 32Mbyte 259 blocks, 128kB block size */
+#ifndef CONFIG_CMD_NAND				/* NOR flash present ? */
+#	define CONFIG_CMD_JFFS2			/* enable JFFS2 support */
+#	define CFG_FLASH_CFI_DRIVER
+#	define CFG_FLASH_CFI
+#	define CONFIG_FLASH_PROTECT_SINGLE_CELL
+#	define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#	define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#	define CFG_MAX_FLASH_SECT	259	/* max number of sectors on one chip	*/
+#	define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+#define MTDPARTS_DEFAULT						\
+	"mtdparts="							\
+	"physmap-flash:"	/* First NOR flash device */		\
+		"256k(U-Boot)"		/* first partition */		\
+		",128k(Environment)"					\
+		",4M(Kernel)"						\
+		",-(RestOfNor)"		/* last partition */
+#define MTDIDS_DEFAULT							\
+	"nor0=physmap-flash"	/* First NOR flash device */
+#endif	/* CONFIG_CMD_NAND */
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH organization
+ */
+
+/* NAND512W3A: 64MByte  8-bit, 4096 Blocks (16kB+512B) of 32 Pages (512+16) */
+/* NAND512W4A: 64MByte 16-bit, 4096 Blocks (16kB+512B) of 32 Pages (512+16) */
+#ifdef CONFIG_CMD_NAND				/* NAND flash present ? */
+#	define CONFIG_CMD_JFFS2			/* enable JFFS2 support */
+#	define CFG_MAX_NAND_DEVICE	1
+#	define NAND_MAX_CHIPS		CFG_MAX_NAND_DEVICE
+#	define CFG_NAND0_BASE		CFG_FLASH_BASE	/* Occludes NOR flash */
+#	define CFG_NAND_BASE_LIST	{ CFG_NAND0_BASE }
+#	undef CONFIG_CMD_FLASH			/* NOR-flash specific */
+#	undef CONFIG_CMD_IMLS			/* NOR-flash specific */
+#	define CFG_NO_FLASH			/* no NOR-flash when using NAND-flash */
+#define MTDPARTS_DEFAULT						\
+	"mtdparts="							\
+	"gen_nand.1:"		/* First NAND flash device */		\
+		"128k(Environment)"	/* first partition */		\
+		",4M(Kernel)"						\
+		",32M(rootfs)"						\
+		",-(RestOfNand)"	/* last partition */
+#define MTDIDS_DEFAULT							\
+	"nand0=gen_nand.1"	/* First NAND flash device */
+#endif	/* CONFIG_CMD_NAND */
+
+/*-----------------------------------------------------------------------
+ * Addresss, size, & location of U-boot's Environment Sector
+ */
+
+#ifdef CONFIG_CMD_NAND				/* NAND flash present ? */
+#	define CFG_ENV_IS_IN_NAND		/* enviroment in NAND flash */
+#	define CFG_ENV_OFFSET	0		/* begining of NAND flash */
+#else
+#	define CFG_ENV_IS_IN_FLASH		/* environment in NOR flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* After u-boot.bin */
+#endif	/* CONFIG_CMD_NAND */
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE		0x10000
+#define CFG_ENV_SECT_SIZE	0x20000
+
+/*----------------------------------------------------------------------
+ * JFFS2 support
+ */
+
+#if defined(CONFIG_CMD_JFFS2)
+#	ifdef CONFIG_CMD_NAND			/* NAND flash present ? */
+#		define CONFIG_JFFS2_NAND	/* JFFS2 support on NAND Flash */
+#	endif	/* CONFIG_CMD_NAND */
+#	define CONFIG_JFFS2_CMDLINE		/* mtdparts command line support */
+#endif	/* CONFIG_CMD_JFFS2 */
+
+
+#endif	/* __CONFIG_H */
diff --git a/lib_sh/board.c b/lib_sh/board.c
index 146bb9e..35adfd6 100644
--- a/lib_sh/board.c
+++ b/lib_sh/board.c
@@ -33,6 +33,16 @@
 #if defined(CONFIG_CMD_NAND)
 #include <nand.h>
 #endif
+#if defined(CONFIG_SH_STB7100)
+#include <asm/stb7100reg.h>
+#elif defined(CONFIG_SH_STX7111)
+#include <asm/stx7111reg.h>
+#elif defined(CONFIG_SH_STX7200)
+#include <asm/stx7200reg.h>
+#else
+#error Missing Device Defintions!
+#endif
+#include <asm/st40reg.h>
 
 extern ulong _uboot_end_data;
 extern ulong _uboot_end;
@@ -109,11 +119,13 @@ static int display_banner (void)
 	return (0);
 }
 
+#ifndef CFG_NO_FLASH
 static void display_flash_config (ulong size)
 {
-	puts ("Flash: ");
+	puts ("NOR:   ");
 	print_size (size, "\n");
 }
+#endif /* CFG_NO_FLASH */
 
 
 static int init_baudrate (void)
@@ -168,7 +180,9 @@ void start_sh4boot (void)
 	bd_t *bd;
 	ulong addr;
 	init_fnc_t **init_fnc_ptr;
+#ifndef CFG_NO_FLASH
 	ulong size;
+#endif /* CFG_NO_FLASH */
 
 	char *s, *e;
 	int i;
@@ -202,10 +216,11 @@ void start_sh4boot (void)
 	monitor_flash_len = (ulong) & _uboot_end_data - TEXT_BASE;
 
 	/* configure available FLASH banks */
-
 	flashWriteEnable();
+#ifndef CFG_NO_FLASH
 	size = flash_init ();
 	display_flash_config (size);
+#endif /* CFG_NO_FLASH */
 
 	bd = gd->bd;
 	bd->bi_boot_params = addr;
@@ -213,7 +228,9 @@ void start_sh4boot (void)
 	bd->bi_memsize = gd->ram_size;	/* size  of  DRAM memory in bytes */
 	bd->bi_baudrate = gd->baudrate;	/* Console Baudrate */
 	bd->bi_flashstart = CFG_FLASH_BASE;
+#ifndef CFG_NO_FLASH
 	bd->bi_flashsize = size;
+#endif /* CFG_NO_FLASH */
 #if CFG_MONITOR_BASE == CFG_FLASH_BASE
 	bd->bi_flashoffset = monitor_flash_len;	/* reserved area for U-Boot */
 #else
@@ -297,3 +314,51 @@ void hang (void)
 	puts ("### ERROR ### Please RESET the board ###\n");
 	for (;;);
 }
+
+
+static void sh_reset (void) __attribute__ ((noreturn));
+static void sh_reset (void)
+{
+#if 1
+	/*
+	 * We will use the on-chip watchdog timer to force a
+	 * power-on-reset of the device.
+	 * A power-on-reset is required to guarantee all SH4-200 cores
+	 * will reset back into 29-bit mode, if they were in SE mode.
+	 * However, on SH4-300 series parts, issuing a TRAP instruction
+	 * with SR.BL=1 is sufficient. However, we will use a "one size fits
+	 * all" solution here, and use the watchdog for all SH parts.
+	 */
+
+		/* WTCNT          = FF	counter to overflow next tick */
+	*ST40_CPG_WTCNT = 0x5AFF;
+
+		/* WTCSR2.CKS[3]  = 0	use legacy clock dividers */
+	*ST40_CPG_WTCSR2 = 0xAA00;
+
+		/* WTCSR.TME      = 1	enable up-count counter */
+		/* WTCSR.WT       = 1	watchdog timer mode */
+		/* WTCSR.RSTS     = 0	enable power-on reset */
+		/* WTCSR.CKS[2:0] = 2	clock division ratio 1:128 */
+		/* NOTE: we need CKS to be big enough to allow
+		 * U-boot to disable the watchdog, AFTER the reset,
+		 * otherwise, we enter an infinite-loop of resetting! */
+	*ST40_CPG_WTCSR = 0xA5C2;
+
+	/* wait for H/W reset to kick in ... */
+	for (;;);
+#else
+	ulong sr;
+	asm ("stc sr, %0":"=r" (sr));
+	sr |= (1 << 28);	/* set block bit */
+	asm ("ldc %0, sr": :"r" (sr));
+	asm volatile ("trapa #0");
+#endif
+}
+
+
+extern int do_reset (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	sh_reset();
+	/*NOTREACHED*/ return (0);
+}
diff --git a/lib_sh/time.c b/lib_sh/time.c
index cf6d5ad..4d58729 100644
--- a/lib_sh/time.c
+++ b/lib_sh/time.c
@@ -26,6 +26,8 @@
 
 #if defined(CONFIG_SH_STB7100)
 #include <asm/stb7100reg.h>
+#elif defined(CONFIG_SH_STX7111)
+#include <asm/stx7111reg.h>
 #elif defined(CONFIG_SH_STX7200)
 #include <asm/stx7200reg.h>
 #else
diff --git a/net/eth.c b/net/eth.c
index 4d1dd21..879f108 100644
--- a/net/eth.c
+++ b/net/eth.c
@@ -542,7 +542,7 @@ int eth_initialize(bd_t *bis)
 #if defined(CONFIG_DRIVER_TI_EMAC)
 	dm644x_eth_miiphy_initialize(bis);
 #endif
-#if defined(CONFIG_DRIVER_NETSTMAC)
+#if defined(CONFIG_DRIVER_NETSTMAC) || defined(CONFIG_DRIVER_NET_STM_GMAC)
 	stmac_miiphy_initialize(bis);
 #endif
 	return 0;
diff --git a/sh_config.mk b/sh_config.mk
index b1998e7..4c6fea6 100644
--- a/sh_config.mk
+++ b/sh_config.mk
@@ -21,9 +21,12 @@
 # MA 02111-1307 USA
 #
 
-# Update this for each release
-
-SH_IDENT_STRING="\"stm23-2008-03-19\""	# QQQ: Have spec file fill this in automatically ?
+# Update this for each release.
+# The SPEC file will automatically substitute the date
+# for actual build number, in the following identifier.
+# Regular Expression for string is:
+# 	"stm[2-9][0-9]-[2-9][0-9][0-9][0-9]-[01][0-9]-[0-3][0-9]"
+SH_IDENT_STRING="\"stm23-2008-06-03\""
 
 PLATFORM_CPPFLAGS += -DCONFIG_SH4 -D__SH4__ -DCONFIG_IDENT_STRING=$(SH_IDENT_STRING)
 PLATFORM_LDFLAGS  += -n
diff --git a/MAKEALL b/MAKEALL
index c4bf635..947d49c 100755
--- a/MAKEALL
+++ b/MAKEALL
@@ -676,8 +676,12 @@ LIST_sh="		\
 	mb519se		\
 	mb618		\
 	mb618se		\
+	mb671		\
+	mb671se		\
 	cb101		\
 	cb101se		\
+	cb102		\
+	cb102se		\
 "
 
 #########################################################################
diff --git a/Makefile b/Makefile
index 4c94e22..ea57072 100644
--- a/Makefile
+++ b/Makefile
@@ -2737,6 +2737,17 @@ mb618se_config :		unconfig
 	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/mb618/config.tmp)
 	@./mkconfig -a mb618 sh sh mb618 "" stx7111
 
+mb671_config \
+mb671se_config :		unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_SH_STX7200   1" >>include/config.h
+	@echo "#define CONFIG_SH_MB671     1" >>include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/mb671/config.tmp)
+	@./mkconfig -a mb671 sh sh mb671 "" stx7200
+
 cb101_config \
 cb101se_config :		unconfig
 	@ >include/config.h
@@ -2748,6 +2759,17 @@ cb101se_config :		unconfig
 	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/cb101/config.tmp)
 	@./mkconfig -a cb101 sh sh cb101 "" stx7200
 
+cb102_config \
+cb102se_config :		unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_SH_STX7200   1" >>include/config.h
+	@echo "#define CONFIG_SH_CB102     1" >>include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/cb102/config.tmp)
+	@./mkconfig -a cb102 sh sh cb102 "" stx7200
+
 
 #========================================================================
 # STMicroelectronics ST200
diff --git a/board/cb101/cb101.c b/board/cb101/cb101.c
index 45908bd..1a3b11c 100644
--- a/board/cb101/cb101.c
+++ b/board/cb101/cb101.c
@@ -25,6 +25,7 @@
 
 #include <common.h>
 #include <command.h>
+#include <asm/soc.h>
 #include <asm/stx7200reg.h>
 #include <asm/io.h>
 #include <asm/pio.h>
@@ -49,13 +50,15 @@ static void configPIO(void)
 	SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
 	SET_PIO_ASC(PIO_PORT(5), 4, 3, 5, 6);  /* UART3 - AS1 */
 
-
+#ifdef CONFIG_DRIVER_NETSTMAC
+	/* Reset the on-board STe101P PHY */
 	SET_PIO_PIN(PIO_PORT(4), 7, STPIO_OUT);
 	STPIO_SET_PIN(PIO_PORT(4), 7, 1);
 	udelay(1);
 	STPIO_SET_PIN(PIO_PORT(4), 7, 0);
 	udelay(1);
 	STPIO_SET_PIN(PIO_PORT(4), 7, 1);
+#endif	/* CONFIG_DRIVER_NETSTMAC */
 
 #if defined(CONFIG_CMD_NAND)
 	/*  Setup PIO for NAND FLASH devices: Ready/Not_Busy */
@@ -141,17 +144,6 @@ int board_init(void)
 	sysconf &= ~((1<<0)|(1<<1)|(1<<2)|(1<<3));
 	*STX7200_SYSCONF_SYS_CFG33 = sysconf;
 
-	/* Route Ethernet pins to output */
-	/* bit26-16: conf_pad_eth(10:0) */
-	sysconf = *STX7200_SYSCONF_SYS_CFG41;
-	/* MII0: conf_pad_eth(0) = 0 (ethernet) */
-	sysconf &= ~(1<<16);
-	/* MII1: conf_pad_eth(2) = 0, (3)=0, (4)=0, (9)=0, (10)=0 (ethernet)
-	 * MII1: conf_pad_eth(6) = 0 (MII1TXD[0] = output) */
-	sysconf &= ~( (1<<(16+2)) | (1<<(16+3)) | (1<<(16+4)) | (1<<(16+6)) |
-		      (1<<(16+9)) | (1<<(16+10)));
-	*STX7200_SYSCONF_SYS_CFG41 = sysconf;
-
 #if defined(CONFIG_CMD_NAND)
 	nand_emi_init();
 #endif	/* CONFIG_CMD_NAND */
@@ -171,5 +163,11 @@ int checkboard (void)
 #endif
 		"\n");
 
+#ifdef CONFIG_DRIVER_NETSTMAC
+#if defined(CONFIG_STMAC_MAC0)
+	/* On-board PHY (MII0) in MII mode, using MII_CLK */
+	stx7200_configure_ethernet(0, 0, 0, 0);
+#endif	/* CONFIG_STMAC_MAC0 */
+#endif	/* CONFIG_DRIVER_NETSTMAC */
 	return 0;
 }
diff --git a/board/cb101/config.mk b/board/cb101/config.mk
index cf00d78..37f427b 100644
--- a/board/cb101/config.mk
+++ b/board/cb101/config.mk
@@ -22,7 +22,7 @@
 #
 
 #
-# MB519 board:
+# CB101 board:
 #
 #	Valid values for TEXT_BASE are:
 #
diff --git a/board/cb102/Makefile b/board/cb102/Makefile
new file mode 100644
index 0000000..1f1f703
--- /dev/null
+++ b/board/cb102/Makefile
@@ -0,0 +1,44 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+AOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o sconsole.o
+
+OBJS	= $(COBJS) $(AOBJS)
+
+$(LIB):	.depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/cb102/cb102.c b/board/cb102/cb102.c
new file mode 100644
index 0000000..f6ecd27
--- /dev/null
+++ b/board/cb102/cb102.c
@@ -0,0 +1,146 @@
+/*
+ * (C) Copyright 2007-2008 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Martin Lesniak <martin.lesniak@st.com> - added cb101 support
+ * Sean McGoogan <Sean.McGoogan@st.com> - added cb102 support
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7200reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+void flashWriteEnable(void)
+{
+	/* Enable Vpp for writing to flash */
+	/* Not under software control on this board. */
+}
+
+void flashWriteDisable(void)
+{
+	/* Disable Vpp for writing to flash */
+	/* Not under software control on this board. */
+}
+
+
+#define PIO_BASE  0xfd020000
+
+
+static void configPIO(void)
+{
+	/*  Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
+	SET_PIO_ASC(PIO_PORT(5), 4, 3, 5, 6);  /* UART3 - AS1 */
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+	/* Reset the on-board SMSC LAN8700 PHY */
+	SET_PIO_PIN(PIO_PORT(4), 7, STPIO_OUT);
+	STPIO_SET_PIN(PIO_PORT(4), 7, 1);
+	udelay(1);
+	STPIO_SET_PIN(PIO_PORT(4), 7, 0);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(4), 7, 1);
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+}
+
+
+int board_init(void)
+{
+	unsigned long sysconf;
+
+	/* Serial port set up */
+	/* Route UART2&3 or SCI inputs instead of DVP to pins: conf_pad_dvp = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG40;
+	sysconf &= ~(1<<16);
+	*STX7200_SYSCONF_SYS_CFG40 = sysconf;
+
+	/* Route UART2&3/SCI outputs instead of DVP to pins: conf_pad_pio[1]=0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<25);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* No idea, more routing: conf_pad_pio[0] = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<24);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART2 (inputs and outputs) instead of SCI to pins: ssc2_mux_sel = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<2);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* conf_pad_pio[4] = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<28);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART3 (inputs and outputs) instead of SCI to pins: ssc3_mux_sel = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* conf_pad_clkobs = 1 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf |= (1<<14);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* I2C and USB related routing */
+	/* bit4: ssc4_mux_sel = 0 (treat SSC4 as I2C) */
+	/* bit26: conf_pad_pio[2] = 0 route USB etc instead of DVO */
+	/* bit27: conf_pad_pio[3] = 0 DVO output selection (probably ignored) */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~((1<<27)|(1<<26)|(1<<4));
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Enable SOFT_JTAG mode.
+	 * Taken from OS21, but is this correct?
+	 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG33;
+	sysconf |= (1<<6);
+	sysconf &= ~((1<<0)|(1<<1)|(1<<2)|(1<<3));
+	*STX7200_SYSCONF_SYS_CFG33 = sysconf;
+
+	configPIO();
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: cb102"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+#if defined(CONFIG_STMAC_MAC0)
+	/* On-board PHY (MII0) in MII mode, using MII_CLK */
+	stx7200_configure_ethernet (0, 0, 0, 0);
+#endif	/* CONFIG_STMAC_MAC0 */
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+	return 0;
+}
diff --git a/board/cb102/config.mk b/board/cb102/config.mk
new file mode 100644
index 0000000..fb571b3
--- /dev/null
+++ b/board/cb102/config.mk
@@ -0,0 +1,44 @@
+#
+# (C) Copyright 2007-2008 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# CB102 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x97F00000	29-bit mode (Traditional Mode)
+#	0x8FF00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 255MB in P1 (cachable)
+TEXT_BASE = 0x97F00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/cb102/init-cb102.S b/board/cb102/init-cb102.S
new file mode 100644
index 0000000..8ba5daf
--- /dev/null
+++ b/board/cb102/init-cb102.S
@@ -0,0 +1,424 @@
+
+#include "asm/stx7200reg.h"
+#include "../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb671.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+#ifndef CONFIG_STM_NEW_POKE_TABLE_PARADIGM
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+#endif /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
+
+.balign 32
+
+
+__memory_setup_table:
+
+	/* ----- STx7200 Clocks ----- */
+
+	/* Set CLOCKGENA PLL0 into BYPASS... */
+	OR32(STX7200_CLOCKGENA_PLL0_CFG, 0x00100000)
+
+	/* Power down CLOCKGENA PLL0... */
+	OR32(STX7200_CLOCKGENA_POWER_CFG, 0x00000001)
+
+	/* Configure CLOCKGENA PLL0... to 900MHz */
+	UPDATE32(STX7200_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x01 | (0x0f << 8))
+
+	/* Enable CLOCKGENA PLL0... */
+	UPDATE32(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffe, 0)
+
+	/* Wait for CLOCKGENA PLL0 to lock... */
+	WHILE_NE32(STX7200_CLOCKGENA_PLL0_CFG, 0x80000000, 0x80000000)
+
+	/* Clear CLOCKGENA PLL0 from BYPASS... */
+	UPDATE32(STX7200_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+
+	/* Set CLOCKGENA PLL1 into BYPASS... */
+	OR32(STX7200_CLOCKGENA_PLL1_CFG, 0x00100000)
+
+	/* Power down CLOCKGENA PLL1... */
+	OR32(STX7200_CLOCKGENA_POWER_CFG, 0x00000002)
+
+	/* Configure CLOCKGENA PLL1... */
+	UPDATE32(STX7200_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x01 | (0x0f << 8))
+
+	/* Enable CLOCKGENA PLL1... */
+	UPDATE32(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffd, 0)
+
+	/* Wait for CLOCKGENA PLL1 to lock... */
+	WHILE_NE32(STX7200_CLOCKGENA_PLL1_CFG, 0x80000000, 0x80000000)
+
+	/* Clear CLOCKGENA PLL1 from BYPASS... */
+	UPDATE32(STX7200_CLOCKGENA_PLL1_CFG, 0xffefffff, 0)
+
+	/* Set CLOCKGENA PLL2 into BYPASS... */
+	OR32(STX7200_CLOCKGENA_PLL2_CFG, 0x00100000)
+
+	/* Power down CLOCKGENA PLL2... */
+	OR32(STX7200_CLOCKGENA_POWER_CFG, 0x00000004)
+
+	/* Configure CLOCKGENA PLL2... */
+	UPDATE32(STX7200_CLOCKGENA_PLL2_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
+
+	/* Enable CLOCKGENA PLL2... */
+	UPDATE32(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffb, 0)
+
+	/* Wait for CLOCKGENA PLL2 to lock... */
+	WHILE_NE32(STX7200_CLOCKGENA_PLL2_CFG, 0x80000000,  0x80000000)
+
+	/* Clear CLOCKGENA PLL2 from BYPASS... */
+	UPDATE32(STX7200_CLOCKGENA_PLL2_CFG, 0xffefffff, 0)
+
+	/* Set CLOCKGENB PLL0 into BYPASS... */
+	OR32(STX7200_CLOCKGENB_PLL0_CFG, 0x00100000)
+
+	/* Power down CLOCKGENB PLL0... */
+	OR32(STX7200_CLOCKGENB_POWER_CFG, 0x00008000)
+
+	/* Configure CLOCKGENB PLL0... */
+	UPDATE32(STX7200_CLOCKGENB_PLL0_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
+
+	/* Enable CLOCKGENB PLL0... */
+	UPDATE32(STX7200_CLOCKGENB_POWER_CFG, 0xffff7fff, 0)
+
+	/* Wait for CLOCKGENB PLL0 to lock... */
+	WHILE_NE32(STX7200_CLOCKGENB_PLL0_CFG, 0x80000000, 0x80000000)
+
+	/* Clear CLOCKGENB PLL0 from BYPASS... */
+	UPDATE32(STX7200_CLOCKGENB_PLL0_CFG, 0xffefffff, 0)
+
+	/* Power down PLL... */
+	OR32(STX7200_SYSCONF_SYS_CFG11, 0x00001000)
+
+#ifdef SLOW_LMI
+	/* Set LMI clock to 666MHz */
+	UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x05 << 9) | (0x6f << 1))
+#else	/* !SLOW_LMI */
+	/* Set LMI clock to 800MHz */
+	UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x50 << 1))
+#endif	/* SLOW_LMI */
+
+	/* Enable CLOCKGENA PLL1... */
+	UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xffffefff, 0)
+
+	/* Wait for CLOCKGENA PLL1 to lock... */
+#ifdef CONFIG_STM_NEW_POKE_TABLE_PARADIGM
+	IF_EQ32(1, STX7200_SYSCONF_DEVICEID_0, 0x0fffffff, 0x0d437041)
+	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 1)
+	ELSE(1)
+	  /* On cut 1 polarity inverted on lock bit */
+	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 0)
+	ENDIF(1)
+#else /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
+	IF_DEVID(STX7200_CUT1)
+	  /* On cut 1 polarity inverted on lock bit */
+	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 0)
+	ENDIF
+	IF_DEVID(STX7200_CUT2)
+	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 1)
+	ENDIF
+#endif /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
+
+	/* ----- STx7200 Sysconf ----- */
+
+	/* PLI_CLOCK_ENABLE set to 0 */
+	UPDATE32(STX7200_SYSCONF_SYS_CFG58, ~(1 << 0), 0)
+
+	/* LMI sub-sys & pl exit from reset */
+	OR32(STX7200_SYSCONF_SYS_CFG11, 0x1 | (1 << 27))
+	OR32(STX7200_SYSCONF_SYS_CFG15, 0x1 | (1 << 27))
+
+	/* Delay ~ 200 uS (assumes 400MHz CPU clock) */
+	DELAY(200 * 400)
+
+	/* PLI_CLOCK_ENABLE set to 1 */
+	OR32(STX7200_SYSCONF_SYS_CFG58, (1 << 0))
+
+	/* Check both DLL on LMI0 are locked */
+	WHILE_NE32(STX7200_SYSCONF_SYS_STA03, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
+
+	/* Check both DLL on LMI1 are locked */
+	WHILE_NE32(STX7200_SYSCONF_SYS_STA05, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
+
+	/* Adjust proga, progb, zoutproga, and receiver mode for LMI0 */
+	POKE32(STX7200_SYSCONF_SYS_CFG12, 0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10))
+
+	/* Adjust proga, progb, zoutproga, and receiver mode for LMI1 */
+	POKE32(STX7200_SYSCONF_SYS_CFG16, 0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10))
+
+	/* Enable AutoPrecharge */
+	POKE32(STX7200_SYSCONF_SYS_CFG38, 0x000ffd08)
+	POKE32(STX7200_SYSCONF_SYS_CFG39, 0x000ffd18)
+
+	/* Force DLL1 and DLL2 command of LMI0 */
+	POKE32(STX7200_SYSCONF_SYS_CFG13, 0x00000002)
+	POKE32(STX7200_SYSCONF_SYS_CFG14, 0x00000002)
+
+	/* Force DLL1 and DLL2 command of LMI1 */
+	POKE32(STX7200_SYSCONF_SYS_CFG17, 0x00000002)
+	POKE32(STX7200_SYSCONF_SYS_CFG18, 0x00000002)
+
+	/* Set cfg55 and cfg56 */
+	POKE32(STX7200_SYSCONF_SYS_CFG55, 0x03fc2004 | (0 << 10) | (0x7 << 7))
+	POKE32(STX7200_SYSCONF_SYS_CFG56, 0x03fc2004 | (0 << 10) | (0x7 << 7))
+
+	/* PDL offsets
+	 # -11=1F5 => 42=0x07D7EBF5, 43=0x000001F5
+	 # -21=1EB => 42=0x07afd7eb, 43=0x000001eb
+	 #sysconf.SYSCONF_CFG42.poke(0x07D7EBF5)
+	 #sysconf.SYSCONF_CFG43.poke(0x000001F5)
+	 */
+
+	/* TO BE UPDATED FOR 7200/MB671 */
+	POKE32(STX7200_SYSCONF_SYS_CFG42, 0x00000000)
+	POKE32(STX7200_SYSCONF_SYS_CFG43, 0x00000000)
+
+	POKE32(STX7200_SYSCONF_SYS_CFG44, 0x00000000)
+	POKE32(STX7200_SYSCONF_SYS_CFG45, 0x00000000)
+
+	/* ----- STx7200 EMI configuration ----- */
+
+	POKE32(ST40_EMI_BANK_ENABLE, 0x00000005)
+
+	/* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
+	POKE32(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE32(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
+	POKE32(ST40_EMI_BANK2_BASEADDRESS, 0x0000000c)
+	POKE32(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
+	POKE32(ST40_EMI_BANK4_BASEADDRESS, 0x00000014)
+
+	/* Bank 0 - On-board 32MBytes Flash at address 0x00000000 -> 0x01ffffff */
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+
+	/* Bank 1 - Not configured */
+	/* Bank 2 - Not configured */
+	/* Bank 3 - Not configured */
+	/* Bank 4 - Not configured */
+
+	/* Program other EMI registers */
+	POKE32(ST40_EMI_GENCFG, 0x00000050)
+
+	/* ----- STx7200 LMI0 configuration ----- */
+
+	/* "Refresh Interval" is set equal to 0xA28=2600 => 2600*3ns=7.8us */
+	POKE32(ST40_LMI_MIM_0(0), 0x07f6015b)
+	POKE32(ST40_LMI_MIM_1(0), 0x000000b0)
+
+	POKE32(ST40_LMI_STR_0(0), 0xcd2db41b)
+	POKE32(ST40_LMI_STR_1(0), 0x002202d6)
+
+	/* lmi base address 0x08000000 + 256Mbytes */
+	POKE32(ST40_LMI_SDRA0_0(0), 0x18001a20)
+
+	/* lmi base address 0x08000000 + 256Mbytes */
+	POKE32(ST40_LMI_SDRA1_0(0), 0x18001a20)
+
+	/* Delay ~ 200 uS (assumes 400MHz CPU clock) */
+	DELAY(200 * 400)
+
+	/* Enable clock with NOP command */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020023)
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+
+	/* Precharge all */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020022)
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+
+	/* Issue EMRS2 */
+	POKE32(ST40_LMI_SDMR0(0), 0x00010000)
+
+	/* Issue EMRS3 */
+	POKE32(ST40_LMI_SDMR0(0), 0x00018000)
+
+	/* Issue EMRS1 to enable DLL */
+	POKE32(ST40_LMI_SDMR0(0), 0x00008004)
+
+	/* Issue MRS with DLL reset, CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
+	POKE32(ST40_LMI_SDMR0(0), 0x00000b53)
+
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+
+	/* Precharge all */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020022)
+	/* 2 CBR (auto refresh) */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020024)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020024)
+
+	/* Issue MRS with CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
+	POKE32(ST40_LMI_SDMR0(0), 0x00000a53)
+
+	/* Enable auto refresh */
+	POKE32(ST40_LMI_MIM_0(0), 0x07f6035b)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+
+	POKE32(ST40_LMI_GCC_0(0), 0x00000000)
+
+	/* ----- STx7200 LMI1 configuration ----- */
+
+	POKE32(ST40_LMI_MIM_0(1), 0x07f6015b)
+	POKE32(ST40_LMI_MIM_1(1), 0x000000b0)
+
+	/* SDRAM Timing Register */
+	POKE32(ST40_LMI_STR_0(1), 0xcd2db41b)
+	POKE32(ST40_LMI_STR_1(1), 0x002202d6)
+
+	/* SDRAM Row Attribute 0 */
+	/* lmi base address 0x18000000 + 64Mbytes */
+	POKE32(ST40_LMI_SDRA0_0(1), 0x1c001a20)
+
+	/* SDRAM Row Attribute 1 */
+	/* lmi base address 0x18000000 + 64Mbytes */
+	POKE32(ST40_LMI_SDRA1_0(1), 0x1c001a20)
+
+	/* Delay ~ 200 uS (assumes 400MHz CPU clock) */
+	DELAY(200 * 400)
+
+	/* Enable clock with NOP command */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020023)
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+
+	/* Precharge all */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020022)
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+
+	/* Issue EMRS2 */
+	POKE32(ST40_LMI_SDMR0(1), 0x00010000)
+
+	/* Issue EMRS3 */
+	POKE32(ST40_LMI_SDMR0(1), 0x00018000)
+
+	/* Issue EMRS1 to enable DLL */
+	POKE32(ST40_LMI_SDMR0(1), 0x00008004)
+
+	/* Issue MRS with DLL reset, CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
+	POKE32(ST40_LMI_SDMR0(1), 0x00000b53)
+
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+
+	/* Precharge all */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020022)
+	/* 2 CBR (auto refresh) */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020024)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020024)
+
+	/* Issue MRS with CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
+	POKE32(ST40_LMI_SDMR0(1), 0x00000a53)
+
+	/* Enable auto refresh */
+	POKE32(ST40_LMI_MIM_0(1), 0x07f6035b)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+
+	POKE32(ST40_LMI_GCC_0(1), 0x00000000)
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI0 and LMI1 base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+	POKE_LONG(ST40_LMI_SDRA0_0(0), 0x50001a00)
+	POKE_LONG(ST40_LMI_SDRA1_0(0), 0x50001a00)
+	POKE_LONG(ST40_LMI_SDRA0_0(1), 0x90001a00)
+	POKE_LONG(ST40_LMI_SDRA1_0(1), 0x90001a00)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/cb102/sconsole.c b/board/cb102/sconsole.c
new file mode 100644
index 0000000..af92525
--- /dev/null
+++ b/board/cb102/sconsole.c
@@ -0,0 +1,129 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+
+#include "sconsole.h"
+
+#if 0
+void (*sconsole_putc) (char) = 0;
+void (*sconsole_puts) (const char *) = 0;
+int (*sconsole_getc) (void) = 0;
+int (*sconsole_tstc) (void) = 0;
+void (*sconsole_setbrg) (void) = 0;
+#endif
+
+#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
+int serial_init (void)
+{
+	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+	sb->pos = 0;
+	sb->size = 0;
+	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
+
+	return (0);
+}
+
+void serial_putc (char c)
+{
+	if (sconsole_putc) {
+		(*sconsole_putc) (c);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		if (c) {
+			sb->data[sb->pos++] = c;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+void serial_puts (const char *s)
+{
+	if (sconsole_puts) {
+		(*sconsole_puts) (s);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		while (*s) {
+			sb->data[sb->pos++] = *s++;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+int serial_getc (void)
+{
+	if (sconsole_getc) {
+		return (*sconsole_getc) ();
+	} else {
+		return 0;
+	}
+}
+
+int serial_tstc (void)
+{
+	if (sconsole_tstc) {
+		return (*sconsole_tstc) ();
+	} else {
+		return 0;
+	}
+}
+
+void serial_setbrg (void)
+{
+	if (sconsole_setbrg) {
+		(*sconsole_setbrg) ();
+	}
+}
+
+void sconsole_flush (void)
+{
+	if (sconsole_putc) {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+		unsigned int end = sb->pos < sb->size
+			? sb->pos + sb->max_size - sb->size
+			: sb->pos - sb->size;
+
+		while (sb->size) {
+			(*sconsole_putc) (sb->data[end++]);
+			if (end == sb->max_size) {
+				end = 0;
+			}
+			sb->size--;
+		}
+	}
+}
+#endif
diff --git a/board/cb102/sconsole.h b/board/cb102/sconsole.h
new file mode 100644
index 0000000..1666f21
--- /dev/null
+++ b/board/cb102/sconsole.h
@@ -0,0 +1,47 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SCONSOLE_H_
+#define _SCONSOLE_H_
+
+#include <config.h>
+
+typedef struct sconsole_buffer_s
+{
+	unsigned long size;
+	unsigned long max_size;
+	unsigned long pos;
+	char data[1];
+} sconsole_buffer_t;
+
+#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
+
+extern void (*sconsole_putc) (char);
+extern void (*sconsole_puts) (const char *);
+extern int (*sconsole_getc) (void);
+extern int (*sconsole_tstc) (void);
+extern void (*sconsole_setbrg) (void);
+
+extern void sconsole_flush (void);
+
+#endif
diff --git a/board/cb102/u-boot.lds b/board/cb102/u-boot.lds
new file mode 100644
index 0000000..3a1e91b
--- /dev/null
+++ b/board/cb102/u-boot.lds
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2007 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(sh4)
+ENTRY(_start)
+
+SECTIONS
+{
+	.text ALIGN(0x4):
+	{
+		__text_start = .;
+		cpu/sh/start.o (.text)
+		*(.text)
+		__text_end = .;
+	}
+
+	.rodata ALIGN(0x4):
+	{
+		__rodata_start = .;
+		*(.rodata)
+		__rodata_end = .;
+	}
+
+	.data ALIGN(0x4):
+	{
+		__data_start = .;
+		*(.data)
+		__data_end = .;
+	}
+
+	.u_boot_cmd ALIGN(0x4):
+	{
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	_uboot_end_data = .;
+
+	.bss ALIGN(0x4):
+	{
+		__bss_start = .;
+		*(.bss)
+		__bss_end = .;
+	}
+	_uboot_end = .;
+}
diff --git a/board/mb519/mb519.c b/board/mb519/mb519.c
index 08d1b21..7db5570 100644
--- a/board/mb519/mb519.c
+++ b/board/mb519/mb519.c
@@ -24,6 +24,7 @@
 
 #include <common.h>
 #include <command.h>
+#include <asm/soc.h>
 #include <asm/stx7200reg.h>
 #include <asm/io.h>
 #include <asm/pio.h>
@@ -113,17 +114,6 @@ int board_init(void)
 	sysconf &= ~((1<<0)|(1<<1)|(1<<2)|(1<<3));
 	*STX7200_SYSCONF_SYS_CFG33 = sysconf;
 
-	/* Route Ethernet pins to output */
-	/* bit26-16: conf_pad_eth(10:0) */
-	sysconf = *STX7200_SYSCONF_SYS_CFG41;
-	/* MII0: conf_pad_eth(0) = 0 (ethernet) */
-	sysconf &= ~(1<<16);
-	/* MII1: conf_pad_eth(2) = 0, (3)=0, (4)=0, (9)=0, (10)=0 (ethernet)
-	 * MII1: conf_pad_eth(6) = 0 (MII1TXD[0] = output) */
-	sysconf &= ~( (1<<(16+2)) | (1<<(16+3)) | (1<<(16+4)) | (1<<(16+6)) |
-		      (1<<(16+9)) | (1<<(16+10)));
-	*STX7200_SYSCONF_SYS_CFG41 = sysconf;
-
 	configPIO();
 
 	return 0;
@@ -139,5 +129,15 @@ int checkboard (void)
 #endif
 		"\n");
 
+#ifdef CONFIG_DRIVER_NETSTMAC
+#if defined(CONFIG_STMAC_MAC0)
+	/* On-board PHY (MII0), in MII mode, using its own clock  */
+	stx7200_configure_ethernet(0, 0, 1, 0);
+#elif defined(CONFIG_STMAC_MAC1)
+	/* External PHY board (MII1), in MII mode, using its own clock */
+	stx7200_configure_ethernet(1, 0, 1, 1);
+#endif
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+
 	return 0;
 }
diff --git a/board/mb671/Makefile b/board/mb671/Makefile
new file mode 100644
index 0000000..1f1f703
--- /dev/null
+++ b/board/mb671/Makefile
@@ -0,0 +1,44 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+AOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o sconsole.o
+
+OBJS	= $(COBJS) $(AOBJS)
+
+$(LIB):	.depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/mb671/config.mk b/board/mb671/config.mk
new file mode 100644
index 0000000..9870753
--- /dev/null
+++ b/board/mb671/config.mk
@@ -0,0 +1,44 @@
+#
+# (C) Copyright 2007-2008 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB671 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x97F00000	29-bit mode (Traditional Mode)
+#	0x8FF00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 255MB in P1 (cachable)
+TEXT_BASE = 0x97F00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/mb671/init-mb671.S b/board/mb671/init-mb671.S
new file mode 100644
index 0000000..1a5ba70
--- /dev/null
+++ b/board/mb671/init-mb671.S
@@ -0,0 +1,466 @@
+
+#include "asm/stx7200reg.h"
+#include "../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb671.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+#ifndef CONFIG_STM_NEW_POKE_TABLE_PARADIGM
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+#endif /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
+
+.balign 32
+
+
+__memory_setup_table:
+
+	/* ----- STx7200 Clocks ----- */
+
+	/* Set CLOCKGENA PLL0 into BYPASS... */
+	OR32(STX7200_CLOCKGENA_PLL0_CFG, 0x00100000)
+
+	/* Power down CLOCKGENA PLL0... */
+	OR32(STX7200_CLOCKGENA_POWER_CFG, 0x00000001)
+
+	/* Configure CLOCKGENA PLL0... */
+#ifdef CONFIG_STM_NEW_POKE_TABLE_PARADIGM
+	IF_EQ32(1, STX7200_SYSCONF_DEVICEID_0, 0x0fffffff, 0x0d437041)
+	  /* On STx7200 cut 2, we can go faster - set to 900MHz */
+	  UPDATE32(STX7200_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
+	ELSE(1)
+	  UPDATE32(STX7200_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x01 | (0x0f << 8) | (0x00 << 16))
+	ENDIF(1)
+#else /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
+	IF_DEVID(STX7200_CUT1)
+	  UPDATE32(STX7200_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x01 | (0x0f << 8) | (0x00 << 16))
+	ENDIF
+	IF_DEVID(STX7200_CUT2)
+	  /* On STx7200 cut 2, we can go faster - set to 900MHz */
+	  UPDATE32(STX7200_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
+	ENDIF
+#endif /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
+
+	/* Enable CLOCKGENA PLL0... */
+	UPDATE32(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffe, 0)
+
+	/* Wait for CLOCKGENA PLL0 to lock... */
+	WHILE_NE32(STX7200_CLOCKGENA_PLL0_CFG, 0x80000000, 0x80000000)
+
+	/* Clear CLOCKGENA PLL0 from BYPASS... */
+	UPDATE32(STX7200_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+
+	/* Set CLOCKGENA PLL1 into BYPASS... */
+	OR32(STX7200_CLOCKGENA_PLL1_CFG, 0x00100000)
+
+	/* Power down CLOCKGENA PLL1... */
+	OR32(STX7200_CLOCKGENA_POWER_CFG, 0x00000002)
+
+	/* Configure CLOCKGENA PLL1... */
+	UPDATE32(STX7200_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x01 | (0x0f << 8))
+
+	/* Enable CLOCKGENA PLL1... */
+	UPDATE32(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffd, 0)
+
+	/* Wait for CLOCKGENA PLL1 to lock... */
+	WHILE_NE32(STX7200_CLOCKGENA_PLL1_CFG, 0x80000000, 0x80000000)
+
+	/* Clear CLOCKGENA PLL1 from BYPASS... */
+	UPDATE32(STX7200_CLOCKGENA_PLL1_CFG, 0xffefffff, 0)
+
+	/* Set CLOCKGENA PLL2 into BYPASS... */
+	OR32(STX7200_CLOCKGENA_PLL2_CFG, 0x00100000)
+
+	/* Power down CLOCKGENA PLL2... */
+	OR32(STX7200_CLOCKGENA_POWER_CFG, 0x00000004)
+
+	/* Configure CLOCKGENA PLL2... */
+	UPDATE32(STX7200_CLOCKGENA_PLL2_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
+
+	/* Enable CLOCKGENA PLL2... */
+	UPDATE32(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffb, 0)
+
+	/* Wait for CLOCKGENA PLL2 to lock... */
+	WHILE_NE32(STX7200_CLOCKGENA_PLL2_CFG, 0x80000000,  0x80000000)
+
+	/* Clear CLOCKGENA PLL2 from BYPASS... */
+	UPDATE32(STX7200_CLOCKGENA_PLL2_CFG, 0xffefffff, 0)
+
+	/* Set CLOCKGENB PLL0 into BYPASS... */
+	OR32(STX7200_CLOCKGENB_PLL0_CFG, 0x00100000)
+
+	/* Power down CLOCKGENB PLL0... */
+	OR32(STX7200_CLOCKGENB_POWER_CFG, 0x00008000)
+
+	/* Configure CLOCKGENB PLL0... */
+	UPDATE32(STX7200_CLOCKGENB_PLL0_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
+
+	/* Enable CLOCKGENB PLL0... */
+	UPDATE32(STX7200_CLOCKGENB_POWER_CFG, 0xffff7fff, 0)
+
+	/* Wait for CLOCKGENB PLL0 to lock... */
+	WHILE_NE32(STX7200_CLOCKGENB_PLL0_CFG, 0x80000000, 0x80000000)
+
+	/* Clear CLOCKGENB PLL0 from BYPASS... */
+	UPDATE32(STX7200_CLOCKGENB_PLL0_CFG, 0xffefffff, 0)
+
+	/* Power down PLL... */
+	OR32(STX7200_SYSCONF_SYS_CFG11, 0x00001000)
+
+	/* Configure PLL... */
+#ifdef CONFIG_STM_NEW_POKE_TABLE_PARADIGM
+	IF_EQ32(1, STX7200_SYSCONF_DEVICEID_0, 0x0fffffff, 0x0d437041)
+	  /* On cut 2 set LMI clock to 800MHz */
+	  UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x50 << 1))
+	ELSE(1)
+	  /* For cut 1 */
+	  IF_EQ32(2, 0xa5020000, 0x000000ff, 0x0000000a)
+	    /* On PCB rev A, we have a limitation on LMI1: Set LMI clock to 400MHz */
+	    UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x28 << 1))
+	  ELSE(2)
+	    /* Set LMI clock to 666MHz */
+	    UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x05 << 9) | (0x6f << 1))
+	  ENDIF(2)
+	ENDIF(1)
+#else /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
+	IF_DEVID(STX7200_CUT1)
+	    /* on cut 1, set LMI clock to 666MHz */
+	  UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x05 << 9) | (0x6f << 1))
+	    /* On PCB rev A, we have a limitation on LMI1: Set LMI clock to 400MHz */
+	  IF(0xa5020000, 0x000000ff, 0x0000000a, UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x28 << 1)))
+	ENDIF
+	IF_DEVID(STX7200_CUT2)
+	  /* On cut 2, set LMI clock to 800MHz */
+	  UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x50 << 1))
+	ENDIF
+#endif /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
+
+	/* Enable CLOCKGENA PLL1... */
+	UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xffffefff, 0)
+
+	/* Wait for CLOCKGENA PLL1 to lock... */
+#ifdef CONFIG_STM_NEW_POKE_TABLE_PARADIGM
+	IF_EQ32(1, STX7200_SYSCONF_DEVICEID_0, 0x0fffffff, 0x0d437041)
+	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 1)
+	ELSE(1)
+	  /* On cut 1 polarity inverted on lock bit */
+	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 0)
+	ENDIF(1)
+#else /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
+	IF_DEVID(STX7200_CUT1)
+	  /* On cut 1 polarity inverted on lock bit */
+	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 0)
+	ENDIF
+	IF_DEVID(STX7200_CUT2)
+	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 1)
+	ENDIF
+#endif /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
+
+	/* ----- STx7200 Sysconf ----- */
+
+	/* PLI_CLOCK_ENABLE set to 0 */
+	UPDATE32(STX7200_SYSCONF_SYS_CFG58, ~(1 << 0), 0)
+
+	/* LMI sub-sys & pl exit from reset */
+	OR32(STX7200_SYSCONF_SYS_CFG11, 0x1 | (1 << 27))
+	OR32(STX7200_SYSCONF_SYS_CFG15, 0x1 | (1 << 27))
+
+	/* Delay ~ 200 uS (assumes 400MHz CPU clock) */
+	DELAY(200 * 400)
+
+	/* PLI_CLOCK_ENABLE set to 1 */
+	OR32(STX7200_SYSCONF_SYS_CFG58, (1 << 0))
+
+	/* Check both DLL on LMI0 are locked */
+	WHILE_NE32(STX7200_SYSCONF_SYS_STA03, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
+
+	/* Check both DLL on LMI1 are locked */
+	WHILE_NE32(STX7200_SYSCONF_SYS_STA05, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
+
+	/* Adjust proga, progb, zoutproga, and receiver mode for LMI0 */
+	POKE32(STX7200_SYSCONF_SYS_CFG12, 0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10))
+
+	/* Adjust proga, progb, zoutproga, and receiver mode for LMI1 */
+	POKE32(STX7200_SYSCONF_SYS_CFG16, 0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10))
+
+	/* Enable AutoPrecharge */
+	POKE32(STX7200_SYSCONF_SYS_CFG38, 0x000ffd08)
+	POKE32(STX7200_SYSCONF_SYS_CFG39, 0x000ffd18)
+
+	/* Force DLL1 and DLL2 command of LMI0 */
+	POKE32(STX7200_SYSCONF_SYS_CFG13, 0x00000002)
+	POKE32(STX7200_SYSCONF_SYS_CFG14, 0x00000002)
+
+	/* Force DLL1 and DLL2 command of LMI1 */
+	POKE32(STX7200_SYSCONF_SYS_CFG17, 0x00000002)
+	POKE32(STX7200_SYSCONF_SYS_CFG18, 0x00000002)
+
+	/* Set cfg55 and cfg56 */
+	POKE32(STX7200_SYSCONF_SYS_CFG55, 0x03fc2004 | (0 << 10) | (0x7 << 7))
+	POKE32(STX7200_SYSCONF_SYS_CFG56, 0x03fc2004 | (0 << 10) | (0x7 << 7))
+
+	/* PDL offsets
+	 # -11=1F5 => 42=0x07D7EBF5, 43=0x000001F5
+	 # -21=1EB => 42=0x07afd7eb, 43=0x000001eb
+	 #sysconf.SYSCONF_CFG42.poke(0x07D7EBF5)
+	 #sysconf.SYSCONF_CFG43.poke(0x000001F5)
+	 */
+
+	/* TO BE UPDATED FOR 7200/MB671 */
+	POKE32(STX7200_SYSCONF_SYS_CFG42, 0x00000000)
+	POKE32(STX7200_SYSCONF_SYS_CFG43, 0x00000000)
+
+	POKE32(STX7200_SYSCONF_SYS_CFG44, 0x00000000)
+	POKE32(STX7200_SYSCONF_SYS_CFG45, 0x00000000)
+
+	/* ----- STx7200 EMI configuration ----- */
+
+	POKE32(ST40_EMI_BANK_ENABLE, 0x00000005)
+
+	/* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
+	POKE32(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE32(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
+	POKE32(ST40_EMI_BANK2_BASEADDRESS, 0x0000000c)
+	POKE32(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
+	POKE32(ST40_EMI_BANK4_BASEADDRESS, 0x00000014)
+
+	/* Bank 0 - On-board 32MBytes Flash at address 0x00000000 -> 0x01ffffff */
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+
+	/* Bank 2 - DVB-CI at address 0x03000000 -> 0x03FFFFFF */
+	POKE32(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
+	POKE32(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
+	POKE32(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
+	POKE32(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+
+	/* Bank 4 - EPLD Registers at address 0x05000000 -> 0x05FFFFFF */
+	POKE32(ST40_EMI_BANK4_EMICONFIGDATA0, 0x042086f1)
+	POKE32(ST40_EMI_BANK4_EMICONFIGDATA1, 0x8a002200)
+	POKE32(ST40_EMI_BANK4_EMICONFIGDATA2, 0x8a004200)
+	POKE32(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)
+
+	/* Program other EMI registers */
+	POKE32(ST40_EMI_GENCFG, 0x00000050)
+
+	/* ----- STx7200 LMI0 configuration ----- */
+
+	/* "Refresh Interval" is set equal to 0xA28=2600 => 2600*3ns=7.8us */
+	POKE32(ST40_LMI_MIM_0(0), 0x07f6015b)
+	POKE32(ST40_LMI_MIM_1(0), 0x000000b0)
+
+	POKE32(ST40_LMI_STR_0(0), 0xcd2db41b)
+	POKE32(ST40_LMI_STR_1(0), 0x002202d6)
+
+	/* lmi base address 0x08000000 + 256Mbytes */
+	POKE32(ST40_LMI_SDRA0_0(0), 0x18001a20)
+
+	/* lmi base address 0x08000000 + 256Mbytes */
+	POKE32(ST40_LMI_SDRA1_0(0), 0x18001a20)
+
+	/* Delay ~ 200 uS (assumes 400MHz CPU clock) */
+	DELAY(200 * 400)
+
+	/* Enable clock with NOP command */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020023)
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+
+	/* Precharge all */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020022)
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+
+	/* Issue EMRS2 */
+	POKE32(ST40_LMI_SDMR0(0), 0x00010000)
+
+	/* Issue EMRS3 */
+	POKE32(ST40_LMI_SDMR0(0), 0x00018000)
+
+	/* Issue EMRS1 to enable DLL */
+	POKE32(ST40_LMI_SDMR0(0), 0x00008004)
+
+	/* Issue MRS with DLL reset, CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
+	POKE32(ST40_LMI_SDMR0(0), 0x00000b53)
+
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+
+	/* Precharge all */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020022)
+	/* 2 CBR (auto refresh) */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020024)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020024)
+
+	/* Issue MRS with CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
+	POKE32(ST40_LMI_SDMR0(0), 0x00000a53)
+
+	/* Enable auto refresh */
+	POKE32(ST40_LMI_MIM_0(0), 0x07f6035b)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+
+	POKE32(ST40_LMI_GCC_0(0), 0x00000000)
+
+	/* ----- STx7200 LMI1 configuration ----- */
+
+	POKE32(ST40_LMI_MIM_0(1), 0x07f6015b)
+	POKE32(ST40_LMI_MIM_1(1), 0x000000b0)
+
+	/* SDRAM Timing Register */
+	POKE32(ST40_LMI_STR_0(1), 0xcd2db41b)
+	POKE32(ST40_LMI_STR_1(1), 0x002202d6)
+
+	/* SDRAM Row Attribute 0 */
+	/* lmi base address 0x18000000 + 64Mbytes */
+	POKE32(ST40_LMI_SDRA0_0(1), 0x1c001a20)
+
+	/* SDRAM Row Attribute 1 */
+	/* lmi base address 0x18000000 + 64Mbytes */
+	POKE32(ST40_LMI_SDRA1_0(1), 0x1c001a20)
+
+	/* Delay ~ 200 uS (assumes 400MHz CPU clock) */
+	DELAY(200 * 400)
+
+	/* Enable clock with NOP command */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020023)
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+
+	/* Precharge all */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020022)
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+
+	/* Issue EMRS2 */
+	POKE32(ST40_LMI_SDMR0(1), 0x00010000)
+
+	/* Issue EMRS3 */
+	POKE32(ST40_LMI_SDMR0(1), 0x00018000)
+
+	/* Issue EMRS1 to enable DLL */
+	POKE32(ST40_LMI_SDMR0(1), 0x00008004)
+
+	/* Issue MRS with DLL reset, CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
+	POKE32(ST40_LMI_SDMR0(1), 0x00000b53)
+
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+
+	/* Precharge all */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020022)
+	/* 2 CBR (auto refresh) */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020024)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020024)
+
+	/* Issue MRS with CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
+	POKE32(ST40_LMI_SDMR0(1), 0x00000a53)
+
+	/* Enable auto refresh */
+	POKE32(ST40_LMI_MIM_0(1), 0x07f6035b)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+
+	POKE32(ST40_LMI_GCC_0(1), 0x00000000)
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI0 and LMI1 base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+	POKE_LONG(ST40_LMI_SDRA0_0(0), 0x50001a00)
+	POKE_LONG(ST40_LMI_SDRA1_0(0), 0x50001a00)
+	POKE_LONG(ST40_LMI_SDRA0_0(1), 0x90001a00)
+	POKE_LONG(ST40_LMI_SDRA1_0(1), 0x90001a00)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/mb671/mb671.c b/board/mb671/mb671.c
new file mode 100644
index 0000000..254ee1a
--- /dev/null
+++ b/board/mb671/mb671.c
@@ -0,0 +1,144 @@
+/*
+ * (C) Copyright 2007-2008 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7200reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+#ifdef CONFIG_SH_SE_MODE
+#define EPLD_BASE		0xb5000000	/* Phys 0x05000000 */
+#else
+#define EPLD_BASE		0xa5000000
+#endif	/* CONFIG_SH_SE_MODE */
+
+#define EPLD_FlashCtrlAddr	SH4_WORD_REG(EPLD_BASE + 0x400000)
+
+void flashWriteEnable(void)
+{
+	/*  Enable vpp for writing to flash */
+	*EPLD_FlashCtrlAddr = 3;
+}
+
+void flashWriteDisable(void)
+{
+	/*  Disable vpp for writing to flash */
+	*EPLD_FlashCtrlAddr = 2;
+}
+
+#define PIO_BASE  0xfd020000
+
+static void configPIO(void)
+{
+	/*  Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
+	SET_PIO_ASC(PIO_PORT(5), 4, 3, 5, 6);  /* UART3 - AS1 */
+}
+
+int board_init(void)
+{
+	unsigned long sysconf;
+
+	/* Serial port set up */
+	/* Route UART2&3 or SCI inputs instead of DVP to pins: conf_pad_dvp = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG40;
+	sysconf &= ~(1<<16);
+	*STX7200_SYSCONF_SYS_CFG40 = sysconf;
+
+	/* Route UART2&3/SCI outputs instead of DVP to pins: conf_pad_pio[1]=0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<25);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* No idea, more routing: conf_pad_pio[0] = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<24);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART2 (inputs and outputs) instead of SCI to pins: ssc2_mux_sel = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<2);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* conf_pad_pio[4] = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<28);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART3 (inputs and outputs) instead of SCI to pins: ssc3_mux_sel = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* conf_pad_clkobs = 1 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf |= (1<<14);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* I2C and USB related routing */
+	/* bit4: ssc4_mux_sel = 0 (treat SSC4 as I2C) */
+	/* bit26: conf_pad_pio[2] = 0 route USB etc instead of DVO */
+	/* bit27: conf_pad_pio[3] = 0 DVO output selection (probably ignored) */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~((1<<27)|(1<<26)|(1<<4));
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Enable SOFT_JTAG mode.
+	 * Taken from OS21, but is this correct?
+	 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG33;
+	sysconf |= (1<<6);
+	sysconf &= ~((1<<0)|(1<<1)|(1<<2)|(1<<3));
+	*STX7200_SYSCONF_SYS_CFG33 = sysconf;
+
+	configPIO();
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STx7200-Reference (MB671)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+#if defined(CONFIG_STMAC_MAC0)
+	/* On-board PHY on MII0 in RMII mode, using MII_CLK */
+	stx7200_configure_ethernet (0, 1, 0, 0);
+#elif defined(CONFIG_STMAC_MAC1)
+	/* External PHY on MII1 in MII mode, using its own clock */
+	stx7200_configure_ethernet (1, 0, 1, 1);
+#endif
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+
+	return 0;
+}
diff --git a/board/mb671/sconsole.c b/board/mb671/sconsole.c
new file mode 100644
index 0000000..af92525
--- /dev/null
+++ b/board/mb671/sconsole.c
@@ -0,0 +1,129 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+
+#include "sconsole.h"
+
+#if 0
+void (*sconsole_putc) (char) = 0;
+void (*sconsole_puts) (const char *) = 0;
+int (*sconsole_getc) (void) = 0;
+int (*sconsole_tstc) (void) = 0;
+void (*sconsole_setbrg) (void) = 0;
+#endif
+
+#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
+int serial_init (void)
+{
+	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+	sb->pos = 0;
+	sb->size = 0;
+	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
+
+	return (0);
+}
+
+void serial_putc (char c)
+{
+	if (sconsole_putc) {
+		(*sconsole_putc) (c);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		if (c) {
+			sb->data[sb->pos++] = c;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+void serial_puts (const char *s)
+{
+	if (sconsole_puts) {
+		(*sconsole_puts) (s);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		while (*s) {
+			sb->data[sb->pos++] = *s++;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+int serial_getc (void)
+{
+	if (sconsole_getc) {
+		return (*sconsole_getc) ();
+	} else {
+		return 0;
+	}
+}
+
+int serial_tstc (void)
+{
+	if (sconsole_tstc) {
+		return (*sconsole_tstc) ();
+	} else {
+		return 0;
+	}
+}
+
+void serial_setbrg (void)
+{
+	if (sconsole_setbrg) {
+		(*sconsole_setbrg) ();
+	}
+}
+
+void sconsole_flush (void)
+{
+	if (sconsole_putc) {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+		unsigned int end = sb->pos < sb->size
+			? sb->pos + sb->max_size - sb->size
+			: sb->pos - sb->size;
+
+		while (sb->size) {
+			(*sconsole_putc) (sb->data[end++]);
+			if (end == sb->max_size) {
+				end = 0;
+			}
+			sb->size--;
+		}
+	}
+}
+#endif
diff --git a/board/mb671/sconsole.h b/board/mb671/sconsole.h
new file mode 100644
index 0000000..1666f21
--- /dev/null
+++ b/board/mb671/sconsole.h
@@ -0,0 +1,47 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SCONSOLE_H_
+#define _SCONSOLE_H_
+
+#include <config.h>
+
+typedef struct sconsole_buffer_s
+{
+	unsigned long size;
+	unsigned long max_size;
+	unsigned long pos;
+	char data[1];
+} sconsole_buffer_t;
+
+#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
+
+extern void (*sconsole_putc) (char);
+extern void (*sconsole_puts) (const char *);
+extern int (*sconsole_getc) (void);
+extern int (*sconsole_tstc) (void);
+extern void (*sconsole_setbrg) (void);
+
+extern void sconsole_flush (void);
+
+#endif
diff --git a/board/mb671/u-boot.lds b/board/mb671/u-boot.lds
new file mode 100644
index 0000000..3a1e91b
--- /dev/null
+++ b/board/mb671/u-boot.lds
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2007 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(sh4)
+ENTRY(_start)
+
+SECTIONS
+{
+	.text ALIGN(0x4):
+	{
+		__text_start = .;
+		cpu/sh/start.o (.text)
+		*(.text)
+		__text_end = .;
+	}
+
+	.rodata ALIGN(0x4):
+	{
+		__rodata_start = .;
+		*(.rodata)
+		__rodata_end = .;
+	}
+
+	.data ALIGN(0x4):
+	{
+		__data_start = .;
+		*(.data)
+		__data_end = .;
+	}
+
+	.u_boot_cmd ALIGN(0x4):
+	{
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	_uboot_end_data = .;
+
+	.bss ALIGN(0x4):
+	{
+		__bss_start = .;
+		*(.bss)
+		__bss_end = .;
+	}
+	_uboot_end = .;
+}
diff --git a/common/cmd_bdinfo.c b/common/cmd_bdinfo.c
index 2de20c2..6625a60 100644
--- a/common/cmd_bdinfo.c
+++ b/common/cmd_bdinfo.c
@@ -280,7 +280,7 @@ int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 #elif defined(CONFIG_SH_STX7200)
 #include <asm/stx7200reg.h>
 #else
-#error Missing Device Defintions!
+#error Missing Device Definitions!
 #endif
 
 int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
diff --git a/cpu/sh/Makefile b/cpu/sh/Makefile
index db4f8db..71308cc 100644
--- a/cpu/sh/Makefile
+++ b/cpu/sh/Makefile
@@ -26,7 +26,7 @@ include $(TOPDIR)/config.mk
 LIB	= lib$(CPU).a
 
 START	= start.o
-OBJS	= cpu.o interrupts.o usb.o
+OBJS	= cpu.o interrupts.o usb.o cmd_pmb.o
 SOBJS	=
 
 all:	.depend $(START) $(LIB)
diff --git a/cpu/sh/cmd_pmb.c b/cpu/sh/cmd_pmb.c
new file mode 100644
index 0000000..07b1c68
--- /dev/null
+++ b/cpu/sh/cmd_pmb.c
@@ -0,0 +1,181 @@
+/*
+ * (C) Copyright 2008 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/pmb.h>
+#include <asm/addrspace.h>
+
+
+//#define DEBUG
+
+#if defined(CONFIG_SH_SE_MODE)
+
+
+#define PMB_ADDR(i)	((volatile unsigned long*)(P4SEG_PMB_ADDR+((i)<<8)))
+#define PMB_DATA(i)	((volatile unsigned long*)(P4SEG_PMB_DATA+((i)<<8)))
+
+
+#ifdef DEBUG
+#define SHOULD_BE_VALID(pmb)							\
+do {										\
+	if ((valid & (1u<<(pmb))) == 0u)					\
+		printf ("ERROR: PMB[%u].V == 0, but it should be   Valid\n",	\
+			(pmb));							\
+} while(0)
+#define SHOULD_BE_INVALID(pmb)							\
+do {										\
+	if ((valid & (1u<<(pmb))) != 0u)					\
+		printf ("ERROR: PMB[%u].V == 1, but it should be INvalid\n",	\
+			(pmb));							\
+} while(0)
+#endif	/* DEBUG */
+
+
+static unsigned pmb_page_size (const unsigned long data)
+{
+	const unsigned long size = data & 0x90ul;
+
+	return	(size==0x00ul) ?  16 :
+		(size==0x10ul) ?  64 :
+		(size==0x80ul) ? 128 :
+				 512;
+}
+
+static void display_pmb (void)
+{
+	size_t i;
+#ifdef DEBUG
+	unsigned valid = 0;	/* assume all PMBs are invalid */
+#endif	/* DEBUG */
+
+	printf ("\ninfo: sizeof(LMI) = 0x%08x = %uMB (uses %u PMB slot%s)\n\n",
+		CFG_SDRAM_SIZE, CFG_SDRAM_SIZE/1024/1024,
+		(CFG_SH_LMI_NEEDS_2_PMB_ENTRIES) ? 2 : 1,
+		(CFG_SH_LMI_NEEDS_2_PMB_ENTRIES) ? "s" : "");
+
+	for (i=0; i<16; i++)
+	{
+		const unsigned long data = *PMB_DATA(i);
+		const unsigned long addr = *PMB_ADDR(i);
+		const unsigned long mb   = pmb_page_size(data);
+		const unsigned long vpn  = addr >> 24;
+		const unsigned long ppn  = data >> 24;
+
+#ifdef DEBUG
+		if ((data & 0x100) != (addr & 0x100))
+			printf ("ERROR: PMB[%u].V disagrees!\n", i);
+#endif	/* DEBUG */
+
+		if (!(data & 0x100))		/* V == 0 ? */
+			continue;		/* skip to next if not valid */
+
+		/* print entry if it is valid */
+		printf ("PMB[%2u]  =  VPN:%02x...%02x  PPN:%02x...%02x  %2s  %1s  %2s  %3uMB\n",
+			i,
+			vpn,				/* VPN (first page) */
+			vpn + (mb >> 4) - 1,		/* VPN (last page) */
+			ppn,				/* PPN (first page) */
+			ppn + (mb >> 4) - 1,		/* PPN (last page) */
+			(data & (1<<0)) ? "WT" : "CB",	/* write-through / copy-back */
+			(data & (1<<3)) ? "C" : "",	/* cacheability */
+			(data & (1<<9)) ? "UB" : "",	/* Unbuffered */
+			mb);				/* SZ */
+
+#ifdef DEBUG
+		valid |= 1u<<i;		/* set bit 'i', in the mask set */
+		switch (i)
+		{
+			case 0:
+				if (vpn != 0x80)
+					printf ("ERROR: PMB[0].VPN != 0x80\n");
+				break;
+
+			case 1:
+				if (vpn != 0x88)
+					printf ("ERROR: PMB[1].VPN != 0x88\n");
+				if (ppn != ((*PMB_DATA(0)>>24)+0x08))
+					printf ("ERROR: PMB[1].PPN != PMB[0].PPN+0x08\n");
+				break;
+
+			case 2:
+				if (vpn != 0x90)
+					printf ("ERROR: PMB[2].VPN != 0x90\n");
+				if (ppn != (*PMB_DATA(0)>>24))
+					printf ("ERROR: PMB[2].PPN != PMB[0].PPN\n");
+				if ((data&0x90) != (*PMB_DATA(0)&0x90))
+					printf ("ERROR: PMB[2].SZ != PMB[0].SZ\n");
+				break;
+
+			case 3:
+				if (vpn != 0x98)
+					printf ("ERROR: PMB[3].VPN != 0x98\n");
+				if (ppn != (*PMB_DATA(1)>>24))
+					printf ("ERROR: PMB[3].PPN != PMB[1].PPN\n");
+				if (ppn != ((*PMB_DATA(2)>>24)+0x08))
+					printf ("ERROR: PMB[3].PPN != PMB[2].PPN+0x08\n");
+				if ((data&0x90) != (*PMB_DATA(1)&0x90))
+					printf ("ERROR: PMB[3].SZ != PMB[1].SZ\n");
+				break;
+
+			default:
+				if ( (vpn < 0xa0) || (vpn > 0xbf) )
+					printf ("ERROR: PMB[%u].VPN not in range 0xa0..0xbf\n",i);
+		}
+#endif	/* DEBUG */
+	}
+
+#ifdef DEBUG
+	/* perform additional checks on validity */
+	SHOULD_BE_VALID(0);
+#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	SHOULD_BE_VALID(1);
+#else
+	SHOULD_BE_INVALID(1);
+#endif	/* CFG_SH_LMI_NEEDS_2_PMB_ENTRIES */
+	SHOULD_BE_VALID(2);
+#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	SHOULD_BE_VALID(3);
+#else
+	SHOULD_BE_INVALID(3);
+#endif	/* CFG_SH_LMI_NEEDS_2_PMB_ENTRIES */
+	SHOULD_BE_INVALID(15);
+#endif	/* DEBUG */
+}
+
+extern int do_pmb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	display_pmb ();
+	return (0);
+}
+
+
+U_BOOT_CMD(
+	pmb, 1, 0, do_pmb,
+	"pmb     - displays the contents of the PMB\n",
+	"- displays the contents of the PMB (when V==1)\n"
+);
+
+#endif	/* CONFIG_SH_SE_MODE */
+
diff --git a/cpu/sh/init_ram.S b/cpu/sh/init_ram.S
index a354471..50318b3 100644
--- a/cpu/sh/init_ram.S
+++ b/cpu/sh/init_ram.S
@@ -123,7 +123,8 @@ p2_to_p1_mask:		.long ~0x20000000
 #define STB7109_CUT1 (STB7100_DEVID_7109_VAL << STB7100_DEVID_ID_SHIFT)
 #define STB7109_CUT2 (STB7100_DEVID_7109_VAL << STB7100_DEVID_ID_SHIFT) | (1 << STB7100_DEVID_CUT_SHIFT)
 #define STB7109_CUT3 (STB7100_DEVID_7109_VAL << STB7100_DEVID_ID_SHIFT) | (2 << STB7100_DEVID_CUT_SHIFT)
-#define STX7200_CUT1 (STX7200_DEVID_7200_VAL << STB7100_DEVID_ID_SHIFT)
+#define STX7200_CUT1 (STX7200_DEVID_7200c1_VAL << STX7200_DEVID_ID_SHIFT)
+#define STX7200_CUT2 (STX7200_DEVID_7200c2_VAL << STX7200_DEVID_ID_SHIFT) | (1 << STX7200_DEVID_CUT_SHIFT)
 
 /*
  * Routine to setup peripheral registers.
diff --git a/cpu/sh/start.S b/cpu/sh/start.S
index 11e370b..4a39e60 100644
--- a/cpu/sh/start.S
+++ b/cpu/sh/start.S
@@ -28,6 +28,7 @@
 #include "asm/addrspace.h"
 #include "asm/sh4reg.h"
 #include "asm/asmdefs.h"
+#include "asm/pmb.h"
 
 #if defined(CONFIG_SH_STB7100)
 #include <asm/stb7100reg.h>
@@ -36,22 +37,31 @@
 #elif defined(CONFIG_SH_STX7200)
 #include <asm/stx7200reg.h>
 #else
-#error Missing Device Defintions!
+#error Missing Device Definitions!
 #endif
 
 
 	.global _start
 _start:
 
+	/* Add a few NOP instructions, to workaround the
+	 * problem reported in the following bugzilla report:
+	 * https://bugzilla.stlinux.com/show_bug.cgi?id=4173 */
+	nop
+	nop
+
 	/* Set SR:	MD=1, RB=0, BL=0, FD=0, IMASK=0xF */
+set_sr:
 	MOV_CONST32_R0 0x400000F0
 	ldc	r0, sr
 
 	/* Set FPSCR:	FR=0, SZ=0, PR=1, DN=0, RM=01 */
+set_fpscr:
 	MOV_CONST32_R0 0x00080001
 	lds	r0, fpscr
 
 	/* disable the watchdog timer */
+disable_watchdog:
 	MOV_CONST32_R0 ST40_CPG_WTCSR
 	mov	r0, r1
 	MOV_CONST16_R0 0xA500	/* WTCSR.TME=0 */
@@ -69,6 +79,7 @@ _start:
 	 *  r8 == 1 assume we are already in 32-bit SE mode (done by GDB).
 	 *  r8 == 0 we are in 29-bit mode, and need to switch to 32-bit mode.
 	 */
+which_location:
 	MOV_CONST32_R0 0x1fffffff	/* set up P0 mask  */
 	mov	r0, r4
 	mova	_start_offset, r0	/* Load source address in r9 */
@@ -99,6 +110,7 @@ _start:
 	 * explicitly invalidate all unused entries
 	 * NOTE: for running from RAM, then keep PMB[0] as is.
 	 */
+invalidate_pmb:
 	MOV_CONST32_R0 (P4SEG_PMB_ADDR)
 	mov	r0, r1
 	mov	#0, r2			/* PMB[n].V = 0, i.e. INVALID */
@@ -112,50 +124,79 @@ _start:
 	  add	#1, r0			/* next index counter */
 
 	/* set up the new PMB entries we want to use */
+set_pmb:
 #if defined(CONFIG_SH_STB7100)
 	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI-Sys UN-cached */
-	SH4_SET_PMB 1 0x90 0x40 128 0 0 1	/* LMI-Sys UN-cached */
-	SH4_SET_PMB 2 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
-	SH4_SET_PMB 3 0xa8 0x00  16		/* NOR FLASH CACHED */
-	SH4_SET_PMB 4 0xb2 0x02  16 0 0 1	/* OFF-chip  Peripherals UN-cached */
-	SH4_SET_PMB 5 0xb8 0x18  64 0 0 1	/* ON-chip   Peripherals UN-cached */
-	SH4_SET_PMB 6 0xbc 0x1c  64 0 0 1	/* ST40 core Peripherals UN-cached */
-#elif defined(CONFIG_SH_STX7200)
-	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 UN-cached */
-	SH4_SET_PMB 1 0x90 0x40 128 0 0 1	/* LMI0 UN-cached */
-	SH4_SET_PMB 2 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
-	SH4_SET_PMB 3 0xa1 0x01  16 0 0 1	/* NOR FLASH UN-cached */
-	SH4_SET_PMB 4 0xa8 0x00  16		/* NOR FLASH CACHED */
-	SH4_SET_PMB 5 0xa9 0x01  16		/* NOR FLASH CACHED */
-#if defined(CONFIG_SH_MB519)			/* MB519 */
-	SH4_SET_PMB 6 0xb5 0x05  16 0 0 1	/* EPLD UN-cached */
-#elif defined(CONFIG_SH_CB101)			/* CB101 */
-	SH4_SET_PMB 6 0xa2 0x02  16 0 0 1	/* NAND FLASH UN-cached */
-	SH4_SET_PMB 7 0xa3 0x03  16 0 0 1	/* NAND FLASH UN-cached */
-#else
-	#error Do not know which board we are using for PMB setup.
-#endif	/* defined(CONFIG_SH_MBxxx) */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI-Sys UN-cached */
+	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 5 0xa8 0x00  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 6 0xb2 0x02  16 0 0 1	/* OFF-chip  Peripherals UN-cached */
+	SH4_SET_PMB 7 0xb8 0x18  64 0 0 1	/* ON-chip   Peripherals UN-cached */
+	SH4_SET_PMB 8 0xbc 0x1c  64 0 0 1	/* ST40 core Peripherals UN-cached */
 #elif defined(CONFIG_SH_STX7111) && defined(CONFIG_SH_MB618)
 	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI UN-cached */
-	SH4_SET_PMB 1 0x90 0x40 128 0 0 1	/* LMI UN-cached */
-	SH4_SET_PMB 2 0xa0 0x00  16 0 0 1	/* NOR/NAND FLASH UN-cached */
-	SH4_SET_PMB 3 0xa1 0x01  16 0 0 1	/* NOR/NAND FLASH UN-cached */
-	SH4_SET_PMB 4 0xa8 0x00  16		/* NOR/NAND FLASH CACHED */
-	SH4_SET_PMB 5 0xa9 0x01  16		/* NOR/NAND FLASH CACHED */
-	SH4_SET_PMB 6 0xb4 0x04  16 0 0 1	/* EPLD UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI UN-cached */
+	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR/NAND FLASH UN-cached */
+	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR/NAND FLASH UN-cached */
+	SH4_SET_PMB 6 0xa8 0x00  16		/* NOR/NAND FLASH CACHED */
+	SH4_SET_PMB 7 0xa9 0x01  16		/* NOR/NAND FLASH CACHED */
+	SH4_SET_PMB 8 0xb4 0x04  16 0 0 1	/* EPLD UN-cached */
+#elif defined(CONFIG_SH_STX7200) && defined(CONFIG_SH_MB519)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 UN-cached */
+	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 6 0xa8 0x00  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 7 0xa9 0x01  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 8 0xb5 0x05  16 0 0 1	/* EPLD UN-cached */
+#elif defined(CONFIG_SH_STX7200) && defined(CONFIG_SH_CB101)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 UN-cached */
+	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 6 0xa8 0x00  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 7 0xa9 0x01  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 8 0xa2 0x02  16 0 0 1	/* NAND FLASH UN-cached */
+	SH4_SET_PMB 9 0xa3 0x03  16 0 0 1	/* NAND FLASH UN-cached */
+#elif defined(CONFIG_SH_STX7200) && defined(CONFIG_SH_MB671)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	SH4_SET_PMB 1 0x88 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	SH4_SET_PMB 3 0x98 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	#endif
+	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 6 0xa8 0x00  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 7 0xa9 0x01  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 8 0xb5 0x05  16 0 0 1	/* EPLD UN-cached */
+#elif defined(CONFIG_SH_STX7200) && defined(CONFIG_SH_CB102)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	SH4_SET_PMB 1 0x88 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	SH4_SET_PMB 3 0x98 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	#endif
+	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 6 0xa8 0x00  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 7 0xa9 0x01  16		/* NOR FLASH CACHED */
 #else
-	#error Do not know which chip we are using for PMB setup.
-#endif	/* defined(CONFIG_SH_STxxx) */
+	#error Do not know which board/chip we are using for PMB setup.
+#endif	/* defined(CONFIG_SH_STB7100) */
 #endif	/* CONFIG_SH_SE_MODE */
 
+concider_hyperspace:
 	cmp/pl	r8			/* Are we in correct place already ? */
 	bt	hyperspace
 
 	/* disable the caches */
+do_disable_caches:
 	mov	#-1, a0		/* clear all bits in the CCR */
 	CALL	sh_cache_clear_op_offset
 
 	/* invalidate+enable the caches: both I$ & D$ (with copy-back) */
+do_enable_caches:
 	MOV_CONST16_R0 (SH4_CCR_OCI|SH4_CCR_ICI|SH4_CCR_ICE|SH4_CCR_OCE|SH4_CCR_EMODE)
 	mov	r0, a0
 	CALL	sh_cache_set_op_offset
@@ -164,17 +205,20 @@ _start:
 	 * switch to P0 region (cachable), if we need to.
 	 * Recall, we are still in 29-bit mode at this juncture.
 	 */
+enter_p0:
 	ENTER_P0
 
 	/*
 	 * initialize the memory controllers, if we need to.
 	 */
+do_init_ram:
 	CALL	init_ram_offset		/* init_ram() */
 
 	/*
 	 * enable SE (32-bit) mode, if we need to.
 	 */
 #ifdef CONFIG_SH_SE_MODE
+enable_se_mode:
 #ifdef CONFIG_CPU_SUBTYPE_SH4_2XX	/* it is an SH4-200 */
 	/* enable SE mode & invalidate the UTLB/ITLB */
 	MOV_CONST32_R0 SH4_CCN_MMUCR
@@ -204,6 +248,7 @@ _start:
 
 	/*
 	 * relocate code: r1=source, r2=dest, r3=dest_end
+	 * QQQ: in 32-bit mode, "dest" is UN-cached - should optimize this.
 	 */
 relocate:
 	mov	#0x1f, r0
@@ -239,6 +284,7 @@ relocate:
 	/*
 	 * now jump to absolute (non-PIC) address environment.
 	 */
+do_hyperspace:
 	mov.l	hyperspace_addr, r1
 	jmp	@r1		/* never returns */
 	  nop
@@ -252,6 +298,7 @@ hyperspace:
 	 */
 
 #ifdef CONFIG_SH_SE_MODE
+do_enable_pmb_cache:
 	/* Enable the cacheability for PMB array #0 */
 	CALL sh_toggle_pmb_cacheability_offset
 #endif	/* CONFIG_SH_SE_MODE */
@@ -272,6 +319,7 @@ clear_bss:
 done_bss:
 
 	/* prepare to call board init routine: start_sh4boot() */
+do_start_sh4boot:
 	mov.l	start_sh4boot_addr, r1
 	jmp	@r1			/* never returns */
 	  mov r8, a0
diff --git a/cpu/sh/stb7100/stb7100.c b/cpu/sh/stb7100/stb7100.c
index 8407357..b9f7c8e 100644
--- a/cpu/sh/stb7100/stb7100.c
+++ b/cpu/sh/stb7100/stb7100.c
@@ -24,6 +24,7 @@
 
 #include <common.h>
 #include <command.h>
+#include <asm/soc.h>
 #include <asm/stb7100reg.h>
 #include <asm/io.h>
 #include <asm/pio.h>
@@ -75,7 +76,7 @@ void stb7100_clocks(void)
 #define ETH_IF_ON           0x00010000 /* ETH interface on */
 #define DVO_ETH_PAD_DISABLE 0x00020000 /* DVO eth pad disable */
 
-int stmac_default_pbl(void)
+extern int stmac_default_pbl(void)
 {
   DECLARE_GLOBAL_DATA_PTR;
   bd_t *bd = gd->bd;
@@ -84,11 +85,10 @@ int stmac_default_pbl(void)
   return 32; /*  may be modified externally */
 }
 
-#ifdef CONFIG_STMAC_STE101P_RMII
-void stb7109_mac_speed(int speed)
+extern void stmac_set_mac_speed(int speed)
 {
-
 	unsigned long sysconf = *STB7100_SYSCONF_SYS_CFG07;
+//	printf("QQQ: %s(speed=%u)\n", __FUNCTION__, speed); /* QQQ - DELETE */
 
 	if (speed == 100)
 		sysconf |= MAC_SPEED_SEL;
@@ -97,7 +97,6 @@ void stb7109_mac_speed(int speed)
 
 	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
 }
-#endif
 
 /* ETH MAC pad configuration */
 static void stmac_eth_hw_setup(void)
@@ -107,11 +106,11 @@ static void stmac_eth_hw_setup(void)
 	sysconf = *STB7100_SYSCONF_SYS_CFG07;
 	sysconf |= (DVO_ETH_PAD_DISABLE | ETH_IF_ON /*| MAC_SPEED_SEL*/);
 
-#ifdef CONFIG_STMAC_STE101P_RMII
+#ifdef CONFIG_STMAC_STE101P_RMII	/* QQQ - DELETE */
 	sysconf |= MII_MODE; /* RMII selected*/
-#else
+#else					/* QQQ - DELETE */
 	sysconf &= ~MII_MODE; /* MII selected */
-#endif
+#endif					/* QQQ - DELETE */
 	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
 
 	/* STe101P: enable the external interrupts */
diff --git a/cpu/sh/stx7111/stx7111.c b/cpu/sh/stx7111/stx7111.c
index eb746f2..70ea7de 100644
--- a/cpu/sh/stx7111/stx7111.c
+++ b/cpu/sh/stx7111/stx7111.c
@@ -25,6 +25,7 @@
 
 #include <common.h>
 #include <command.h>
+#include <asm/soc.h>
 #include <asm/stx7111reg.h>
 #include <asm/io.h>
 #include <asm/pio.h>
@@ -57,16 +58,17 @@ static void stx7111_clocks(void)
 
 /* Remaining bits define pad functions, default appears to work */
 
-int stmac_default_pbl(void)
+extern int stmac_default_pbl(void)
 {
 	return 32;
 }
 
-#ifdef CONFIG_STMAC_STE101P_RMII	/* QQQ */
-void stx7111_mac_speed(int speed)
+extern void stmac_set_mac_speed(int speed)
 {
+	/* QQQ: check this code is actually correct for the 7111 */
 	unsigned long sysconf = *STX7111_SYSCONF_SYS_CFG07;
 
+//	printf("QQQ: %s(speed=%u)\n", __FUNCTION__, speed); /* QQQ - DELETE */
 	/* MAC_SPEED_SEL = 0|1 */
 	if (speed == 100)
 		sysconf |= MAC_SPEED_SEL;
@@ -75,7 +77,6 @@ void stx7111_mac_speed(int speed)
 
 	*STX7111_SYSCONF_SYS_CFG07 = sysconf;
 }
-#endif	/* CONFIG_STMAC_STE101P_RMII */
 
 /* ETH MAC pad configuration */
 static void stmac_eth_hw_setup(void)
diff --git a/cpu/sh/stx7200/stx7200.c b/cpu/sh/stx7200/stx7200.c
index 44dffc5..98c8f0e 100644
--- a/cpu/sh/stx7200/stx7200.c
+++ b/cpu/sh/stx7200/stx7200.c
@@ -25,6 +25,7 @@
 
 #include <common.h>
 #include <command.h>
+#include <asm/soc.h>
 #include <asm/stx7200reg.h>
 #include <asm/io.h>
 #include <asm/pio.h>
@@ -58,52 +59,77 @@ static void stx7200_clocks(void)
 #define DISABLE_MSG_WRITE       (1<<14)
 /* Remaining bits define pad functions, default appears to work */
 
-int stmac_default_pbl(void)
+extern int stmac_default_pbl(void)
 {
 	return 32;
 }
 
-#ifdef CONFIG_STMAC_STE101P_RMII
-void stb7109_mac_speed(int speed)
+extern void stmac_set_mac_speed(int speed)
 {
+#if defined(CONFIG_STMAC_MAC0)
+	const int mac = 0;    /* First MAC */
+#elif defined(CONFIG_STMAC_MAC1)
+	const int mac = 1;    /* Second MAC */
+#endif
 	unsigned long sysconf = *STX7200_SYSCONF_SYS_CFG41;
 
 	if (speed == 100)
-		sysconf |= MAC_SPEED;
+		sysconf |= (MAC_SPEED << mac);
 	else if (speed == 10)
-		sysconf &= ~MAC_SPEED;
+		sysconf &= ~(MAC_SPEED << mac);
 
 	*STX7200_SYSCONF_SYS_CFG41 = sysconf;
 }
-#endif
 
 /* ETH MAC pad configuration */
-static void stmac_eth_hw_setup(void)
+extern void stx7200_configure_ethernet(
+	int mac, int rmii, int ext_clk, int phy_bus)
 {
 	unsigned long sysconf;
-#if defined(CONFIG_STMAC_MAC0)
-	const int shift = 0;	/* First MAC */
-#elif defined(CONFIG_STMAC_MAC1)
-	const int shift = 1;	/* Second MAC */
-#endif
 
 	sysconf = *STX7200_SYSCONF_SYS_CFG41;
-        sysconf &= ~(DISABLE_MSG_READ << shift);
-        sysconf &= ~(DISABLE_MSG_WRITE << shift);
-        //sysconf |=  (VCI_ACK_SOURCE << shift);
-        sysconf &= ~(VCI_ACK_SOURCE << shift);
-        sysconf |=  (RESET << shift);
-
-#ifdef CONFIG_STMAC_STE101P_RMII
-        sysconf |= (MII_MODE << shift);
-        sysconf &= ~(PHY_CLK_EXT << shift);
-#else
-        sysconf &= ~(MII_MODE << shift);
-        sysconf &= ~(PHY_CLK_EXT << shift);
-#endif
+
+	/* Route Ethernet pins to output */
+	/* bit26-16: conf_pad_eth(10:0) */
+	if (mac == 0) {
+		/* MII0: conf_pad_eth(0) = 0 (ethernet) */
+		sysconf &= ~(1<<16);
+	} else {
+		/* MII1: conf_pad_eth(2) = 0, (3)=0, (4)=0, (9)=0, (10)=0 (eth)
+		 * MII1: conf_pad_eth(6) = 0 (MII1TXD[0] = output)
+		 * (remaining bits have no effect in ethernet mode */
+		sysconf &= ~( (1<<(16+2)) | (1<<(16+3)) | (1<<(16+4)) |
+			      (1<<(16+5)) | (1<<(16+6)) | (1<<(16+7)) |
+			      (1<<(16+8)) | (1<<(16+9)) | (1<<(16+10))  );
+	}
+
+	/* DISABLE_MSG_FOR_WRITE=0 */
+	sysconf &= ~(DISABLE_MSG_WRITE << mac);
+
+	/* DISABLE_MSG_FOR_READ=0 */
+	sysconf &= ~(DISABLE_MSG_READ << mac);
+
+	/* VCI_ACK_SOURCE = 0 */
+        sysconf &= ~(VCI_ACK_SOURCE << mac);
+
+	/* ETHERNET_INTERFACE_ON (aka RESET) = 1 */
+        sysconf |= (RESET << mac);
+
+	/* RMII_MODE */
+	if (rmii)
+		sysconf |= (MII_MODE << mac);
+	else
+		sysconf &= ~(MII_MODE << mac);
+
+	/* PHY_CLK_EXT */
+	if (ext_clk)
+		sysconf |= (PHY_CLK_EXT << mac);
+	else
+		sysconf &= ~(PHY_CLK_EXT << mac);
+
 	*STX7200_SYSCONF_SYS_CFG41 = sysconf;
 }
-#endif
+#endif	/* CONFIG_DRIVER_NETSTMAC */
 
 int soc_init(void)
 {
@@ -112,10 +138,6 @@ int soc_init(void)
 
 	stx7200_clocks();
 
-#ifdef CONFIG_DRIVER_NETSTMAC
-	stmac_eth_hw_setup();
-#endif
-
 	bd->bi_devid = *STX7200_SYSCONF_DEVICEID_0;
 
 	/*  Make sure reset period is shorter than WDT timeout */
@@ -426,6 +448,8 @@ static void usb_soft_jtag_reset(void)
 
 extern void stx7200_usb_init(void)
 {
+	DECLARE_GLOBAL_DATA_PTR;
+	const bd_t * const bd = gd->bd;
 	unsigned long reg;
 	const unsigned char power_pins[3] = {1, 3, 4};
 	const unsigned char oc_pins[3] = {0, 2, 5};
@@ -466,8 +490,12 @@ extern void stx7200_usb_init(void)
 	/* USB power */
 	SET_PIO_PIN(PIO_PORT(7), power_pins[port], STPIO_ALT_OUT);
 	STPIO_SET_PIN(PIO_PORT(7), power_pins[port], 1);
-	/* USB oc */
-	SET_PIO_PIN(PIO_PORT(7), oc_pins[port], STPIO_ALT_BIDIR);
+
+	/* USB Over-Current */
+ 	if (STX7200_DEVICEID_CUT(bd->bi_devid) < 2)
+		SET_PIO_PIN(PIO_PORT(7), oc_pins[port], STPIO_ALT_BIDIR);
+	else
+		SET_PIO_PIN(PIO_PORT(7), oc_pins[port], STPIO_IN);
 
 	/* tusb_powerdown_req[port] = 0 */
 	reg = readl(STX7200_SYSCONF_SYS_CFG22);
diff --git a/cpu/sh/usb.c b/cpu/sh/usb.c
index 979b264..708f1df 100644
--- a/cpu/sh/usb.c
+++ b/cpu/sh/usb.c
@@ -32,7 +32,7 @@ extern void stx7111_usb_init(void);
 #elif defined(CONFIG_SH_STX7200)
 extern void stx7200_usb_init(void);
 #else
-#error Missing Device Defintions!
+#error Missing Device Definitions!
 #endif
 
 #if defined(CONFIG_USB_OHCI_NEW) && defined(CFG_USB_OHCI_CPU_INIT)
diff --git a/drivers/mtd/cfi_flash.c b/drivers/mtd/cfi_flash.c
index 0ad82e7..9c80b26 100644
--- a/drivers/mtd/cfi_flash.c
+++ b/drivers/mtd/cfi_flash.c
@@ -1147,7 +1147,7 @@ static int flash_detect_cfi (flash_info_t * info)
 		for (info->chipwidth = FLASH_CFI_BY8;
 		     info->chipwidth <= info->portwidth;
 		     info->chipwidth <<= 1) {
-			flash_write_cmd (info, 0, 0, info->cmd_reset);
+			flash_write_cmd (info, 0, 0, FLASH_CMD_RESET);
 			for (cfi_offset=0; cfi_offset < sizeof(flash_offset_cfi)/sizeof(uint); cfi_offset++) {
 				flash_write_cmd (info, 0, flash_offset_cfi[cfi_offset], FLASH_CMD_CFI);
 				if (flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP, 'Q')
@@ -1273,7 +1273,7 @@ ulong flash_get_size (ulong base, int banknum)
 					num_erase_regions, NUM_ERASE_REGIONS);
 				break;
 			}
-			flash_write_cmd (info, 0, 0, FLASH_CMD_CFI);
+
 			if (geometry_reversed)
 				tmp = flash_read_long (info, 0,
 					       FLASH_OFFSET_ERASE_REGIONS +
@@ -1300,14 +1300,18 @@ ulong flash_get_size (ulong base, int banknum)
 				case CFI_CMDSET_INTEL_STANDARD:
 					/* for multi-bank devices, the READ_ID command
 					 * must be issued on a per sector basis */
-					flash_write_cmd (info, sect_cnt, 0, FLASH_CMD_READ_ID);
+					flash_write_cmd (info, sect_cnt,
+                                                         info->cfi_offset,
+                                                         FLASH_CMD_READ_ID);
 					info->protect[sect_cnt] =
 						flash_isset (info, sect_cnt,
 							     FLASH_OFFSET_PROTECT,
 							     FLASH_STATUS_PROTECT);
 					/* for multi-bank devices, the RESET command
 					 * must be issued on a per sector basis */
-					flash_write_cmd (info, sect_cnt, 0, FLASH_CMD_RESET);
+					flash_write_cmd (info, sect_cnt,
+                                                         info->cfi_offset,
+                                                         FLASH_CMD_RESET);
 					break;
 				default:
 					info->protect[sect_cnt] = 0; /* default: not protected */
@@ -1315,11 +1319,13 @@ ulong flash_get_size (ulong base, int banknum)
 
 				sect_cnt++;
 			}
+                        switch (info->vendor) {
+                        case CFI_CMDSET_INTEL_EXTENDED:
+                        case CFI_CMDSET_INTEL_STANDARD:
+                            flash_write_cmd (info, 0, info->cfi_offset, FLASH_CMD_CFI);
+                        }
 		}
 
-		/* go back into CFI mode */
-		flash_write_cmd (info, 0, 0, FLASH_CMD_CFI);
-
 		info->sector_count = sect_cnt;
 		/* multiply the size by the number of chips */
 		info->size = (1 << flash_read_uchar (info, FLASH_OFFSET_SIZE)) * size_ratio;
diff --git a/drivers/net/stm-stmac.c b/drivers/net/stm-stmac.c
index 332fb63..11cd8e8 100644
--- a/drivers/net/stm-stmac.c
+++ b/drivers/net/stm-stmac.c
@@ -25,6 +25,7 @@
 #if defined(CONFIG_DRIVER_NETSTMAC) || defined(CONFIG_DRIVER_NET_STM_GMAC)
 
 #include <command.h>
+#include <asm/soc.h>
 #include <asm/addrspace.h>
 #include <asm/io.h>
 #include <net.h>
@@ -75,8 +76,6 @@ struct dma_t
 
 static void *rx_packets[CONFIG_DMA_RX_SIZE];
 
-extern int stmac_default_pbl(void);
-
 #define likely(x)	__builtin_expect(!!(x), 1)
 #define unlikely(x)	__builtin_expect(!!(x), 0)
 
@@ -84,16 +83,15 @@ extern int stmac_default_pbl(void);
 				 Phy interface
    ---------------------------------------------------------------------------*/
 
-#if defined(CONFIG_STMAC_STE10XP)	/* ST STE10xP */
+#if defined(CONFIG_STMAC_STE10XP)	/* ST STe10xp */
 
-/* STE100P phy identifier values */
-#define STE100P_PHY_HI_ID       0x1c04
-#define STE100P_PHY_LO_ID       0x0011
+/* STe100p phy identifier values */
+#define STE100P_PHY_ID		0x1c040011u
+#define STE100P_PHY_ID_MASK	0xffffffffu
 
-/* STE101P phy identifier values */
-#define STE101P_PHY_HI_ID       0x0006
-#define STE101P_PHY_LO_ID_REVA  0x1c51
-#define STE101P_PHY_LO_ID_REVB  0x1c52
+/* STe101p phy identifier values */
+#define STE101P_PHY_ID		0x00061c50u
+#define STE101P_PHY_ID_MASK	0xfffffff0u
 
 /******************************************************************************
  * IEEE Standard 802.3-2002 vendor specific registers (0x10-0x1e) STe10xP
@@ -134,15 +132,15 @@ extern int stmac_default_pbl(void);
 #elif defined(CONFIG_STMAC_LAN8700)	/* SMSC LAN8700 */
 
 /* SMSC LAN8700 phy identifier values */
-#define LAN8700_PHY_HI_ID       0x0007
-#define LAN8700_PHY_LO_ID       0xc0c3
+#define LAN8700_PHY_ID		0x0007c0c0u
+#define LAN8700_PHY_ID_MASK	0xfffffff0u
 
 #define	SPECIAL_MODE_REG	0x12		/* Special Modes Register */
 #define	PHY_ADDR_MSK		0x001f		/* PHY Address Mask */
 #define	PHY_ADDR_SHIFT		0		/* PHY Address Mask */
 
 #else
-#error Need to define PHY
+#error Need to define which PHY to use
 #endif
 
 
@@ -231,40 +229,32 @@ static unsigned int stmac_phy_check_speed (int phy_addr)
 /* Automatically gets and returns the PHY device */
 static unsigned int stmac_phy_get_addr (void)
 {
-	int i, phyaddr;
-
-	uint stmac_phy_id = 0;
+	unsigned int i;
 
 	for (i = 0; i < 32; i++) {
-		unsigned int id1, id2;
-		phyaddr = (i + 1) % 32;
-
+		unsigned int id1, id2, id;
+		unsigned int phyaddr = (i + 1u) % 32u;
 		id1 = stmac_mii_read (phyaddr, MII_PHYSID1);
 		id2 = stmac_mii_read (phyaddr, MII_PHYSID2);
-
-		/* Make sure it is a valid identifier */
+		id  = (id1 << 16) | (id2);
+		/* Make sure it is a valid (known) identifier */
 #if defined(CONFIG_STMAC_STE10XP)
-		if ((id1 == STE101P_PHY_HI_ID) &&
-		    ((id2 == STE101P_PHY_LO_ID_REVB) ||
-		     (id2 == STE101P_PHY_LO_ID_REVA))) {
-			stmac_phy_id = id1;
-			printf (STMAC "STE101P found\n");
-		} else if ((id1 == STE100P_PHY_HI_ID) &&
-			   (id2 == STE100P_PHY_LO_ID)) {
-			stmac_phy_id = id1;
-			printf (STMAC "STE100P found\n");
+		if ((id & STE101P_PHY_ID_MASK) == STE101P_PHY_ID) {
+			printf (STMAC "STe101P found\n");
+			return phyaddr;
+		} else if ((id & STE100P_PHY_ID_MASK) == STE100P_PHY_ID) {
+			printf (STMAC "STe100P found\n");
+			return phyaddr;
 		}
 #elif defined(CONFIG_STMAC_LAN8700)
-		if ((id1 == LAN8700_PHY_HI_ID) &&
-		    (id2 == LAN8700_PHY_LO_ID)) {
-			stmac_phy_id = id1;
+		if ((id & LAN8700_PHY_ID_MASK) == LAN8700_PHY_ID) {
 			printf (STMAC "SMSC LAN8700 found\n");
-		}
-#endif	/* CONFIG_STMAC_LAN8700 */
-
-		if (stmac_phy_id)
 			return phyaddr;
+		}
+#endif	/* CONFIG_STMAC_STE10XP */
 	}
+
+	printf (STMAC "Unable to find a PHY (unknown ID?)\n");
 	return (-1);
 }
 
@@ -582,9 +572,10 @@ static void stmac_set_mac_mii_cap (int full_duplex, unsigned int speed)
 
 	STMAC_WRITE (flow, MAC_FLOW_CONTROL);
 	STMAC_WRITE (ctrl, MAC_CONTROL);
-#ifdef CONFIG_STMAC_STE101P_RMII
-	stb7109_mac_speed (speed);
-#endif
+	
+	/* ensure the SoC knows the correct speed */
+	stmac_set_mac_speed (speed);
+
 	return;
 }
 
@@ -1192,13 +1183,14 @@ static int stmac_reset_eth (bd_t * bd)
 
 extern int eth_init (bd_t * bd)
 {
+	PRINTK (STMAC "entering %s()\n", __FUNCTION__);
 	stmac_reset_eth (bd);
 	return 0;
 }
 
 extern void eth_halt (void)
 {
-	PRINTK (STMAC "%s\n", __FUNCTION__);
+	PRINTK (STMAC "entering %s()\n", __FUNCTION__);
 
 	/* Reset the TX/RX processes */
 	stmac_dma_stop_rx ();
@@ -1221,6 +1213,7 @@ extern int eth_rx (void)
 /* Send a data block via Ethernet. */
 extern int eth_send (volatile void *packet, int length)
 {
+	PRINTK (STMAC "entering %s()\n", __FUNCTION__);
 #ifdef DEBUG
 	const unsigned char *p = packet;
 	printf("TX   :  0x%08x ", p);
@@ -1240,6 +1233,7 @@ extern int eth_send (volatile void *packet, int length)
 
 extern int stmac_miiphy_initialize(bd_t *bis)
 {
+	PRINTK (STMAC "entering %s()\n", __FUNCTION__);
 #if defined(CONFIG_MII) || defined(CONFIG_CMD_MII)
 	miiphy_register(miidevice, stmac_miiphy_read, stmac_miiphy_write);
 #endif
diff --git a/include/asm-sh/io.h b/include/asm-sh/io.h
index bd61dd5..3841851 100644
--- a/include/asm-sh/io.h
+++ b/include/asm-sh/io.h
@@ -56,7 +56,9 @@
        defined(CONFIG_SH_HMS1)	|| \
        defined(CONFIG_SH_MB519)	|| \
        defined(CONFIG_SH_MB618)	|| \
-       defined(CONFIG_SH_CB101)
+       defined(CONFIG_SH_MB671)	|| \
+       defined(CONFIG_SH_CB101)	|| \
+       defined(CONFIG_SH_CB102)
 #  include "asm/io_stb1eval.h"
 #else
 #  error "What system is this?"
diff --git a/include/asm-sh/pmb.h b/include/asm-sh/pmb.h
new file mode 100644
index 0000000..a5e3069
--- /dev/null
+++ b/include/asm-sh/pmb.h
@@ -0,0 +1,78 @@
+/*
+ * (C) Copyright 2008 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef _PMB_H_
+#define _PMB_H_
+
+	/*
+	 * The PMB contains 16 entries, and supports the following
+	 * 4 page sizes: 16MB, 64MB, 128MB, and 512MB.
+	 *
+	 * Although the PMB has a total of 16 entries, but we will
+	 * pretend that there are only 14, by grouping #0 and #1
+	 * logically together, we will also group #2 and #3 logically
+	 * together. Each of these two new groups will be used to map
+	 * up to 256MB of main memory (LMI0). One group ([2:3]) will
+	 * always map main memory as UN-cached. The other group ([0:1])
+	 * will usually be cached, but will sometimes be un-cached for
+	 * special needs. Both the new groups will reference the *same*
+	 * physical memory, and hence they are virtual aliases for each other.
+	 *
+	 * Thus, PMB[0:1] is used as main memory (LMI), and will mostly
+	 * be used as cached, except on initialization, and when passing
+	 * control to the linux kernel, where it will be un-cached.
+	 * The cacheability of PMB[0:1] may be toggled by calling
+	 * the function sh_toggle_pmb_cacheability().
+	 *
+	 * PMB[2:3] is an alias for PMB[0:1], except it is guaranteed
+	 * to always be UN-cached.
+	 *
+	 * PMB[0:1]  will map 0x80000000 .. 0x8fffffff.	(256MB)
+	 * PMB[2:3]  will map 0x90000000 .. 0x9fffffff.	(256MB)
+	 * PMB[4:15] will map 0xa0000000 .. 0xbfffffff.	(512MB)
+	 *
+	 * If sizeof(LMI) <= 128MB, then PMB[1] and PMB[3] are *unused*,
+	 * i.e. PMB[1].V == PMB[3].V == 0.
+	 *
+	 * Note: PMB[0:3] should all be initialized as UN-cached,
+	 * and then sh_toggle_pmb_cacheability() should be called
+	 * to enable the caching of PMB[0:1].
+	 */
+
+	 /*
+	 * If the main LMI memory is 256MB, then we need to have
+	 * two PMB entries to represent this amount of memory.
+	 * The following predicate will yield TRUE if U-boot
+	 * requires 2 PMB entries (#0, and #1) for main memory
+	 * (plus two more (#2 and #3) for its un-cached alias),
+	 * and FALSE if only a single entry (#0) is required
+	 * (plus one more (#2) for its un-cached alias).
+	 */
+#define CFG_SH_LMI_NEEDS_2_PMB_ENTRIES	\
+	( (CFG_SDRAM_SIZE) > (128*1024*1024) )
+
+
+#endif	/* _PMB_H_ */
+
diff --git a/include/asm-sh/soc.h b/include/asm-sh/soc.h
new file mode 100644
index 0000000..cab439c
--- /dev/null
+++ b/include/asm-sh/soc.h
@@ -0,0 +1,44 @@
+/*
+ * (C) Copyright 2008 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef _SOC_H_
+#define	_SOC_H_
+
+
+/*
+ *	common call-back functons for STMAC.
+ */
+extern int  stmac_default_pbl (void);
+extern void stmac_set_mac_speed (int speed);
+
+
+/*
+ *	functions for the STx7200 SoC device.
+ */
+extern void stx7200_configure_ethernet (
+	int mac, int rmii, int ext_clk, int phy_bus);
+
+#endif	/* _SOC_H_ */
+
diff --git a/include/asm-sh/stx7200reg.h b/include/asm-sh/stx7200reg.h
index aa5a487..313ea4b 100644
--- a/include/asm-sh/stx7200reg.h
+++ b/include/asm-sh/stx7200reg.h
@@ -301,14 +301,28 @@
 #define STX7200_SYSCONF_SYS_CFG45	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01b4)
 #define STX7200_SYSCONF_SYS_CFG46	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01b8)
 #define STX7200_SYSCONF_SYS_CFG47	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01bc)
+#define STX7200_SYSCONF_SYS_CFG48	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01c0)
+#define STX7200_SYSCONF_SYS_CFG49	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01c4)
+#define STX7200_SYSCONF_SYS_CFG50	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01c8)
+#define STX7200_SYSCONF_SYS_CFG51	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01cc)
+#define STX7200_SYSCONF_SYS_CFG52	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01d0)
+#define STX7200_SYSCONF_SYS_CFG53	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01d4)
+#define STX7200_SYSCONF_SYS_CFG54	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01d8)
+#define STX7200_SYSCONF_SYS_CFG55	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01dc)
+#define STX7200_SYSCONF_SYS_CFG56	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01e0)
+#define STX7200_SYSCONF_SYS_CFG57	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01e4)
+#define STX7200_SYSCONF_SYS_CFG58	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01e8)
 
-#define STX7200_DEVID_7200_VAL		0x2C0
+#define STX7200_DEVID_7200c1_VAL	0x2C0	/* STx7200 cut 1.x */
+#define STX7200_DEVID_7200c2_VAL	0x037	/* STx7200 cut 2.x */
 #define STX7200_DEVID_ID_SHIFT		12
-#define STX7200_DEVID_ID_MASK		0x3ff
+#define STX7200_DEVID_ID_MASK		0x3ff	/* ten bits */
 #define STX7200_DEVID_CUT_SHIFT		28
-#define STX7200_DEVID_CUT_MASK		0xf
+#define STX7200_DEVID_CUT_MASK		0xf	/* four bits */
 
-#define STX7200_DEVICEID_7200(ID) ((((ID) >> STX7200_DEVID_ID_SHIFT) & STX7200_DEVID_ID_MASK) == STX7200_DEVID_7200_VAL)
+#define STX7200_DEVICEID_7200(ID)	(	\
+	((((ID)>>STX7200_DEVID_ID_SHIFT)&STX7200_DEVID_ID_MASK)==STX7200_DEVID_7200c1_VAL)  || \
+	((((ID)>>STX7200_DEVID_ID_SHIFT)&STX7200_DEVID_ID_MASK)==STX7200_DEVID_7200c2_VAL)     )
 #define STX7200_DEVICEID_CUT(ID)  ((((ID) >> STX7200_DEVID_CUT_SHIFT) & STX7200_DEVID_CUT_MASK) + 1)
 
 #endif /* __STX7200REG_H */
diff --git a/include/configs/cb102.h b/include/configs/cb102.h
new file mode 100644
index 0000000..cbea66d
--- /dev/null
+++ b/include/configs/cb102.h
@@ -0,0 +1,251 @@
+/*
+ * (C) Copyright 2007-2008 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
+
+/* This should really be replaced with something which uses bd->...	*/
+#define P_CLOCK_RATE	87500000	/* clock rate for CSP		*/
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH (uncached) via PMB */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI0 via PMB */
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI0 Physical Address */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI0 un-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH in P2 region */
+#define CFG_SDRAM_BASE		0x88000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x10000000	/* 256MB of LMI0 SDRAM */
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 kB for Monitor */
+#define CFG_MONITOR_BASE        CFG_FLASH_BASE
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1MB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128kB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD cb102
+
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 kB */
+#	define MONITOR_SECTORS	"1:0-8"		/* 9 sectors */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 kB */
+#	define MONITOR_SECTORS	"1:0-10"	/* 11 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+//#define CONFIG_CMD_JFFS2	/* QQQ: is this needed ? */
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/* we are using the internal ST ASC UART */
+#define CONFIG_STM_ASC_SERIAL	1
+
+/* choose which UART to use */
+#define CFG_STM_ASC_BASE	0xfd033000ul	/* TERM UART3 (J8001) */
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/* are we using the internal ST MAC device ? */
+#define CONFIG_DRIVER_NETSTMAC
+#define CONFIG_STMAC_MAC0			/* Use MAC #0 */
+#define CFG_STM_STMAC_BASE	 0xfd500000ul	/* MAC #0 */
+
+/* we use the on-board SMSC PHY */
+#define CONFIG_STMAC_LAN8700			/* SMSC LAN8700 */
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB0_BASE			0xfd200000	/* ST72681 + NAND08GW3B */
+#	define CFG_USB1_BASE			0xfd300000	/* Front (near RJ-45) */
+#	define CFG_USB2_BASE			0xfd400000	/* Rear (J9002) */
+#	define CFG_USB_BASE			CFG_USB2_BASE
+#	undef CFG_USB_BASE					/* QQQ - DELETE */
+#	define CFG_USB_BASE			CFG_USB2_BASE	/* QQQ - DELETE */
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+#if defined(CONFIG_SH_STB7100_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CFG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"CB102> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+#if 1
+/* M29W640GB: 8Mbyte, 127*64kB plus 8*8kB, a total of 135 blocks */
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+#define CONFIG_FLASH_PROTECT_SINGLE_CELL
+#define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#define CFG_MAX_FLASH_SECT	135	/* max number of sectors on one chip	*/
+#define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+#elif 0
+/* M58LT256GT: 32Mbyte 259 blocks, 128K block size plus parameter block */
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+#define CONFIG_FLASH_PROTECT_SINGLE_CELL
+#define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#define CFG_MAX_FLASH_SECT	259	/* max number of sectors on one chip	*/
+#define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+#endif
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH organization
+ */
+
+/* NAND flash is NOT visible via the EMI, but only through OHCI */
+
+/*-----------------------------------------------------------------------
+ * Address, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_OFFSET		CFG_MONITOR_LEN
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE		0x10000		/* 64kB */
+#define CFG_ENV_SECT_SIZE	0x10000		/* 64kB */
+
+/*----------------------------------------------------------------------
+ * JFFS2 support
+ */
+
+#if defined(CONFIG_CMD_JFFS2)
+#define CONFIG_JFFS2_CMDLINE	/* mtdparts command line support */
+#define MTDPARTS_DEFAULT						\
+	"mtdparts="							\
+	"physmap-flash:"	/* First NOR flash device */		\
+		"256k(U-Boot)"		/* first partition */		\
+		",128k(Environment)"					\
+		",-(RestOfNor0)"	/* last partition */
+#define MTDIDS_DEFAULT							\
+	"nor0=physmap-flash"	/* First NOR flash device */
+#endif	/* CONFIG_CMD_JFFS2 */
+
+#endif	/* __CONFIG_H */
+
diff --git a/include/configs/mb519.h b/include/configs/mb519.h
index c022c44..c85cbda 100644
--- a/include/configs/mb519.h
+++ b/include/configs/mb519.h
@@ -112,7 +112,8 @@
 #define CONFIG_STM_ASC_SERIAL	1
 
 /* choose which UART to use */
-#define CFG_STM_ASC_BASE	0xfd032000ul	/* UART2 */
+#define CFG_STM_ASC_BASE	0xfd032000ul	/* UART2 (lower) */
+//#define CFG_STM_ASC_BASE	0xfd033000ul	/* UART3 (upper) */
 
 /*---------------------------------------------------------------
  * Ethernet driver config
diff --git a/include/configs/mb671.h b/include/configs/mb671.h
new file mode 100644
index 0000000..fca7d1c
--- /dev/null
+++ b/include/configs/mb671.h
@@ -0,0 +1,250 @@
+/*
+ * (C) Copyright 2007-2008 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
+
+/* This should really be replaced with something which uses bd->...	*/
+#define P_CLOCK_RATE	87500000	/* clock rate for CSP		*/
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH (uncached) via PMB */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI0 via PMB */
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI0 Physical Address */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI0 un-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH in P2 region */
+#define CFG_SDRAM_BASE		0x88000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x10000000	/* 256MB of LMI0 SDRAM */
+
+#define CFG_MONITOR_LEN		0x00020000	/* Reserve 128 kB for Monitor */
+#define CFG_MONITOR_BASE        CFG_FLASH_BASE
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1MB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128kB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD mb671
+
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 kB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 kB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/* we are using the internal ST ASC UART */
+#define CONFIG_STM_ASC_SERIAL	1
+
+/* choose which UART to use */
+#define CFG_STM_ASC_BASE	0xfd032000ul	/* UART2 (lower) */
+//#define CFG_STM_ASC_BASE	0xfd033000ul	/* UART3 (upper) */
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 2 options for ethernet, both use the on-chip ST-MAC.
+ * The choice in PHYs is:
+ *    1) The on-board SMSC LAN8700 PHY.
+ *    2) External PHY connected via the MII off-board connector (MB539B).
+ */
+
+/* are we using the internal ST MAC device ? */
+#define CONFIG_DRIVER_NETSTMAC
+
+/* choose which internal MAC to use */
+#if 1
+#	define CONFIG_STMAC_MAC0			/* Use MAC #0 */
+#else
+#	define CONFIG_STMAC_MAC1			/* Use MAC #1 */
+#endif
+
+/*
+ * Select the appropriate base address for the selected MAC.
+ * Also, choose which external PHY type to use.
+ */
+#if defined(CONFIG_STMAC_MAC0)
+#	define CFG_STM_STMAC_BASE	 0xfd500000ul	/* MAC #0 */
+#	define CONFIG_STMAC_LAN8700			/* SMSC LAN8700 */
+#elif defined(CONFIG_STMAC_MAC1)
+#	define CFG_STM_STMAC_BASE	 0xfd510000ul	/* MAC #1 */
+#	define CONFIG_STMAC_LAN8700			/* SMSC LAN8700 */
+#endif
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+//#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB0_BASE			0xfd200000	/* middle */
+#	define CFG_USB1_BASE			0xfd300000	/* right */
+#	define CFG_USB2_BASE			0xfd400000	/* left */
+#	define CFG_USB_BASE			CFG_USB0_BASE
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+/* SATA should work on cut 2 of the STi7200 */
+//#define CONFIG_SH_STB7100_SATA
+
+#ifdef CONFIG_SH_STB7100_SATA
+#	define CFG_PIO_MODE		4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#	define CFG_ATA_BASE_ADDR	0x????
+#	define CFG_ATA_IDE0_OFFSET	0x0
+#	define CFG_ATA_REG_OFFSET	0x0
+#	define CFG_ATA_DATA_OFFSET	0x0
+#	define CFG_ATA_STRIDE		0x4
+#	define CFG_ATA_ALT_OFFSET	0x8
+#endif	/* CONFIG_SH_STB7100_SATA */
+
+#if defined(CONFIG_SH_STB7100_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CFG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"MB671> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+/* M58LT256GT: 32Mbyte 259 blocks, 128K block size plus parameter block */
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+#define CONFIG_FLASH_PROTECT_SINGLE_CELL
+#define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#define CFG_MAX_FLASH_SECT	259	/* max number of sectors on one chip	*/
+#define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+
+/*-----------------------------------------------------------------------
+ * Addresss, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_OFFSET		CFG_MONITOR_LEN
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE		0x10000
+#define CFG_ENV_SECT_SIZE	0x20000
+
+#endif	/* __CONFIG_H */
diff --git a/lib_generic/display_options.c b/lib_generic/display_options.c
index 5ddd94f..27af335 100644
--- a/lib_generic/display_options.c
+++ b/lib_generic/display_options.c
@@ -62,7 +62,7 @@ void print_size (ulong size, const char *s)
 		n += 1;
 	}
 
-	printf ("%2ld", n);
+	printf ("%3ld", n);
 	if (m) {
 		printf (".%ld", m);
 	}
diff --git a/lib_sh/board.c b/lib_sh/board.c
index 35adfd6..4e5ab94 100644
--- a/lib_sh/board.c
+++ b/lib_sh/board.c
@@ -40,7 +40,7 @@
 #elif defined(CONFIG_SH_STX7200)
 #include <asm/stx7200reg.h>
 #else
-#error Missing Device Defintions!
+#error Missing Device Definitions!
 #endif
 #include <asm/st40reg.h>
 
diff --git a/lib_sh/cacheops.S b/lib_sh/cacheops.S
index 940d7c8..22eca9c 100644
--- a/lib_sh/cacheops.S
+++ b/lib_sh/cacheops.S
@@ -1,7 +1,8 @@
 /*
- * (C) Copyright 2004 STMicroelectronics.
+ * (C) Copyright 2004-2008 STMicroelectronics.
  *
  * Andy Sturges <andy.sturges@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -28,6 +29,7 @@
 #include "asm/asmdefs.h"
 #include "asm/linkage.h"
 #include "asm/sh4reg.h"
+#include "asm/pmb.h"
 
 	.text
 
@@ -97,27 +99,66 @@ where	<opcode> should be the masking opcode: "and" or "or".
 	/*
 	 * void sh_toggle_pmb_cacheability (void)
 	 *
-	 * Toggles the cacheability for PMB #0
+	 * Toggles the cacheability for PMB index #0, and
+	 * possibly PMB index #1 as well.
 	 *
 	 * We do this by changing the PC to run out of an
-	 * alised PMB entry (not #0), which is UN-cached.
-	 * From here we 'toggle' the cachability of PMB
-	 * array entry #0, then invalidate the ITLB.
-	 * Finally we switch back the PC to the region
-	 * we were originaly running from.
+	 * aliased PMB entry (not #0, or #1), which is UN-cached.
+	 * From here we 'toggle' the cacheability of the
+	 * appropriate PMB array entries, then invalidate
+	 * the ITLB.  Finally we switch back the PC to the
+	 * region we were originally running from.
 	 *
-	 * We only toggle the UB and the C flags of the PMB array.
+	 * We only toggle the UB and the C flags of PMB[0],
+	 * and possibly PMB[1].
+	 *
+	 * i.e. this function does:
+	 * {
+	 *	PC        = PC | 0x10000000;
+	 *	PMB[0].C  = ~PMB[0].C;
+	 *	PMB[0].UB = ~PMB[0].UB;
+	 * #if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	 *	PMB[1].C  = ~PMB[1].C;
+	 *	PMB[1].UB = ~PMB[1].UB;
+	 * #endif
+	 *      MMUCR.TI  = 1;
+	 *	PC        = PC & ~0x10000000;
+	 * }
 	 *
 	 * Assumptions:
-	 * We assume that an un-cached PMB entry already exists
-	 * which is an alias to the PMB entry we are currenty
-	 * running in. We assume that the transition into
-	 * the UN-cached one can be acevied by setting bit #28
-	 * of the PC.  i.e. OR-ing it with 0x10000000.
+	 * 0) We use 'Z' to mean 0 or 1.
+	 * 1) We assume that the PC (on entry) in running in
+	 *    the virtual address space controlled by
+	 *    array index #Z of the PMB.
+	 *    i.e. PC is in VA defined by PMB[Z].
+	 * 2) PMB[Z] may be cached or UN-cached on entry.
+	 *    The cacheability on exit will be inverted,
+	 *    (i.e. toggled) w.r.t the cacheability on entry.
+	 * 3) We assume that an UN-cached PMB entry already
+	 *    exists which is an alias to the same physical
+	 *    address as the PMB entry we are currently running in.
+	 *    i.e. PMB[x] is an UN-cached alias for PMB[Z].
+	 *    so, PMB[Z].PPN == PMB[x].PPN
+	 * 4) The un-cached PMB entry 'x' must not be:
+	 *    a) Index #Z as this is the one we are changing
+	 *    b) Index #15 as the linux kernel uses this on entry.
+	 *    i.e. x is in the range 2 .. 14
+	 *    Typically, x will be 2 (or 3), but this function
+	 *    does not require this assignment.
+	 * 5) We assume that the transition into the
+	 *    UN-cached area PMB[x] can be achieved by setting
+	 *    bit #28 of the PC.  i.e. OR-ing it with 0x10000000.
+	 *    so, PMB[Z].VPN | 0x10000000 == PMB[x].VPN
+	 *    i.e. PMB[Z] has VA 0x80000000 ... 0x8fffffff
+	 *         PMB[x] has VA 0x90000000 ... 0x9fffffff
+	 * 6) We assume both PMB arrays are enabled, valid, and
+	 *    will not result in an expection when dereferecned.
+	 *    i.e. PMB[Z].V == PMB[x].V == 1
 	 */
 ENTRY(sh_toggle_pmb_cacheability)
-	/* use PMB entry array #0 */
-	.set index, 0		/* PMB array #0 */
+	/* use PMB entry arrays #0, and #1 */
+	.set index0, 0		/* PMB array #0 */
+	.set index1, 1		/* PMB array #1 */
 
 	/* set PC mask as bit #28 */
 	.set mask, 0x10000000	/* 0x80000000 ^ 0x90000000 */
@@ -130,13 +171,21 @@ ENTRY(sh_toggle_pmb_cacheability)
 	mov	r0, r2
 	SWITCH_PMB or, r2	/* PC = PC | 0x10000000 */
 
-	/* now toggle the cacheability of indexed PMB entry */
+	/* now toggle the cacheability of PMB[0] */
 	MOV_CONST32_R0	(toggle)
 	mov	r0, r3
-	MOV_CONST32_R0	(P4SEG_PMB_DATA|(index<<8))
+	MOV_CONST32_R0	(P4SEG_PMB_DATA|(index0<<8))
+	mov.l	@r0, r1		/* read it */
+	xor	r3, r1		/* xor it */
+	mov.l	r1, @r0		/* write it */
+
+#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	/* now toggle the cacheability of PMB[1] */
+	MOV_CONST32_R0	(P4SEG_PMB_DATA|(index1<<8))
 	mov.l	@r0, r1		/* read it */
 	xor	r3, r1		/* xor it */
 	mov.l	r1, @r0		/* write it */
+#endif
 
 	/* Invalidate the ITLB, by setting MMUCR.TI */
 	MOV_CONST32_R0 SH4_CCN_MMUCR
@@ -147,7 +196,7 @@ ENTRY(sh_toggle_pmb_cacheability)
 
 	/* switch PC, to run from original PMB region */
 	not	r2, r2		/* invert the mask */
-	SWITCH_PMB and, r2	/* PC = PC & !0x10000000 */
+	SWITCH_PMB and, r2	/* PC = PC & ~0x10000000 */
 
 	/* return to the caller */
 	rts
diff --git a/lib_sh/sh_linux.c b/lib_sh/sh_linux.c
index 2cc484e..8875288 100644
--- a/lib_sh/sh_linux.c
+++ b/lib_sh/sh_linux.c
@@ -1,7 +1,8 @@
 /*
- * (C) Copyright 2004 STMicroelectronics.
+ * (C) Copyright 2004-2008 STMicroelectronics.
  *
  * Andy Sturges <andy.sturges@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -27,7 +28,8 @@
 #include <asm/cache.h>
 #include <asm/io.h>
 #include <asm/sh4reg.h>
-#include "asm/addrspace.h"
+#include <asm/addrspace.h>
+#include <asm/pmb.h>
 
 #ifdef CONFIG_SHOW_BOOT_PROGRESS
 # include <status_led.h>
@@ -244,7 +246,7 @@ void do_bootm_linux (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[],
 
 	SHOW_BOOT_PROGRESS (15);
 
-	/* try and detect if the kernel is incomptable with U-boot */
+	/* try and detect if the kernel is incompatible with U-boot */
 	if ((*SE_MODE & 0xFFFFFF00) != 0x53453F00)	/* 'SE?.' */
 	{
 		printf("\nWarning: Unable to determine if kernel is built for 29- or 32-bit mode!\n");
@@ -252,11 +254,11 @@ void do_bootm_linux (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[],
 	else if ((*SE_MODE & 0xFF) != CURRENT_SE_MODE)
 	{
 		printf("\n"
-			"Error: A %2u-bit Kernel is incomptable with this %2u-bit U-Boot!\n"
+			"Error: A %2u-bit Kernel is incompatible with this %2u-bit U-Boot!\n"
 			"Please re-configure and re-build vmlinux or u-boot.\n"
 			"Aborting the Boot process - Boot FAILED.  (SE_MODE=0x%08x)\n",
+			CURRENT_SE_MODE ^ (32 ^ 29),
 			CURRENT_SE_MODE,
-			CURRENT_SE_MODE ^ 0x3d,
 			*SE_MODE);
 		return;
 	}
@@ -276,6 +278,11 @@ void do_bootm_linux (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[],
 		*INITRD_START, *INITRD_SIZE);
 
 	/*
+	 * remove Vpp from the FLASH, so that no further writes can occur.
+	 */
+	flashWriteDisable();
+
+	/*
 	 * Flush the operand caches, to ensure that there is no unwritten
 	 * data residing only in the caches, before the kernel invalidates
 	 * them.
@@ -285,50 +292,73 @@ void do_bootm_linux (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[],
 	/* Invalidate both instruction and data caches */
 	sh_cache_set_op(SH4_CCR_OCI|SH4_CCR_ICI);
 
-	/*
-	 * remove Vpp from the FLASH, so that no further writes can occur.
-	 */
-	flashWriteDisable();
-
 #ifdef CONFIG_SH_SE_MODE
 	/*
 	 * Before we can jump into the kernel, we need to invalidate all
-	 * (bar one) of the PMB array entries we are currently using.
+	 * (bar one, or two) of the PMB array entries we are currently using.
 	 * Failure to do this, can result in the kernel creating a
 	 * new PMB entry with an overlapping virtual address, which
 	 * when accessed may result in a ITLBMULTIHIT or OTLBMULTIHIT
 	 * exception being raised.
+	 *
 	 * We also need to enter the kernel running out of an UNCACHED
 	 * PMB entry. To perform this mode switch, we actually need to
-	 * have 2 PMB entries (#0, #1) both valid for the duration of
+	 * have 2 PMB entries (#0, #2) both valid for the duration of
 	 * this mode switching. However, we invalidate all the others,
 	 * prior to this mode switch. Only after the mode switch, can
-	 * we then invaludate PMB[1], leaving just one (uncached) PMB
+	 * we then invalidate PMB[2], leaving just one (uncached) PMB
 	 * still valid - the one mapping the kernel itself (PMB[0]).
-	 * Note: after this point, U-boot may lose access to 
+	 *
+	 * Note: if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES is true, then
+	 * please read the previous comment as:
+	 *
+	 * We also need to enter the kernel running out of an UNCACHED
+	 * PMB entry. To perform this mode switch, we actually need to
+	 * have 4 PMB entries (#0, #1, #2 & #3) valid for the duration of
+	 * this mode switching. However, we invalidate all the others,
+	 * prior to this mode switch. Only after the mode switch, can
+	 * we then invalidate PMB[2:3], leaving just two (uncached) PMB
+	 * still valid - the two mapping the kernel itself (PMB[0:1]).
+	 *
+	 * Note: after this point, U-boot may lose access to
 	 * peripherals, including the serial console - so we can not
 	 * safely call puts(), printf(), etc. from this point onwards.
 	 */
-	/* set PMB[n].V = 0, for n == 2..15 */
-	for(i=2; i<16; i++)
+#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	/* set PMB[n].V = 0, for n == 4..15 */
+	for(i=4; i<16; i++)
+	{
+		*PMB_ADDR(i) = 0;	/* PMB[i].V = 0 */
+	}
+#else	/* CFG_SH_LMI_NEEDS_2_PMB_ENTRIES */
+	/* set PMB[n].V = 0, for n == 1, 3..15 */
+	*PMB_ADDR(1) = 0;		/* PMB[1].V = 0 */
+	for(i=3; i<16; i++)
 	{
 		*PMB_ADDR(i) = 0;	/* PMB[i].V = 0 */
 	}
+#endif	/* CFG_SH_LMI_NEEDS_2_PMB_ENTRIES */
 
 	/*
-	 * Now run out of the UN-cached PMB array #0.
+	 * Now run out of the UN-cached PMB array #0 (and #1).
 	 * For 32-bit mode, our contract with the kernel requires
 	 * that the kernel starts running out of an uncached PMB mapping.
 	 */
 	sh_toggle_pmb_cacheability();
 
-	/* now invalidate PMB entry #1, leaving just PMB #0 valid */
-	*PMB_ADDR(1) = 0;	/* PMB[1].V = 0 */
+#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	/* now invalidate PMB entry #2, #3, leaving just PMB #0, #1 valid */
+	*PMB_ADDR(2) = 0;	/* PMB[2].V = 0 */
+	*PMB_ADDR(3) = 0;	/* PMB[3].V = 0 */
+#else	/* CFG_SH_LMI_NEEDS_2_PMB_ENTRIES */
+	/* now invalidate PMB entry #2, leaving just PMB #0 valid */
+	*PMB_ADDR(2) = 0;	/* PMB[2].V = 0 */
+#endif	/* CFG_SH_LMI_NEEDS_2_PMB_ENTRIES */
 
 	/*
 	 * we need to ensure that the ITLB is flushed, and not
 	 * harbouring any mappings from the recently invalidated
-	 * PMB entires.
+	 * PMB entries.
 	 */
 	 *(volatile unsigned long*)SH4_CCN_MMUCR |= SH4_MMUCR_TI;
 #endif	/* CONFIG_SH_SE_MODE */
diff --git a/lib_sh/time.c b/lib_sh/time.c
index 4d58729..981a495 100644
--- a/lib_sh/time.c
+++ b/lib_sh/time.c
@@ -31,7 +31,7 @@
 #elif defined(CONFIG_SH_STX7200)
 #include <asm/stx7200reg.h>
 #else
-#error Missing Device Defintions!
+#error Missing Device Definitions!
 #endif
 
 #define TMU_TICKS_PER_SEC CFG_HZ
diff --git a/sh_config.mk b/sh_config.mk
index 4c6fea6..e641654 100644
--- a/sh_config.mk
+++ b/sh_config.mk
@@ -1,6 +1,7 @@
 #
-# (C) Copyright 2004
+# (C) Copyright 2004-2008
 # Andy Sturges, STMicroelectronics, andy.sturges@st.com
+# Sean McGoogan STMicroelectronics, <Sean.McGoogan@st.com>
 #
 # See file CREDITS for list of people who contributed to this
 # project.
@@ -26,7 +27,7 @@
 # for actual build number, in the following identifier.
 # Regular Expression for string is:
 # 	"stm[2-9][0-9]-[2-9][0-9][0-9][0-9]-[01][0-9]-[0-3][0-9]"
-SH_IDENT_STRING="\"stm23-2008-06-03\""
+SH_IDENT_STRING="\"stm23-2008-07-31\""
 
 PLATFORM_CPPFLAGS += -DCONFIG_SH4 -D__SH4__ -DCONFIG_IDENT_STRING=$(SH_IDENT_STRING)
 PLATFORM_LDFLAGS  += -n
diff --git a/MAKEALL b/MAKEALL
index 947d49c..383c14a 100755
--- a/MAKEALL
+++ b/MAKEALL
@@ -678,6 +678,8 @@ LIST_sh="		\
 	mb618se		\
 	mb671		\
 	mb671se		\
+	mb680		\
+	mb680se		\
 	cb101		\
 	cb101se		\
 	cb102		\
diff --git a/Makefile b/Makefile
index ea57072..f569360 100644
--- a/Makefile
+++ b/Makefile
@@ -2737,6 +2737,17 @@ mb618se_config :		unconfig
 	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/mb618/config.tmp)
 	@./mkconfig -a mb618 sh sh mb618 "" stx7111
 
+mb628_config \
+mb628se_config :		unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_SH_STX7141   1" >>include/config.h
+	@echo "#define CONFIG_SH_MB628     1" >>include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/mb628/config.tmp)
+	@./mkconfig -a mb628 sh sh mb628 "" stx7141
+
 mb671_config \
 mb671se_config :		unconfig
 	@ >include/config.h
@@ -2748,6 +2759,17 @@ mb671se_config :		unconfig
 	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/mb671/config.tmp)
 	@./mkconfig -a mb671 sh sh mb671 "" stx7200
 
+mb680_config \
+mb680se_config :		unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_SH_STX7105   1" >>include/config.h
+	@echo "#define CONFIG_SH_MB680     1" >>include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/mb680/config.tmp)
+	@./mkconfig -a mb680 sh sh mb680 "" stx7105
+
 cb101_config \
 cb101se_config :		unconfig
 	@ >include/config.h
diff --git a/board/cb101/init-cb101.S b/board/cb101/init-cb101.S
index c088092..7cc8997 100644
--- a/board/cb101/init-cb101.S
+++ b/board/cb101/init-cb101.S
@@ -151,13 +151,13 @@ __memory_setup_table:
   POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
   POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x00000014)
 
-  /* Bank #0 - NOR FLASH (32MB) at address 0x00000000 -> 0x01ffffff */
+  /* Bank #0 - NOR FLASH (32MiB) at address 0x00000000 -> 0x01ffffff */
   POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x04320691)
   POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x8F122300)
   POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x8F122300)
   POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
 
-  /* Bank #1 - NAND FLASH (128MB), at address 0x02000000 -> 0x02FFFFFF */
+  /* Bank #1 - NAND FLASH (128MiB), at address 0x02000000 -> 0x02FFFFFF */
 #if 0
   /* this code has been moved to nand_emi_init() in board/cb101/cb101.c */
   POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA0, 0x04100e99);
@@ -193,10 +193,10 @@ __memory_setup_table:
   POKE_LONG(ST40_LMI_STR_0(0), 0xcb2cab5b)
   POKE_LONG(ST40_LMI_STR_1(0), 0x000002d6)
 
-  /* lmi base address 0x08000000 + 128Mbytes 13x10 */
+  /* lmi base address 0x08000000 + 128MiB 13x10 */
   POKE_LONG(ST40_LMI_SDRA0_0(0), 0x10000a00)
 
-  /* lmi base address 0x08000000 + 128Mbytes 13x10 */
+  /* lmi base address 0x08000000 + 128MiB 13x10 */
   POKE_LONG(ST40_LMI_SDRA1_0(0), 0x10000a00)
 
   /* Enable clock with NOP command */
@@ -284,10 +284,10 @@ __memory_setup_table:
   POKE_LONG(ST40_LMI_STR_0(1), 0xcb2cab5b)
   POKE_LONG(ST40_LMI_STR_1(1), 0x000002d6)
 
-  /* lmi base address 0x18000000 + 64Mbytes 13x10 (all 128MBytes are not visible in 29bits mode) */
+  /* lmi base address 0x18000000 + 64MiB 13x10 (all 128MiB are not visible in 29bits mode) */
   POKE_LONG(ST40_LMI_SDRA0_0(1), 0x1c000a00)
 
-  /* lmi base address 0x18000000 + 64Mbytes 13x10 (all 128MBytes are not visible in 29bits mode) */
+  /* lmi base address 0x18000000 + 64MiB 13x10 (all 128MiB are not visible in 29bits mode) */
   POKE_LONG(ST40_LMI_SDRA1_0(1), 0x1c000a00)
 
   /* Enable clock with NOP command */
diff --git a/board/cb102/init-cb102.S b/board/cb102/init-cb102.S
index 8ba5daf..2be2646 100644
--- a/board/cb102/init-cb102.S
+++ b/board/cb102/init-cb102.S
@@ -211,7 +211,7 @@ __memory_setup_table:
 	POKE32(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
 	POKE32(ST40_EMI_BANK4_BASEADDRESS, 0x00000014)
 
-	/* Bank 0 - On-board 32MBytes Flash at address 0x00000000 -> 0x01ffffff */
+	/* Bank 0 - On-board 32MiB Flash at address 0x00000000 -> 0x01ffffff */
 	POKE32(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
 	POKE32(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
 	POKE32(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
@@ -234,10 +234,10 @@ __memory_setup_table:
 	POKE32(ST40_LMI_STR_0(0), 0xcd2db41b)
 	POKE32(ST40_LMI_STR_1(0), 0x002202d6)
 
-	/* lmi base address 0x08000000 + 256Mbytes */
+	/* lmi base address 0x08000000 + 256MiB */
 	POKE32(ST40_LMI_SDRA0_0(0), 0x18001a20)
 
-	/* lmi base address 0x08000000 + 256Mbytes */
+	/* lmi base address 0x08000000 + 256MiB */
 	POKE32(ST40_LMI_SDRA1_0(0), 0x18001a20)
 
 	/* Delay ~ 200 uS (assumes 400MHz CPU clock) */
@@ -323,11 +323,11 @@ __memory_setup_table:
 	POKE32(ST40_LMI_STR_1(1), 0x002202d6)
 
 	/* SDRAM Row Attribute 0 */
-	/* lmi base address 0x18000000 + 64Mbytes */
+	/* lmi base address 0x18000000 + 64MiB */
 	POKE32(ST40_LMI_SDRA0_0(1), 0x1c001a20)
 
 	/* SDRAM Row Attribute 1 */
-	/* lmi base address 0x18000000 + 64Mbytes */
+	/* lmi base address 0x18000000 + 64MiB */
 	POKE32(ST40_LMI_SDRA1_0(1), 0x1c001a20)
 
 	/* Delay ~ 200 uS (assumes 400MHz CPU clock) */
diff --git a/board/mb519/init-mb519.S b/board/mb519/init-mb519.S
index f1539e0..5bde353 100644
--- a/board/mb519/init-mb519.S
+++ b/board/mb519/init-mb519.S
@@ -151,7 +151,7 @@ __memory_setup_table:
   POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
   POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x00000014)
 
-  /* Bank 0 - On-board 32MBytes Flash at address 0x00000000 -> 0x01ffffff */
+  /* Bank 0 - On-board 32MiB Flash at address 0x00000000 -> 0x01ffffff */
   POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
   POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
   POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
@@ -181,10 +181,10 @@ __memory_setup_table:
   POKE_LONG(ST40_LMI_STR_0(0), 0xcb2cab5b)
   POKE_LONG(ST40_LMI_STR_1(0), 0x000002d6)
 
-  /* lmi base address 0x08000000 + 128Mbytes 13x10 */
+  /* lmi base address 0x08000000 + 128MiB 13x10 */
   POKE_LONG(ST40_LMI_SDRA0_0(0), 0x10000a00)
 
-  /* lmi base address 0x08000000 + 128Mbytes 13x10 */
+  /* lmi base address 0x08000000 + 128MiB 13x10 */
   POKE_LONG(ST40_LMI_SDRA1_0(0), 0x10000a00)
 
   /* Enable clock with NOP command */
@@ -272,10 +272,10 @@ __memory_setup_table:
   POKE_LONG(ST40_LMI_STR_0(1), 0xcb2cab5b)
   POKE_LONG(ST40_LMI_STR_1(1), 0x000002d6)
 
-  /* lmi base address 0x18000000 + 64Mbytes 13x10 (all 128MBytes are not visible in 29bits mode) */
+  /* lmi base address 0x18000000 + 64MiB 13x10 (all 128MiB are not visible in 29bits mode) */
   POKE_LONG(ST40_LMI_SDRA0_0(1), 0x1c000a00)
 
-  /* lmi base address 0x18000000 + 64Mbytes 13x10 (all 128MBytes are not visible in 29bits mode) */
+  /* lmi base address 0x18000000 + 64MiB 13x10 (all 128MiB are not visible in 29bits mode) */
   POKE_LONG(ST40_LMI_SDRA1_0(1), 0x1c000a00)
 
   /* Enable clock with NOP command */
diff --git a/board/mb618/init-mb618.S b/board/mb618/init-mb618.S
index 7518a9c..273f471 100644
--- a/board/mb618/init-mb618.S
+++ b/board/mb618/init-mb618.S
@@ -168,13 +168,13 @@ __memory_setup_table:
 	POKE32(ST40_EMI_BANK3_BASEADDRESS, 0x00000014)
 	POKE32(ST40_EMI_BANK4_BASEADDRESS, 0x0000001C)
 
-	/* Bank 0 - On-board 32MBytes Flash at address 0x00000000 -> 0x01ffffff */
+	/* Bank 0 - On-board 32MiB Flash at address 0x00000000 -> 0x01ffffff */
 	POKE32(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
 	POKE32(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
 	POKE32(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
 	POKE32(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
 
-	/* Bank 1 - STEM 8 MBytes 0x04000000 -> 0x047fffff */
+	/* Bank 1 - STEM 8 MiB 0x04000000 -> 0x047fffff */
 	POKE32(ST40_EMI_BANK1_EMICONFIGDATA0, 0x002016d1)
 	POKE32(ST40_EMI_BANK1_EMICONFIGDATA1, 0x9d222200)
 	POKE32(ST40_EMI_BANK1_EMICONFIGDATA2, 0x9d220044)
@@ -186,8 +186,8 @@ __memory_setup_table:
 	POKE32(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
 	POKE32(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
 
-	/* Bank 3 - 32MB Boards register and either DVBCI notCe2 or
-		STEM notCS1 (16MB + 16MB split bank) 0x05000000 -> 0x06ffffff
+	/* Bank 3 - 32MiB Boards register and either DVBCI notCe2 or
+		STEM notCS1 (16MiB + 16MiB split bank) 0x05000000 -> 0x06ffffff
 	 */
 	POKE32(ST40_EMI_BANK3_EMICONFIGDATA0, 0x002016d1)
 	POKE32(ST40_EMI_BANK3_EMICONFIGDATA1, 0x9d222200)
@@ -214,7 +214,7 @@ __memory_setup_table:
 	POKE32(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
 	POKE32(ST40_EMI_BANK4_BASEADDRESS, 0x00000012)
 
-	/* Bank 0 - On-board 32MBytes Flash at address 0x00000000 -> 0x01ffffff */
+	/* Bank 0 - On-board 32MiB Flash at address 0x00000000 -> 0x01ffffff */
 	POKE32(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
 	POKE32(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
 	POKE32(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
@@ -222,7 +222,7 @@ __memory_setup_table:
 
 	/* Bank 1 - Not configured */
 
-	/* Bank 2 - 16MB DVB-CI at address 0x03000000 -> 0x03FFFFFF */
+	/* Bank 2 - 16MiB DVB-CI at address 0x03000000 -> 0x03FFFFFF */
 	POKE32(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
 	POKE32(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
 	POKE32(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
@@ -234,7 +234,7 @@ __memory_setup_table:
 	POKE32(ST40_EMI_BANK3_EMICONFIGDATA2, 0x9d220044)
 	POKE32(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
 
-	/* Bank 4 - 8MB STEM at address 0x04800000 -> 0x04ffffff */
+	/* Bank 4 - 8MiB STEM at address 0x04800000 -> 0x04ffffff */
 	POKE32(ST40_EMI_BANK4_EMICONFIGDATA0, 0x002016d1)
 	POKE32(ST40_EMI_BANK4_EMICONFIGDATA1, 0x9d222200)
 	POKE32(ST40_EMI_BANK4_EMICONFIGDATA2, 0x9d220044)
@@ -271,7 +271,7 @@ __memory_setup_table:
 	POKE32(ST40_LMI_STR_1(), 0x002202d6)
 
 	/* SDRAM Array Attribute Register
-	 # Upper LMI addr=0x0C000000 + 128Mbytes=0x14000000, 13x10
+	 # Upper LMI addr=0x0C000000 + 128MiB=0x14000000, 13x10
 	 */
 #if LMI_16BITS_MODE == 0
 	POKE32(ST40_LMI_SDRA0_0(), 0x14000a20)
@@ -280,7 +280,7 @@ __memory_setup_table:
 #endif
 
 	/* SDRAM Array Attribute Register
-	 # Upper LMI addr=0x0C000000 + 128Mbytes=0x14000000, 13x10
+	 # Upper LMI addr=0x0C000000 + 128MiB=0x14000000, 13x10
 	 */
 #if LMI_16BITS_MODE == 0
 	POKE32(ST40_LMI_SDRA1_0(), 0x14000a20)
diff --git a/board/mb618/mb618.c b/board/mb618/mb618.c
index 919de04..ab35eac 100644
--- a/board/mb618/mb618.c
+++ b/board/mb618/mb618.c
@@ -30,12 +30,20 @@
 
 #define PIO_BASE  0xfd020000	/* Base of PIO block in COMMs block */
 
+#ifndef CONFIG_SH_NO_EPLD
 #ifdef CONFIG_SH_SE_MODE
-#define EPLD_BASE		0xb4000000	/* Phys 0x04000000 */
+#define EPLD_BASE		0xb6000000	/* Phys 0x06000000 */
 #else
-#define EPLD_BASE		0xa4000000
+#define EPLD_BASE		0xa6000000
 #endif	/* CONFIG_SH_SE_MODE */
 
+#define EPLD_IDENT		0x00	/* READ: EPLD Identifier Register */
+#define EPLD_BANK		0x00	/* WRITE: EPLD Bank Register */
+#define EPLD_TEST		0x04	/* EPLD Test Register (Banked) */
+#define EPLD_CTRL		0x04	/* EPLD Control Register (Banked) */
+#define EPLD_SET_BANK_TEST	0x00	/* Bank = EPLD_TEST */
+#define EPLD_SET_BANK_CTRL	0x01	/* Bank = EPLD_CTRL */
+
 static inline void epld_write(unsigned long value, unsigned long offset)
 {
 	/* 8-bit write to EPLD registers */
@@ -47,6 +55,7 @@ static inline unsigned long epld_read(unsigned long offset)
 	/* 8-bit read from EPLD registers */
 	return readb(EPLD_BASE + offset);
 }
+#endif	/* CONFIG_SH_NO_EPLD */
 
 void flashWriteEnable(void)
 {
@@ -77,17 +86,24 @@ extern int board_init(void)
 	return 0;
 }
 
-#ifdef CONFIG_DRIVER_NET_STM_GMAC
-static void mb618_phy_reset05(void)
+#if defined(CONFIG_DRIVER_NET_STM_GMAC) && !defined(CONFIG_SH_NO_EPLD)
+/*
+ * Reset the Ethernet PHY, via the EPLD.
+ * This code is only for EPLD version 06 or later.
+ */
+static inline void mb618_phy_reset06(void)
 {
+	/* set EPLD Bank = Ctrl */
+	epld_write(EPLD_SET_BANK_CTRL, EPLD_BANK);
+
 	/* Bring the PHY out of reset in MII mode */
-	epld_write(0x4 | 0, 0);
-	epld_write(0x4 | 1, 0);
+	epld_write(0x4 | 0, EPLD_CTRL);
+	epld_write(0x4 | 1, EPLD_CTRL);
 }
-#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+#endif	/* defined(CONFIG_DRIVER_NET_STM_GMAC) && !defined(CONFIG_SH_NO_EPLD) */
 
 /*
- * We have several EPLD versions to cope with, with slightly different memory
+ * We have several EPLD versions, with slightly different memory
  * maps and features:
  *
  * version 04:
@@ -104,61 +120,91 @@ static void mb618_phy_reset05(void)
  *  4   Test     Test        55
  *  8   IntStat  IntMaskSet  -
  *  c   IntMask  IntMaskClr  0
+ *
+ * version 06:
+ * off        read       write         reset
+ *  0         Ident      Bank          46 (Bank register defaults to 0)
+ *  4 bank=0  Test       Test          55
+ *  4 bank=1  Ctrl       Ctrl          0e
+ *  4 bank=2  IntPri0    IntPri0  f9
+ *  4 bank=3  IntPri1    IntPri1  f0
+ *  8         IntStat    IntMaskSet    -
+ *  c         IntMask    IntMaskClr    00
+ *
+ * Ctrl register bits:
+ *  0 = Ethernet Phy notReset
+ *  1 = RMIInotMIISelect
+ *  2 = Mode Select_7111 (ModeSelect when D0 == 1)
+ *  3 = Mode Select_8700 (ModeSelect when D0 == 0)
+ *
+ *  The version 06 map is also applicable to later versions.
+ *
+ *  NOTE: U-Boot only supports version 06 or later of the EPLD.
+ *  Versions of the EPLD prior to this version are NOT supported!
  */
+
 static int mb618_init_epld(void)
 {
-	unsigned char epld_reg;
-	int test_offset = -1;
-	int version_offset = -1;
-	int version = -1;
-
-	epld_reg = epld_read(0x4);
-	switch (epld_reg) {
-	case 0x20:
-		/*
-		 * Probably the Ctrl reg of a 04 EPLD. Look for the default
-		 * value in the test reg (we can't do a test as it is broken).
-		 */
-		epld_reg = epld_read(0x8);
-		if (epld_reg == 0x33)
-			version = 4;
-		break;
-	case 0x55:
-		/* Probably the Test reg of the 05 or later EPLD */
-		test_offset = 4;
-		version_offset = 0;
-		break;
+#ifdef CONFIG_SH_NO_EPLD
+	/* we ignore talking to the EPLD, tell the user */
+	printf("info: Disregarding any EPLD\n");
+
+#else	/* CONFIG_SH_NO_EPLD */
+	const unsigned char test_values[2] = {0xa4u, 0x2fu};
+	unsigned char epld_reg, inverted;
+	unsigned char epld_version, board_version;
+	int i;
+
+	/* set EPLD Bank = Test */
+	epld_write(EPLD_SET_BANK_TEST, EPLD_BANK);
+
+	/* for each test value ... */
+	for (i=0; i<sizeof(test_values)/sizeof(test_values[0]); i++) {
+		/* write (anything) to the test register */
+		epld_write(test_values[i], EPLD_TEST);
+		/* calculate what we expect back */
+		inverted = ~test_values[i];
+		/* now read it back */
+		epld_reg = epld_read(EPLD_TEST);
+		/* verify we got back an inverted result */
+		if (epld_reg != inverted) {
+			printf("Failed EPLD test (offset=%02x, %02x!=%02x)\n",
+				EPLD_TEST, epld_reg, inverted);
+			return 1;	/* Failure! */
+			}
 	}
 
-	if (test_offset > 0) {
-		epld_write(0x63, test_offset);
-		epld_reg = epld_read(test_offset);
-		if (epld_reg != (unsigned char)(~0x63)) {
-			printf("Failed mb618 EPLD test (off %02x, res %02x)\n",
-			       test_offset, epld_reg);
-			return 1;
-		}
-
-		/* Assume we can trust the version register */
-		version = epld_read(version_offset) & 0xf;
-	}
+	/* Assume we can trust the ident register */
+	epld_reg      = epld_read(EPLD_IDENT);
+	board_version = (epld_reg >> 5) & 0x07u;
+	epld_version  = (epld_reg >> 0) & 0x1fu;
 
-	if (version < 0) {
-		printf("Unable to determine mb618 EPLD version\n");
-		return 1;
+	/* is it acceptable ? */
+	if (epld_version < 6) {
+		printf("Unsupported EPLD version (reg=0x%02x)\n",
+			epld_reg);
+		return 1;	/* Failure! */
 	}
 
-	printf("mb618 EPLD version %02d\n", version);
+	/* display the board revision, and EPLD version */
+	printf("MB618: revision %c, EPLD version %02d\n",
+		board_version + 'A',
+		epld_version);
 
-	switch (version) {
-	case 5:
-		/* We need to control the PHY reset in software */
+	/* now perform the EPLD initializations we want */
 #ifdef CONFIG_DRIVER_NET_STM_GMAC
-		mb618_phy_reset05();
+	mb618_phy_reset06();
 #endif
-		break;
-	}
 
+	/* set the Test register back to RESET conditions (for linux) */
+	/* set EPLD Bank = Test */
+	epld_write(EPLD_SET_BANK_TEST, EPLD_BANK);
+	/* write inverted 0x55, so it reads back as 0x55 */
+	epld_write(~0x55u, EPLD_TEST);
+
+#endif	/* CONFIG_SH_NO_EPLD */
+
+	/* return a "success" result */
 	return 0;
 }
 
diff --git a/board/mb628/Makefile b/board/mb628/Makefile
new file mode 100644
index 0000000..ff0f69a
--- /dev/null
+++ b/board/mb628/Makefile
@@ -0,0 +1,44 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+AOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o sconsole.o nand.o
+
+OBJS	= $(COBJS) $(AOBJS)
+
+$(LIB):	.depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/mb628/config.mk b/board/mb628/config.mk
new file mode 100644
index 0000000..9e31df5
--- /dev/null
+++ b/board/mb628/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2008 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB628 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x8F700000	29-bit mode (Traditional Mode)
+#	0x87F00000	32-bit mode (Space-Enhancement Mode)	QQQ
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at eSTB BASE + 47MB in P1 (cachable)
+TEXT_BASE = 0x8F700000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/mb628/init-mb628.S b/board/mb628/init-mb628.S
new file mode 100644
index 0000000..b315e05
--- /dev/null
+++ b/board/mb628/init-mb628.S
@@ -0,0 +1,47 @@
+#include "asm/stx7141reg.h"
+#include "../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb628.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+.balign 32
+
+
+__memory_setup_table:
+
+/* QQQ - TO DO */
+
+#ifdef CONFIG_SH_SE_MODE
+#error QQQ
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/mb628/mb628.c b/board/mb628/mb628.c
new file mode 100644
index 0000000..71e7c20
--- /dev/null
+++ b/board/mb628/mb628.c
@@ -0,0 +1,130 @@
+/*
+ * (C) Copyright 2008 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stx7141reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+
+/* EPLD registers */
+#ifdef CONFIG_SH_SE_MODE
+#define EPLD_BASE		0xb5000000	/* Phys 0x05050000 */
+#else
+#define EPLD_BASE		0xa5000000
+#endif	/* CONFIG_SH_SE_MODE */
+#define EPLD_IDENT		0x00010000
+#define EPLD_TEST		0x00020000
+#define EPLD_FLASH		0x00050000
+
+
+static inline void epld_write(unsigned long value, unsigned long offset)
+{
+	/* 8-bit write to EPLD registers */
+	writeb(value, EPLD_BASE + offset);
+}
+
+static inline unsigned long epld_read(unsigned long offset)
+{
+	/* 8-bit read from EPLD registers */
+	return readb(EPLD_BASE + offset);
+}
+
+extern void flashWriteEnable(void)
+{
+	/* Enable Vpp for writing to flash */
+	epld_write(3, EPLD_FLASH);
+}
+
+extern void flashWriteDisable(void)
+{
+	/* Disable Vpp for writing to flash */
+	epld_write(2, EPLD_FLASH);
+}
+
+static void configPIO(void)
+{
+	unsigned long sysconf;
+
+	/* Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(10), 0, 1, 2, 3);  /* ASC1 */
+	SET_PIO_ASC(PIO_PORT(6),  0, 1, 2, 3);  /* ASC2 */
+
+	/* Enable ASC UARTS */
+	sysconf = *STX7141_SYSCONF_SYS_CFG36;
+	/* CFG36[29] = 0 = UART1_CTRL_NOT_MII_SEL */
+	sysconf &= 1ul << 29;
+	/* CFG36[30] = 1 = UART2_CTS_SEL */
+	/* CFG36[31] = 1 = UART2_RXD_SEL */
+	sysconf |= 1ul << 30 | 1ul << 31;
+	*STX7141_SYSCONF_SYS_CFG36 = sysconf;
+
+	/* Route ASC1 via PIO[10] for TX, RX, CTS & RTS */
+	sysconf = *STX7141_SYSCONF_SYS_CFG46;
+	/* PIO10[0] Selector: CFG46[7:6]   = 3 */
+	/* PIO10[1] Selector: CFG46[9:8]   = 3 */
+	/* PIO10[2] Selector: CFG46[11:10] = 3 */
+	/* PIO10[3] Selector: CFG46[13:12] = 3 */
+	sysconf |= 3ul << 6 | 3ul << 8 | 3ul << 10 | 3ul << 12;
+	*STX7141_SYSCONF_SYS_CFG46 = sysconf;
+
+	/* Route ASC2 via PIO[6] for TX & RX */
+	sysconf = *STX7141_SYSCONF_SYS_CFG20;
+	/* PIO6[0] Selector: CFG20[28:27] = 3 */
+	/* PIO6[0] Selector: CFG20[30:29] = 3 */
+	sysconf |= 3ul << 27 | 3ul << 29;
+	*STX7141_SYSCONF_SYS_CFG20 = sysconf;
+
+	/* Route ASC2 via PIO[6] for CTS & RTS */
+	sysconf = *STX7141_SYSCONF_SYS_CFG25;
+	/* PIO6[0] Selector: CFG25[1:0] = 3 */
+	/* PIO6[0] Selector: CFG25[3:2] = 3 */
+	sysconf |= 3ul << 0 | 3ul << 2;
+	*STX7141_SYSCONF_SYS_CFG25 = sysconf;
+}
+
+extern int board_init(void)
+{
+	configPIO();
+
+	return 0;
+}
+
+extern int checkboard (void)
+{
+	unsigned version;
+
+	printf ("\n\nBoard: STx7141-Mboard (MB628)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	version = epld_read(EPLD_IDENT);
+	printf("mb628 EPLD version %02d\n", version);
+	return 0;
+}
diff --git a/board/mb628/nand.c b/board/mb628/nand.c
new file mode 100644
index 0000000..ac6dd48
--- /dev/null
+++ b/board/mb628/nand.c
@@ -0,0 +1,93 @@
+/*
+ * (C) Copyright 2006 DENX Software Engineering
+ * (C) Copyright 2008 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+
+#if defined(CONFIG_CMD_NAND)
+
+#include <nand.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stx7141reg.h>
+
+
+/*
+ * hardware specific access to control-lines
+ *	CL -> Emi_Addr(17)
+ *	AL -> Emi_Addr(18)
+ *	nCE is handled by EMI (not s/w controlable)
+ */
+static void mb618_hwcontrol(struct mtd_info *mtdinfo, int cmd)
+{
+	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
+
+	switch(cmd) {
+
+	case NAND_CTL_SETCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 17));
+		break;
+
+	case NAND_CTL_CLRCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 17));
+		break;
+
+	case NAND_CTL_SETALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 18));
+		break;
+
+	case NAND_CTL_CLRALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 18));
+		break;
+	}
+}
+
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+extern int board_nand_init(struct nand_chip *nand)
+{
+	nand->hwcontrol = mb618_hwcontrol;
+	nand->eccmode = NAND_ECC_SOFT;
+	nand->chip_delay = 25;
+	nand->options = NAND_NO_AUTOINCR;
+	return 0;
+}
+#endif	/* CONFIG_CMD_NAND */
+
diff --git a/board/mb628/sconsole.c b/board/mb628/sconsole.c
new file mode 100644
index 0000000..af92525
--- /dev/null
+++ b/board/mb628/sconsole.c
@@ -0,0 +1,129 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+
+#include "sconsole.h"
+
+#if 0
+void (*sconsole_putc) (char) = 0;
+void (*sconsole_puts) (const char *) = 0;
+int (*sconsole_getc) (void) = 0;
+int (*sconsole_tstc) (void) = 0;
+void (*sconsole_setbrg) (void) = 0;
+#endif
+
+#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
+int serial_init (void)
+{
+	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+	sb->pos = 0;
+	sb->size = 0;
+	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
+
+	return (0);
+}
+
+void serial_putc (char c)
+{
+	if (sconsole_putc) {
+		(*sconsole_putc) (c);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		if (c) {
+			sb->data[sb->pos++] = c;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+void serial_puts (const char *s)
+{
+	if (sconsole_puts) {
+		(*sconsole_puts) (s);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		while (*s) {
+			sb->data[sb->pos++] = *s++;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+int serial_getc (void)
+{
+	if (sconsole_getc) {
+		return (*sconsole_getc) ();
+	} else {
+		return 0;
+	}
+}
+
+int serial_tstc (void)
+{
+	if (sconsole_tstc) {
+		return (*sconsole_tstc) ();
+	} else {
+		return 0;
+	}
+}
+
+void serial_setbrg (void)
+{
+	if (sconsole_setbrg) {
+		(*sconsole_setbrg) ();
+	}
+}
+
+void sconsole_flush (void)
+{
+	if (sconsole_putc) {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+		unsigned int end = sb->pos < sb->size
+			? sb->pos + sb->max_size - sb->size
+			: sb->pos - sb->size;
+
+		while (sb->size) {
+			(*sconsole_putc) (sb->data[end++]);
+			if (end == sb->max_size) {
+				end = 0;
+			}
+			sb->size--;
+		}
+	}
+}
+#endif
diff --git a/board/mb628/sconsole.h b/board/mb628/sconsole.h
new file mode 100644
index 0000000..1666f21
--- /dev/null
+++ b/board/mb628/sconsole.h
@@ -0,0 +1,47 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SCONSOLE_H_
+#define _SCONSOLE_H_
+
+#include <config.h>
+
+typedef struct sconsole_buffer_s
+{
+	unsigned long size;
+	unsigned long max_size;
+	unsigned long pos;
+	char data[1];
+} sconsole_buffer_t;
+
+#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
+
+extern void (*sconsole_putc) (char);
+extern void (*sconsole_puts) (const char *);
+extern int (*sconsole_getc) (void);
+extern int (*sconsole_tstc) (void);
+extern void (*sconsole_setbrg) (void);
+
+extern void sconsole_flush (void);
+
+#endif
diff --git a/board/mb628/u-boot.lds b/board/mb628/u-boot.lds
new file mode 100644
index 0000000..3a1e91b
--- /dev/null
+++ b/board/mb628/u-boot.lds
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2007 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(sh4)
+ENTRY(_start)
+
+SECTIONS
+{
+	.text ALIGN(0x4):
+	{
+		__text_start = .;
+		cpu/sh/start.o (.text)
+		*(.text)
+		__text_end = .;
+	}
+
+	.rodata ALIGN(0x4):
+	{
+		__rodata_start = .;
+		*(.rodata)
+		__rodata_end = .;
+	}
+
+	.data ALIGN(0x4):
+	{
+		__data_start = .;
+		*(.data)
+		__data_end = .;
+	}
+
+	.u_boot_cmd ALIGN(0x4):
+	{
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	_uboot_end_data = .;
+
+	.bss ALIGN(0x4):
+	{
+		__bss_start = .;
+		*(.bss)
+		__bss_end = .;
+	}
+	_uboot_end = .;
+}
diff --git a/board/mb671/init-mb671.S b/board/mb671/init-mb671.S
index 1a5ba70..2fd9536 100644
--- a/board/mb671/init-mb671.S
+++ b/board/mb671/init-mb671.S
@@ -246,7 +246,7 @@ __memory_setup_table:
 	POKE32(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
 	POKE32(ST40_EMI_BANK4_BASEADDRESS, 0x00000014)
 
-	/* Bank 0 - On-board 32MBytes Flash at address 0x00000000 -> 0x01ffffff */
+	/* Bank 0 - On-board 32MiB Flash at address 0x00000000 -> 0x01ffffff */
 	POKE32(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
 	POKE32(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
 	POKE32(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
@@ -276,10 +276,10 @@ __memory_setup_table:
 	POKE32(ST40_LMI_STR_0(0), 0xcd2db41b)
 	POKE32(ST40_LMI_STR_1(0), 0x002202d6)
 
-	/* lmi base address 0x08000000 + 256Mbytes */
+	/* lmi base address 0x08000000 + 256MiB */
 	POKE32(ST40_LMI_SDRA0_0(0), 0x18001a20)
 
-	/* lmi base address 0x08000000 + 256Mbytes */
+	/* lmi base address 0x08000000 + 256MiB */
 	POKE32(ST40_LMI_SDRA1_0(0), 0x18001a20)
 
 	/* Delay ~ 200 uS (assumes 400MHz CPU clock) */
@@ -365,11 +365,11 @@ __memory_setup_table:
 	POKE32(ST40_LMI_STR_1(1), 0x002202d6)
 
 	/* SDRAM Row Attribute 0 */
-	/* lmi base address 0x18000000 + 64Mbytes */
+	/* lmi base address 0x18000000 + 64MiB */
 	POKE32(ST40_LMI_SDRA0_0(1), 0x1c001a20)
 
 	/* SDRAM Row Attribute 1 */
-	/* lmi base address 0x18000000 + 64Mbytes */
+	/* lmi base address 0x18000000 + 64MiB */
 	POKE32(ST40_LMI_SDRA1_0(1), 0x1c001a20)
 
 	/* Delay ~ 200 uS (assumes 400MHz CPU clock) */
diff --git a/board/mb680/Makefile b/board/mb680/Makefile
new file mode 100644
index 0000000..ff0f69a
--- /dev/null
+++ b/board/mb680/Makefile
@@ -0,0 +1,44 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+AOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o sconsole.o nand.o
+
+OBJS	= $(COBJS) $(AOBJS)
+
+$(LIB):	.depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/mb680/config.mk b/board/mb680/config.mk
new file mode 100644
index 0000000..e79b8e0
--- /dev/null
+++ b/board/mb680/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2008 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB680 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x9BF00000	29-bit mode (Traditional Mode)
+#	0x8FF00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 255MB in P1 (cachable)
+TEXT_BASE = 0x9BF00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/mb680/init-mb680.S b/board/mb680/init-mb680.S
new file mode 100644
index 0000000..21a4d67
--- /dev/null
+++ b/board/mb680/init-mb680.S
@@ -0,0 +1,385 @@
+#include "asm/stx7105reg.h"
+#include "../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb680.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+.balign 32
+
+
+__memory_setup_table:
+
+	/* ----- STx7105 Clocks ----- */
+
+	/* Set source clocks to OSC */
+	POKE32(STX7105_CLOCKGENA_CLKOPSRC_SWITCH_CFG, 0x00000000)
+	POKE32(STX7105_CLOCKGENA_CLKOPSRC_SWITCH_CFG2, 0x00000000)
+
+	/* Wait for CLOCKGENA PLL0 to stop ... */
+	WHILE_NE32(STX7105_CLOCKGENA_PLL0_ENABLE_FB, 0xFFFFFFFF, 0x00000000)
+
+	/* Wait for CLOCKGENA PLL1 to stop ... */
+	WHILE_NE32(STX7105_CLOCKGENA_PLL1_ENABLE_FB, 0xFFFFFFFF, 0x00000000)
+
+	/*  Clockgen A PLL0 setup */
+
+	/* Set CLOCKGENA PLL0 into BYPASS... */
+	OR32(STX7105_CLOCKGENA_PLL0_CFG, 0x00100000)
+
+	/* Power down CLOCKGENA PLL0... */
+	OR32(STX7105_CLOCKGENA_POWER_CFG, 0x00000001)
+
+	/* Configure CLOCKGENA PLL0LS to 450MHz (PLL0HS to 900MHz): mdiv = 0x01, ndiv = 0x0f */
+	UPDATE32(STX7105_CLOCKGENA_PLL0_CFG, 0xfff80000, (0xf << 8) | (0x01 & 0x7))
+
+	/* Enable CLOCKGENA PLL0... */
+	UPDATE32(STX7105_CLOCKGENA_POWER_CFG, 0xfffffffe, 0)
+
+	/* Wait for CLOCKGENA PLL0 to lock... */
+	WHILE_NE32(STX7105_CLOCKGENA_PLL0_CFG, 0x80000000, 0x80000000)
+
+	/* Clear CLOCKGENA PLL0 from BYPASS... */
+	UPDATE32(STX7105_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+
+	/*  Clockgen A PLL1 setup */
+
+	/* Set CLOCKGENA PLL1 into BYPASS... */
+	OR32(STX7105_CLOCKGENA_PLL1_CFG, 0x00100000)
+
+	/* Power down CLOCKGENA PLL1... */
+	OR32(STX7105_CLOCKGENA_POWER_CFG, 0x00000002)
+
+	/* Configure CLOCKGENA PLL1 to 800MHz: mdiv = 0x03, ndiv = 0x28, pdiv = 0x0 */
+	/* UPDATE32(STX7105_CLOCKGENA_PLL1_CFG, 0xfff80000, (0 << 16) | (0x28 << 8) | (0x03)) */
+	/* Configure CLOCKGENA PLL1 to 400MHz: mdiv = 0x09, ndiv = 0x78, pdiv = 0x1 */
+	UPDATE32(STX7105_CLOCKGENA_PLL1_CFG, 0xfff80000, (1 << 16) | (0x78 << 8) | (0x09))
+
+	/* Enable CLOCKGENA PLL1... */
+	UPDATE32(STX7105_CLOCKGENA_POWER_CFG, 0xfffffffd, 0)
+
+	/* Wait for CLOCKGENA PLL1 to lock... */
+	WHILE_NE32(STX7105_CLOCKGENA_PLL1_CFG, 0x80000000, 0x80000000)
+
+	/* Clear CLOCKGENA PLL1 from BYPASS... */
+	UPDATE32(STX7105_CLOCKGENA_PLL1_CFG, 0xffefffff, 0)
+
+
+	/*  Clockgen A divider setup */
+	POKE32(STX7105_CLOCKGENA_PLL1_DIV0_CFG, 0x00000001)    /* STNOC=200 */
+	POKE32(STX7105_CLOCKGENA_PLL1_DIV1_CFG, 0x00000000)    /* FDMA0=400 */
+	POKE32(STX7105_CLOCKGENA_PLL1_DIV2_CFG, 0x00000000)    /* FDMA1=400 */
+	POKE32(STX7105_CLOCKGENA_PLL1_DIV3_CFG, 0x00000103)    /* Not used */
+	POKE32(STX7105_CLOCKGENA_PLL0LS_DIV4_CFG, 0x00010100)  /* ST40_ICK=450 */
+	POKE32(STX7105_CLOCKGENA_PLL1_DIV5_CFG, 0x00000103)    /* IC_IF_100=100  - for Comms */
+	POKE32(STX7105_CLOCKGENA_PLL0LS_DIV6_CFG, 0x00010100)  /* LX_DMU_CPU=450 */
+	POKE32(STX7105_CLOCKGENA_PLL0LS_DIV7_CFG, 0x00010100)  /* LX_AUD_CPU=450 */
+	POKE32(STX7105_CLOCKGENA_PLL1_DIV8_CFG, 0x00000001)    /* IC_BDISP_200=200 */
+	POKE32(STX7105_CLOCKGENA_PLL1_DIV9_CFG, 0x00000001)    /* IC_DISP_200=200 */
+	POKE32(STX7105_CLOCKGENA_PLL1_DIV10_CFG, 0x00000001)   /* IC_TS_200=200  - for Crypto */
+	POKE32(STX7105_CLOCKGENA_PLL1_DIV11_CFG, 0x00000001)   /* DISP_PIPE_200=200 */
+	POKE32(STX7105_CLOCKGENA_PLL1_DIV12_CFG, 0x00000001)   /* BLIT_PROC/IC_DELTA_200=266 */
+	POKE32(STX7105_CLOCKGENA_PLL0LS_DIV13_CFG, 0x00000811) /* ETH_PHY=25 */
+	POKE32(STX7105_CLOCKGENA_PLL1_DIV14_CFG, 0x0000050B)   /* PCI=33.3 */
+	POKE32(STX7105_CLOCKGENA_PLL1_DIV15_CFG, 0x00000103)   /* EMI_MASTER=100 */
+	POKE32(STX7105_CLOCKGENA_PLL1_DIV16_CFG, 0x00000001)   /* IC_COMPO_200=200 */
+	POKE32(STX7105_CLOCKGENA_PLL1_DIV17_CFG, 0x00000001)   /* IC_IF_200=200 */
+
+	/* Route clocks to ... */
+	POKE32(STX7105_CLOCKGENA_CLKOPSRC_SWITCH_CFG, 0xA6AA59AA)
+	POKE32(STX7105_CLOCKGENA_CLKOPSRC_SWITCH_CFG2, 0x0000000A)
+
+	/* SPI.CLOCK_DIV: divide emi_master_clk by 4 for spi boot clock */
+	POKE32(0xfe702010, 0x00000004)
+
+	/* ClockGen B for Audio */
+	/*  No setup            */
+
+
+	/* ClockGen D for LMI */
+
+	/* Power down PLL... */
+	OR32(STX7105_SYSCONF_SYS_CFG11, 0x00001000)
+
+	/* Configure PLL... */
+	/* Set LMI clock to 800MHz */
+	/* UPDATE32(STX7105_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x50 << 1)) */
+	/* Cut 1.0 restriction -> Set LMI clock to 400MHz */
+	UPDATE32(STX7105_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x28 << 1))
+
+	/* Enable CLOCKGENA PLL1... */
+	UPDATE32(STX7105_SYSCONF_SYS_CFG11, 0xffffefff, 0)
+
+	/* Wait for CLOCKGENA PLL1 to lock... (polarity inverted on lock bit) */
+	WHILE_NE32(STX7105_SYSCONF_SYS_STA03, 0x00000001, 0)
+
+
+	/* ----- STx7105 SysConf ----- */
+
+	/* PLI_CLOCK_ENABLE set to 0 */
+	/* OR32(STX7105_SYSCONF_SYS_CFG04, ~(1 << 2))	- Steve Punter misinterpretted? */
+	UPDATE32(STX7105_SYSCONF_SYS_CFG04, ~(1 << 2), 0)
+
+	/* LMI sub-sys & pl exit from reset */
+	OR32(STX7105_SYSCONF_SYS_CFG11, (0x00000001 | (1 << 14) | 1 << 27))
+
+	/* Delay ~ 200 microseconds (assume 400MHz CPU clock) */
+	DELAY(200 * 400)
+
+	/* PLI_CLOCK_ENABLE set to 1 */
+	OR32(STX7105_SYSCONF_SYS_CFG04, (1 << 2))
+
+	/* Check both DLL on LMI0 are locked */
+	WHILE_NE32(STX7105_SYSCONF_SYS_STA03, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
+
+	/* Adjust proga, progb, zoutproga, and receiver mode for LMI0 */
+	POKE32(STX7105_SYSCONF_SYS_CFG12, (0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10)))
+
+	/* Enable AutoPrecharge */
+	POKE32(STX7105_SYSCONF_SYS_CFG38, 0x002FFE0C)
+
+	/* Force DLL1 and DLL2 commands of LMI0 */
+	/* POKE32(STX7105_SYSCONF_SYS_CFG13, 0x00000000) */
+	/* POKE32(STX7105_SYSCONF_SYS_CFG14, 0x00000000) */
+
+	/* LMI Padlogic Control */
+	POKE32(STX7105_SYSCONF_SYS_CFG55, 0x03fc2384)
+
+	/* Include DUMMY PCB track */
+	OR32(STX7105_SYSCONF_SYS_CFG55, (1 << 6))
+
+	/* TO BE UPDATED FOR 7105/MB680 */
+	/* sysconf.SYSCONF_CFG42.poke(sysconf.SYSCONF_CFG42.peek() | (0 << 18) | (0 << 9) | (0 << 0) ) */
+	UPDATE32(STX7105_SYSCONF_SYS_CFG42, 0xfffbfdfe, 0)
+	/* sysconf.SYSCONF_CFG43.poke(sysconf.SYSCONF_CFG43.peek() | (0) ) */
+	UPDATE32(STX7105_SYSCONF_SYS_CFG43, 0xfffffffe, 0)
+
+	/* Coarse settings (-T/4) */
+	OR32(STX7105_SYSCONF_SYS_CFG42, (5 << 27))
+	OR32(STX7105_SYSCONF_SYS_CFG13, (1 << 22))
+
+	/* DQS Valid Window */
+	/* sysconf.SYSCONF_CFG43.poke(sysconf.SYSCONF_CFG43.peek() | (0 << 18)) */
+	UPDATE32(STX7105_SYSCONF_SYS_CFG43, 0xfffbffff, 0)
+
+	/* DQS270_DEL offsets */
+	/* sysconf.SYSCONF_CFG51.poke(sysconf.SYSCONF_CFG51.peek() | (0 << 16) | (0 << 0)) */
+	UPDATE32(STX7105_SYSCONF_SYS_CFG51, 0xfffefffe, 0)
+	/* sysconf.SYSCONF_CFG52.poke(sysconf.SYSCONF_CFG52.peek() | (0 << 16) | (0 << 0)) */
+	UPDATE32(STX7105_SYSCONF_SYS_CFG52, 0xfffefffe, 0)
+
+
+	/* ----- STx7105 EMI configuration ----- */
+
+	POKE32(ST40_EMI_BANK_ENABLE, 0x00000005)
+
+	/* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
+	POKE32(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE32(ST40_EMI_BANK1_BASEADDRESS, 0x00000010)
+	POKE32(ST40_EMI_BANK2_BASEADDRESS, 0x00000012)
+	POKE32(ST40_EMI_BANK3_BASEADDRESS, 0x00000014)
+	POKE32(ST40_EMI_BANK4_BASEADDRESS, 0x0000001c)
+
+	/* Bank 0 - 32MiB: NOR, NAND & Serial Flash at address 0x00000000 -> 0x03ffffff */
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+
+	/* Bank 1 - 8MiB at address 0x04000000 -> 0x047fffff */
+	POKE32(ST40_EMI_BANK1_EMICONFIGDATA0, 0x002016d1)
+	POKE32(ST40_EMI_BANK1_EMICONFIGDATA1, 0x9d222200)
+	POKE32(ST40_EMI_BANK1_EMICONFIGDATA2, 0x9d220044)
+	POKE32(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000)
+
+	/* Bank 2 - 8MiB at address 0x04800000 -> 0x04FFFFFF */
+	POKE32(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
+	POKE32(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
+	POKE32(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
+	POKE32(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+
+	/* Bank 3 - 32MiB at address 0x05000000 -> 0x06FFFFFF */
+	POKE32(ST40_EMI_BANK3_EMICONFIGDATA0, 0x002016d1)
+	POKE32(ST40_EMI_BANK3_EMICONFIGDATA1, 0x9d222200)
+	POKE32(ST40_EMI_BANK3_EMICONFIGDATA2, 0x9d220044)
+	POKE32(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
+
+	/* Bank 4 - 16MiB EPLD Registers at address 0x07000000 -> 0x07FFFFFF */
+	POKE32(ST40_EMI_BANK4_EMICONFIGDATA0, 0x002016d1)
+	POKE32(ST40_EMI_BANK4_EMICONFIGDATA1, 0x9d222200)
+	POKE32(ST40_EMI_BANK4_EMICONFIGDATA2, 0x9d220044)
+	POKE32(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)
+
+	/* Program other EMI registers */
+	POKE32(ST40_EMI_GENCFG, 0x00000010)
+
+
+	/* ----- STx7105 LMI0 configuration ----- */
+
+	/* Configuring LMI0 for DDR2 SDRAM Elpida EDE5116AHBG-8E-E
+
+	   SDRAM Mode Register
+	   Refresh Interval:  NOTE: Using Lmi=200 (LMI2X=400).
+	 # 300 Mhz --->  T=3.4ns => MIM[28:16]=2038=0x7F6 ((2294-256)+ACo-3.4ns<+AH4-7.8us)
+	 # 330 Mhz --->  T=3.1ns => MIM[28:16]=2260 ((2516-256)+ACo-3.1ns<+AH4-7.8us)
+	 # 360 Mhz --->  T=2.8ns => MIM[28:16]=2529 ((2785-256)+ACo-2.8ns<+AH4-7.8us)
+	 # 400 Mhz --->  T=2.5ns => MIM[28:16]=2864 ((3120-256)+ACo-2.5ns=7.8us)
+	 */
+	POKE32(ST40_LMI_MIM_0(), 0x07F6017b)
+
+	/* set bandwidth limiter */
+	POKE32(ST40_LMI_MIM_1(), 0xffff0000)
+
+	/* SDRAM Timing Register */
+	POKE32(ST40_LMI_STR_0(), 0xcd2db41b)
+	POKE32(ST40_LMI_STR_1(), 0x00202ed6)
+
+	/* SDRAM Row Attribute 0 */
+	/* lmi base address 0x0C000000 +
+	    256 MiB   0x10000000
+	              ----------
+	              0x1C000000
+	   Size: 13x10, 8 banks
+	 */
+	POKE32(ST40_LMI_SDRA0_0(), 0x1c001a20)
+
+	/* SDRAM Row Attribute 1 */
+	/* lmi base address 0x0C000000 +
+	    256 MiB   0x10000000
+	              ----------
+	              0x1C000000
+	   Size: 13x10, 8 banks
+	 */
+	POKE32(ST40_LMI_SDRA1_0(), 0x1c001a20)
+
+	/* SDRAM Control Register */
+	/* Delay ~ 200 milliseconds (assume 400MHz CPU clock) */
+	DELAY(200000 * 400)
+	/* Enable clock with NOP command */
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020023)
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+
+	/* Precharge all */
+	POKE32(ST40_LMI_SCR_0(), 0x00020022)
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+
+	/* Issue EMRS2 */
+	POKE32(ST40_LMI_SDMR0(), 0x00010000)
+
+	/* Issue EMRS3 */
+	POKE32(ST40_LMI_SDMR0(), 0x00018000)
+
+	/* Issue EMRS1 to enable DLL */
+	POKE32(ST40_LMI_SDMR0(), 0x00008004)
+
+	/* Issue MRS with DLL reset, CAS 5, Write recovery 5, Sequential, Burst length 8 */
+	POKE32(ST40_LMI_SDMR0(), 0x00000b53)
+
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+
+	/* Precharge all */
+	POKE32(ST40_LMI_SCR_0(), 0x00020022)
+
+	/* 2 CBR (auto refresh) */
+	POKE32(ST40_LMI_SCR_0(), 0x00020024)
+	POKE32(ST40_LMI_SCR_0(), 0x00020024)
+
+	/* Issue MRS with CAS 5, Write recovery 5, Sequential, Burst length 8 */
+	POKE32(ST40_LMI_SDMR0(), 0x00000a53)
+
+	/* Issue EMRS1 for OCD calibration default */
+	/* lmi.LMI_SDMR0_0.poke(0x000007c4) */
+
+	/* Issue EMRS1 for OCD calibration exit */
+	/* lmi.LMI_SDMR0_0.poke(0x00000444) */
+
+	/* Enable auto refresh */
+	OR32(ST40_LMI_MIM_0(), (1 << 9))
+
+	/* DQS recovery mechanism (bit 5) */
+	/* OR32(ST40_LMI_MIM_0(), (1 << 5)) - Steve Punter misinterpretted? */
+	UPDATE32(ST40_LMI_MIM_0(), ~(1 << 5), 0)
+	/* NO DQS recovery */
+	/* UPDATE32(ST40_LMI_MIM_0(), 0xffffffdf, 0) */
+
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+
+	POKE32(ST40_LMI_GCC_0(), 0x00000000)
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE32(STX7105_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	/* Change LMI upper bound addresses
+	 # Upper LMI addr=0x40000000 + 256MiB=0x50000000
+	 */
+	UPDATE32(ST40_LMI_SDRA0_0(), 0x001FFFFF, 0x50000000)
+	UPDATE32(ST40_LMI_SDRA1_0(), 0x001FFFFF, 0x50000000)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/mb680/mb680.c b/board/mb680/mb680.c
new file mode 100644
index 0000000..ed8d87a
--- /dev/null
+++ b/board/mb680/mb680.c
@@ -0,0 +1,171 @@
+/*
+ * (C) Copyright 2008 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stx7105reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+
+#define PIO_BASE  0xfd020000	/* Base of PIO block in COMMs block */
+
+
+/* following are the offsets in the EMI functions EPLD (IC21),
+ * in the STB Peripheral board (MB705)*/
+#define EPLD_IDENT		0x00	/* EPLD Identifier Register */
+#define EPLD_TEST		0x02	/* EPLD Test Register */
+#define EPLD_MISC		0x0a	/* Miscellaneous Control Register */
+
+#ifdef CONFIG_SH_SE_MODE
+#define EPLD_BASE		0xb7000000	/* Phys 0x07000000 */
+#else
+#define EPLD_BASE		0xa7000000	/* EMI Bank E */
+#endif	/* CONFIG_SH_SE_MODE */
+
+
+static inline void epld_write(unsigned long value, unsigned long offset)
+{
+	/* 16-bit write to EPLD registers */
+	writew(value, EPLD_BASE + offset);
+}
+
+static inline unsigned long epld_read(unsigned long offset)
+{
+	/* 16-bit read from EPLD registers */
+	return readw(EPLD_BASE + offset);
+}
+
+void flashWriteEnable(void)
+{
+	unsigned short epld_reg;
+
+	/* Enable Vpp for writing to flash */
+	epld_reg = epld_read(EPLD_MISC);
+	epld_reg |= 1u << 3;	/* NandFlashWP = MISC[3] = 1 */
+	epld_reg |= 1u << 2;	/* NorFlashVpp = MISC[2] = 1 */
+	epld_write(epld_reg, EPLD_MISC);
+}
+
+void flashWriteDisable(void)
+{
+	unsigned short epld_reg;
+
+	/* Disable Vpp for writing to flash */
+	epld_reg = epld_read(EPLD_MISC);
+	epld_reg &= ~(1u << 3);	/* NandFlashWP = MISC[3] = 0 */
+	epld_reg &= ~(1u << 2);	/* NorFlashVpp = MISC[2] = 0 */
+	epld_write(epld_reg, EPLD_MISC);
+}
+
+static int mb680_init_epld(void)
+{
+	const unsigned short test_value = 0x1234u;
+	unsigned short epld_reg;
+	unsigned short epld_version, board_version;
+
+	/* write (anything) to the test register */
+	epld_write(test_value, EPLD_TEST);
+	/* verify we got back an inverted result */
+	epld_reg = epld_read(EPLD_TEST);
+	if (epld_reg != (test_value ^ 0xffffu)) {
+		printf("Failed EPLD test (offset=%02x, result=%04x)\n",
+			EPLD_TEST, epld_reg);
+		return 1;
+		}
+
+	/* Assume we can trust the version register */
+	epld_reg = epld_read(EPLD_IDENT);
+	board_version = epld_reg >> 4 & 0xfu;
+	epld_version = epld_reg & 0xfu;
+
+	/* display the board revision, and EPLD version */
+	printf("MB705: revision %c, EPLD version %02d\n",
+		board_version + 'A' - 1,
+		epld_version);
+
+	/* return a "success" result */
+	return 0;
+}
+
+static void configPIO(void)
+{
+	unsigned long sysconf;
+
+	/* Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(4), 0, 1, 2, 3);  /* UART2 - AS0 */
+	SET_PIO_ASC(PIO_PORT(5), 0, 1, 3, 2);  /* UART3 - AS1 */
+
+	/* Select UART2 via PIO4 */
+	sysconf = *STX7105_SYSCONF_SYS_CFG07;
+	/* CFG07[1] = UART2_RXD_SRC_SELECT = 0 */
+	/* CFG07[2] = UART2_CTS_SRC_SELECT = 0 */
+	sysconf &= ~(1ul<<2 | 1ul<<1);
+	*STX7105_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART2 via PIO4 for TX, RX, CTS & RTS */
+	sysconf = *STX7105_SYSCONF_SYS_CFG34;
+	/* PIO4[0] CFG34[8,0]   AltFunction = 3 */
+	/* PIO4[1] CFG34[9,1]   AltFunction = 3 */
+	/* PIO4[2] CFG34[10,2]  AltFunction = 3 */
+	/* PIO4[3] CFG34[11,3]  AltFunction = 3 */
+	sysconf &= ~0x0f0ful;	/* 3,3,3,3 */
+	sysconf |=  0x0f00ul;	/* 2,2,2,2 */
+	*STX7105_SYSCONF_SYS_CFG34 = sysconf;
+
+	/* Route UART3 via PIO5 for TX, RX, CTS & RTS */
+	sysconf = *STX7105_SYSCONF_SYS_CFG35;
+	/* PIO5[0] CFG35[8,0]   AltFunction = 3 */
+	/* PIO5[1] CFG35[9,1]   AltFunction = 3 */
+	/* PIO5[2] CFG35[10,2]  AltFunction = 3 */
+	/* PIO5[3] CFG35[11,3]  AltFunction = 3 */
+	sysconf &= ~0x0f0ful;	/* 3,3,3,3 */
+	sysconf |=  0x000ful;	/* 1,1,1,1 */
+	*STX7105_SYSCONF_SYS_CFG35 = sysconf;
+}
+
+extern int board_init(void)
+{
+	configPIO();
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STx7105-Mboard (MB680)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	/*
+	 * initialize the EPLD.
+	 */
+	mb680_init_epld();
+
+	return 0;
+}
diff --git a/board/mb680/nand.c b/board/mb680/nand.c
new file mode 100644
index 0000000..c013fe1
--- /dev/null
+++ b/board/mb680/nand.c
@@ -0,0 +1,93 @@
+/*
+ * (C) Copyright 2006 DENX Software Engineering
+ * (C) Copyright 2008 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+
+#if defined(CONFIG_CMD_NAND)
+
+#include <nand.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stx7105reg.h>
+
+
+/*
+ * hardware specific access to control-lines
+ *	CL -> Emi_Addr(17)
+ *	AL -> Emi_Addr(18)
+ *	nCE is handled by EMI (not s/w controlable)
+ */
+static void mb680_hwcontrol(struct mtd_info *mtdinfo, int cmd)
+{
+	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
+
+	switch(cmd) {
+
+	case NAND_CTL_SETCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 17));
+		break;
+
+	case NAND_CTL_CLRCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 17));
+		break;
+
+	case NAND_CTL_SETALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 18));
+		break;
+
+	case NAND_CTL_CLRALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 18));
+		break;
+	}
+}
+
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+extern int board_nand_init(struct nand_chip *nand)
+{
+	nand->hwcontrol = mb680_hwcontrol;
+	nand->eccmode = NAND_ECC_SOFT;
+	nand->chip_delay = 25;
+	nand->options = NAND_NO_AUTOINCR;
+	return 0;
+}
+#endif	/* CONFIG_CMD_NAND */
+
diff --git a/board/mb680/sconsole.c b/board/mb680/sconsole.c
new file mode 100644
index 0000000..af92525
--- /dev/null
+++ b/board/mb680/sconsole.c
@@ -0,0 +1,129 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+
+#include "sconsole.h"
+
+#if 0
+void (*sconsole_putc) (char) = 0;
+void (*sconsole_puts) (const char *) = 0;
+int (*sconsole_getc) (void) = 0;
+int (*sconsole_tstc) (void) = 0;
+void (*sconsole_setbrg) (void) = 0;
+#endif
+
+#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
+int serial_init (void)
+{
+	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+	sb->pos = 0;
+	sb->size = 0;
+	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
+
+	return (0);
+}
+
+void serial_putc (char c)
+{
+	if (sconsole_putc) {
+		(*sconsole_putc) (c);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		if (c) {
+			sb->data[sb->pos++] = c;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+void serial_puts (const char *s)
+{
+	if (sconsole_puts) {
+		(*sconsole_puts) (s);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		while (*s) {
+			sb->data[sb->pos++] = *s++;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+int serial_getc (void)
+{
+	if (sconsole_getc) {
+		return (*sconsole_getc) ();
+	} else {
+		return 0;
+	}
+}
+
+int serial_tstc (void)
+{
+	if (sconsole_tstc) {
+		return (*sconsole_tstc) ();
+	} else {
+		return 0;
+	}
+}
+
+void serial_setbrg (void)
+{
+	if (sconsole_setbrg) {
+		(*sconsole_setbrg) ();
+	}
+}
+
+void sconsole_flush (void)
+{
+	if (sconsole_putc) {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+		unsigned int end = sb->pos < sb->size
+			? sb->pos + sb->max_size - sb->size
+			: sb->pos - sb->size;
+
+		while (sb->size) {
+			(*sconsole_putc) (sb->data[end++]);
+			if (end == sb->max_size) {
+				end = 0;
+			}
+			sb->size--;
+		}
+	}
+}
+#endif
diff --git a/board/mb680/sconsole.h b/board/mb680/sconsole.h
new file mode 100644
index 0000000..1666f21
--- /dev/null
+++ b/board/mb680/sconsole.h
@@ -0,0 +1,47 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SCONSOLE_H_
+#define _SCONSOLE_H_
+
+#include <config.h>
+
+typedef struct sconsole_buffer_s
+{
+	unsigned long size;
+	unsigned long max_size;
+	unsigned long pos;
+	char data[1];
+} sconsole_buffer_t;
+
+#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
+
+extern void (*sconsole_putc) (char);
+extern void (*sconsole_puts) (const char *);
+extern int (*sconsole_getc) (void);
+extern int (*sconsole_tstc) (void);
+extern void (*sconsole_setbrg) (void);
+
+extern void sconsole_flush (void);
+
+#endif
diff --git a/board/mb680/u-boot.lds b/board/mb680/u-boot.lds
new file mode 100644
index 0000000..3a1e91b
--- /dev/null
+++ b/board/mb680/u-boot.lds
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2007 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(sh4)
+ENTRY(_start)
+
+SECTIONS
+{
+	.text ALIGN(0x4):
+	{
+		__text_start = .;
+		cpu/sh/start.o (.text)
+		*(.text)
+		__text_end = .;
+	}
+
+	.rodata ALIGN(0x4):
+	{
+		__rodata_start = .;
+		*(.rodata)
+		__rodata_end = .;
+	}
+
+	.data ALIGN(0x4):
+	{
+		__data_start = .;
+		*(.data)
+		__data_end = .;
+	}
+
+	.u_boot_cmd ALIGN(0x4):
+	{
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	_uboot_end_data = .;
+
+	.bss ALIGN(0x4):
+	{
+		__bss_start = .;
+		*(.bss)
+		__bss_end = .;
+	}
+	_uboot_end = .;
+}
diff --git a/common/cmd_bdinfo.c b/common/cmd_bdinfo.c
index 6625a60..49cf608 100644
--- a/common/cmd_bdinfo.c
+++ b/common/cmd_bdinfo.c
@@ -31,6 +31,10 @@
 DECLARE_GLOBAL_DATA_PTR;
 
 static void print_num(const char *, ulong);
+#if defined(CONFIG_SH4)
+static void print_mem(const char *, ulong);
+static void print_mhz(const char *name, ulong value);
+#endif
 
 #ifndef CONFIG_ARM	/* PowerPC and other */
 
@@ -275,8 +279,12 @@ int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 
 #if defined(CONFIG_SH_STB7100)
 #include <asm/stb7100reg.h>
+#elif defined(CONFIG_SH_STX7105)
+#include <asm/stx7105reg.h>
 #elif defined(CONFIG_SH_STX7111)
 #include <asm/stx7111reg.h>
+#elif defined(CONFIG_SH_STX7141)
+#include <asm/stx7141reg.h>
 #elif defined(CONFIG_SH_STX7200)
 #include <asm/stx7200reg.h>
 #else
@@ -292,55 +300,64 @@ int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 
 	print_num ("boot_params",	(ulong)bd->bi_boot_params);
 	print_num ("memstart",		(ulong)bd->bi_memstart);
-	print_num ("memsize",		(ulong)bd->bi_memsize);
+	print_mem ("memsize",		(ulong)bd->bi_memsize);
 	print_num ("flashstart",	(ulong)bd->bi_flashstart);
-	print_num ("flashsize",		(ulong)bd->bi_flashsize);
+	print_mem ("flashsize",		(ulong)bd->bi_flashsize);
 	print_num ("flashoffset",	(ulong)bd->bi_flashoffset);
 
+#if defined(CONFIG_CMD_NET)
 	puts ("ethaddr     =");
 	for (i=0; i<6; ++i) {
 		printf ("%c%02X", i ? ':' : ' ', bd->bi_enetaddr[i]);
 	}
 	puts ("\nip_addr     = ");
 	print_IPaddr (bd->bi_ip_addr);
+#endif
 	printf ("\nbaudrate    = %d bps\n", bd->bi_baudrate);
 
-#ifdef CONFIG_SH_STB7100
+#if defined(CONFIG_SH_STB7100)
 	if (STB7100_DEVICEID_7109(bd->bi_devid))
-		printf("\nSTb7109 version %ld.x\n", STB7100_DEVICEID_CUT(bd->bi_devid));
-	else if ( STB7100_DEVICEID_7100(bd->bi_devid))
-		printf("\nSTb7100 version %ld.x\n", STB7100_DEVICEID_CUT(bd->bi_devid));
-	else
-		printf("\nUnknown device\n");
-	printf ("PLL0      = %3d MHz\n", bd->bi_pll0frq);
-	printf ("PLL1      = %3d MHz\n", bd->bi_pll1frq);
-	printf ("ST40  CPU = %3d MHz\n", bd->bi_st40cpufrq);
-	printf ("ST40  BUS = %3d MHz\n", bd->bi_st40busfrq);
-	printf ("ST40  PER = %3d MHz\n", bd->bi_st40perfrq);
-	printf ("ST231 CPU = %3d MHz\n", bd->bi_st231frq);
-	printf ("ST BUS    = %3d MHz\n", bd->bi_stbusfrq);
-	printf ("EMI       = %3d MHz\n", bd->bi_emifrq);
-	printf ("LMI       = %3d MHz\n", bd->bi_lmifrq);
-#endif
-#ifdef CONFIG_SH_STX7111
+		printf ("\nSTb7109 version %ld.x", STB7100_DEVICEID_CUT(bd->bi_devid));
+	else if (STB7100_DEVICEID_7100(bd->bi_devid))
+		printf ("\nSTb7100 version %ld.x", STB7100_DEVICEID_CUT(bd->bi_devid));
+#elif defined(CONFIG_SH_STX7105)
+	if (STX7105_DEVICEID_7105(bd->bi_devid))
+		printf ("\nSTx7105 version %ld.x", STX7105_DEVICEID_CUT(bd->bi_devid));
+#elif defined(CONFIG_SH_STX7111)
 	if (STX7111_DEVICEID_7111(bd->bi_devid))
-		printf("\nSTx7111 version %ld.x\n", STX7111_DEVICEID_CUT(bd->bi_devid));
-	else
-		printf("\nUnknown device\n");
-	printf ("EMI       = %3d MHz\n", bd->bi_emifrq);
-#endif
-#ifdef CONFIG_SH_STX7200
+		printf ("\nSTx7111 version %ld.x", STX7111_DEVICEID_CUT(bd->bi_devid));
+#elif defined(CONFIG_SH_STX7141)
+	if (STX7141_DEVICEID_7141(bd->bi_devid))
+		printf ("\nSTx7141 version %ld.x", STX7141_DEVICEID_CUT(bd->bi_devid));
+#elif defined(CONFIG_SH_STX7200)
 	if (STX7200_DEVICEID_7200(bd->bi_devid))
-		printf("\nSTx7200 version %ld.x\n", STX7200_DEVICEID_CUT(bd->bi_devid));
-	else
-		printf("\nUnknown device\n");
-	printf ("EMI       = %3d MHz\n", bd->bi_emifrq);
+		printf ("\nSTx7200 version %ld.x", STX7200_DEVICEID_CUT(bd->bi_devid));
+#else
+#error Missing Device Definitions!
 #endif
+	else
+		printf ("\nUnknown device! (id=0x%08lx)", bd->bi_devid);
+
 #ifdef CONFIG_SH_SE_MODE
-	printf ("\nAddress Mode: 32-bit\n");
+	printf ("  [32-bit mode]\n");
 #else
-	printf ("\nAddress Mode: 29-bit\n");
+	printf ("  [29-bit mode]\n");
 #endif
+
+#ifdef CONFIG_SH_STB7100
+	print_mhz ("PLL0",		bd->bi_pll0frq);
+	print_mhz ("PLL1",		bd->bi_pll1frq);
+	print_mhz ("ST40  CPU",		bd->bi_st40cpufrq);
+	print_mhz ("ST40  BUS",		bd->bi_st40busfrq);
+	print_mhz ("ST40  PER",		bd->bi_st40perfrq);
+	print_mhz ("ST231 CPU",		bd->bi_st231frq);
+	print_mhz ("ST BUS",		bd->bi_stbusfrq);
+	print_mhz ("EMI",		bd->bi_emifrq);
+	print_mhz ("LMI",		bd->bi_lmifrq);
+#else
+	print_mhz ("EMI",		bd->bi_emifrq);
+#endif	/* CONFIG_SH_STB7100 */
+
 	return 0;
 }
 
@@ -407,6 +424,18 @@ static void print_num(const char *name, ulong value)
 	printf ("%-12s= 0x%08lX\n", name, value);
 }
 
+#if defined(CONFIG_SH4)
+static void print_mem(const char *name, ulong value)
+{
+	printf ("%-12s= 0x%08lX\t(", name, value);
+	print_size (value, ")\n");
+}
+static void print_mhz(const char *name, ulong value)
+{
+	printf ("%-12s= %3lu MHz\n", name, value);
+}
+#endif
+
 #if defined(CONFIG_PPC) || defined(CONFIG_M68K)
 static void print_str(const char *name, const char *str)
 {
diff --git a/common/cmd_doc.c b/common/cmd_doc.c
index 3d717c0..ae08a70 100644
--- a/common/cmd_doc.c
+++ b/common/cmd_doc.c
@@ -348,8 +348,8 @@ int doc_rw (struct DiskOnChip* this, int cmd,
 
 void doc_print(struct DiskOnChip *this) {
 	printf("%s at 0x%lX,\n"
-	       "\t  %d chip%s %s, size %d MB, \n"
-	       "\t  total size %ld MB, sector size %ld kB\n",
+	       "\t  %d chip%s %s, size %d MiB, \n"
+	       "\t  total size %ld MiB, sector size %ld KiB\n",
 	       this->name, this->physadr, this->numchips,
 	       this->numchips>1 ? "s" : "", this->chips_name,
 	       1 << (this->chipshift - 20),
@@ -366,9 +366,9 @@ void doc_print(struct DiskOnChip *this) {
 		       "\t    Binary partition: size %ld%s\n"
 		       "\t    Flash disk partition: size %ld%s, offset 0x%lx\n",
 		       bin_size > (1 << 20) ? bin_size >> 20 : bin_size >> 10,
-		       bin_size > (1 << 20) ? "MB" : "kB",
+		       bin_size > (1 << 20) ? "MiB" : "KiB",
 		       flash_size > (1 << 20) ? flash_size >> 20 : flash_size >> 10,
-		       flash_size > (1 << 20) ? "MB" : "kB", bin_size);
+		       flash_size > (1 << 20) ? "MiB" : "KiB", bin_size);
 	} else {
 		puts ("\t  No NFTL boot record found.\n");
 	}
@@ -794,7 +794,7 @@ static void DoC_ScanChips(struct DiskOnChip *this)
 	this->totlen = this->numchips * (1 << this->chipshift);
 
 #ifdef DOC_DEBUG
-	printf("%d flash chips found. Total DiskOnChip size: %ld MB\n",
+	printf("%d flash chips found. Total DiskOnChip size: %ld MiB\n",
 	       this->numchips, this->totlen >> 20);
 #endif
 }
@@ -990,7 +990,7 @@ static void DoC2k_init(struct DiskOnChip* this)
 	else
 		this->nftl_found = 1;
 
-	printf("%s @ 0x%lX, %ld MB\n", this->name, this->physadr, this->totlen >> 20);
+	printf("%s @ 0x%lX, %ld MiB\n", this->name, this->physadr, this->totlen >> 20);
 }
 
 int doc_read_ecc(struct DiskOnChip* this, loff_t from, size_t len,
diff --git a/common/cmd_mem.c b/common/cmd_mem.c
index 1953be1..149995c 100644
--- a/common/cmd_mem.c
+++ b/common/cmd_mem.c
@@ -392,14 +392,14 @@ int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	   ) {
 		int rc;
 
-		puts ("Copy to Flash... ");
+		puts ("Copy to Flash\n");
 
 		rc = flash_write ((char *)addr, dest, count*size);
 		if (rc != 0) {
 			flash_perror (rc);
 			return (1);
 		}
-		puts ("done\n");
+		puts (" done\n");
 		return 0;
 	}
 #endif
@@ -710,7 +710,8 @@ int do_mem_mtest (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 		pattern = 0;
 	}
 
-	printf ("Testing %08x ... %08x:\n", (uint)start, (uint)end);
+	printf ("Testing %08lx ... %08lx  (", (ulong)start, (ulong)end);
+	print_size ( (ulong)end - (ulong)start, "):\n" );
 #if defined(CFG_ALT_MEMTEST)
 	PRINTF("%s:%d: start 0x%p end 0x%p\n",
 		__FUNCTION__, __LINE__, start, end);
diff --git a/common/cmd_mii.c b/common/cmd_mii.c
index f530a38..73e94ff 100644
--- a/common/cmd_mii.c
+++ b/common/cmd_mii.c
@@ -107,7 +107,7 @@ int do_mii (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 		for (j = start; j < end; j++) {
 			if (miiphy_info (devname, j, &oui, &model, &rev) == 0) {
 				printf ("PHY 0x%02X: "
-					"OUI = 0x%04X, "
+					"OUI = 0x%06X, "
 					"Model = 0x%02X, "
 					"Rev = 0x%02X, "
 					"%3dbase%s, %s\n",
@@ -493,7 +493,7 @@ int do_mii (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 		for (j = start; j <= end; j++) {
 			if (miiphy_info (devname, j, &oui, &model, &rev) == 0) {
 				printf("PHY 0x%02X: "
-					"OUI = 0x%04X, "
+					"OUI = 0x%06X, "
 					"Model = 0x%02X, "
 					"Rev = 0x%02X, "
 					"%3dbase%s, %s\n",
diff --git a/common/env_flash.c b/common/env_flash.c
index eccfb62..52cca46 100644
--- a/common/env_flash.c
+++ b/common/env_flash.c
@@ -187,8 +187,9 @@ int saveenv(void)
 		goto Done;
 	}
 
-	puts ("Writing to Flash... ");
-	debug (" %08lX ... %08lX ...",
+	puts ("Writing to Flash...");
+	debug ("  %08lX ... %08lX ...",
+	puts ("\n");
 		(ulong)&(flash_addr_new->data),
 		sizeof(env_ptr->data)+(ulong)&(flash_addr_new->data));
 	if ((rc = flash_write((char *)env_ptr->data,
@@ -207,7 +208,7 @@ int saveenv(void)
 		flash_perror (rc);
 		goto Done;
 	}
-	puts ("done\n");
+	puts (" done\n");
 
 #if CFG_ENV_SECT_SIZE > CFG_ENV_SIZE
 	if (up_data) { /* restore the rest of sector */
@@ -306,8 +307,10 @@ int saveenv(void)
 	end_addr = flash_sect_addr + 0x20000 - 1;
 #endif
 
-	debug ("Protect off %08lX ... %08lX\n",
+	puts ("Unprotecting Flash...");
+	debug ("  %08lX ... %08lX",
 		(ulong)flash_sect_addr, end_addr);
+	puts ("\n");
 
 	if (flash_sect_protect (0, flash_sect_addr, end_addr))
 		return 1;
@@ -316,16 +319,17 @@ int saveenv(void)
 	if (flash_sect_erase (flash_sect_addr, end_addr))
 		return 1;
 
-	puts ("Writing to Flash... ");
+	puts ("Writing to Flash...\n");
 	rc = flash_write((char *)env_buffer, flash_sect_addr, len);
 	if (rc != 0) {
 		flash_perror (rc);
 		rcode = 1;
 	} else {
-		puts ("done\n");
+		puts (" done\n");
 	}
 
 	/* try to re-protect */
+	puts ("Protecting Flash...\n");
 	(void) flash_sect_protect (1, flash_sect_addr, end_addr);
 	return rcode;
 }
diff --git a/common/lcd.c b/common/lcd.c
index 914dc2e..c7d4670 100644
--- a/common/lcd.c
+++ b/common/lcd.c
@@ -746,7 +746,7 @@ static void *lcd_logo (void)
 		strmhz(temp, gd->cpu_clk));
 	lcd_drawchars (LCD_INFO_X, LCD_INFO_Y + VIDEO_FONT_HEIGHT * 3,
 					info, strlen(info));
-	sprintf (info, "  %ld MB RAM, %ld MB Flash",
+	sprintf (info, "  %ld MiB RAM, %ld MiB Flash",
 		gd->ram_size >> 20,
 		gd->bd->bi_flashsize >> 20 );
 	lcd_drawchars (LCD_INFO_X, LCD_INFO_Y + VIDEO_FONT_HEIGHT * 4,
@@ -754,7 +754,7 @@ static void *lcd_logo (void)
 #  else
 	/* leave one blank line */
 
-	sprintf (info, "MPC823 CPU at %s MHz, %ld MB RAM, %ld MB Flash",
+	sprintf (info, "MPC823 CPU at %s MHz, %ld MiB RAM, %ld MiB Flash",
 		strmhz(temp, gd->cpu_clk),
 		gd->ram_size >> 20,
 		gd->bd->bi_flashsize >> 20 );
diff --git a/cpu/sh/start.S b/cpu/sh/start.S
index 4a39e60..5ee33f7 100644
--- a/cpu/sh/start.S
+++ b/cpu/sh/start.S
@@ -32,8 +32,12 @@
 
 #if defined(CONFIG_SH_STB7100)
 #include <asm/stb7100reg.h>
+#elif defined(CONFIG_SH_STX7105)
+#include <asm/stx7105reg.h>
 #elif defined(CONFIG_SH_STX7111)
 #include <asm/stx7111reg.h>
+#elif defined(CONFIG_SH_STX7141)
+#include <asm/stx7141reg.h>
 #elif defined(CONFIG_SH_STX7200)
 #include <asm/stx7200reg.h>
 #else
@@ -133,6 +137,19 @@ set_pmb:
 	SH4_SET_PMB 6 0xb2 0x02  16 0 0 1	/* OFF-chip  Peripherals UN-cached */
 	SH4_SET_PMB 7 0xb8 0x18  64 0 0 1	/* ON-chip   Peripherals UN-cached */
 	SH4_SET_PMB 8 0xbc 0x1c  64 0 0 1	/* ST40 core Peripherals UN-cached */
+#elif defined(CONFIG_SH_STX7105) && defined(CONFIG_SH_MB680)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	SH4_SET_PMB 1 0x88 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	SH4_SET_PMB 3 0x98 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	#endif
+	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 6 0xa4 0x04  16 0 0 1	/* NAND FLASH UN-cached */
+	SH4_SET_PMB 7 0xa8 0x00  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 8 0xa9 0x01  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 9 0xb7 0x07  16 0 0 1	/* EPLD UN-cached */
 #elif defined(CONFIG_SH_STX7111) && defined(CONFIG_SH_MB618)
 	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI UN-cached */
 	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI UN-cached */
@@ -140,7 +157,11 @@ set_pmb:
 	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR/NAND FLASH UN-cached */
 	SH4_SET_PMB 6 0xa8 0x00  16		/* NOR/NAND FLASH CACHED */
 	SH4_SET_PMB 7 0xa9 0x01  16		/* NOR/NAND FLASH CACHED */
-	SH4_SET_PMB 8 0xb4 0x04  16 0 0 1	/* EPLD UN-cached */
+#ifndef CONFIG_SH_NO_EPLD
+	SH4_SET_PMB 8 0xb6 0x06  16 0 0 1	/* EPLD UN-cached */
+#endif	/* CONFIG_SH_NO_EPLD */
+#elif defined(CONFIG_SH_STX7141) && defined(CONFIG_SH_MB628)
+#error QQQ - to do!
 #elif defined(CONFIG_SH_STX7200) && defined(CONFIG_SH_MB519)
 	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 UN-cached */
 	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 UN-cached */
@@ -197,7 +218,7 @@ do_disable_caches:
 
 	/* invalidate+enable the caches: both I$ & D$ (with copy-back) */
 do_enable_caches:
-	MOV_CONST16_R0 (SH4_CCR_OCI|SH4_CCR_ICI|SH4_CCR_ICE|SH4_CCR_OCE|SH4_CCR_EMODE)
+	MOV_CONST16_R0 (SH4_CCR_OCI|SH4_CCR_ICI|SH4_CCR_ICE|SH4_CCR_OCE|SH4_CCR_CB|SH4_CCR_EMODE)
 	mov	r0, a0
 	CALL	sh_cache_set_op_offset
 
diff --git a/cpu/sh/stx7105/Makefile b/cpu/sh/stx7105/Makefile
new file mode 100644
index 0000000..35cd852
--- /dev/null
+++ b/cpu/sh/stx7105/Makefile
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2008 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(SOC).a
+
+OBJS	= stx7105.o
+SOBJS	=
+
+all:	.depend $(LIB)
+
+$(LIB):	$(SOBJS) $(OBJS)
+	$(AR) crv $@ $(SOBJS) $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/cpu/sh/stx7105/stx7105.c b/cpu/sh/stx7105/stx7105.c
new file mode 100644
index 0000000..8306f37
--- /dev/null
+++ b/cpu/sh/stx7105/stx7105.c
@@ -0,0 +1,252 @@
+/*
+ * (C) Copyright 2008 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7105reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stbus.h>
+#include <ata.h>
+
+#define PIO_BASE  ST40_PIO0_REGS_BASE
+
+static void stx7105_clocks(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	/*
+	 * FIXME
+	 * Gross hack to get the serial port working.
+	 * See the defintion of PCLK in drivers/stm-asc.c
+	 * for where this is used.
+	 */
+	bd->bi_emifrq = 100;
+}
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+
+#define ETHERNET_INTERFACE_ON	(1ul<<16)
+#define EXT_MDIO		(1ul<<17)
+#define RMII_MODE		(1ul<<18)
+#define PHY_CLK_EXT		(1ul<<19)
+#define MAC_SPEED_SEL           (1ul<<20)
+#define PHY_INTF_SEL_MASK	(0x3ul<<25)
+#define ENMII			(1ul<<27)
+/* Remaining bits define pad functions, default appears to work */
+
+extern int stmac_default_pbl(void)
+{
+	return 8;
+}
+
+extern void stmac_set_mac_speed(int speed)
+{
+	unsigned long sysconf = *STX7105_SYSCONF_SYS_CFG07;
+
+	/* MAC_SPEED_SEL = 0|1 */
+	if (speed == 100)
+		sysconf |= MAC_SPEED_SEL;
+	else if (speed == 10)
+		sysconf &= ~MAC_SPEED_SEL;
+
+	*STX7105_SYSCONF_SYS_CFG07 = sysconf;
+}
+
+/* ETH MAC pad configuration */
+static void stmac_eth_hw_setup( int reverse_mii, int rmii_mode, int mode,
+				int ext_mdio, int ext_clk, int phy_bus)
+{
+	unsigned long sysconf;
+
+	sysconf = *STX7105_SYSCONF_SYS_CFG07;
+	/* Ethernet ON */
+	sysconf |= (ETHERNET_INTERFACE_ON);
+	/* MII M-DIO select: 1: miim_dio from external input, 0: from GMAC */
+	if (ext_mdio)
+		sysconf |= (EXT_MDIO);
+	else
+		sysconf &= ~(EXT_MDIO);
+	/* RMII pin multiplexing: 0: RMII interface active, 1: MII interface */
+	if (rmii_mode)
+		sysconf &= ~(RMII_MODE);
+	else
+		sysconf |= (RMII_MODE);
+	/* PHY EXT CLOCK: 0: provided by STx7105; 1: external */
+	if (ext_clk)
+		sysconf |= (PHY_CLK_EXT);
+	else
+		sysconf &= ~(PHY_CLK_EXT);
+	/* Default GMII/MII selection */
+	sysconf &= ~(PHY_INTF_SEL_MASK);
+	sysconf |= ((mode&3ul)<<25);
+	/* MII mode */
+	if (reverse_mii)
+		sysconf &= ~(ENMII);
+	else
+		sysconf |= (ENMII);
+	*STX7105_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Pin configuration... */
+
+	/* PIO7[4] CFG37[8+4,4] = Alternate1 = MIIRX_DV/MII_EXCRS */
+	/* PIO7[5] CFG37[8+5,5] = Alternate1 = MIIRX_ER/MII_EXCOL */
+	/* PIO7[6] CFG37[8+6,6] = Alternate1 = MIITXD[0] */
+	/* PIO7[7] CFG37[8+7,7] = Alternate1 = MIITXD[1] */
+	sysconf = *STX7105_SYSCONF_SYS_CFG37;
+	sysconf &= ~(0xf0f0ul);	/* Mask=3,3,3,3 */
+	sysconf |=   0x0000ul;	/* OR  =0,0,0,0 */
+	*STX7105_SYSCONF_SYS_CFG37 = sysconf;
+	SET_PIO_PIN(PIO_PORT(7), 4, STPIO_ALT_BIDIR);
+	SET_PIO_PIN(PIO_PORT(7), 5, STPIO_ALT_BIDIR);
+	SET_PIO_PIN(PIO_PORT(7), 6, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(7), 7, STPIO_ALT_OUT);
+
+	/* PIO8[0] CFG46[8+0,0] = Alternate1 = MIITXD[2] */
+	/* PIO8[1] CFG46[8+1,1] = Alternate1 = MIITXD[3] */
+	/* PIO8[2] CFG46[8+2,2] = Alternate1 = MIITX_EN */
+	/* PIO8[3] CFG46[8+3,3] = Alternate1 = MIIMDIO */
+	/* PIO8[4] CFG46[8+4,4] = Alternate1 = MIIMDC */
+	/* PIO8[5] CFG46[8+5,5] = Alternate1 = MIIRXCLK */
+	/* PIO8[6] CFG46[8+6,6] = Alternate1 = MIIRXD[0] */
+	/* PIO8[7] CFG46[8+7,7] = Alternate1 = MIIRXD[1] */
+	sysconf = *STX7105_SYSCONF_SYS_CFG46;
+	sysconf &= ~(0xfffful);	/* Mask=3,3,3,3,3,3,3,3 */
+	sysconf |=   0x0000ul;	/* OR  =0,0,0,0,0,0,0,0 */
+	*STX7105_SYSCONF_SYS_CFG46 = sysconf;
+	SET_PIO_PIN(PIO_PORT(8), 0, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8), 1, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8), 2, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8), 3, STPIO_ALT_BIDIR);
+	SET_PIO_PIN(PIO_PORT(8), 4, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8), 5, STPIO_ALT_BIDIR);
+	SET_PIO_PIN(PIO_PORT(8), 6, STPIO_ALT_BIDIR);
+	SET_PIO_PIN(PIO_PORT(8), 7, STPIO_ALT_BIDIR);
+
+	/* PIO9[0] CFG47[8+0,0] = Alternate1 = MIIRXD[2] */
+	/* PIO9[1] CFG47[8+1,1] = Alternate1 = MIIRXD[3] */
+	/* PIO9[2] CFG47[8+2,2] = Alternate1 = MIITXCLK */
+	/* PIO9[3] CFG47[8+3,3] = Alternate1 = MIICOL */
+	/* PIO9[4] CFG47[8+4,4] = Alternate1 = MIICRS */
+	/* PIO9[5] CFG47[8+5,5] = Alternate1 = MIIPHYCLK */
+	/* PIO9[6] CFG47[8+6,6] = Alternate1 = MIIMDINT */
+	sysconf = *STX7105_SYSCONF_SYS_CFG47;
+	sysconf &= ~(0x7f7ful);	/* Mask=3,3,3,3,3,3,3 */
+	sysconf |=   0x0000ul;	/* OR  =0,0,0,0,0,0,0 */
+	*STX7105_SYSCONF_SYS_CFG47 = sysconf;
+	SET_PIO_PIN(PIO_PORT(9), 0, STPIO_ALT_BIDIR);
+	SET_PIO_PIN(PIO_PORT(9), 1, STPIO_ALT_BIDIR);
+	SET_PIO_PIN(PIO_PORT(9), 2, STPIO_ALT_BIDIR);
+	SET_PIO_PIN(PIO_PORT(9), 3, STPIO_ALT_BIDIR);
+	SET_PIO_PIN(PIO_PORT(9), 4, STPIO_ALT_BIDIR);
+	SET_PIO_PIN(PIO_PORT(9), 5, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(9), 6, STPIO_ALT_BIDIR);
+}
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+int soc_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	stx7105_clocks();
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+	stmac_eth_hw_setup (0, 0, 0, 1, 0, 0);
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+	bd->bi_devid = *STX7105_SYSCONF_DEVICEID_0;
+
+#if QQQ	/* QQQ - TO FIX */
+	/*  Make sure reset period is shorter than WDT timeout */
+	*STX7105_SYSCONF_SYS_CFG09 = (*STX7105_SYSCONF_SYS_CFG09 & 0xFF000000) | 0x000A8C;
+#endif	/* QQQ - TO FIX */
+
+	return 0;
+}
+
+
+#if defined(CONFIG_USB_OHCI_NEW)
+extern void stx7105_usb_init(void)
+{
+	unsigned long reg;
+	const unsigned char oc_pins[2]    = {4, 6};	/* PIO4 */
+	const unsigned char power_pins[2] = {5, 7};	/* PIO4 */
+#if CFG_USB_BASE == CFG_USB0_BASE
+	const size_t port = 0;
+#elif CFG_USB_BASE == CFG_USB1_BASE
+	const size_t port = 1;
+#else
+#error Unknown USB Host Controller Base Address
+#endif
+
+	/* Power on the USB */
+	reg = readl(STX7105_SYSCONF_SYS_CFG32);
+	/* Power up USB host controller */
+	/* USBn_HC_POWER_DOWN_REQ = 0 = Powered Up */
+	reg &= ~(1ul<<(4+port));
+	/* Power up USB PHY */
+	/* USBn_PHY_POWER_DOWN_REQ = 0 = Powered Up */
+	reg &= ~(1ul<<(6+port));
+	writel(reg, STX7105_SYSCONF_SYS_CFG32);
+
+	/* USB overcurrent enable */
+	reg = readl(STX7105_SYSCONF_SYS_CFG04);
+	/* USB0_PRT_OVCURR_POL = 0 = Active Low */
+	reg &= ~(1ul<<(3+port));
+	/* USBn_PRT_OVCURR_IN = 0 = PIO4[oc_pins[port]] */
+	reg &= ~(1ul<<(5+port));
+	/* CFG_USBn_OVRCURR_ENABLE = 1 = OC Enabled */
+	reg |= 1ul<<(11+port);
+	writel(reg, STX7105_SYSCONF_SYS_CFG04);
+
+	/* Route USBn OC Routing via PIO4[oc_pins[port]] */
+	reg = *STX7105_SYSCONF_SYS_CFG34;
+	/* PIO4[oc_pins[port]] CFG34[8+oc_pins[port],oc_pins[port]] = Alternate4 */
+	reg &= ~(0x0101ul<<(oc_pins[port]));	/* Mask=3 */
+	reg |=   0x0101ul<<(oc_pins[port]);	/* OR=3 */
+	*STX7105_SYSCONF_SYS_CFG34 = reg;
+	/* set PIO directionality, for OC as IN */
+	SET_PIO_PIN(PIO_PORT(4), oc_pins[port], STPIO_IN);
+
+	/* Route USBn POWER Routing via PIO4[power_pins[port]] */
+	reg = *STX7105_SYSCONF_SYS_CFG34;
+	/* PIO4[power_pins[port]] CFG34[8+power_pins[port],power_pins[port]] = Alternate4 */
+	reg &= ~(0x0101ul<<(power_pins[port]));	/* Mask=3 */
+	reg |=   0x0101ul<<(power_pins[port]);	/* OR=3 */
+	*STX7105_SYSCONF_SYS_CFG34 = reg;
+	/* set PIO directionality, for POWER as ALT_OUT */
+	SET_PIO_PIN(PIO_PORT(4), power_pins[port], STPIO_ALT_OUT);
+
+	/* start the USB Wrapper Host Controller */
+	ST40_start_host_control(
+		USB_FLAGS_STRAP_8BIT |
+		USB_FLAGS_STBUS_CONFIG_THRESHOLD128);
+}
+
+#endif /* defined(CONFIG_USB_OHCI_NEW) */
+
diff --git a/cpu/sh/stx7141/Makefile b/cpu/sh/stx7141/Makefile
new file mode 100644
index 0000000..d053c92
--- /dev/null
+++ b/cpu/sh/stx7141/Makefile
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2008 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(SOC).a
+
+OBJS	= stx7141.o
+SOBJS	=
+
+all:	.depend $(LIB)
+
+$(LIB):	$(SOBJS) $(OBJS)
+	$(AR) crv $@ $(SOBJS) $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/cpu/sh/stx7141/stx7141.c b/cpu/sh/stx7141/stx7141.c
new file mode 100644
index 0000000..51af6d8
--- /dev/null
+++ b/cpu/sh/stx7141/stx7141.c
@@ -0,0 +1,198 @@
+/*
+ * (C) Copyright 2008 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7141reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stbus.h>
+#include <ata.h>
+
+
+static void stx7141_clocks(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	/*
+	 * FIXME
+	 * Gross hack to get the serial port working.
+	 * See the defintion of PCLK in drivers/stm-asc.c
+	 * for where this is used.
+	 */
+	bd->bi_emifrq = 100;
+}
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+
+#define ETHERNET_INTERFACE_ON	(1ul<<16)
+#define PHY_CLK_EXT		(1ul<<19)
+#define MAC_SPEED_SEL           (1ul<<20)
+#define PHY_INTF_SEL_MASK	(0x7ul<<24)
+#define ENMII			(1ul<<27)
+
+/* Remaining bits define pad functions, default appears to work */
+
+extern int stmac_default_pbl(void)
+{
+	return 32;
+}
+
+extern void stmac_set_mac_speed(int speed)
+{
+#ifdef QQQ	/* QQQ - TO DO */
+	/* QQQ: check this code is actually correct for the 7141 */
+	unsigned long sysconf = *STX7141_SYSCONF_SYS_CFG07;
+
+//	printf("QQQ: %s(speed=%u)\n", __FUNCTION__, speed); /* QQQ - DELETE */
+	/* MAC_SPEED_SEL = 0|1 */
+	if (speed == 100)
+		sysconf |= MAC_SPEED_SEL;
+	else if (speed == 10)
+		sysconf &= ~MAC_SPEED_SEL;
+
+	*STX7141_SYSCONF_SYS_CFG07 = sysconf;
+#endif		/* QQQ - TO DO */
+}
+
+/* ETH MAC pad configuration */
+static void stmac_eth_hw_setup(void)
+{
+#ifdef QQQ	/* QQQ - TO DO */
+	const unsigned long en_mii  = 1;
+	const unsigned long sel     = 0;
+	const unsigned long ext_clk = 0;
+
+	unsigned long sysconf = *STX7141_SYSCONF_SYS_CFG07;
+
+	/* Ethernet ON */
+	sysconf |= ETHERNET_INTERFACE_ON;
+
+	/* PHY EXT CLOCK: 0: provided by STX7141; 1: external */
+	if (ext_clk)
+		sysconf |= PHY_CLK_EXT;
+	else
+		sysconf &= ~PHY_CLK_EXT;
+
+	/* Default GMII/MII slection */
+	sysconf &= ~PHY_INTF_SEL_MASK;
+	sysconf |= ((sel<<24) & PHY_INTF_SEL_MASK);
+
+	/* MII mode */
+	if (en_mii)
+		sysconf |= ENMII;
+	else
+		sysconf &= ~ENMII;
+
+	*STX7141_SYSCONF_SYS_CFG07 = sysconf;
+#endif		/* QQQ - TO DO */
+}
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+int soc_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	stx7141_clocks();
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+	stmac_eth_hw_setup();
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+	bd->bi_devid = *STX7141_SYSCONF_DEVICEID_0;
+
+#ifdef QQQ	/* QQQ - TO DO */
+	/*  Make sure reset period is shorter than WDT timeout */
+	*STX7141_SYSCONF_SYS_CFG09 = (*STX7141_SYSCONF_SYS_CFG09 & 0xFF000000) | 0x000A8C;
+
+#endif		/* QQQ - TO DO */
+	return 0;
+}
+
+
+#if defined(CONFIG_USB_OHCI_NEW)
+extern void stx7141_usb_init(void)
+{
+#ifdef QQQ	/* QQQ - TO DO */
+	unsigned long reg, req_reg;
+
+	/* Power on the USB */
+	reg = readl(STX7141_SYSCONF_SYS_CFG32);
+	reg &= ~(1ul<<4); /* USB_POWER_DOWN_REQ = 0 */
+	writel(reg, STX7141_SYSCONF_SYS_CFG32);
+
+	/* Work around for USB over-current detection chip being
+	 * active low, and the 7141 being active high.
+	 * Note this is an undocumented bit, which apparently enables
+	 * an inverter on the overcurrent signal.
+	 */
+	reg = readl(STX7141_SYSCONF_SYS_CFG06);
+	reg |= 1ul<<29;
+	writel(reg, STX7141_SYSCONF_SYS_CFG06);
+
+	/* USB oc */
+	SET_PIO_PIN(PIO_PORT(5), 6, STPIO_IN);
+	/* USB power */
+	SET_PIO_PIN(PIO_PORT(5), 7, STPIO_ALT_OUT);
+	STPIO_SET_PIN(PIO_PORT(5), 7, 1);
+
+	/* Set strap mode */
+#define STRAP_MODE	AHB2STBUS_STRAP_16_BIT
+	reg = readl(AHB2STBUS_STRAP);
+#if STRAP_MODE == 0
+	reg &= ~AHB2STBUS_STRAP_16_BIT;
+#else
+	reg |= STRAP_MODE;
+#endif
+	writel(reg, AHB2STBUS_STRAP);
+
+	/* Start PLL */
+	reg = readl(AHB2STBUS_STRAP);
+	writel(reg | AHB2STBUS_STRAP_PLL, AHB2STBUS_STRAP);
+	udelay(100000);	/* QQQ: can this delay be shorter ? */
+	writel(reg & (~AHB2STBUS_STRAP_PLL), AHB2STBUS_STRAP);
+	udelay(100000);	/* QQQ: can this delay be shorter ? */
+
+	req_reg =
+		(1<<21) |  /* Turn on read-ahead */
+		(5<<16) |  /* Opcode is store/load 32 */
+		(0<<15) |  /* Turn off write posting */
+		(1<<14) |  /* Enable threshold */
+		(3<<9)  |  /* 2**3 Packets in a chunk */
+		(0<<4)  |  /* No messages */
+		(8<<0);    /* Threshold is 256 */
+
+	do {
+		writel(req_reg, AHB2STBUS_STBUS_CONFIG);
+		reg = readl(AHB2STBUS_STBUS_CONFIG);
+	} while ((reg & 0x7FFFFFFF) != req_reg);
+#endif		/* QQQ - TO DO */
+}
+
+#endif /* defined(CONFIG_USB_OHCI_NEW) */
+
diff --git a/cpu/sh/usb.c b/cpu/sh/usb.c
index 708f1df..72d1cc6 100644
--- a/cpu/sh/usb.c
+++ b/cpu/sh/usb.c
@@ -24,11 +24,21 @@
 
 #include <common.h>
 #include <command.h>
+#include <asm/stbus.h>
+#include <asm/io.h>
+
+
+#define mdelay(n) ({unsigned long msec=(n); while (msec--) udelay(1000);})
+
 
 #if defined(CONFIG_SH_STB7100)
 extern void stb7100_usb_init(void);
+#elif defined(CONFIG_SH_STX7105)
+extern void stx7105_usb_init(void);
 #elif defined(CONFIG_SH_STX7111)
 extern void stx7111_usb_init(void);
+#elif defined(CONFIG_SH_STX7141)
+extern void stx7141_usb_init(void);
 #elif defined(CONFIG_SH_STX7200)
 extern void stx7200_usb_init(void);
 #else
@@ -41,8 +51,12 @@ extern int usb_cpu_init(void)
 {
 #if defined(CONFIG_SH_STB7100)
 	stb7100_usb_init();
+#elif defined(CONFIG_SH_STX7105)
+	stx7105_usb_init();
 #elif defined(CONFIG_SH_STX7111)
 	stx7111_usb_init();
+#elif defined(CONFIG_SH_STX7141)
+	stx7141_usb_init();
 #elif defined(CONFIG_SH_STX7200)
 	stx7200_usb_init();
 #endif
@@ -59,5 +73,78 @@ extern int usb_cpu_init_fail(void)
 	return 0;
 }
 
+extern int ST40_start_host_control(unsigned int flags)
+{
+	static int initialized = 0;
+	unsigned long reg, req_reg;
+
+	if (initialized)
+		return 0;	/* already initialized */
+
+	if (flags &
+	    (USB_FLAGS_STRAP_8BIT | USB_FLAGS_STRAP_16BIT)) {
+		/* Set strap mode */
+		reg = readl(AHB2STBUS_STRAP);
+		if (flags & USB_FLAGS_STRAP_16BIT)
+			reg |= AHB2STBUS_STRAP_16_BIT;
+		else
+			reg &= ~AHB2STBUS_STRAP_16_BIT;
+		writel(reg, AHB2STBUS_STRAP);
+	}
+
+	if (flags & USB_FLAGS_STRAP_PLL) {
+		/* Start PLL */
+		reg = readl(AHB2STBUS_STRAP);
+		writel(reg | AHB2STBUS_STRAP_PLL, AHB2STBUS_STRAP);
+		mdelay(30);
+		writel(reg & (~AHB2STBUS_STRAP_PLL), AHB2STBUS_STRAP);
+		mdelay(30);
+	}
+
+	if (flags & USB_FLAGS_OPC_MSGSIZE_CHUNKSIZE) {
+		/* Set the STBus Opcode Config for load/store 32 */
+		writel(AHB2STBUS_STBUS_OPC_32BIT, AHB2STBUS_STBUS_OPC);
+
+		/* Set the Message Size Config to n packets per message */
+		writel(AHB2STBUS_MSGSIZE_4, AHB2STBUS_MSGSIZE);
+
+		/* Set the chunksize to n packets */
+		writel(AHB2STBUS_CHUNKSIZE_4, AHB2STBUS_CHUNKSIZE);
+	}
+
+	if (flags &
+	    (USB_FLAGS_STBUS_CONFIG_THRESHOLD128 |
+	     USB_FLAGS_STBUS_CONFIG_THRESHOLD256)) {
+
+		if (flags & USB_FLAGS_STBUS_CONFIG_THRESHOLD128)
+			req_reg =
+				(1<<21) |  /* Turn on read-ahead */
+				(5<<16) |  /* Opcode is store/load 32 */
+				(0<<15) |  /* Turn off write posting */
+				(1<<14) |  /* Enable threshold */
+				(3<<9)  |  /* 2**3 Packets in a chunk */
+				(0<<4)  |  /* No messages */
+				7;         /* Threshold is 128 */
+		else
+			req_reg =
+				(1<<21) |  /* Turn on read-ahead */
+				(5<<16) |  /* Opcode is store/load 32 */
+				(0<<15) |  /* Turn off write posting */
+				(1<<14) |  /* Enable threshold */
+				(3<<9)  |  /* 2**3 Packets in a chunk */
+				(0<<4)  |  /* No messages */
+				(8<<0);    /* Threshold is 256 */
+
+		do {
+			writel(req_reg, AHB2STBUS_STBUS_CONFIG);
+			reg = readl(AHB2STBUS_STBUS_CONFIG);
+		} while ((reg & 0x7FFFFFFF) != req_reg);
+	}
+
+	initialized = 1;
+
+	return 0;
+}
+
 #endif /* defined(CONFIG_USB_OHCI_NEW) && defined(CFG_USB_OHCI_CPU_INIT) */
 
diff --git a/disk/part.c b/disk/part.c
index 56b9427..76208be 100644
--- a/disk/part.c
+++ b/disk/part.c
@@ -145,7 +145,7 @@ void dev_print (block_dev_desc_t *dev_desc)
 		lba = dev_desc->lba;
 
 		lba512 = (lba * (dev_desc->blksz/512));
-		mb = (10 * lba512) / 2048;	/* 2048 = (1024 * 1024) / 512 MB */
+		mb = (10 * lba512) / 2048;	/* 2048 = (1024 * 1024) / 512 MiB */
 		/* round to 1 digit */
 		mb_quot	= mb / 10;
 		mb_rem	= mb - (10 * mb_quot);
@@ -158,13 +158,13 @@ void dev_print (block_dev_desc_t *dev_desc)
 			printf ("            Supports 48-bit addressing\n");
 #endif
 #if defined(CFG_64BIT_LBA) && defined(CFG_64BIT_VSPRINTF)
-		printf ("            Capacity: %ld.%ld MB = %ld.%ld GB (%qd x %ld)\n",
+		printf ("            Capacity: %ld.%ld MiB = %ld.%ld GiB (%qd x %ld)\n",
 			mb_quot, mb_rem,
 			gb_quot, gb_rem,
 			lba,
 			dev_desc->blksz);
 #else
-		printf ("            Capacity: %ld.%ld MB = %ld.%ld GB (%ld x %ld)\n",
+		printf ("            Capacity: %ld.%ld MiB = %ld.%ld GiB (%ld x %ld)\n",
 			mb_quot, mb_rem,
 			gb_quot, gb_rem,
 			(ulong)lba,
diff --git a/disk/part_mac.c b/disk/part_mac.c
index d303a73..e85d1c2 100644
--- a/disk/part_mac.c
+++ b/disk/part_mac.c
@@ -95,7 +95,7 @@ void print_part_mac (block_dev_desc_t *dev_desc)
 
 	n  = ddesc.blk_count;
 
-	mb = ldiv(n, ((1024 * 1024) / ddesc.blk_size)); /* MB */
+	mb = ldiv(n, ((1024 * 1024) / ddesc.blk_size)); /* MiB */
 	/* round to 1 digit */
 	mb.rem *= 10 * ddesc.blk_size;
 	mb.rem += 512 * 1024;
@@ -107,7 +107,7 @@ void print_part_mac (block_dev_desc_t *dev_desc)
 
 
 	printf ("Block Size=%d, Number of Blocks=%d, "
-		"Total Capacity: %ld.%ld MB = %ld.%ld GB\n"
+		"Total Capacity: %ld.%ld MiB = %ld.%ld GiB\n"
 		"DeviceType=0x%x, DeviceId=0x%x\n\n"
 		"   #:                 type name"
 		"                   length   base       (size)\n",
@@ -139,7 +139,7 @@ void print_part_mac (block_dev_desc_t *dev_desc)
 		/* update partition count */
 		n = mpart.map_count;
 
-		c      = 'k';
+		c      = 'K';
 		bytes  = mpart.block_count;
 		bytes /= (1024 / ddesc.blk_size);  /* kB; assumes blk_size == 512 */
 		if (bytes >= 1024) {
@@ -151,7 +151,7 @@ void print_part_mac (block_dev_desc_t *dev_desc)
 			c = 'G';
 		}
 
-		printf ("%20.32s %-18.32s %10u @ %-10u (%3ld%c)\n",
+		printf ("%20.32s %-18.32s %10u @ %-10u (%3ld%ciB)\n",
 			mpart.type,
 			mpart.name,
 			mpart.block_count,
diff --git a/drivers/mtd/cfi_flash.c b/drivers/mtd/cfi_flash.c
index 9c80b26..1362ed0 100644
--- a/drivers/mtd/cfi_flash.c
+++ b/drivers/mtd/cfi_flash.c
@@ -348,7 +348,7 @@ unsigned long flash_init (void)
 		size += flash_info[i].size = flash_get_size (bank_base[i], i);
 		if (flash_info[i].flash_id == FLASH_UNKNOWN) {
 #ifndef CFG_FLASH_QUIET_TEST
-			printf ("## Unknown FLASH on Bank %d - Size = 0x%08lx = %ld MB\n",
+			printf ("## Unknown FLASH on Bank %d - Size = 0x%08lx = %ld MiB\n",
 				i+1, flash_info[i].size, flash_info[i].size << 20);
 #endif /* CFG_FLASH_QUIET_TEST */
 		}
@@ -520,7 +520,7 @@ void flash_print_info (flash_info_t * info)
 
 	printf ("CFI conformant FLASH (%d x %d)",
 		(info->portwidth << 3), (info->chipwidth << 3));
-	printf ("  Size: %ld MB in %d Sectors\n",
+	printf ("  Size: %ld MiB in %d Sectors\n",
 		info->size >> 20, info->sector_count);
 	printf ("  ");
 	switch (info->vendor) {
@@ -612,6 +612,7 @@ int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
 	int aln;
 	cfiword_t cword;
 	int i, rc;
+	const ulong dot_stride = 16ul << 10;	/* 16 KiB */
 
 #ifdef CFG_FLASH_USE_BUFFER_WRITE
 	int buffered_size;
@@ -677,6 +678,10 @@ int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
 			return rc;
 		wp += info->portwidth;
 		cnt -= info->portwidth;
+		/* print a dot every 'dot_stride' bytes */
+		/* Note: dependant on alignment may print one too many */
+		if ((wp % dot_stride) == 0x0ul)
+			putc ('.');
 	}
 #endif /* CFG_FLASH_USE_BUFFER_WRITE */
 	if (cnt == 0) {
diff --git a/drivers/mtd/nand/diskonchip.c b/drivers/mtd/nand/diskonchip.c
index e17af70..4453cb8 100644
--- a/drivers/mtd/nand/diskonchip.c
+++ b/drivers/mtd/nand/diskonchip.c
@@ -1576,7 +1576,7 @@ static inline int __init doc_probe(unsigned long physadr)
 			reg = DoC_Mplus_Toggle;
 			break;
 		case DOC_ChipID_DocMilPlus32:
-			printk(KERN_ERR "DiskOnChip Millennium Plus 32MB is not supported, ignoring.\n");
+			printk(KERN_ERR "DiskOnChip Millennium Plus 32MiB is not supported, ignoring.\n");
 		default:
 			ret = -ENODEV;
 			goto notfound;
diff --git a/drivers/mtd/nand/nand.c b/drivers/mtd/nand/nand.c
index b532338..195a725 100644
--- a/drivers/mtd/nand/nand.c
+++ b/drivers/mtd/nand/nand.c
@@ -70,7 +70,7 @@ void nand_init(void)
 		if (nand_curr_device == -1)
 			nand_curr_device = i;
 	}
-	printf("%lu MiB\n", size / (1024 * 1024));
+	print_size (size, "\n");
 
 #ifdef CFG_NAND_SELECT_DEVICE
 	/*
diff --git a/drivers/mtd/nand_legacy/nand_legacy.c b/drivers/mtd/nand_legacy/nand_legacy.c
index 49d2ebb..b8d1f58 100644
--- a/drivers/mtd/nand_legacy/nand_legacy.c
+++ b/drivers/mtd/nand_legacy/nand_legacy.c
@@ -242,8 +242,8 @@ void nand_print(struct nand_chip *nand)
 {
 	if (nand->numchips > 1) {
 		printf("%s at 0x%lx,\n"
-		       "\t  %d chips %s, size %d MB, \n"
-		       "\t  total size %ld MB, sector size %ld kB\n",
+		       "\t  %d chips %s, size %d MiB, \n"
+		       "\t  total size %ld MiB, sector size %ld KiB\n",
 		       nand->name, nand->IO_ADDR, nand->numchips,
 		       nand->chips_name, 1 << (nand->chipshift - 20),
 		       nand->totlen >> 20, nand->erasesize >> 10);
@@ -515,7 +515,7 @@ static void NanD_ScanChips(struct nand_chip *nand)
 	nand->totlen = nand->numchips * (1 << nand->chipshift);
 
 #ifdef NAND_DEBUG
-	printf("%d flash chips found. Total nand_chip size: %ld MB\n",
+	printf("%d flash chips found. Total nand_chip size: %ld MiB\n",
 	       nand->numchips, nand->totlen >> 20);
 #endif
 }
diff --git a/drivers/net/stm-stmac.c b/drivers/net/stm-stmac.c
index 11cd8e8..cd8034a 100644
--- a/drivers/net/stm-stmac.c
+++ b/drivers/net/stm-stmac.c
@@ -42,6 +42,9 @@
 #	define PRINTK(args...)
 #endif
 
+/* do we want to put the PHY in loop-back mode ? */
+/* #define CONFIG_PHY_LOOPBACK */
+
 /* prefix to use for diagnostics */
 #ifdef CONFIG_DRIVER_NETSTMAC
 #	define STMAC	"STM-MAC: "
@@ -123,6 +126,8 @@ static void *rx_packets[CONFIG_DMA_RX_SIZE];
 #define XMC_PHY_ADDR_MSK         0x00f8	/* PHY Address Mask */
 #define XMC_PHY_ADDR_SHIFT       3	/* PHY Address Mask */
 #define XMC_PRE_SUP              0x0002	/* Preamble Suppression */
+#define PHY_ADDR_MSK		XMC_PHY_ADDR_MSK	/* PHY Address Mask */
+#define PHY_ADDR_SHIFT		XMC_PHY_ADDR_SHIFT	/* PHY Address Mask */
 
 /* MII mode */
 #define MII_TSTAT_SMII  0x1000
@@ -135,9 +140,19 @@ static void *rx_packets[CONFIG_DMA_RX_SIZE];
 #define LAN8700_PHY_ID		0x0007c0c0u
 #define LAN8700_PHY_ID_MASK	0xfffffff0u
 
-#define	SPECIAL_MODE_REG	0x12		/* Special Modes Register */
-#define	PHY_ADDR_MSK		0x001f		/* PHY Address Mask */
-#define	PHY_ADDR_SHIFT		0		/* PHY Address Mask */
+#define SPECIAL_MODE_REG	0x12		/* Special Modes Register */
+#define PHY_ADDR_MSK		0x001f		/* PHY Address Mask */
+#define PHY_ADDR_SHIFT		0		/* PHY Address Mask */
+
+#elif defined(CONFIG_STMAC_DP83865)	/* Nat Semi DP83865 */
+
+/* Nat Semi DP83865 phy identifier values */
+#define DP83865_PHY_ID		0x20005c70u
+#define DP83865_PHY_ID_MASK	0xfffffff0u
+
+#define PHY_SUP_REG		0x1f		/* PHY Support Register */
+#define PHY_ADDR_MSK		0x001f		/* PHY Address Mask */
+#define PHY_ADDR_SHIFT		0		/* PHY Address Mask */
 
 #else
 #error Need to define which PHY to use
@@ -251,6 +266,11 @@ static unsigned int stmac_phy_get_addr (void)
 			printf (STMAC "SMSC LAN8700 found\n");
 			return phyaddr;
 		}
+#elif defined(CONFIG_STMAC_DP83865)
+		if ((id & DP83865_PHY_ID_MASK) == DP83865_PHY_ID) {
+			printf (STMAC "NS DP83865 found\n");
+			return phyaddr;
+		}
 #endif	/* CONFIG_STMAC_STE10XP */
 	}
 
@@ -276,13 +296,14 @@ static int stmac_phy_init (void)
 	/* test for H/W address disagreement with the assigned address */
 #if defined(CONFIG_STMAC_STE10XP)
 	value = stmac_mii_read (eth_phy_addr, MII_XMC);
-	value = (value & XMC_PHY_ADDR_MSK) >> XMC_PHY_ADDR_SHIFT;
 #elif defined(CONFIG_STMAC_LAN8700)
 	value = stmac_mii_read (eth_phy_addr, SPECIAL_MODE_REG);
-	value = (value & PHY_ADDR_MSK) >> PHY_ADDR_SHIFT;
+#elif defined(CONFIG_STMAC_DP83865)
+	value = stmac_mii_read (eth_phy_addr, PHY_SUP_REG);
 #else
 #error Need to define PHY
 #endif
+	value = (value & PHY_ADDR_MSK) >> PHY_ADDR_SHIFT;
 	if (value != eth_phy_addr) {
 		printf (STMAC "PHY address mismatch with hardware (hw %d != %d)\n",
 			value,
@@ -319,6 +340,13 @@ static int stmac_phy_init (void)
 	stmac_phy_negotiate (eth_phy_addr);
 	stmac_phy_check_speed (eth_phy_addr);
 
+#ifdef CONFIG_PHY_LOOPBACK
+	/* put the PHY in loop-back mode, if required */
+	value = stmac_mii_read (eth_phy_addr, MII_BMCR);
+	value |= BMCR_LOOPBACK;
+	stmac_mii_write (eth_phy_addr, MII_BMCR, value);
+#endif	/* CONFIG_PHY_LOOPBACK */
+
 	return 0;
 }
 
@@ -1036,7 +1064,7 @@ static void stmac_eth_rx (void)
 			 * the CRC */
 			frame_len = drx->des01.rx.frame_length;
 			if ((frame_len >= 0) && (frame_len <= PKTSIZE_ALIGN)) {
-#ifdef DEBUG
+#if defined(DEBUG) || defined(CONFIG_PHY_LOOPBACK)
 				const unsigned char *p = rx_packets[cur_rx];
 				printf("\nRX[%d]:  0x%08x ", cur_rx, p);
 				printf("DA=%02x:%02x:%02x:%02x:%02x:%02x",
@@ -1214,8 +1242,8 @@ extern int eth_rx (void)
 extern int eth_send (volatile void *packet, int length)
 {
 	PRINTK (STMAC "entering %s()\n", __FUNCTION__);
-#ifdef DEBUG
-	const unsigned char *p = packet;
+#if defined(DEBUG) || defined(CONFIG_PHY_LOOPBACK)
+	const unsigned char * p = (const unsigned char*)packet;
 	printf("TX   :  0x%08x ", p);
 	printf("DA=%02x:%02x:%02x:%02x:%02x:%02x",
 		p[0], p[1], p[2], p[3], p[4], p[5]);
diff --git a/drivers/net/stm-stmac.h b/drivers/net/stm-stmac.h
index 11ecf5b..6890f70 100644
--- a/drivers/net/stm-stmac.h
+++ b/drivers/net/stm-stmac.h
@@ -218,7 +218,7 @@
 //#define BMCR_PDOWN			0x0800		/* Power-down */
 #define BMCR_ANENABLE			0x1000		/* Enable Auto-Negotiation */
 //#define BMCR_SPEED100			0x2000		/* Select 100Mbps */
-//#define BMCR_LOOPBACK			0x4000		/* Enable Loop-back Mode */
+#define BMCR_LOOPBACK			0x4000		/* Enable Loop-back Mode */
 //#define BMCR_RESET			0x8000		/* Software Reset */
 
 /* Basic Mode Status Register defines */
diff --git a/drivers/serial/stm-asc.c b/drivers/serial/stm-asc.c
index 4075e66..217a66d 100644
--- a/drivers/serial/stm-asc.c
+++ b/drivers/serial/stm-asc.c
@@ -1,9 +1,10 @@
 /*
- * drivers/stm-asc.c
+ * drivers/serial/stm-asc.c
  *
  * Support for Serial I/O using STMicroelectronics' on-chip ASC.
  *
- *  Copyright (c) 2004  STMicroelectronics Limited
+ *  Copyright (c) 2004,2008  STMicroelectronics Limited
+ *  Sean McGoogan <Sean.McGoogan@st.com>
  *  Copyright (C) 1999  Takeshi Yaegachi & Niibe Yutaka
  *
  * This file is subject to the terms and conditions of the GNU Lesser
@@ -20,21 +21,20 @@
 #include "asm/io.h"
 #include "asm/pio.h"
 
-#define CREAD	0000200
-#define HUPCL	0002000
-#define CLOCAL	0004000
-#define	CSTOPB	0000100
-#define CSIZE	0000060
-#define CS7	0000040
-#define CS8	0000060
-#define PARENB	0000400
-#define PARODD  0001000
+#define CS7		0000040
+#define CS8		0000060
+#define CSIZE		0000060
+#define CSTOPB		0000100
+#define CREAD		0000200
+#define PARENB		0000400
+#define PARODD		0001000
+#define HUPCL		0002000
+#define CLOCAL		0004000
 
 #define BAUDMODE	0x00001000
 #define CTSENABLE	0x00000800
 #define RXENABLE	0x00000100
 #define RUN		0x00000080
-#define LOOPBACK	0x00000000
 #define STOPBIT		0x00000008
 #define MODE		0x00000001
 #define MODE_7BIT_PAR	0x0003
@@ -56,43 +56,42 @@
 #define STA_RBF		0x0001
 
 
-#define UART_BAUDRATE_OFFSET    0x00
-#define UART_TXBUFFER_OFFSET    0x04
-#define UART_RXBUFFER_OFFSET    0x08
-#define UART_CONTROL_OFFSET     0x0C
-#define UART_INTENABLE_OFFSET   0x10
-#define UART_STATUS_OFFSET      0x14
-#define UART_GUARDTIME_OFFSET   0x18
-#define UART_TIMEOUT_OFFSET     0x1C
-#define UART_TXRESET_OFFSET     0x20
-#define UART_RXRESET_OFFSET     0x24
-#define UART_RETRIES_OFFSET     0x28
-
-#define UART_BAUDRATE_REG   (CFG_STM_ASC_BASE + UART_BAUDRATE_OFFSET)
-#define UART_TXBUFFER_REG   (CFG_STM_ASC_BASE + UART_TXBUFFER_OFFSET)
-#define UART_RXBUFFER_REG   (CFG_STM_ASC_BASE + UART_RXBUFFER_OFFSET)
-#define UART_CONTROL_REG    (CFG_STM_ASC_BASE + UART_CONTROL_OFFSET)
-#define UART_INTENABLE_REG  (CFG_STM_ASC_BASE + UART_INTENABLE_OFFSET)
-#define UART_STATUS_REG     (CFG_STM_ASC_BASE + UART_STATUS_OFFSET)
-#define UART_GUARDTIME_REG  (CFG_STM_ASC_BASE + UART_GUARDTIME_OFFSET)
-#define UART_TIMEOUT_REG    (CFG_STM_ASC_BASE + UART_TIMEOUT_OFFSET)
-#define UART_TXRESET_REG    (CFG_STM_ASC_BASE + UART_TXRESET_OFFSET)
-#define UART_RXRESET_REG    (CFG_STM_ASC_BASE + UART_RXRESET_OFFSET)
-#define UART_RETRIES_REG    (CFG_STM_ASC_BASE + UART_RETRIES_OFFSET)
+#define UART_BAUDRATE_OFFSET	0x00
+#define UART_TXBUFFER_OFFSET	0x04
+#define UART_RXBUFFER_OFFSET	0x08
+#define UART_CONTROL_OFFSET	0x0C
+#define UART_INTENABLE_OFFSET	0x10
+#define UART_STATUS_OFFSET	0x14
+#define UART_GUARDTIME_OFFSET	0x18
+#define UART_TIMEOUT_OFFSET	0x1C
+#define UART_TXRESET_OFFSET	0x20
+#define UART_RXRESET_OFFSET	0x24
+#define UART_RETRIES_OFFSET	0x28
+
+#define UART_BAUDRATE_REG	(CFG_STM_ASC_BASE + UART_BAUDRATE_OFFSET)
+#define UART_TXBUFFER_REG	(CFG_STM_ASC_BASE + UART_TXBUFFER_OFFSET)
+#define UART_RXBUFFER_REG	(CFG_STM_ASC_BASE + UART_RXBUFFER_OFFSET)
+#define UART_CONTROL_REG	(CFG_STM_ASC_BASE + UART_CONTROL_OFFSET)
+#define UART_INTENABLE_REG	(CFG_STM_ASC_BASE + UART_INTENABLE_OFFSET)
+#define UART_STATUS_REG		(CFG_STM_ASC_BASE + UART_STATUS_OFFSET)
+#define UART_GUARDTIME_REG	(CFG_STM_ASC_BASE + UART_GUARDTIME_OFFSET)
+#define UART_TIMEOUT_REG	(CFG_STM_ASC_BASE + UART_TIMEOUT_OFFSET)
+#define UART_TXRESET_REG	(CFG_STM_ASC_BASE + UART_TXRESET_OFFSET)
+#define UART_RXRESET_REG	(CFG_STM_ASC_BASE + UART_RXRESET_OFFSET)
+#define UART_RETRIES_REG	(CFG_STM_ASC_BASE + UART_RETRIES_OFFSET)
 
 
 /*---- Values for the BAUDRATE Register -----------------------*/
 
-
-#if defined(CONFIG_SH_STB7100) || defined(CONFIG_SH_STX7111) || defined(CONFIG_SH_STX7200)
+#if defined(__SH4__)
 #define PCLK			(gd->bd->bi_emifrq*1000000)
 #define BAUDRATE_VAL_M0(bps)	(PCLK / (16 * (bps)))
-#define BAUDRATE_VAL_M1(bps)    ( (((bps * (1 << 14))+ (1<<13)) / (PCLK/(1 << 6))))
-#else
+#define BAUDRATE_VAL_M1(bps)	((((bps * (1 << 14))+ (1<<13)) / (PCLK/(1 << 6))))
+#else	/* !defined(__SH4__) */
 #define PCLK			B_CLOCK_RATE
 #define BAUDRATE_VAL_M0(bps)	(PCLK / (16 * (bps)))
 #define BAUDRATE_VAL_M1(bps)	(int)((((double)bps * (1 << 20))/ PCLK)+0.5)
-#endif
+#endif	/* defined(__SH4__) */
 
 /*
  * MODE 0
@@ -104,172 +103,185 @@
  *                   baudrate * 16 * 2^16
  * ASCBaudRate =   ------------------------
  *                          ICCLK
+ *
+ * NOTE:
+ * Mode 1 should be used for baudrates of 19200, and above, as it
+ * has a lower deviation error than Mode 0 for higher frequencies.
+ * Mode 0 should be used for all baudrates below 19200.
  */
 
-#define BPS_2400	BAUDRATE_VAL_M0(2400)
-#define BPS_4800	BAUDRATE_VAL_M0(4800)
-#define BPS_9600	BAUDRATE_VAL_M0(9600)
-#define BPS_19200	BAUDRATE_VAL_M1(19200)
-#define BPS_38400	BAUDRATE_VAL_M1(38400)
-#define BPS_57600	BAUDRATE_VAL_M1(57600)
-#define BPS_96000	BAUDRATE_VAL_M1(96000)
-#define BPS_115200	BAUDRATE_VAL_M1(115200)
-
 
 #if defined(CONFIG_STM_ST231)
-
 #define p2_outl(addr,b) writel(b,addr)
 #define p2_inl(addr)    readl(addr)
-
 #endif
 
 
-/* This function should be implemented for asc driver */
-void handleError (void)
+#ifdef CONFIG_HWFLOW
+static int hwflow = 0;		/* turned off by default */
+#endif	/* CONFIG_HWFLOW */
+
+
+/* busy wait until it is safe to send a char */
+static inline void TxCharReady (void)
 {
-	return;
-}
+	unsigned long status;
 
-static int hwflow = 0;		/* turned off by default */
+	do {
+		status = p2_inl (UART_STATUS_REG);
+	} while (status & STA_TF);
+}
 
-int serial_init (void)
+/* initialize the ASC */
+extern int serial_init (void)
 {
 	DECLARE_GLOBAL_DATA_PTR;
-	int cflag = CREAD | HUPCL | CLOCAL | CSTOPB;
-	unsigned int status;
+	const int cflag = CREAD | HUPCL | CLOCAL | CSTOPB | CS8 | PARODD;
+	unsigned long val;
 	int baud = gd->baudrate;
-	int t;
-	int p2_val;
+	int t, mode=1;
+
 	switch (baud) {
+#if 0
 	case 0:
 		t = -1;
 		break;
 	case 2400:
-		t = BPS_2400;
+		t = BAUDRATE_VAL_M0(2400);
+		mode = 0;
 		break;
 	case 4800:
-		t = BPS_4800;
+		t = BAUDRATE_VAL_M0(4800);
+		mode = 0;
 		break;
+#endif
 	case 9600:
-		t = BPS_9600;
+		t = BAUDRATE_VAL_M0(9600);
+		mode = 0;
 		break;
 	case 19200:
-		t = BPS_19200;
+		t = BAUDRATE_VAL_M1(19200);
 		break;
 	case 38400:
-		t = BPS_38400;
+		t = BAUDRATE_VAL_M1(38400);
 		break;
 	case 57600:
-		t = BPS_57600;
+		t = BAUDRATE_VAL_M1(57600);
 		break;
 	default:
-		printf ("sci: unsupported baud rate: %d, using 115200 instead.\n", baud);
+		printf ("ASC: unsupported baud rate: %d, using 115200 instead.\n", baud);
 	case 115200:
-		t = BPS_115200;
+		t = BAUDRATE_VAL_M1(115200);
 		break;
 	}
 
-	cflag |= CS8;
-	cflag |= PARODD;
-
 	/* wait for end of current transmission */
-	do {
-		status = p2_inl (UART_STATUS_REG);
-	} while (status & STA_TF);
+	TxCharReady ();
 
-	p2_val = p2_inl (UART_CONTROL_REG);
-	p2_outl (UART_CONTROL_REG, (p2_val & ~RUN));
-	p2_val = RXENABLE;
+	/* disable the baudrate generator */
+	val = p2_inl (UART_CONTROL_REG);
+	p2_outl (UART_CONTROL_REG, (val & ~RUN));
+
+	/* set baud generator reload value */
+	p2_outl (UART_BAUDRATE_REG, t);
 
-	/* reset fifo rx e tx */
+	/* reset the RX & TX buffers */
 	p2_outl (UART_TXRESET_REG, 1);
 	p2_outl (UART_RXRESET_REG, 1);
 
+	/* build up the value to be written to CONTROL */
+	val = RXENABLE | RUN;
+
 	/* set character length */
 	if ((cflag & CSIZE) == CS7)
-		p2_val |= MODE_7BIT_PAR;
+		val |= MODE_7BIT_PAR;
 	else {
 		if (cflag & PARENB)
-			p2_val |= MODE_8BIT_PAR;
+			val |= MODE_8BIT_PAR;
 		else
-			p2_val |= MODE_8BIT;
+			val |= MODE_8BIT;
 	}
 
 	/* set stop bit */
 	/* it seems no '0 stop bits' option is available: by default
 	 * we get 0.5 stop bits */
 	if (cflag & CSTOPB)
-		p2_val |= STOP_1BIT;
+		val |= STOP_1BIT;
 
 	/* odd parity */
 	if (cflag & PARODD)
-		p2_val |= PARITYODD;
+		val |= PARITYODD;
 
+#ifdef CONFIG_HWFLOW
 	/*  set flow control */
 	if (hwflow)
-		p2_val |= CTSENABLE;
+		val |= CTSENABLE;
+#endif	/* CONFIG_HWFLOW */
 
-	/* set speed and baud generator mode */
-	p2_outl (UART_BAUDRATE_REG, t);
-	p2_val |= BAUDMODE;
+	/* set baud generator mode */
+	if (mode)
+		val |= BAUDMODE;
 
-	/* write final value and enable port */
-	p2_outl (UART_CONTROL_REG, (p2_val | RUN));
+	/* finally, write value and enable ASC */
+	p2_outl (UART_CONTROL_REG, val);
 	return 0;
 }
 
-int serial_tstc (void)
+/* returns TRUE if a char is available, ready to be read */
+extern int serial_tstc (void)
 {
-	unsigned short status;
+	unsigned long status;
 
 	status = p2_inl (UART_STATUS_REG);
 	return (status & STA_RBF);
 }
 
-/* This function doesn't correctly work */
-int serial_getc (void)
+/* blocking function, that returns next char */
+extern int serial_getc (void)
 {
 	char ch;
 
+	/* polling wait: for a char to be read */
 	while (!serial_tstc ());
 
+	/* read char, now that we know we have one */
 	ch = p2_inl (UART_RXBUFFER_REG);
 
+	/* return consumed char to the caller */
 	return ch;
 }
 
-static inline int putDebugCharReady (void)
-{
-	unsigned long status;
-
-	status = p2_inl (UART_STATUS_REG);
-	return !(status & STA_TF);
-}
-
-void serial_putc (char ch)
+/* write write out a single char */
+extern void serial_putc (char ch)
 {
+	/* Stream-LF to CR+LF conversion */
 	if (ch == 10)
 		serial_putc ('\r');
-	while (!putDebugCharReady ());
+
+	/* wait till safe to write next char */
+	TxCharReady ();
+
+	/* finally, write next char */
 	p2_outl (UART_TXBUFFER_REG, ch);
 }
 
-void serial_puts (const char *s)
+/* write an entire (NUL-terminated) string */
+extern void serial_puts (const char *s)
 {
 	while (*s) {
 		serial_putc (*s++);
 	}
 }
 
-
-void serial_setbrg (void)
+/* called to adjust baud-rate */
+extern void serial_setbrg (void)
 {
-
-  serial_init();
+	/* just re-initialize ASC */
+	serial_init ();
 }
 
 #ifdef CONFIG_HWFLOW
-int hwflow_onoff (int on)
+extern int hwflow_onoff (int on)
 {
 	switch (on) {
 	case 0:
@@ -286,6 +298,6 @@ int hwflow_onoff (int on)
 	}
 	return hwflow;
 }
-#endif
+#endif	/* CONFIG_HWFLOW */
 
 #endif	/* CONFIG_STM_ASC_SERIAL */
diff --git a/include/asm-sh/io.h b/include/asm-sh/io.h
index 3841851..96458d7 100644
--- a/include/asm-sh/io.h
+++ b/include/asm-sh/io.h
@@ -56,7 +56,9 @@
        defined(CONFIG_SH_HMS1)	|| \
        defined(CONFIG_SH_MB519)	|| \
        defined(CONFIG_SH_MB618)	|| \
+       defined(CONFIG_SH_MB628)	|| \
        defined(CONFIG_SH_MB671)	|| \
+       defined(CONFIG_SH_MB680)	|| \
        defined(CONFIG_SH_CB101)	|| \
        defined(CONFIG_SH_CB102)
 #  include "asm/io_stb1eval.h"
diff --git a/include/asm-sh/pio.h b/include/asm-sh/pio.h
index a2556e5..d271ed4 100644
--- a/include/asm-sh/pio.h
+++ b/include/asm-sh/pio.h
@@ -1,6 +1,7 @@
 /*
- * (C) Copyright 2005
- * Andy Stugres, STMicroelectronics, <andy.sturges@st.com>
+ * (C) Copyright STMicroelectronics 2005, 2008
+ * Andy Stugres, <andy.sturges@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -24,15 +25,15 @@
 #ifndef _PIO_H_
 #define _PIO_H_	1
 
-#define STPIO_NONPIO            0       /* Non-PIO function (ST40 defn) */
-#define STPIO_BIDIR_Z1          0       /* Input weak pull-up (arch defn) */
-#define STPIO_BIDIR             1       /* Bidirectonal open-drain */
-#define STPIO_OUT               2       /* Output push-pull */
-/*efine STPIO_BIDIR             3        * Bidirectional open drain */
-#define STPIO_IN                4       /* Input Hi-Z */
-/*efine STPIO_IN                5        * Input Hi-Z */
-#define STPIO_ALT_OUT           6       /* Alt output push-pull (arch defn) */
-#define STPIO_ALT_BIDIR         7       /* Alt bidir open drain (arch defn) */
+#define STPIO_NONPIO		0	/* Non-PIO function (ST40 defn) */
+#define STPIO_BIDIR_Z1		0	/* Input weak pull-up (arch defn) */
+#define STPIO_BIDIR		1	/* Bidirectonal open-drain */
+#define STPIO_OUT		2	/* Output push-pull */
+/*efine STPIO_BIDIR		3	* Bidirectional open drain */
+#define STPIO_IN		4	/* Input Hi-Z */
+/*efine STPIO_IN		5	* Input Hi-Z */
+#define STPIO_ALT_OUT		6	/* Alt output push-pull (arch defn) */
+#define STPIO_ALT_BIDIR		7	/* Alt bidir open drain (arch defn) */
 
 #define STPIO_POUT_OFFSET	0x00
 #define STPIO_PIN_OFFSET	0x10
@@ -45,37 +46,71 @@
 #define STPIO_SET_OFFSET	0x4
 #define STPIO_CLEAR_OFFSET	0x8
 
-#define PIO_PORT_SIZE 0x1000
+#if defined(CONFIG_SH_STB7100)
+#define PIO_PORT_SIZE		0x1000					/* QQQ - DELETE */
+#define PIO_PORT(n)		( ((n)*PIO_PORT_SIZE) + PIO_BASE)	/* QQQ - DELETE */
+#else	/* CONFIG_SH_STB7100 */
+#define PIO_PORT(n)		( ST40_PIO ## n ## _REGS_BASE )
+#endif	/* CONFIG_SH_STB7100 */
 
-#define PIO_PORT(n) (((n)*PIO_PORT_SIZE) + PIO_BASE)
+#define PIN_C0(PIN, DIR)	((((DIR) & 0x1)!=0) << (PIN))
+#define PIN_C1(PIN, DIR)	((((DIR) & 0x2)!=0) << (PIN))
+#define PIN_C2(PIN, DIR)	((((DIR) & 0x4)!=0) << (PIN))
 
-#define PIN_C0(PIN, DIR) (((DIR & 0x1)!=0) << PIN)
-#define PIN_C1(PIN, DIR) (((DIR & 0x2)!=0) << PIN)
-#define PIN_C2(PIN, DIR) (((DIR & 0x4)!=0) << PIN)
+#define CLEAR_PIN_C0(PIN, DIR)	((((DIR) & 0x1)==0) << (PIN))
+#define CLEAR_PIN_C1(PIN, DIR)	((((DIR) & 0x2)==0) << (PIN))
+#define CLEAR_PIN_C2(PIN, DIR)	((((DIR) & 0x4)==0) << (PIN))
 
-#define CLEAR_PIN_C0(PIN, DIR) (((DIR & 0x1)==0) << PIN)
-#define CLEAR_PIN_C1(PIN, DIR) (((DIR & 0x2)==0) << PIN)
-#define CLEAR_PIN_C2(PIN, DIR) (((DIR & 0x4)==0) << PIN)
+#define SET_PIO_PIN(PIO_ADDR, PIN, DIR)					\
+do {									\
+	writel(	PIN_C0((PIN),(DIR)),					\
+		(PIO_ADDR)+STPIO_PC0_OFFSET+STPIO_SET_OFFSET);		\
+	writel(	PIN_C1((PIN),(DIR)),					\
+		(PIO_ADDR)+STPIO_PC1_OFFSET+STPIO_SET_OFFSET);		\
+	writel(	PIN_C2((PIN),(DIR)),					\
+		(PIO_ADDR)+STPIO_PC2_OFFSET+STPIO_SET_OFFSET);		\
+	writel(	CLEAR_PIN_C0((PIN),(DIR)),				\
+		(PIO_ADDR)+STPIO_PC0_OFFSET+STPIO_CLEAR_OFFSET);	\
+	writel(	CLEAR_PIN_C1((PIN),(DIR)),				\
+		(PIO_ADDR)+STPIO_PC1_OFFSET+STPIO_CLEAR_OFFSET);	\
+	writel(	CLEAR_PIN_C2((PIN),(DIR)),				\
+		(PIO_ADDR)+STPIO_PC2_OFFSET+STPIO_CLEAR_OFFSET);	\
+} while (0)
 
-#define SET_PIO_PIN(PIO_ADDR, PIN, DIR) do {writel(PIN_C0(PIN,DIR),PIO_ADDR+0x24);\
-				    writel(PIN_C1(PIN,DIR),PIO_ADDR+0x34);\
-				    writel(PIN_C2(PIN,DIR),PIO_ADDR+0x44);\
-				    writel(CLEAR_PIN_C0(PIN,DIR),PIO_ADDR+0x28);\
-				    writel(CLEAR_PIN_C1(PIN,DIR),PIO_ADDR+0x38);\
-				    writel(CLEAR_PIN_C2(PIN,DIR),PIO_ADDR+0x48);} while (0)
+#define STPIO_SET_PIN(PIO_ADDR, PIN, V)				\
+do {								\
+	writel(	1<<(PIN),					\
+		(PIO_ADDR) + STPIO_POUT_OFFSET +		\
+		((V)? STPIO_SET_OFFSET : STPIO_CLEAR_OFFSET));	\
+} while (0)
+#define STPIO_GET_PIN(PORT, PIN)				\
+	((readb(PIO_PORT(PORT)+STPIO_PIN_OFFSET)>>(PIN))&0x01)
 
-#define STPIO_SET_PIN(PIO_ADDR, PIN, V) writel(1<<PIN, PIO_ADDR + STPIO_POUT_OFFSET + ((V)? STPIO_SET_OFFSET : STPIO_CLEAR_OFFSET))
-#define STPIO_GET_PIN(PORT, PIN) ((readb(PIO_PORT(PORT)+STPIO_PIN_OFFSET)>>(PIN))&0x01)
+#define SET_PIO_ASC_OUTDIR(PIO_ADDR, TX, RX, CTS, RTS, OUTDIR)	\
+do {								\
+	writel(	PIN_C0((TX),  (OUTDIR))		|		\
+		PIN_C0((RX),  STPIO_IN)		|		\
+		PIN_C0((CTS), STPIO_IN)		|		\
+		PIN_C0((RTS), (OUTDIR)),			\
+		(PIO_ADDR)+STPIO_PC0_OFFSET+STPIO_SET_OFFSET);	\
+	writel(	PIN_C1((TX),  (OUTDIR))		|		\
+		PIN_C1((RX),  STPIO_IN)		|		\
+		PIN_C1((CTS), STPIO_IN)		|		\
+		PIN_C1((RTS), (OUTDIR)),			\
+		(PIO_ADDR)+STPIO_PC1_OFFSET+STPIO_SET_OFFSET);	\
+	writel(	PIN_C2((TX),  (OUTDIR))		|		\
+		PIN_C2((RX),  STPIO_IN)		|		\
+		PIN_C2((CTS), STPIO_IN)		|		\
+		PIN_C2((RTS), (OUTDIR)),			\
+		(PIO_ADDR)+STPIO_PC2_OFFSET+STPIO_SET_OFFSET);	\
+} while (0)
 
-#define SET_PIO_ASC(PIO_ADDR, TX, RX, CTS, RTS) \
-	writel(PIN_C0(TX, STPIO_ALT_OUT) | PIN_C0(RX, STPIO_IN) | \
-	       PIN_C0(CTS, STPIO_IN) | PIN_C0(RTS, STPIO_ALT_OUT),\
-	       PIO_ADDR+0x24) ; \
-	writel(PIN_C1(TX, STPIO_ALT_OUT) | PIN_C1(RX, STPIO_IN) | \
-	       PIN_C1(CTS, STPIO_IN) | PIN_C1(RTS, STPIO_ALT_OUT),\
-	       PIO_ADDR+0x34) ; \
-	writel(PIN_C2(TX, STPIO_ALT_OUT) | PIN_C2(RX, STPIO_IN) | \
-	       PIN_C2(CTS, STPIO_IN) | PIN_C2(RTS, STPIO_ALT_OUT),\
-	       PIO_ADDR+0x44) ;
+#if defined(CONFIG_SH_STX7141)
+#define SET_PIO_ASC(PIO_ADDR, TX, RX, CTS, RTS)			\
+	SET_PIO_ASC_OUTDIR((PIO_ADDR), (TX), (RX), (CTS), (RTS), STPIO_OUT)
+#else	/* CONFIG_SH_STX7141 */
+#define SET_PIO_ASC(PIO_ADDR, TX, RX, CTS, RTS)			\
+	SET_PIO_ASC_OUTDIR((PIO_ADDR), (TX), (RX), (CTS), (RTS), STPIO_ALT_OUT)
+#endif	/* CONFIG_SH_STX7141 */
 
 #endif
diff --git a/include/asm-sh/st40reg.h b/include/asm-sh/st40reg.h
index c8798d3..796e39d 100644
--- a/include/asm-sh/st40reg.h
+++ b/include/asm-sh/st40reg.h
@@ -1,7 +1,8 @@
 /*
- * Copyright (C) STMicroelectronics Ltd. 2002, 2003, 2007.
+ * Copyright (C) STMicroelectronics Ltd. 2002, 2003, 2007, 2008
  *
  * andy.sturges@st.com
+ * Sean McGoogan <Sean.McGoogan@st.com>
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -381,7 +382,6 @@
 #define ST40_EMI_BANK5_EMICONFIGDATA1	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0248)
 #define ST40_EMI_BANK5_EMICONFIGDATA2	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0250)
 #define ST40_EMI_BANK5_EMICONFIGDATA3	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0258)
-#define ST40_EMI_BANK_ENABLE		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0280)
 
 #define ST40_EMI_BANK0_BASEADDRESS	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0800)
 #define ST40_EMI_BANK1_BASEADDRESS	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0810)
@@ -389,7 +389,7 @@
 #define ST40_EMI_BANK3_BASEADDRESS	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0830)
 #define ST40_EMI_BANK4_BASEADDRESS	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0840)
 #define ST40_EMI_BANK5_BASEADDRESS	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0850)
-#define ST40_EMI_BANKNUMBER		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0860)
+#define ST40_EMI_BANK_ENABLE		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0860)
 
 /* Peripheral Component Interconnect control registers (all ST40 variants) */
 /* PCI Local Registers */
diff --git a/include/asm-sh/stbus.h b/include/asm-sh/stbus.h
index c88a45d..f4441fe 100644
--- a/include/asm-sh/stbus.h
+++ b/include/asm-sh/stbus.h
@@ -25,17 +25,24 @@
 #ifndef __STBUS_H__
 #define __STBUS_H__
 
-/*--------------------------------------------------------------*
- * These register are described in ADCS 7801572B.
- *--------------------------------------------------------------*/
+/*
+ * This file attempts to support all the various flavours of USB wrappers,
+ * thus some of the registers appear to overlap.
+ *
+ * Some of these register are described in ADCS 7518758 and 7618754
+ */
+
 
 /* Defines for the USB controller register offsets. */
 #define AHB2STBUS_WRAPPER_GLUE_BASE	(CFG_USB_BASE + 0x00000000)
+#define AHB2STBUS_OHCI_BASE		(CFG_USB_BASE + 0x000ffc00)
+#define AHB2STBUS_EHCI_BASE		(CFG_USB_BASE + 0x000ffe00)
 #define AHB2STBUS_PROTOCOL_BASE		(CFG_USB_BASE + 0x000fff00)
 
-#if defined(CONFIG_SH_STB7000) || defined(CONFIG_SH_STX7200)
 
-/* The transaction opcode is programmed in this register. */
+/* Protocol converter registers (separate registers) */
+
+/* The transaction opcode is programmed in this register */
 #define AHB2STBUS_STBUS_OPC		(AHB2STBUS_PROTOCOL_BASE + 0x00)
 #define AHB2STBUS_STBUS_OPC_4BIT	0x00
 #define AHB2STBUS_STBUS_OPC_8BIT	0x01
@@ -53,7 +60,7 @@
 #define AHB2STBUS_MSGSIZE_32		0x5
 #define AHB2STBUS_MSGSIZE_64		0x6
 
-/* The chunk size in number of packets is programmed in this register. */
+/* The chunk size in number of packets is programmed in this register */
 #define AHB2STBUS_CHUNKSIZE		(AHB2STBUS_PROTOCOL_BASE + 0x08)
 #define AHB2STBUS_CHUNKSIZE_DISABLE	0x0
 #define AHB2STBUS_CHUNKSIZE_2		0x1
@@ -63,16 +70,30 @@
 #define AHB2STBUS_CHUNKSIZE_32		0x5
 #define AHB2STBUS_CHUNKSIZE_64		0x6
 
-#elif defined(CONFIG_SH_STX7111)
 
-/* No documentation for this */
+/* Protocol converter registers (combined register) */
+
 #define AHB2STBUS_STBUS_CONFIG		(AHB2STBUS_PROTOCOL_BASE + 0x04)
 
-#endif
 
-/* AHB Strap options are programmed in this register. */
+/* Wrapper Glue registers */
+
 #define AHB2STBUS_STRAP			(AHB2STBUS_WRAPPER_GLUE_BASE + 0x14)
 #define AHB2STBUS_STRAP_PLL		0x08	/* PLL_PWR_DWN */
-#define AHB2STBUS_STRAP_16_BIT		0x04	/* SS_WORD_IF */
+#define AHB2STBUS_STRAP_8_BIT		0x00	/* ss_word_if */
+#define AHB2STBUS_STRAP_16_BIT		0x04	/* ss_word_if */
+
+
+/* QQQ move the following to somewhere more sensible */
+#define USB_FLAGS_STRAP_8BIT			(1<<0)
+#define USB_FLAGS_STRAP_16BIT			(2<<0)
+#define USB_FLAGS_STRAP_PLL			(1<<2)
+#define USB_FLAGS_OPC_MSGSIZE_CHUNKSIZE		(1<<3)
+#define USB_FLAGS_STBUS_CONFIG_THRESHOLD128	(1<<4)
+#define USB_FLAGS_STBUS_CONFIG_THRESHOLD256	(2<<4)
+
+
+/* function to start the USB Host Controller Wrapper */
+extern int ST40_start_host_control(unsigned int flags);
 
 #endif	/* __STBUS_H__ */
diff --git a/include/asm-sh/stx7105reg.h b/include/asm-sh/stx7105reg.h
new file mode 100644
index 0000000..a1ca3d9
--- /dev/null
+++ b/include/asm-sh/stx7105reg.h
@@ -0,0 +1,373 @@
+/*
+ * Copyright (C) STMicroelectronics Ltd. 2008.
+ *
+ * All rights reserved.
+ */
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/bare/sh4reg/sti7105.h
+ */
+
+
+#ifndef __STX7105REG_H
+#define __STX7105REG_H
+
+#include "sh4regtype.h"
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Peripheral versions
+ */
+
+#ifndef ST40_LMIGP_VERSION
+#define ST40_LMIGP_VERSION 1
+#endif
+#ifndef ST40_NAND_CONTROLLER_VERSION
+#define ST40_NAND_CONTROLLER_VERSION 1
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Base addresses for control register banks.
+ */
+
+/* Generic SH4 control registers */
+#ifndef SH4_TMU_REGS_BASE
+#define SH4_TMU_REGS_BASE 0xffd80000
+#endif
+
+/* Common ST40 control registers */
+#ifndef ST40_CPG_REGS_BASE
+#define ST40_CPG_REGS_BASE 0xffc00000
+#endif
+#ifndef ST40_INTC_REGS_BASE
+#define ST40_INTC_REGS_BASE 0xffd00000
+#endif
+#ifndef ST40_SCIF2_REGS_BASE
+#define ST40_SCIF2_REGS_BASE 0xffe80000
+#endif
+
+#ifndef STX7105_COMMS_BASE
+#define STX7105_COMMS_BASE 0xfd000000
+#endif
+
+#ifndef ST40_ILC_REGS_BASE
+#define ST40_ILC_REGS_BASE STX7105_COMMS_BASE
+#endif
+
+/* STx7105 control registers */
+#ifndef STX7105_SYSCONF_REGS_BASE
+#define STX7105_SYSCONF_REGS_BASE 0xfe001000
+#endif
+
+#ifndef STX7105_CLOCKGENA_REGS_BASE
+#define STX7105_CLOCKGENA_REGS_BASE 0xfe213000
+#endif
+
+#ifndef STX7105_CLOCKGENB_REGS_BASE
+#define STX7105_CLOCKGENB_REGS_BASE 0xfe000000
+#endif
+
+/* System Architecture Volume 2: Bus Interfaces */
+#ifndef ST40_LMI_REGS_BASE
+#define ST40_LMI_REGS_BASE 0xfe901000
+#endif
+#ifndef ST40_EMI_REGS_BASE
+#define ST40_EMI_REGS_BASE 0xfe700000
+#endif
+
+/* System Architecture Volume 4: I/O Devices */
+#ifndef ST40_PIO0_REGS_BASE
+#define ST40_PIO0_REGS_BASE (STX7105_COMMS_BASE + 0x00020000)
+#endif
+#ifndef ST40_PIO1_REGS_BASE
+#define ST40_PIO1_REGS_BASE (STX7105_COMMS_BASE + 0x00021000)
+#endif
+#ifndef ST40_PIO2_REGS_BASE
+#define ST40_PIO2_REGS_BASE (STX7105_COMMS_BASE + 0x00022000)
+#endif
+#ifndef ST40_PIO3_REGS_BASE
+#define ST40_PIO3_REGS_BASE (STX7105_COMMS_BASE + 0x00023000)
+#endif
+#ifndef ST40_PIO4_REGS_BASE
+#define ST40_PIO4_REGS_BASE (STX7105_COMMS_BASE + 0x00024000)
+#endif
+#ifndef ST40_PIO5_REGS_BASE
+#define ST40_PIO5_REGS_BASE (STX7105_COMMS_BASE + 0x00025000)
+#endif
+#ifndef ST40_PIO6_REGS_BASE
+#define ST40_PIO6_REGS_BASE (STX7105_COMMS_BASE + 0x00026000)
+#endif
+#ifndef ST40_ASC0_REGS_BASE
+#define ST40_ASC0_REGS_BASE (STX7105_COMMS_BASE + 0x00030000)
+#endif
+#ifndef ST40_ASC1_REGS_BASE
+#define ST40_ASC1_REGS_BASE (STX7105_COMMS_BASE + 0x00031000)
+#endif
+#ifndef ST40_ASC2_REGS_BASE
+#define ST40_ASC2_REGS_BASE (STX7105_COMMS_BASE + 0x00032000)
+#endif
+#ifndef ST40_ASC3_REGS_BASE
+#define ST40_ASC3_REGS_BASE (STX7105_COMMS_BASE + 0x00033000)
+#endif
+#ifndef ST40_SSC0_REGS_BASE
+#define ST40_SSC0_REGS_BASE (STX7105_COMMS_BASE + 0x00040000)
+#endif
+#ifndef ST40_SSC1_REGS_BASE
+#define ST40_SSC1_REGS_BASE (STX7105_COMMS_BASE + 0x00041000)
+#endif
+#ifndef ST40_SSC2_REGS_BASE
+#define ST40_SSC2_REGS_BASE (STX7105_COMMS_BASE + 0x00042000)
+#endif
+#ifndef ST40_SSC3_REGS_BASE
+#define ST40_SSC3_REGS_BASE (STX7105_COMMS_BASE + 0x00043000)
+#endif
+#ifndef ST40_MAILBOX0_REGS_BASE
+#define ST40_MAILBOX0_REGS_BASE 0xfe211000
+#endif
+#ifndef ST40_MAILBOX1_REGS_BASE
+#define ST40_MAILBOX1_REGS_BASE (ST40_MAILBOX0_REGS_BASE + 0x1000)
+#endif
+
+#ifndef ST40_PIO7_REGS_BASE
+#define ST40_PIO7_REGS_BASE	0xfe010000
+#endif
+#ifndef ST40_PIO8_REGS_BASE
+#define ST40_PIO8_REGS_BASE	0xfe011000
+#endif
+#ifndef ST40_PIO9_REGS_BASE
+#define ST40_PIO9_REGS_BASE	0xfe012000
+#endif
+#ifndef ST40_PIO10_REGS_BASE
+#define ST40_PIO10_REGS_BASE	0xfe013000
+#endif
+#ifndef ST40_PIO11_REGS_BASE
+#define ST40_PIO11_REGS_BASE	0xfe014000
+#endif
+#ifndef ST40_PIO12_REGS_BASE
+#define ST40_PIO12_REGS_BASE	0xfe015000
+#endif
+#ifndef ST40_PIO13_REGS_BASE
+#define ST40_PIO13_REGS_BASE	0xfe016000
+#endif
+#ifndef ST40_PIO14_REGS_BASE
+#define ST40_PIO14_REGS_BASE	0xfe017000
+#endif
+#ifndef ST40_PIO15_REGS_BASE
+#define ST40_PIO15_REGS_BASE	0xfe018000
+#endif
+#ifndef ST40_PIO16_REGS_BASE
+#define ST40_PIO16_REGS_BASE	0xfe019000
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+#include "st40reg.h"
+
+/*
+ * STx7105 control registers
+ */
+
+/* Clock Generator control registers (STx7105 variant) */
+#define STX7105_CLOCKGENA_PLL0_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x00)
+#define STX7105_CLOCKGENA_PLL1_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x04)
+#define STX7105_CLOCKGENA_POWER_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x10)
+#define STX7105_CLOCKGENA_CLKOPSRC_SWITCH_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x14)
+#define STX7105_CLOCKGENA_OSC_ENABLE_FB		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x18)
+#define STX7105_CLOCKGENA_PLL0_ENABLE_FB	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x1c)
+#define STX7105_CLOCKGENA_PLL1_ENABLE_FB	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x20)
+#define STX7105_CLOCKGENA_CLKOPSRC_SWITCH_CFG2	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x24)
+#define STX7105_CLOCKGENA_CLKOBS_MUX1_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x30)
+#define STX7105_CLOCKGENA_CLKOBS_MASTER_MAXCOUNT SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x34)
+#define STX7105_CLOCKGENA_CLKOBS_CMD		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x38)
+#define STX7105_CLOCKGENA_CLKOBS_STATUS		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x3c)
+#define STX7105_CLOCKGENA_CLKOBS_SLAVE0_COUNT	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x40)
+#define STX7105_CLOCKGENA_CLKOBS_OSCMUX_DEBUG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x44)
+#define STX7105_CLOCKGENA_CLKOBS_MUX2_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x48)
+#define STX7105_CLOCKGENA_LOW_POWER_CTRL	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x4c)
+#define STX7105_CLOCKGENA_OSC_DIV0_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x800)
+#define STX7105_CLOCKGENA_OSC_DIV1_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x804)
+#define STX7105_CLOCKGENA_OSC_DIV2_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x808)
+#define STX7105_CLOCKGENA_OSC_DIV3_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x80c)
+#define STX7105_CLOCKGENA_OSC_DIV4_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x810)
+#define STX7105_CLOCKGENA_OSC_DIV5_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x814)
+#define STX7105_CLOCKGENA_OSC_DIV6_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x818)
+#define STX7105_CLOCKGENA_OSC_DIV7_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x81c)
+#define STX7105_CLOCKGENA_OSC_DIV8_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x820)
+#define STX7105_CLOCKGENA_OSC_DIV9_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x824)
+#define STX7105_CLOCKGENA_OSC_DIV10_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x828)
+#define STX7105_CLOCKGENA_OSC_DIV11_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x82c)
+#define STX7105_CLOCKGENA_OSC_DIV12_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x830)
+#define STX7105_CLOCKGENA_OSC_DIV13_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x834)
+#define STX7105_CLOCKGENA_OSC_DIV14_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x838)
+#define STX7105_CLOCKGENA_OSC_DIV15_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x83c)
+#define STX7105_CLOCKGENA_OSC_DIV16_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x840)
+#define STX7105_CLOCKGENA_OSC_DIV17_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x844)
+#define STX7105_CLOCKGENA_PLL0HS_DIV0_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x900)
+#define STX7105_CLOCKGENA_PLL0HS_DIV1_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x904)
+#define STX7105_CLOCKGENA_PLL0HS_DIV2_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x908)
+#define STX7105_CLOCKGENA_PLL0HS_DIV3_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x90c)
+#define STX7105_CLOCKGENA_PLL0LS_DIV4_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa10)
+#define STX7105_CLOCKGENA_PLL0LS_DIV5_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa14)
+#define STX7105_CLOCKGENA_PLL0LS_DIV6_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa18)
+#define STX7105_CLOCKGENA_PLL0LS_DIV7_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa1c)
+#define STX7105_CLOCKGENA_PLL0LS_DIV8_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa20)
+#define STX7105_CLOCKGENA_PLL0LS_DIV9_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa24)
+#define STX7105_CLOCKGENA_PLL0LS_DIV10_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa28)
+#define STX7105_CLOCKGENA_PLL0LS_DIV11_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa2c)
+#define STX7105_CLOCKGENA_PLL0LS_DIV12_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa30)
+#define STX7105_CLOCKGENA_PLL0LS_DIV13_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa34)
+#define STX7105_CLOCKGENA_PLL0LS_DIV14_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa38)
+#define STX7105_CLOCKGENA_PLL0LS_DIV15_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa3c0)
+#define STX7105_CLOCKGENA_PLL0LS_DIV16_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa40)
+#define STX7105_CLOCKGENA_PLL0LS_DIV17_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa44)
+#define STX7105_CLOCKGENA_PLL1_DIV0_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb00)
+#define STX7105_CLOCKGENA_PLL1_DIV1_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb04)
+#define STX7105_CLOCKGENA_PLL1_DIV2_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb08)
+#define STX7105_CLOCKGENA_PLL1_DIV3_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb0c)
+#define STX7105_CLOCKGENA_PLL1_DIV4_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb10)
+#define STX7105_CLOCKGENA_PLL1_DIV5_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb14)
+#define STX7105_CLOCKGENA_PLL1_DIV6_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb18)
+#define STX7105_CLOCKGENA_PLL1_DIV7_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb1c)
+#define STX7105_CLOCKGENA_PLL1_DIV8_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb20)
+#define STX7105_CLOCKGENA_PLL1_DIV9_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb24)
+#define STX7105_CLOCKGENA_PLL1_DIV10_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb28)
+#define STX7105_CLOCKGENA_PLL1_DIV11_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb2c)
+#define STX7105_CLOCKGENA_PLL1_DIV12_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb30)
+#define STX7105_CLOCKGENA_PLL1_DIV13_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb34)
+#define STX7105_CLOCKGENA_PLL1_DIV14_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb38)
+#define STX7105_CLOCKGENA_PLL1_DIV15_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb3c)
+#define STX7105_CLOCKGENA_PLL1_DIV16_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb40)
+#define STX7105_CLOCKGENA_PLL1_DIV17_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb44)
+
+#define STX7105_CLOCKGENB_LOCK			SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x10)
+#define STX7105_CLOCKGENB_FS0_CTRL		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x14)
+#define STX7105_CLOCKGENB_FS0_MD1		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x18)
+#define STX7105_CLOCKGENB_FS0_PE1		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x1c)
+#define STX7105_CLOCKGENB_FS0_EN_PRG1		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x20)
+#define STX7105_CLOCKGENB_FS0_SDIV1		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x24)
+#define STX7105_CLOCKGENB_FS0_MD2		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x28)
+#define STX7105_CLOCKGENB_FS0_PE2		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x2c)
+#define STX7105_CLOCKGENB_FS0_EN_PRG2		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x30)
+#define STX7105_CLOCKGENB_FS0_SDIV2		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x34)
+#define STX7105_CLOCKGENB_FS0_MD3		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x38)
+#define STX7105_CLOCKGENB_FS0_PE3		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x3c)
+#define STX7105_CLOCKGENB_FS0_EN_PRG3		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x40)
+#define STX7105_CLOCKGENB_FS0_SDIV3		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x44)
+#define STX7105_CLOCKGENB_FS0_CLOCKOUT_CTRL	SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x58)
+#define STX7105_CLOCKGENB_FS1_CTRL		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x5c)
+#define STX7105_CLOCKGENB_FS1_MD1		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x60)
+#define STX7105_CLOCKGENB_FS1_PE1		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x64)
+#define STX7105_CLOCKGENB_FS1_EN_PRG1		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x68)
+#define STX7105_CLOCKGENB_FS1_SDIV1		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x6c)
+#define STX7105_CLOCKGENB_FS1_MD2		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x70)
+#define STX7105_CLOCKGENB_FS1_PE2		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x74)
+#define STX7105_CLOCKGENB_FS1_EN_PRG2		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x78)
+#define STX7105_CLOCKGENB_FS1_SDIV2		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x7c)
+#define STX7105_CLOCKGENB_FS1_MD3		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x80)
+#define STX7105_CLOCKGENB_FS1_PE3		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x84)
+#define STX7105_CLOCKGENB_FS1_EN_PRG3		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x88)
+#define STX7105_CLOCKGENB_FS1_SDIV3		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x8c)
+#define STX7105_CLOCKGENB_FS1_MD4		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x90)
+#define STX7105_CLOCKGENB_FS1_PE4		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x94)
+#define STX7105_CLOCKGENB_FS1_EN_PRG4		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x98)
+#define STX7105_CLOCKGENB_FS1_SDIV4		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x9c)
+#define STX7105_CLOCKGENB_FS1_CLOCKOUT_CTRL	SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0xa0)
+#define STX7105_CLOCKGENB_DISPLAY_CFG		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0xa4)
+#define STX7105_CLOCKGENB_FS_SELECT		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0xa8)
+#define STX7105_CLOCKGENB_POWER_DOWN		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0xac)
+#define STX7105_CLOCKGENB_POWER_ENABLE		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0xb0)
+#define STX7105_CLOCKGENB_OUT_CTRL		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0xb4)
+#define STX7105_CLOCKGENB_CRYSTAL_SEL		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0xb8)
+
+/* System configuration registers (STx7105 variant) */
+#define STX7105_SYSCONF_DEVICEID_0		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0000)
+#define STX7105_SYSCONF_DEVICEID_1		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0004)
+#define STX7105_SYSCONF_DEVICEID		SH4_GWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0000)
+#define STX7105_SYSCONF_SYS_STA00		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0008)
+#define STX7105_SYSCONF_SYS_STA01		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x000c)
+#define STX7105_SYSCONF_SYS_STA02		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0010)
+#define STX7105_SYSCONF_SYS_STA03		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0014)
+#define STX7105_SYSCONF_SYS_STA04		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0018)
+#define STX7105_SYSCONF_SYS_STA05		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x001c)
+#define STX7105_SYSCONF_SYS_STA06		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0020)
+#define STX7105_SYSCONF_SYS_STA07		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0024)
+#define STX7105_SYSCONF_SYS_STA08		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0028)
+#define STX7105_SYSCONF_SYS_STA09		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x002c)
+#define STX7105_SYSCONF_SYS_STA10		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0030)
+#define STX7105_SYSCONF_SYS_STA11		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0034)
+#define STX7105_SYSCONF_SYS_STA12		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0038)
+#define STX7105_SYSCONF_SYS_STA13		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x003c)
+#define STX7105_SYSCONF_SYS_STA14		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0040)
+#define STX7105_SYSCONF_SYS_STA15		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0044)
+#define STX7105_SYSCONF_SYS_CFG00		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0100)
+#define STX7105_SYSCONF_SYS_CFG01		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0104)
+#define STX7105_SYSCONF_SYS_CFG02		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0108)
+#define STX7105_SYSCONF_SYS_CFG03		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x010c)
+#define STX7105_SYSCONF_SYS_CFG04		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0110)
+#define STX7105_SYSCONF_SYS_CFG05		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0114)
+#define STX7105_SYSCONF_SYS_CFG06		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0118)
+#define STX7105_SYSCONF_SYS_CFG07		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x011c)
+#define STX7105_SYSCONF_SYS_CFG08		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0120)
+#define STX7105_SYSCONF_SYS_CFG09		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0124)
+#define STX7105_SYSCONF_SYS_CFG10		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0128)
+#define STX7105_SYSCONF_SYS_CFG11		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x012c)
+#define STX7105_SYSCONF_SYS_CFG12		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0130)
+#define STX7105_SYSCONF_SYS_CFG13		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0134)
+#define STX7105_SYSCONF_SYS_CFG14		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0138)
+#define STX7105_SYSCONF_SYS_CFG15		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x013c)
+#define STX7105_SYSCONF_SYS_CFG16		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0140)
+#define STX7105_SYSCONF_SYS_CFG17		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0144)
+#define STX7105_SYSCONF_SYS_CFG18		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0148)
+#define STX7105_SYSCONF_SYS_CFG19		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x014c)
+#define STX7105_SYSCONF_SYS_CFG20		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0150)
+#define STX7105_SYSCONF_SYS_CFG21		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0154)
+#define STX7105_SYSCONF_SYS_CFG22		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0158)
+#define STX7105_SYSCONF_SYS_CFG23		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x015c)
+#define STX7105_SYSCONF_SYS_CFG24		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0160)
+#define STX7105_SYSCONF_SYS_CFG25		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0164)
+#define STX7105_SYSCONF_SYS_CFG26		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0168)
+#define STX7105_SYSCONF_SYS_CFG27		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x016c)
+#define STX7105_SYSCONF_SYS_CFG28		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0170)
+#define STX7105_SYSCONF_SYS_CFG29		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0174)
+#define STX7105_SYSCONF_SYS_CFG30		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0178)
+#define STX7105_SYSCONF_SYS_CFG31		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x017c)
+#define STX7105_SYSCONF_SYS_CFG32		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0180)
+#define STX7105_SYSCONF_SYS_CFG33		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0184)
+#define STX7105_SYSCONF_SYS_CFG34		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0188)
+#define STX7105_SYSCONF_SYS_CFG35		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x018c)
+#define STX7105_SYSCONF_SYS_CFG36		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0190)
+#define STX7105_SYSCONF_SYS_CFG37		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0194)
+#define STX7105_SYSCONF_SYS_CFG38		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0198)
+#define STX7105_SYSCONF_SYS_CFG39		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x019c)
+#define STX7105_SYSCONF_SYS_CFG40		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01a0)
+#define STX7105_SYSCONF_SYS_CFG41		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01a4)
+#define STX7105_SYSCONF_SYS_CFG42		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01a8)
+#define STX7105_SYSCONF_SYS_CFG43		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01ac)
+#define STX7105_SYSCONF_SYS_CFG44		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01b0)
+#define STX7105_SYSCONF_SYS_CFG45		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01b4)
+#define STX7105_SYSCONF_SYS_CFG46		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01b8)
+#define STX7105_SYSCONF_SYS_CFG47		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01bc)
+#define STX7105_SYSCONF_SYS_CFG48		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01c0)
+#define STX7105_SYSCONF_SYS_CFG49		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01c4)
+#define STX7105_SYSCONF_SYS_CFG50		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01c8)
+#define STX7105_SYSCONF_SYS_CFG51		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01cc)
+#define STX7105_SYSCONF_SYS_CFG52		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01d0)
+#define STX7105_SYSCONF_SYS_CFG53		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01d4)
+#define STX7105_SYSCONF_SYS_CFG54		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01d8)
+#define STX7105_SYSCONF_SYS_CFG55		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01dc)
+
+/* Device ID values, masks & predicates */
+#define STX7105_DEVID_7105_VAL		0x03E
+#define STX7105_DEVID_ID_SHIFT		12
+#define STX7105_DEVID_ID_MASK		0x3ff
+#define STX7105_DEVID_CUT_SHIFT		28
+#define STX7105_DEVID_CUT_MASK		0xf
+
+#define STX7105_DEVICEID_7105(ID) ((((ID) >> STX7105_DEVID_ID_SHIFT) & STX7105_DEVID_ID_MASK) == STX7105_DEVID_7105_VAL)
+#define STX7105_DEVICEID_CUT(ID)  ((((ID) >> STX7105_DEVID_CUT_SHIFT) & STX7105_DEVID_CUT_MASK) + 1)
+
+#endif /* __STX7105REG_H */
diff --git a/include/asm-sh/stx7141reg.h b/include/asm-sh/stx7141reg.h
new file mode 100644
index 0000000..ed5dc1f
--- /dev/null
+++ b/include/asm-sh/stx7141reg.h
@@ -0,0 +1,377 @@
+/*
+ * Copyright (C) STMicroelectronics Ltd. 2008.
+ *
+ * All rights reserved.
+ */
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/bare/sh4reg/sti7141reg.h
+ */
+
+
+#ifndef __STX7141REG_H
+#define __STX7141REG_H
+
+#include "sh4regtype.h"
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Peripheral versions
+ */
+
+#ifndef ST40_LMIGP_VERSION
+#define ST40_LMIGP_VERSION 1
+#endif
+#ifndef ST40_NAND_CONTROLLER_VERSION
+#define ST40_NAND_CONTROLLER_VERSION 1
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Base addresses for control register banks.
+ */
+
+/* Generic SH4 control registers */
+#ifndef SH4_TMU_REGS_BASE
+#define SH4_TMU_REGS_BASE 0xffd80000
+#endif
+
+/* Common ST40 control registers */
+#ifndef ST40_CPG_REGS_BASE
+#define ST40_CPG_REGS_BASE 0xffc00000
+#endif
+#ifndef ST40_INTC_REGS_BASE
+#define ST40_INTC_REGS_BASE 0xffd00000
+#endif
+#ifndef ST40_SCIF2_REGS_BASE
+#define ST40_SCIF2_REGS_BASE 0xffe80000
+#endif
+
+#ifndef STX7141_COMMS_BASE
+#define STX7141_COMMS_BASE 0xfd000000
+#endif
+
+/* This is the COMMS ILC */
+#ifndef ST40_ILC_REGS_BASE
+#define ST40_ILC_REGS_BASE STX7141_COMMS_BASE
+#endif
+
+/*
+ * The STx7141 has two further ILC3's which we access in a similar way, but
+ * specify the ILC index first.
+ */
+#define STX7141_ILC_INPUT_INTERRUPT(n, m)	SH4_DWORD_REG(STX7141_ILC##n##_REGS_BASE + (0x0080 + ((m) * 4)))
+#define STX7141_ILC_STATUS(n, m)		SH4_DWORD_REG(STX7141_ILC##n##_REGS_BASE + (0x0200 + ((m) * 4)))
+#define STX7141_ILC_CLEAR_STATUS(n, m)		SH4_DWORD_REG(STX7141_ILC##n##_REGS_BASE + (0x0280 + ((m) * 4)))
+#define STX7141_ILC_ENABLE(n, m)		SH4_DWORD_REG(STX7141_ILC##n##_REGS_BASE + (0x0400 + ((m) * 4)))
+#define STX7141_ILC_CLEAR_ENABLE(n, m)		SH4_DWORD_REG(STX7141_ILC##n##_REGS_BASE + (0x0480 + ((m) * 4)))
+#define STX7141_ILC_SET_ENABLE(n, m)		SH4_DWORD_REG(STX7141_ILC##n##_REGS_BASE + (0x0500 + ((m) * 4)))
+#define STX7141_ILC_WAKEUP_ENABLE(n, m)		SH4_DWORD_REG(STX7141_ILC##n##_REGS_BASE + (0x0600 + ((m) * 4)))
+#define STX7141_ILC_WAKEUP_ACTIVE_LEVEL(n, m)	SH4_DWORD_REG(STX7141_ILC##n##_REGS_BASE + (0x0680 + ((m) * 4)))
+
+/* eSTB ST40 ILC */
+#ifndef STX7141_ILC0_REGS_BASE
+#define STX7141_ILC0_REGS_BASE 0xfd120000
+#endif
+
+/* eCM ST40 ILC */
+#ifndef STX7141_ILC1_REGS_BASE
+#define STX7141_ILC1_REGS_BASE 0xfd122000
+#endif
+
+#ifdef __STX7141_ECM__
+/* The eCM has an INTC2 */
+#ifndef ST40_INTC2_REGS_BASE
+#define ST40_INTC2_REGS_BASE 0xfd124000
+#endif
+#endif
+
+/* STx7141 control registers */
+#ifndef STX7141_SYSCONF_REGS_BASE
+#define STX7141_SYSCONF_REGS_BASE 0xfe001000
+#endif
+
+#ifndef STX7141_CLOCKGENA_REGS_BASE
+#define STX7141_CLOCKGENA_REGS_BASE 0xfe213000
+#endif
+
+#ifndef STX7141_CLOCKGENB_REGS_BASE
+#define STX7141_CLOCKGENB_REGS_BASE 0xfe000000
+#endif
+
+/* System Architecture Volume 2: Bus Interfaces */
+#ifndef ST40_LMI0_REGS_BASE
+#define ST40_LMI0_REGS_BASE 0xfe901000
+#endif
+#ifndef ST40_LMI1_REGS_BASE
+#define ST40_LMI1_REGS_BASE 0xfe902000
+#endif
+#ifndef ST40_EMI_REGS_BASE
+#define ST40_EMI_REGS_BASE 0xfe700000
+#endif
+
+/* System Architecture Volume 4: I/O Devices */
+#ifndef ST40_PIO1_REGS_BASE
+#define ST40_PIO1_REGS_BASE (STX7141_COMMS_BASE + 0x00020000)
+#endif
+#ifndef ST40_PIO2_REGS_BASE
+#define ST40_PIO2_REGS_BASE (STX7141_COMMS_BASE + 0x00021000)
+#endif
+#ifndef ST40_PIO3_REGS_BASE
+#define ST40_PIO3_REGS_BASE (STX7141_COMMS_BASE + 0x00022000)
+#endif
+#ifndef ST40_PIO4_REGS_BASE
+#define ST40_PIO4_REGS_BASE (STX7141_COMMS_BASE + 0x00023000)
+#endif
+#ifndef ST40_PIO5_REGS_BASE
+#define ST40_PIO5_REGS_BASE (STX7141_COMMS_BASE + 0x00024000)
+#endif
+#ifndef ST40_PIO6_REGS_BASE
+#define ST40_PIO6_REGS_BASE (STX7141_COMMS_BASE + 0x00025000)
+#endif
+#ifndef ST40_PIO7_REGS_BASE
+#define ST40_PIO7_REGS_BASE (STX7141_COMMS_BASE + 0x00026000)
+#endif
+
+/* The STx7141 also has a bank of stand-alone bank of PIOs */
+#ifndef STX7141_T1_PIO_REGS_BASE
+#define STX7141_T1_PIO_REGS_BASE 0xfe010000
+#endif
+
+#ifndef ST40_PIO8_REGS_BASE
+#define ST40_PIO8_REGS_BASE STX7141_T1_PIO_REGS_BASE
+#endif
+#ifndef ST40_PIO9_REGS_BASE
+#define ST40_PIO9_REGS_BASE (STX7141_T1_PIO_REGS_BASE + 0x00001000)
+#endif
+#ifndef ST40_PIO10_REGS_BASE
+#define ST40_PIO10_REGS_BASE (STX7141_T1_PIO_REGS_BASE + 0x00002000)
+#endif
+#ifndef ST40_PIO11_REGS_BASE
+#define ST40_PIO11_REGS_BASE (STX7141_T1_PIO_REGS_BASE + 0x00003000)
+#endif
+#ifndef ST40_PIO12_REGS_BASE
+#define ST40_PIO12_REGS_BASE (STX7141_T1_PIO_REGS_BASE + 0x00004000)
+#endif
+#ifndef ST40_PIO13_REGS_BASE
+#define ST40_PIO13_REGS_BASE (STX7141_T1_PIO_REGS_BASE + 0x00005000)
+#endif
+#ifndef ST40_PIO14_REGS_BASE
+#define ST40_PIO14_REGS_BASE (STX7141_T1_PIO_REGS_BASE + 0x00006000)
+#endif
+#ifndef ST40_PIO15_REGS_BASE
+#define ST40_PIO15_REGS_BASE (STX7141_T1_PIO_REGS_BASE + 0x00007000)
+#endif
+#ifndef ST40_PIO16_REGS_BASE
+#define ST40_PIO16_REGS_BASE (STX7141_T1_PIO_REGS_BASE + 0x00008000)
+#endif
+
+#ifndef ST40_ASC0_REGS_BASE
+#define ST40_ASC0_REGS_BASE (STX7141_COMMS_BASE + 0x00030000)
+#endif
+#ifndef ST40_ASC1_REGS_BASE
+#define ST40_ASC1_REGS_BASE (STX7141_COMMS_BASE + 0x00031000)
+#endif
+#ifndef ST40_ASC2_REGS_BASE
+#define ST40_ASC2_REGS_BASE (STX7141_COMMS_BASE + 0x00032000)
+#endif
+#ifndef ST40_MAILBOX0_REGS_BASE
+#define ST40_MAILBOX0_REGS_BASE 0xfe211000
+#endif
+#ifndef ST40_MAILBOX1_REGS_BASE
+#define ST40_MAILBOX1_REGS_BASE (ST40_MAILBOX0_REGS_BASE + 0x1000)
+#endif
+#ifndef ST40_MAILBOX2_REGS_BASE
+#define ST40_MAILBOX2_REGS_BASE (ST40_MAILBOX0_REGS_BASE + 0x0800)
+#endif
+#ifndef ST40_MAILBOX3_REGS_BASE
+#define ST40_MAILBOX3_REGS_BASE (ST40_MAILBOX0_REGS_BASE + 0x1800)
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+#include "st40reg.h"
+
+/*
+ * STx7141 control registers
+ */
+
+/* Clock Generator control registers (STx7141 variant) */
+#define STX7141_CLOCKGENA_PLL0_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x00)
+#define STX7141_CLOCKGENA_PLL1_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x04)
+#define STX7141_CLOCKGENA_POWER_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x10)
+#define STX7141_CLOCKGENA_CLKOPSRC_SWITCH_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x14)
+#define STX7141_CLOCKGENA_OSC_ENABLE_FB		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x18)
+#define STX7141_CLOCKGENA_PLL0_ENABLE_FB	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x1c)
+#define STX7141_CLOCKGENA_PLL1_ENABLE_FB	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x20)
+#define STX7141_CLOCKGENA_CLKOPSRC_SWITCH_CFG2	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x24)
+#define STX7141_CLOCKGENA_CLKOBS_MUX1_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x30)
+#define STX7141_CLOCKGENA_CLKOBS_MASTER_MAXCOUNT SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x34)
+#define STX7141_CLOCKGENA_CLKOBS_CMD		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x38)
+#define STX7141_CLOCKGENA_CLKOBS_STATUS		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x3c)
+#define STX7141_CLOCKGENA_CLKOBS_SLAVE0_COUNT	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x40)
+#define STX7141_CLOCKGENA_CLKOBS_OSCMUX_DEBUG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x44)
+#define STX7141_CLOCKGENA_CLKOBS_MUX2_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x48)
+#define STX7141_CLOCKGENA_LOW_POWER_CTRL	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x4c)
+#define STX7141_CLOCKGENA_OSC_DIV0_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x800)
+#define STX7141_CLOCKGENA_OSC_DIV1_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x804)
+#define STX7141_CLOCKGENA_OSC_DIV2_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x808)
+#define STX7141_CLOCKGENA_OSC_DIV3_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x80c)
+#define STX7141_CLOCKGENA_OSC_DIV4_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x810)
+#define STX7141_CLOCKGENA_OSC_DIV5_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x814)
+#define STX7141_CLOCKGENA_OSC_DIV6_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x818)
+#define STX7141_CLOCKGENA_OSC_DIV7_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x81c)
+#define STX7141_CLOCKGENA_OSC_DIV8_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x820)
+#define STX7141_CLOCKGENA_OSC_DIV9_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x824)
+#define STX7141_CLOCKGENA_OSC_DIV10_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x828)
+#define STX7141_CLOCKGENA_OSC_DIV11_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x82c)
+#define STX7141_CLOCKGENA_OSC_DIV12_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x830)
+#define STX7141_CLOCKGENA_OSC_DIV13_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x834)
+#define STX7141_CLOCKGENA_OSC_DIV14_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x838)
+#define STX7141_CLOCKGENA_OSC_DIV15_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x83c)
+#define STX7141_CLOCKGENA_OSC_DIV16_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x840)
+#define STX7141_CLOCKGENA_OSC_DIV17_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x844)
+#define STX7141_CLOCKGENA_PLL0HS_DIV0_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x900)
+#define STX7141_CLOCKGENA_PLL0HS_DIV1_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x904)
+#define STX7141_CLOCKGENA_PLL0HS_DIV2_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x908)
+#define STX7141_CLOCKGENA_PLL0HS_DIV3_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x90c)
+#define STX7141_CLOCKGENA_PLL0LS_DIV4_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa10)
+#define STX7141_CLOCKGENA_PLL0LS_DIV5_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa14)
+#define STX7141_CLOCKGENA_PLL0LS_DIV6_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa18)
+#define STX7141_CLOCKGENA_PLL0LS_DIV7_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa1c)
+#define STX7141_CLOCKGENA_PLL0LS_DIV8_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa20)
+#define STX7141_CLOCKGENA_PLL0LS_DIV9_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa24)
+#define STX7141_CLOCKGENA_PLL0LS_DIV10_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa28)
+#define STX7141_CLOCKGENA_PLL0LS_DIV11_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa2c)
+#define STX7141_CLOCKGENA_PLL0LS_DIV12_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa30)
+#define STX7141_CLOCKGENA_PLL0LS_DIV13_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa34)
+#define STX7141_CLOCKGENA_PLL0LS_DIV14_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa38)
+#define STX7141_CLOCKGENA_PLL0LS_DIV15_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa3c)
+#define STX7141_CLOCKGENA_PLL0LS_DIV16_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa40)
+#define STX7141_CLOCKGENA_PLL0LS_DIV17_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa44)
+#define STX7141_CLOCKGENA_PLL1_DIV0_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb00)
+#define STX7141_CLOCKGENA_PLL1_DIV1_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb04)
+#define STX7141_CLOCKGENA_PLL1_DIV2_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb08)
+#define STX7141_CLOCKGENA_PLL1_DIV3_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb0c)
+#define STX7141_CLOCKGENA_PLL1_DIV4_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb10)
+#define STX7141_CLOCKGENA_PLL1_DIV5_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb14)
+#define STX7141_CLOCKGENA_PLL1_DIV6_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb18)
+#define STX7141_CLOCKGENA_PLL1_DIV7_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb1c)
+#define STX7141_CLOCKGENA_PLL1_DIV8_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb20)
+#define STX7141_CLOCKGENA_PLL1_DIV9_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb24)
+#define STX7141_CLOCKGENA_PLL1_DIV10_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb28)
+#define STX7141_CLOCKGENA_PLL1_DIV11_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb2c)
+#define STX7141_CLOCKGENA_PLL1_DIV12_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb30)
+#define STX7141_CLOCKGENA_PLL1_DIV13_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb34)
+#define STX7141_CLOCKGENA_PLL1_DIV14_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb38)
+#define STX7141_CLOCKGENA_PLL1_DIV15_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb3c)
+#define STX7141_CLOCKGENA_PLL1_DIV16_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb40)
+#define STX7141_CLOCKGENA_PLL1_DIV17_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb44)
+#define STX7141_CLOCKGENA_PLL0_BIST_REFCOUNT	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf00)
+#define STX7141_CLOCKGENA_PLL0_BIST_CMPCOUNT	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf04)
+#define STX7141_CLOCKGENA_PLL0_BIST_CONFIG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf08)
+#define STX7141_CLOCKGENA_PLL0_BIST_OUTCOUNT	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf0c)
+#define STX7141_CLOCKGENA_PLL1_BIST_REFCOUNT	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf10)
+#define STX7141_CLOCKGENA_PLL1_BIST_CMPCOUNT	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf14)
+#define STX7141_CLOCKGENA_PLL1_BIST_CONFIG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf18)
+#define STX7141_CLOCKGENA_PLL1_BIST_OUTCOUNT	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf1c)
+#define STX7141_CLOCKGENA_JITTERBIST_PAT	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf20)
+#define STX7141_CLOCKGENA_JITTERBIST_CMD	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf24)
+#define STX7141_CLOCKGENA_JITTERBIST_CPT_PAT	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf28)
+#define STX7141_CLOCKGENA_JITTERBIST_CPT_NOT_PAT SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf2c)
+#define STX7141_CLOCKGENA_JITTERBIST_BEAT_COUNT	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf30)
+#define STX7141_CLOCKGENA_JITTERBIST_BEAT_EDGE	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf34)
+#define STX7141_CLOCKGENA_BIST_BENDBAD		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xff8)
+#define STX7141_CLOCKGENA_BIST_SELECT		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xffc)
+
+/* System configuration registers (STx7141 variant) */
+#define STX7141_SYSCONF_DEVICEID_0		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0000)
+#define STX7141_SYSCONF_DEVICEID_1		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0004)
+#define STX7141_SYSCONF_DEVICEID		SH4_GWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0000)
+#define STX7141_SYSCONF_SYS_STA00		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0008)
+#define STX7141_SYSCONF_SYS_STA01		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x000c)
+#define STX7141_SYSCONF_SYS_STA02		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0010)
+#define STX7141_SYSCONF_SYS_STA03		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0014)
+#define STX7141_SYSCONF_SYS_STA04		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0018)
+#define STX7141_SYSCONF_SYS_STA05		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x001c)
+#define STX7141_SYSCONF_SYS_STA06		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0020)
+#define STX7141_SYSCONF_SYS_STA07		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0024)
+#define STX7141_SYSCONF_SYS_STA08		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0028)
+#define STX7141_SYSCONF_SYS_STA09		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x002c)
+#define STX7141_SYSCONF_SYS_STA10		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0030)
+#define STX7141_SYSCONF_SYS_STA11		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0034)
+#define STX7141_SYSCONF_SYS_STA12		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0038)
+#define STX7141_SYSCONF_SYS_STA13		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x003c)
+#define STX7141_SYSCONF_SYS_STA14		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0040)
+#define STX7141_SYSCONF_SYS_STA15		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0044)
+#define STX7141_SYSCONF_SYS_CFG00		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0100)
+#define STX7141_SYSCONF_SYS_CFG01		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0104)
+#define STX7141_SYSCONF_SYS_CFG02		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0108)
+#define STX7141_SYSCONF_SYS_CFG03		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x010c)
+#define STX7141_SYSCONF_SYS_CFG04		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0110)
+#define STX7141_SYSCONF_SYS_CFG05		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0114)
+#define STX7141_SYSCONF_SYS_CFG06		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0118)
+#define STX7141_SYSCONF_SYS_CFG07		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x011c)
+#define STX7141_SYSCONF_SYS_CFG08		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0120)
+#define STX7141_SYSCONF_SYS_CFG09		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0124)
+#define STX7141_SYSCONF_SYS_CFG10		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0128)
+#define STX7141_SYSCONF_SYS_CFG11		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x012c)
+#define STX7141_SYSCONF_SYS_CFG12		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0130)
+#define STX7141_SYSCONF_SYS_CFG13		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0134)
+#define STX7141_SYSCONF_SYS_CFG14		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0138)
+#define STX7141_SYSCONF_SYS_CFG15		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x013c)
+#define STX7141_SYSCONF_SYS_CFG16		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0140)
+#define STX7141_SYSCONF_SYS_CFG17		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0144)
+#define STX7141_SYSCONF_SYS_CFG18		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0148)
+#define STX7141_SYSCONF_SYS_CFG19		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x014c)
+#define STX7141_SYSCONF_SYS_CFG20		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0150)
+#define STX7141_SYSCONF_SYS_CFG21		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0154)
+#define STX7141_SYSCONF_SYS_CFG22		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0158)
+#define STX7141_SYSCONF_SYS_CFG23		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x015c)
+#define STX7141_SYSCONF_SYS_CFG24		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0160)
+#define STX7141_SYSCONF_SYS_CFG25		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0164)
+#define STX7141_SYSCONF_SYS_CFG26		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0168)
+#define STX7141_SYSCONF_SYS_CFG27		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x016c)
+#define STX7141_SYSCONF_SYS_CFG28		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0170)
+#define STX7141_SYSCONF_SYS_CFG29		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0174)
+#define STX7141_SYSCONF_SYS_CFG30		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0178)
+#define STX7141_SYSCONF_SYS_CFG31		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x017c)
+#define STX7141_SYSCONF_SYS_CFG32		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0180)
+#define STX7141_SYSCONF_SYS_CFG33		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0184)
+#define STX7141_SYSCONF_SYS_CFG34		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0188)
+#define STX7141_SYSCONF_SYS_CFG35		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x018c)
+#define STX7141_SYSCONF_SYS_CFG36		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0190)
+#define STX7141_SYSCONF_SYS_CFG37		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0194)
+#define STX7141_SYSCONF_SYS_CFG38		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0198)
+#define STX7141_SYSCONF_SYS_CFG39		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x019c)
+#define STX7141_SYSCONF_SYS_CFG40		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01a0)
+#define STX7141_SYSCONF_SYS_CFG41		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01a4)
+#define STX7141_SYSCONF_SYS_CFG42		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01a8)
+#define STX7141_SYSCONF_SYS_CFG43		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01ac)
+#define STX7141_SYSCONF_SYS_CFG44		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01b0)
+#define STX7141_SYSCONF_SYS_CFG45		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01b4)
+#define STX7141_SYSCONF_SYS_CFG46		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01b8)
+#define STX7141_SYSCONF_SYS_CFG47		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01bc)
+#define STX7141_SYSCONF_SYS_CFG48		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01c0)
+#define STX7141_SYSCONF_SYS_CFG49		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01c4)
+#define STX7141_SYSCONF_SYS_CFG50		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01c8)
+#define STX7141_SYSCONF_SYS_CFG51		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01cc)
+#define STX7141_SYSCONF_SYS_CFG52		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01d0)
+#define STX7141_SYSCONF_SYS_CFG53		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01d4)
+#define STX7141_SYSCONF_SYS_CFG54		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01d8)
+#define STX7141_SYSCONF_SYS_CFG55		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01dc)
+
+/* Device ID values, masks & predicates */
+#define STX7141_DEVID_7141_VAL		0x03C
+#define STX7141_DEVID_ID_SHIFT		12
+#define STX7141_DEVID_ID_MASK		0x3ff
+#define STX7141_DEVID_CUT_SHIFT		28
+#define STX7141_DEVID_CUT_MASK		0xf
+
+#define STX7141_DEVICEID_7141(ID) ((((ID) >> STX7141_DEVID_ID_SHIFT) & STX7141_DEVID_ID_MASK) == STX7141_DEVID_7141_VAL)
+#define STX7141_DEVICEID_CUT(ID)  ((((ID) >> STX7141_DEVID_CUT_SHIFT) & STX7141_DEVID_CUT_MASK) + 1)
+
+#endif /* __STX7141REG_H */
diff --git a/include/asm-sh/u-boot.h b/include/asm-sh/u-boot.h
index cfd97a2..480450d 100644
--- a/include/asm-sh/u-boot.h
+++ b/include/asm-sh/u-boot.h
@@ -48,7 +48,10 @@ typedef struct bd_info
 	unsigned long bi_emifrq;
 	unsigned long bi_lmifrq;
 #endif
-#if defined(CONFIG_SH_STX7111) || defined(CONFIG_SH_STX7200)
+#if	defined(CONFIG_SH_STX7105) ||	\
+	defined(CONFIG_SH_STX7111) ||	\
+	defined(CONFIG_SH_STX7141) ||	\
+	defined(CONFIG_SH_STX7200)
 	unsigned long bi_devid;
 	unsigned long bi_emifrq;
 #endif
diff --git a/include/configs/cb101.h b/include/configs/cb101.h
index 0572129..547b337 100644
--- a/include/configs/cb101.h
+++ b/include/configs/cb101.h
@@ -52,12 +52,12 @@
 #define CFG_SDRAM_BASE		0x88000000      /* SDRAM in P1 region */
 #endif
 
-#define CFG_SDRAM_SIZE		0x08000000	/* 128MB of LMI0 SDRAM */
+#define CFG_SDRAM_SIZE		0x08000000	/* 128 MiB of LMI0 SDRAM */
 
-#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 kB for Monitor */
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
 #define CFG_MONITOR_BASE        CFG_FLASH_BASE
-#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1MB for malloc */
-#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128kB */
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
 #define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
 
 #define CFG_MEMTEST_START	CFG_SDRAM_BASE
@@ -71,9 +71,9 @@
 
 #define BOARD cb101
 
-#if CFG_MONITOR_LEN == 0x00020000		/* 128 kB */
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
 #	define MONITOR_SECTORS	"1:0"		/* 1 sector */
-#elif CFG_MONITOR_LEN == 0x00040000		/* 256 kB */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
 #	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
 #else						/* unknown */
 #	error "Unable to determine sectors for monitor"
@@ -210,7 +210,7 @@
  * NOR FLASH organization
  */
 
-/* M58LT256GT: 32Mbyte 259 blocks, 128K block size plus parameter block */
+/* M58LT256GT: 32MiB 259 blocks, 128KiB block size plus parameter block */
 #define CFG_FLASH_CFI_WIDTH	FLASH_CFI_16BIT
 #define CFG_FLASH_CFI_DRIVER
 #define CFG_FLASH_CFI
diff --git a/include/configs/cb102.h b/include/configs/cb102.h
index cbea66d..cb48bee 100644
--- a/include/configs/cb102.h
+++ b/include/configs/cb102.h
@@ -53,12 +53,12 @@
 #define CFG_SDRAM_BASE		0x88000000      /* SDRAM in P1 region */
 #endif
 
-#define CFG_SDRAM_SIZE		0x10000000	/* 256MB of LMI0 SDRAM */
+#define CFG_SDRAM_SIZE		0x10000000	/* 256 MiB of LMI0 SDRAM */
 
-#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 kB for Monitor */
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
 #define CFG_MONITOR_BASE        CFG_FLASH_BASE
-#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1MB for malloc */
-#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128kB */
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
 #define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
 
 #define CFG_MEMTEST_START	CFG_SDRAM_BASE
@@ -72,9 +72,9 @@
 
 #define BOARD cb102
 
-#if CFG_MONITOR_LEN == 0x00020000		/* 128 kB */
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
 #	define MONITOR_SECTORS	"1:0-8"		/* 9 sectors */
-#elif CFG_MONITOR_LEN == 0x00040000		/* 256 kB */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
 #	define MONITOR_SECTORS	"1:0-10"	/* 11 sectors */
 #else						/* unknown */
 #	error "Unable to determine sectors for monitor"
@@ -196,7 +196,7 @@
  */
 
 #if 1
-/* M29W640GB: 8Mbyte, 127*64kB plus 8*8kB, a total of 135 blocks */
+/* M29W640GB: 8MiB, 127*64 KiB plus 8*8 KiB, a total of 135 blocks */
 #define CFG_FLASH_CFI_DRIVER
 #define CFG_FLASH_CFI
 #define CONFIG_FLASH_PROTECT_SINGLE_CELL
@@ -205,7 +205,7 @@
 #define CFG_MAX_FLASH_SECT	135	/* max number of sectors on one chip	*/
 #define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
 #elif 0
-/* M58LT256GT: 32Mbyte 259 blocks, 128K block size plus parameter block */
+/* M58LT256GT: 32MiB 259 blocks, 128KiB block size plus parameter block */
 #define CFG_FLASH_CFI_DRIVER
 #define CFG_FLASH_CFI
 #define CONFIG_FLASH_PROTECT_SINGLE_CELL
@@ -228,8 +228,8 @@
 #define CFG_ENV_IS_IN_FLASH	1
 #define CFG_ENV_OFFSET		CFG_MONITOR_LEN
 #define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
-#define CFG_ENV_SIZE		0x10000		/* 64kB */
-#define CFG_ENV_SECT_SIZE	0x10000		/* 64kB */
+#define CFG_ENV_SIZE		0x10000		/* 64 KiB */
+#define CFG_ENV_SECT_SIZE	0x10000		/* 64 KiB */
 
 /*----------------------------------------------------------------------
  * JFFS2 support
diff --git a/include/configs/mb411.h b/include/configs/mb411.h
index 5214aaa..7f6cb1f 100644
--- a/include/configs/mb411.h
+++ b/include/configs/mb411.h
@@ -47,9 +47,9 @@
 #define CFG_FLASH_BASE		0xA0000000
 #define CFG_RESET_ADDRESS	0xA0000000
 
-#define CFG_MONITOR_LEN		0x00020000	/* Reserve 128 kB for Monitor */
+#define CFG_MONITOR_LEN		0x00020000	/* Reserve 128 KiB for Monitor */
 #define CFG_MONITOR_BASE        0xA0000000
-#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1MB kB for malloc */
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
 #define CFG_BOOTPARAMS_LEN	(128 << 10)
 #define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
 
@@ -64,9 +64,9 @@
 
 #define BOARD mb411
 
-#if CFG_MONITOR_LEN == 0x00020000		/* 128 kB */
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
 #	define MONITOR_SECTORS	"1:0"		/* 1 sector */
-#elif CFG_MONITOR_LEN == 0x00040000		/* 256 kB */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
 #	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
 #else						/* unknown */
 #	error "Unable to determine sectors for monitor"
@@ -251,7 +251,7 @@
  * NOR FLASH organization
  */
 
-/* STb7100 Mboard organised as 8MB flash with 128k blocks */
+/* STb7100 Mboard organised as 8 MiB flash with 128 KiB blocks */
 #define CFG_FLASH_CFI_DRIVER
 #define CFG_FLASH_CFI
 #define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
diff --git a/include/configs/mb442.h b/include/configs/mb442.h
index f45a06b..b95c9d9 100644
--- a/include/configs/mb442.h
+++ b/include/configs/mb442.h
@@ -56,11 +56,11 @@
 #define CFG_SDRAM_BASE		0x84000000      /* SDRAM in P1 region */
 #endif
 
-#define CFG_SDRAM_SIZE		0x04000000	/* 64MB of LMI-Sys SDRAM */
+#define CFG_SDRAM_SIZE		0x04000000	/* 64 MiB of LMI-Sys SDRAM */
 
-#define CFG_MONITOR_LEN		0x00020000	/* Reserve 128 kB for Monitor */
+#define CFG_MONITOR_LEN		0x00020000	/* Reserve 128 KiB for Monitor */
 #define CFG_MONITOR_BASE        CFG_FLASH_BASE
-#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1MB for malloc */
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
 #define CFG_BOOTPARAMS_LEN	(128 << 10)
 #define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
 
@@ -75,9 +75,9 @@
 
 #define BOARD mb442
 
-#if CFG_MONITOR_LEN == 0x00020000		/* 128 kB */
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
 #	define MONITOR_SECTORS	"1:0"		/* 1 sector */
-#elif CFG_MONITOR_LEN == 0x00040000		/* 256 kB */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
 #	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
 #else						/* unknown */
 #	error "Unable to determine sectors for monitor"
@@ -245,7 +245,7 @@
  * NOR FLASH organization
  */
 
-/* STb7100 reference board organised as 8MB flash with 128k blocks */
+/* STb7100 reference board organised as 8 MiB flash with 128 KiB blocks */
 #define CFG_FLASH_CFI_DRIVER
 #define CFG_FLASH_CFI
 #define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
diff --git a/include/configs/mb448.h b/include/configs/mb448.h
index e00a455..342a49e 100644
--- a/include/configs/mb448.h
+++ b/include/configs/mb448.h
@@ -47,9 +47,9 @@
 #define CFG_FLASH_BASE		0xA0000000
 #define CFG_RESET_ADDRESS	0xA0000000
 
-#define CFG_MONITOR_LEN		0x00020000	/* Reserve 128 kB for Monitor */
+#define CFG_MONITOR_LEN		0x00020000	/* Reserve 128 KiB for Monitor */
 #define CFG_MONITOR_BASE        0xA0000000
-#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1MB kB for malloc */
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
 #define CFG_BOOTPARAMS_LEN	(128 << 10)
 #define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
 
@@ -64,9 +64,9 @@
 
 #define BOARD mb448
 
-#if CFG_MONITOR_LEN == 0x00020000		/* 128 kB */
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
 #	define MONITOR_SECTORS	"1:0"		/* 1 sector */
-#elif CFG_MONITOR_LEN == 0x00040000		/* 256 kB */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
 #	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
 #else						/* unknown */
 #	error "Unable to determine sectors for monitor"
@@ -222,7 +222,7 @@
  * NOR FLASH organization
  */
 
-/* STb7109E reference board organised as 8MB flash with 128k blocks */
+/* STb7109E reference board organised as 8 MiB flash with 128 KiB blocks */
 #define CFG_FLASH_CFI_DRIVER
 #define CFG_FLASH_CFI
 #define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
diff --git a/include/configs/mb519.h b/include/configs/mb519.h
index c85cbda..3723d9d 100644
--- a/include/configs/mb519.h
+++ b/include/configs/mb519.h
@@ -52,12 +52,12 @@
 #define CFG_SDRAM_BASE		0x88000000      /* SDRAM in P1 region */
 #endif
 
-#define CFG_SDRAM_SIZE		0x08000000	/* 128MB of LMI0 SDRAM */
+#define CFG_SDRAM_SIZE		0x08000000	/* 128 MiB of LMI0 SDRAM */
 
-#define CFG_MONITOR_LEN		0x00020000	/* Reserve 128 kB for Monitor */
+#define CFG_MONITOR_LEN		0x00020000	/* Reserve 128 KiB for Monitor */
 #define CFG_MONITOR_BASE        CFG_FLASH_BASE
-#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1MB for malloc */
-#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128kB */
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
 #define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
 
 #define CFG_MEMTEST_START	CFG_SDRAM_BASE
@@ -71,9 +71,9 @@
 
 #define BOARD mb519
 
-#if CFG_MONITOR_LEN == 0x00020000		/* 128 kB */
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
 #	define MONITOR_SECTORS	"1:0"		/* 1 sector */
-#elif CFG_MONITOR_LEN == 0x00040000		/* 256 kB */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
 #	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
 #else						/* unknown */
 #	error "Unable to determine sectors for monitor"
@@ -231,7 +231,7 @@
  * NOR FLASH organization
  */
 
-/* M58LT256GT: 32Mbyte 259 blocks, 128K block size plus parameter block */
+/* M58LT256GT: 32MiB 259 blocks, 128 KiB block size plus parameter block */
 #define CFG_FLASH_CFI_DRIVER
 #define CFG_FLASH_CFI
 #define CONFIG_FLASH_PROTECT_SINGLE_CELL
diff --git a/include/configs/mb618.h b/include/configs/mb618.h
index 08e422c..fdd9a13 100644
--- a/include/configs/mb618.h
+++ b/include/configs/mb618.h
@@ -52,12 +52,12 @@
 #define CFG_SDRAM_BASE		0x8C000000      /* SDRAM in P1 region */
 #endif
 
-#define CFG_SDRAM_SIZE		0x08000000	/* 128MB of LMI SDRAM */
+#define CFG_SDRAM_SIZE		0x08000000	/* 128 MiB of LMI SDRAM */
 
-#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 kB for Monitor */
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
 #define CFG_MONITOR_BASE        CFG_FLASH_BASE
-#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1MB for malloc */
-#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128kB */
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
 #define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
 
 #define CFG_MEMTEST_START	CFG_SDRAM_BASE
@@ -71,9 +71,9 @@
 
 #define BOARD mb618
 
-#if CFG_MONITOR_LEN == 0x00020000		/* 128 kB */
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
 #	define MONITOR_SECTORS	"1:0"		/* 1 sector */
-#elif CFG_MONITOR_LEN == 0x00040000		/* 256 kB */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
 #	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
 #else						/* unknown */
 #	error "Unable to determine sectors for monitor"
@@ -217,7 +217,7 @@
  * NOR FLASH organization
  */
 
-/* M58LT256GT: 32Mbyte 259 blocks, 128kB block size */
+/* M58LT256GT: 32MiB 259 blocks, 128 KiB block size */
 #ifndef CONFIG_CMD_NAND				/* NOR flash present ? */
 #	define CONFIG_CMD_JFFS2			/* enable JFFS2 support */
 #	define CFG_FLASH_CFI_DRIVER
@@ -242,8 +242,8 @@
  * NAND FLASH organization
  */
 
-/* NAND512W3A: 64MByte  8-bit, 4096 Blocks (16kB+512B) of 32 Pages (512+16) */
-/* NAND512W4A: 64MByte 16-bit, 4096 Blocks (16kB+512B) of 32 Pages (512+16) */
+/* NAND512W3A: 64MiB  8-bit, 4096 Blocks (16KiB+512B) of 32 Pages (512+16) */
+/* NAND512W4A: 64MiB 16-bit, 4096 Blocks (16KiB+512B) of 32 Pages (512+16) */
 #ifdef CONFIG_CMD_NAND				/* NAND flash present ? */
 #	define CONFIG_CMD_JFFS2			/* enable JFFS2 support */
 #	define CFG_MAX_NAND_DEVICE	1
diff --git a/include/configs/mb628.h b/include/configs/mb628.h
new file mode 100644
index 0000000..ccfc5ad
--- /dev/null
+++ b/include/configs/mb628.h
@@ -0,0 +1,302 @@
+/*
+ * (C) Copyright 2008 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
+
+/* This should really be replaced with something which uses bd->...	*/
+#define P_CLOCK_RATE	87500000	/* clock rate for CSP		*/
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH (uncached) via PMB */
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI Physical Address */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI    Cached addr via PMB */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI UN-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH in P2 region */
+#define CFG_SDRAM_BASE		0x8C800000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x03000000	/* 48 MiB of LMI SDRAM */
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
+#define CFG_MONITOR_BASE        CFG_FLASH_BASE
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD mb628
+
+#if CFG_MONITOR_LEN == 0x00008000		/* 32 KiB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00010000		/* 64 KiB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#elif CFG_MONITOR_LEN == 0x00018000		/* 96 KiB */
+#	define MONITOR_SECTORS	"1:0-2"		/* 3 sectors */
+#elif CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
+#	define MONITOR_SECTORS	"1:0-3"		/* 4 sectors */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
+#	define MONITOR_SECTORS	"1:0-4"		/* 5 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/* we are using the internal ST ASC UART */
+#define CONFIG_STM_ASC_SERIAL	1
+
+/* choose which UART to use */
+#if 1
+	/* ASC1	(left-most)	"RS232 1" */
+#	define CFG_STM_ASC_BASE		0xfd031000
+#else
+	/* ASC2	(right-most)	"RS232 2" */
+#	define CFG_STM_ASC_BASE		0xfd032000
+#endif
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 2 options for ethernet, both use the on-chip ST-GMAC.
+ * The choice in PHYs are:
+ *    The on-board SMSC LAN8700
+ *    External PHY connected via the MII off-board connector.
+ */
+
+/* are we using the internal ST GMAC device ? */
+#define CONFIG_DRIVER_NET_STM_GMAC
+
+/*
+ * Select the appropriate base address for the GMAC.
+ * Also, choose which PHY to use.
+ */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+#	define CFG_STM_STMAC_BASE	 0xfd110000ul	/* MAC = STM GMAC0 */
+#	define CONFIG_STMAC_LAN8700			/* PHY = SMSC LAN8700 */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+//QQQ	#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB_BASE			0xfe100000
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+#if defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CFG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"MB628> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* Whether the hardware supports NOR or NAND Flash depends on J70.
+ * Only ONE of these may be present at any one time. Each hides the other.
+ * In position 1-2 CSA selects NAND, in position 2-3 is selects NOR.
+ * Note that J69 must also be in position 2-3 to select the
+ * on-board Flash (for either the on-board NOR or NAND flash).
+ *
+ * i.e.		ON-board NOR FLASH:	J69:2-3, J70:2-3
+ *	 	ON-board NAND FLASH:	J69:2-3, J70:1-2
+ */
+//#define CONFIG_CMD_NAND		/* define for NAND flash */
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+/* M58LT256JSB: 32MiB 259 blocks, 128 KiB block size */
+#ifndef CONFIG_CMD_NAND				/* NOR flash present ? */
+#	define CONFIG_CMD_JFFS2			/* enable JFFS2 support */
+#	define CFG_FLASH_CFI_DRIVER
+#	define CFG_FLASH_CFI
+#	define CONFIG_FLASH_PROTECT_SINGLE_CELL
+#	define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#	define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#	define CFG_MAX_FLASH_SECT	259	/* max number of sectors on one chip	*/
+#	define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+#define MTDPARTS_DEFAULT						\
+	"mtdparts="							\
+	"physmap-flash:"	/* First NOR flash device */		\
+		"256k(U-Boot)"		/* first partition */		\
+		",128k(Environment)"					\
+		",4M(Kernel)"						\
+		",-(RestOfNor)"		/* last partition */
+#define MTDIDS_DEFAULT							\
+	"nor0=physmap-flash"	/* First NOR flash device */
+#endif	/* CONFIG_CMD_NAND */
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH organization
+ */
+
+/* NAND512W3A: 64MiB  8-bit, 4096 Blocks (16KiB+512B) of 32 Pages (512+16) */
+/* NAND512W4A: 64MiB 16-bit, 4096 Blocks (16KiB+512B) of 32 Pages (512+16) */
+#ifdef CONFIG_CMD_NAND				/* NAND flash present ? */
+#	define CONFIG_CMD_JFFS2			/* enable JFFS2 support */
+#	define CFG_MAX_NAND_DEVICE	1
+#	define NAND_MAX_CHIPS		CFG_MAX_NAND_DEVICE
+#	define CFG_NAND0_BASE		CFG_FLASH_BASE	/* Occludes NOR flash */
+#	define CFG_NAND_BASE_LIST	{ CFG_NAND0_BASE }
+#	undef CONFIG_CMD_FLASH			/* NOR-flash specific */
+#	undef CONFIG_CMD_IMLS			/* NOR-flash specific */
+#	define CFG_NO_FLASH			/* no NOR-flash when using NAND-flash */
+#define MTDPARTS_DEFAULT						\
+	"mtdparts="							\
+	"gen_nand.1:"		/* First NAND flash device */		\
+		"128k(Environment)"	/* first partition */		\
+		",4M(Kernel)"						\
+		",32M(rootfs)"						\
+		",-(RestOfNand)"	/* last partition */
+#define MTDIDS_DEFAULT							\
+	"nand0=gen_nand.1"	/* First NAND flash device */
+#endif	/* CONFIG_CMD_NAND */
+
+/*-----------------------------------------------------------------------
+ * Addresss, size, & location of U-boot's Environment Sector
+ */
+
+#ifdef CONFIG_CMD_NAND				/* NAND flash present ? */
+#	define CFG_ENV_IS_IN_NAND		/* enviroment in NAND flash */
+#	define CFG_ENV_OFFSET	0		/* begining of NAND flash */
+#else
+#	define CFG_ENV_IS_IN_FLASH		/* environment in NOR flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* After u-boot.bin */
+#endif	/* CONFIG_CMD_NAND */
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE		0x10000
+#define CFG_ENV_SECT_SIZE	0x20000
+
+/*----------------------------------------------------------------------
+ * JFFS2 support
+ */
+
+#if defined(CONFIG_CMD_JFFS2)
+#	ifdef CONFIG_CMD_NAND			/* NAND flash present ? */
+#		define CONFIG_JFFS2_NAND	/* JFFS2 support on NAND Flash */
+#	endif	/* CONFIG_CMD_NAND */
+#	define CONFIG_JFFS2_CMDLINE		/* mtdparts command line support */
+#endif	/* CONFIG_CMD_JFFS2 */
+
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/mb671.h b/include/configs/mb671.h
index fca7d1c..ef0ebf3 100644
--- a/include/configs/mb671.h
+++ b/include/configs/mb671.h
@@ -52,12 +52,12 @@
 #define CFG_SDRAM_BASE		0x88000000      /* SDRAM in P1 region */
 #endif
 
-#define CFG_SDRAM_SIZE		0x10000000	/* 256MB of LMI0 SDRAM */
+#define CFG_SDRAM_SIZE		0x10000000	/* 256 MiB of LMI0 SDRAM */
 
-#define CFG_MONITOR_LEN		0x00020000	/* Reserve 128 kB for Monitor */
+#define CFG_MONITOR_LEN		0x00020000	/* Reserve 128 KiB for Monitor */
 #define CFG_MONITOR_BASE        CFG_FLASH_BASE
-#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1MB for malloc */
-#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128kB */
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
 #define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
 
 #define CFG_MEMTEST_START	CFG_SDRAM_BASE
@@ -71,9 +71,9 @@
 
 #define BOARD mb671
 
-#if CFG_MONITOR_LEN == 0x00020000		/* 128 kB */
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
 #	define MONITOR_SECTORS	"1:0"		/* 1 sector */
-#elif CFG_MONITOR_LEN == 0x00040000		/* 256 kB */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
 #	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
 #else						/* unknown */
 #	error "Unable to determine sectors for monitor"
@@ -228,7 +228,7 @@
  * NOR FLASH organization
  */
 
-/* M58LT256GT: 32Mbyte 259 blocks, 128K block size plus parameter block */
+/* M58LT256GT: 32MiB 259 blocks, 128 KiB block size plus parameter block */
 #define CFG_FLASH_CFI_DRIVER
 #define CFG_FLASH_CFI
 #define CONFIG_FLASH_PROTECT_SINGLE_CELL
diff --git a/include/configs/mb680.h b/include/configs/mb680.h
new file mode 100644
index 0000000..6700e1b
--- /dev/null
+++ b/include/configs/mb680.h
@@ -0,0 +1,316 @@
+/*
+ * (C) Copyright 2008 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
+
+/* This should really be replaced with something which uses bd->...	*/
+#define P_CLOCK_RATE	87500000	/* clock rate for CSP		*/
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_FLASH_BASE		0xA0000000	/* NOR FLASH (uncached) via PMB */
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI Physical Address */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI    Cached addr via PMB */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI UN-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_FLASH_BASE		0xA0000000	/* NOR FLASH in P2 region */
+#define CFG_SDRAM_BASE		0x8C000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x10000000	/* 256 MiB of LMI SDRAM */
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
+#define CFG_MONITOR_BASE        CFG_FLASH_BASE
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD mb680
+
+#if CFG_MONITOR_LEN == 0x00008000		/* 32 KiB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00010000		/* 64 KiB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#elif CFG_MONITOR_LEN == 0x00018000		/* 96 KiB */
+#	define MONITOR_SECTORS	"1:0-2"		/* 3 sectors */
+#elif CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
+#	define MONITOR_SECTORS	"1:0-3"		/* 4 sectors */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
+#	define MONITOR_SECTORS	"1:0-4"		/* 5 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/* we are using the internal ST ASC UART */
+#define CONFIG_STM_ASC_SERIAL	1
+
+/* choose which UART to use */
+#if 1
+#	define CFG_STM_ASC_BASE		0xfd032000ul	/* UART2 = AS0 */
+#else
+#	define CFG_STM_ASC_BASE		0xfd033000ul	/* UART3 = AS1 */
+#endif
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 2 options for ethernet, both use the on-chip ST-GMAC.
+ * The choice in PHYs are:
+ *    The on-board Nat Semi DP83865
+ *    External PHY connected via the MII off-board connector.
+ */
+
+/* are we using the internal ST GMAC device ? */
+#define CONFIG_DRIVER_NET_STM_GMAC
+
+/*
+ * Select the appropriate base address for the GMAC.
+ * Also, choose which PHY to use.
+ */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+#	define CFG_STM_STMAC_BASE	 0xfd110000ul	/* MAC = STM GMAC0 */
+#	define CONFIG_STMAC_DP83865			/* PHY = NS DP83865 */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB0_BASE			0xfe100000	/* upper */
+#	define CFG_USB1_BASE			0xfea00000	/* lower */
+#	define CFG_USB_BASE			CFG_USB0_BASE
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+#if defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CFG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"MB680> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* Choose if we want FLASH Support (NAND &/or NOR devices)
+ * With the MB680 + MB705 combination, we may use *both*
+ * NOR and NAND flash, at the same time, if we want.
+ *
+ * Note: by default CONFIG_CMD_FLASH is defined in config_cmd_default.h
+ */
+#undef CONFIG_CMD_FLASH		/* undefine it, define only if needed */
+#define CONFIG_CMD_FLASH	/* define for NOR flash */
+#define CONFIG_CMD_NAND		/* define for NAND flash */
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+/* M58LT256: 32MiB 259 blocks, 128 KiB block size */
+#ifdef CONFIG_CMD_FLASH				/* NOR flash present ? */
+#	define CFG_FLASH_CFI_DRIVER
+#	define CFG_FLASH_CFI
+#	define CONFIG_FLASH_PROTECT_SINGLE_CELL
+#	define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#	define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#	define CFG_MAX_FLASH_SECT	259	/* max number of sectors on one chip	*/
+#	define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+#	define MTDPARTS_NOR						\
+	"physmap-flash:"	/* First NOR flash device */		\
+		"256k(U-Boot)"		/* first partition */		\
+		",128k(Environment)"					\
+		",4M(Kernel)"						\
+		",-(RestOfNor0)"	/* last partition */
+#	define MTDIDS_NOR						\
+	"nor0=physmap-flash"	/* First NOR flash device */
+#else
+#	undef CONFIG_CMD_IMLS			/* NOR-flash specific */
+#	define CFG_NO_FLASH			/* NOR-flash specific */
+#endif	/* CONFIG_CMD_FLASH */
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH organization
+ */
+
+/* NAND512W3A: 64MiB  8-bit, 4096 Blocks (16KiB+512B) of 32 Pages (512+16) */
+#ifdef CONFIG_CMD_NAND				/* NAND flash present ? */
+#	define CFG_MAX_NAND_DEVICE	1
+#	define NAND_MAX_CHIPS		CFG_MAX_NAND_DEVICE
+#	define CFG_NAND0_BASE		0xA4000000	/* Physical 0x04000000 */
+#	define CFG_NAND_BASE_LIST	{ CFG_NAND0_BASE }
+#	define MTDPARTS_NAND						\
+	"gen_nand.1:"		/* First NAND flash device */		\
+		"128k(env-nand0)"	/* first partition */		\
+		",4M(kernel-nand0)"					\
+		",32M(root-nand0)"					\
+		",-(RestOfNand0)"	/* last partition */
+#	define MTDIDS_NAND						\
+	"nand0=gen_nand.1"	/* First NAND flash device */
+#endif	/* CONFIG_CMD_NAND */
+
+/*-----------------------------------------------------------------------
+ * Address, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_SIZE			0x4000	/* 16 KiB of environment data */
+
+#ifdef CONFIG_CMD_FLASH				/* NOR flash present ? */
+#	define CFG_ENV_IS_IN_FLASH		/* environment in NOR flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
+#	define CFG_ENV_SECT_SIZE	0x20000	/* 128 KiB Sector size */
+#elif defined(CONFIG_CMD_NAND)			/* NAND flash present ? */
+#	define CFG_ENV_IS_IN_NAND		/* environment in NAND flash */
+#	define CFG_ENV_OFFSET	0		/* beginning of NAND flash */
+#else
+#	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#endif	/* CONFIG_CMD_NAND */
+
+/*----------------------------------------------------------------------
+ * JFFS2 + MTD Partition support
+ */
+
+#if 1 && (defined(CONFIG_CMD_FLASH) || defined(CONFIG_CMD_NAND))
+#	define CONFIG_CMD_JFFS2			/* enable JFFS2 support */
+#endif
+
+#if defined(CONFIG_CMD_JFFS2)
+#	define CONFIG_JFFS2_CMDLINE		/* mtdparts command line support */
+#	define CONFIG_JFFS2_NAND		/* JFFS2 support on NAND Flash */
+#	if defined(CONFIG_CMD_FLASH) && defined(CONFIG_CMD_NAND) /* Both NOR + NAND */
+#		define MTDPARTS_DEFAULT						\
+		"mtdparts="							\
+			MTDPARTS_NOR	/* NOR flash devices */			\
+			";"		/* delimiter */				\
+			MTDPARTS_NAND	/* NAND flash devices */
+#		define MTDIDS_DEFAULT						\
+			MTDIDS_NOR	/* NOR flash devices */			\
+			","		/* delimiter */				\
+			MTDIDS_NAND	/* NAND flash devices */
+#	elif defined(CONFIG_CMD_FLASH)		/* Only NOR flash devices */
+#		define MTDPARTS_DEFAULT	"mtdparts=" MTDPARTS_NOR
+#		define MTDIDS_DEFAULT	MTDIDS_NOR
+#	elif defined(CONFIG_CMD_NAND)		/* Only NAND flash devices */
+#		define MTDPARTS_DEFAULT	"mtdparts=" MTDPARTS_NAND
+#		define MTDIDS_DEFAULT	MTDIDS_NAND
+#	endif	/* defined(CONFIG_CMD_FLASH) && defined(CONFIG_CMD_NAND) */
+#endif	/* CONFIG_CMD_JFFS2 */
+
+#endif	/* __CONFIG_H */
diff --git a/lib_generic/display_options.c b/lib_generic/display_options.c
index 27af335..25af4d5 100644
--- a/lib_generic/display_options.c
+++ b/lib_generic/display_options.c
@@ -39,17 +39,17 @@ int display_options (void)
 }
 
 /*
- * print sizes as "xxx kB", "xxx.y kB", "xxx MB" or "xxx.y MB" as needed;
+ * print sizes as "xxx KiB", "xxx.y KiB", "xxx MiB" or "xxx.y MiB" as needed;
  * allow for optional trailing string (like "\n")
  */
 void print_size (ulong size, const char *s)
 {
 	ulong m, n;
-	ulong d = 1 << 20;		/* 1 MB */
+	ulong d = 1 << 20;		/* 1 MiB */
 	char  c = 'M';
 
-	if (size < d) {			/* print in kB */
-		c = 'k';
+	if (size < d) {			/* print in KiB */
+		c = 'K';
 		d = 1 << 10;
 	}
 
@@ -66,7 +66,7 @@ void print_size (ulong size, const char *s)
 	if (m) {
 		printf (".%ld", m);
 	}
-	printf (" %cB%s", c, s);
+	printf (" %ciB%s", c, s);
 }
 
 /*
diff --git a/lib_sh/board.c b/lib_sh/board.c
index 4e5ab94..f135424 100644
--- a/lib_sh/board.c
+++ b/lib_sh/board.c
@@ -35,8 +35,12 @@
 #endif
 #if defined(CONFIG_SH_STB7100)
 #include <asm/stb7100reg.h>
+#elif defined(CONFIG_SH_STX7105)
+#include <asm/stx7105reg.h>
 #elif defined(CONFIG_SH_STX7111)
 #include <asm/stx7111reg.h>
+#elif defined(CONFIG_SH_STX7141)
+#include <asm/stx7141reg.h>
 #elif defined(CONFIG_SH_STX7200)
 #include <asm/stx7200reg.h>
 #else
diff --git a/lib_sh/time.c b/lib_sh/time.c
index 981a495..d676033 100644
--- a/lib_sh/time.c
+++ b/lib_sh/time.c
@@ -26,8 +26,12 @@
 
 #if defined(CONFIG_SH_STB7100)
 #include <asm/stb7100reg.h>
+#elif defined(CONFIG_SH_STX7105)
+#include <asm/stx7105reg.h>
 #elif defined(CONFIG_SH_STX7111)
 #include <asm/stx7111reg.h>
+#elif defined(CONFIG_SH_STX7141)
+#include <asm/stx7141reg.h>
 #elif defined(CONFIG_SH_STX7200)
 #include <asm/stx7200reg.h>
 #else
diff --git a/net/tftp.c b/net/tftp.c
index 8b95bcf..a10de80 100644
--- a/net/tftp.c
+++ b/net/tftp.c
@@ -315,7 +315,7 @@ TftpHandler (uchar * pkt, unsigned dest, unsigned src, unsigned len)
 		if (TftpBlock == 0) {
 			TftpBlockWrap++;
 			TftpBlockWrapOffset += TftpBlkSize * TFTP_SEQUENCE_SIZE;
-			printf ("\n\t %lu MB received\n\t ", TftpBlockWrapOffset>>20);
+			printf ("\n\t %lu MiB received\n\t ", TftpBlockWrapOffset>>20);
 		} else {
 			if (((TftpBlock - 1) % 10) == 0) {
 				putc ('#');
diff --git a/sh_config.mk b/sh_config.mk
index e641654..30b7ecb 100644
--- a/sh_config.mk
+++ b/sh_config.mk
@@ -27,7 +27,7 @@
 # for actual build number, in the following identifier.
 # Regular Expression for string is:
 # 	"stm[2-9][0-9]-[2-9][0-9][0-9][0-9]-[01][0-9]-[0-3][0-9]"
-SH_IDENT_STRING="\"stm23-2008-07-31\""
+SH_IDENT_STRING="\"stm23-2008-10-13\""
 
 PLATFORM_CPPFLAGS += -DCONFIG_SH4 -D__SH4__ -DCONFIG_IDENT_STRING=$(SH_IDENT_STRING)
 PLATFORM_LDFLAGS  += -n
diff --git a/tools/mkimage.c b/tools/mkimage.c
index 9c8d9b9..60e9940 100644
--- a/tools/mkimage.c
+++ b/tools/mkimage.c
@@ -627,7 +627,7 @@ print_header (image_header_t *hdr)
 	printf ("Image Name:   %.*s\n", IH_NMLEN, hdr->ih_name);
 	printf ("Created:      %s", ctime(&timestamp));
 	printf ("Image Type:   "); print_type(hdr);
-	printf ("Data Size:    %d Bytes = %.2f kB = %.2f MB\n",
+	printf ("Data Size:    %d Bytes = %.2f KiB = %.2f MiB\n",
 		size, (double)size / 1.024e3, (double)size / 1.048576e6 );
 	printf ("Load Address: 0x%08X\n", ntohl(hdr->ih_load));
 	printf ("Entry Point:  0x%08X\n", ntohl(hdr->ih_ep));
@@ -649,7 +649,7 @@ print_header (image_header_t *hdr)
 		for (i=0; len_ptr[i]; ++i) {
 			size = ntohl(len_ptr[i]);
 
-			printf ("   Image %d: %8d Bytes = %4d kB = %d MB\n",
+			printf ("   Image %d: %8d Bytes = %4d KiB = %d MiB\n",
 				i, size, size>>10, size>>20);
 			if (hdr->ih_type == IH_TYPE_SCRIPT && i > 0) {
 				/*
diff --git a/tools/updater/flash_hw.c b/tools/updater/flash_hw.c
index 2d9b8c8..f16b2e9 100644
--- a/tools/updater/flash_hw.c
+++ b/tools/updater/flash_hw.c
@@ -210,49 +210,49 @@ static ulong flash_get_size (ulong addr, flash_info_t *info)
 			info->flash_id += FLASH_AM400T;
 			info->sector_count = 11;
 			info->size = 0x00100000;
-			break;			/* => 1 MB		*/
+			break;			/* => 1 MiB		*/
 
 		case AMD_ID_LV400B:
 			DEBUGF("Am29LV400B\n");
 			info->flash_id += FLASH_AM400B;
 			info->sector_count = 11;
 			info->size = 0x00100000;
-			break;			/* => 1 MB		*/
+			break;			/* => 1 MiB		*/
 
 		case AMD_ID_LV800T:
 			DEBUGF("Am29LV800T\n");
 			info->flash_id += FLASH_AM800T;
 			info->sector_count = 19;
 			info->size = 0x00200000;
-			break;			/* => 2 MB		*/
+			break;			/* => 2 MiB		*/
 
 		case AMD_ID_LV800B:
 			DEBUGF("Am29LV400B\n");
 			info->flash_id += FLASH_AM800B;
 			info->sector_count = 19;
 			info->size = 0x00200000;
-			break;			/* => 2 MB		*/
+			break;			/* => 2 MiB		*/
 
 		case AMD_ID_LV160T:
 			DEBUGF("Am29LV160T\n");
 			info->flash_id += FLASH_AM160T;
 			info->sector_count = 35;
 			info->size = 0x00400000;
-			break;			/* => 4 MB		*/
+			break;			/* => 4 MiB		*/
 
 		case AMD_ID_LV160B:
 			DEBUGF("Am29LV160B\n");
 			info->flash_id += FLASH_AM160B;
 			info->sector_count = 35;
 			info->size = 0x00400000;
-			break;			/* => 4 MB		*/
+			break;			/* => 4 MiB		*/
 
 		case AMD_ID_LV320T:
 			DEBUGF("Am29LV320T\n");
 			info->flash_id += FLASH_AM320T;
 			info->sector_count = 67;
 			info->size = 0x00800000;
-			break;			/* => 8 MB		*/
+			break;			/* => 8 MiB		*/
 
 #if 0
 		/* Has the same ID as AMD_ID_LV320T, to be fixed */
@@ -261,7 +261,7 @@ static ulong flash_get_size (ulong addr, flash_info_t *info)
 			info->flash_id += FLASH_AM320B;
 			info->sector_count = 67;
 			info->size = 0x00800000;
-			break;			/* => 8 MB		*/
+			break;			/* => 8 MiB		*/
 #endif
 
 		case AMD_ID_LV033C:
@@ -613,33 +613,33 @@ void flash_print_info (flash_info_t *info)
 	}
 
 	switch (info->flash_id & FLASH_TYPEMASK) {
-	case FLASH_AM040:	printf ("29F040 or 29LV040 (4 Mbit, uniform sectors)\n");
+	case FLASH_AM040:	printf ("29F040 or 29LV040 (4 Mibit, uniform sectors)\n");
 				break;
-	case FLASH_AM400B:	printf ("AM29LV400B (4 Mbit, bottom boot sect)\n");
+	case FLASH_AM400B:	printf ("AM29LV400B (4 Mibit, bottom boot sect)\n");
 				break;
-	case FLASH_AM400T:	printf ("AM29LV400T (4 Mbit, top boot sector)\n");
+	case FLASH_AM400T:	printf ("AM29LV400T (4 Mibit, top boot sector)\n");
 				break;
-	case FLASH_AM800B:	printf ("AM29LV800B (8 Mbit, bottom boot sect)\n");
+	case FLASH_AM800B:	printf ("AM29LV800B (8 Mibit, bottom boot sect)\n");
 				break;
-	case FLASH_AM800T:	printf ("AM29LV800T (8 Mbit, top boot sector)\n");
+	case FLASH_AM800T:	printf ("AM29LV800T (8 Mibit, top boot sector)\n");
 				break;
-	case FLASH_AM160B:	printf ("AM29LV160B (16 Mbit, bottom boot sect)\n");
+	case FLASH_AM160B:	printf ("AM29LV160B (16 Mibit, bottom boot sect)\n");
 				break;
-	case FLASH_AM160T:	printf ("AM29LV160T (16 Mbit, top boot sector)\n");
+	case FLASH_AM160T:	printf ("AM29LV160T (16 Mibit, top boot sector)\n");
 				break;
-	case FLASH_AM320B:	printf ("AM29LV320B (32 Mbit, bottom boot sect)\n");
+	case FLASH_AM320B:	printf ("AM29LV320B (32 Mibit, bottom boot sect)\n");
 				break;
-	case FLASH_AM320T:	printf ("AM29LV320T (32 Mbit, top boot sector)\n");
+	case FLASH_AM320T:	printf ("AM29LV320T (32 Mibit, top boot sector)\n");
 				break;
 	default:		printf ("Unknown Chip Type\n");
 				break;
 	}
 
 	if (info->size % 0x100000 == 0) {
-		printf ("  Size: %ld MB in %d Sectors\n",
+		printf ("  Size: %ld MiB in %d Sectors\n",
 			info->size / 0x100000, info->sector_count);
 	} else if (info->size % 0x400 == 0) {
-		printf ("  Size: %ld KB in %d Sectors\n",
+		printf ("  Size: %ld KiB in %d Sectors\n",
 			info->size / 0x400, info->sector_count);
 	} else {
 		printf ("  Size: %ld B in %d Sectors\n",
diff --git a/MAKEALL b/MAKEALL
index 383c14a..931ea5e 100755
--- a/MAKEALL
+++ b/MAKEALL
@@ -680,6 +680,8 @@ LIST_sh="		\
 	mb671se		\
 	mb680		\
 	mb680se		\
+	pdk7105		\
+	pdk7105se	\
 	cb101		\
 	cb101se		\
 	cb102		\
diff --git a/Makefile b/Makefile
index f569360..24e239d 100644
--- a/Makefile
+++ b/Makefile
@@ -2745,7 +2745,7 @@ mb628se_config :		unconfig
 	$(if $(findstring se,$@), \
 	@echo "#define CONFIG_SH_SE_MODE   1" >>include/config.h)
 	$(if $(findstring se,$@), \
-	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/mb628/config.tmp)
+	@echo "TEXT_BASE = 0x83900000" >$(obj)board/mb628/config.tmp)
 	@./mkconfig -a mb628 sh sh mb628 "" stx7141
 
 mb671_config \
@@ -2770,6 +2770,17 @@ mb680se_config :		unconfig
 	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/mb680/config.tmp)
 	@./mkconfig -a mb680 sh sh mb680 "" stx7105
 
+pdk7105_config \
+pdk7105se_config :		unconfig
+	@ >include/config.h
+	@echo "#define CONFIG_SH_STX7105   1" >>include/config.h
+	@echo "#define CONFIG_SH_PDK7105   1" >>include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/pdk7105/config.tmp)
+	@./mkconfig -a pdk7105 sh sh pdk7105 "" stx7105
+
 cb101_config \
 cb101se_config :		unconfig
 	@ >include/config.h
diff --git a/board/cb101/Makefile b/board/cb101/Makefile
index ff0f69a..219443a 100644
--- a/board/cb101/Makefile
+++ b/board/cb101/Makefile
@@ -27,7 +27,7 @@ LIB	= lib$(BOARD).a
 
 AOBJS	= init-$(BOARD).o
 
-COBJS	= $(BOARD).o sconsole.o nand.o
+COBJS	= $(BOARD).o nand.o
 
 OBJS	= $(COBJS) $(AOBJS)
 
diff --git a/board/cb101/sconsole.c b/board/cb101/sconsole.c
deleted file mode 100644
index af92525..0000000
--- a/board/cb101/sconsole.c
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-
-#include "sconsole.h"
-
-#if 0
-void (*sconsole_putc) (char) = 0;
-void (*sconsole_puts) (const char *) = 0;
-int (*sconsole_getc) (void) = 0;
-int (*sconsole_tstc) (void) = 0;
-void (*sconsole_setbrg) (void) = 0;
-#endif
-
-#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
-int serial_init (void)
-{
-	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-	sb->pos = 0;
-	sb->size = 0;
-	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
-
-	return (0);
-}
-
-void serial_putc (char c)
-{
-	if (sconsole_putc) {
-		(*sconsole_putc) (c);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		if (c) {
-			sb->data[sb->pos++] = c;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-void serial_puts (const char *s)
-{
-	if (sconsole_puts) {
-		(*sconsole_puts) (s);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		while (*s) {
-			sb->data[sb->pos++] = *s++;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-int serial_getc (void)
-{
-	if (sconsole_getc) {
-		return (*sconsole_getc) ();
-	} else {
-		return 0;
-	}
-}
-
-int serial_tstc (void)
-{
-	if (sconsole_tstc) {
-		return (*sconsole_tstc) ();
-	} else {
-		return 0;
-	}
-}
-
-void serial_setbrg (void)
-{
-	if (sconsole_setbrg) {
-		(*sconsole_setbrg) ();
-	}
-}
-
-void sconsole_flush (void)
-{
-	if (sconsole_putc) {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-		unsigned int end = sb->pos < sb->size
-			? sb->pos + sb->max_size - sb->size
-			: sb->pos - sb->size;
-
-		while (sb->size) {
-			(*sconsole_putc) (sb->data[end++]);
-			if (end == sb->max_size) {
-				end = 0;
-			}
-			sb->size--;
-		}
-	}
-}
-#endif
diff --git a/board/cb101/sconsole.h b/board/cb101/sconsole.h
deleted file mode 100644
index 1666f21..0000000
--- a/board/cb101/sconsole.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef _SCONSOLE_H_
-#define _SCONSOLE_H_
-
-#include <config.h>
-
-typedef struct sconsole_buffer_s
-{
-	unsigned long size;
-	unsigned long max_size;
-	unsigned long pos;
-	char data[1];
-} sconsole_buffer_t;
-
-#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
-
-extern void (*sconsole_putc) (char);
-extern void (*sconsole_puts) (const char *);
-extern int (*sconsole_getc) (void);
-extern int (*sconsole_tstc) (void);
-extern void (*sconsole_setbrg) (void);
-
-extern void sconsole_flush (void);
-
-#endif
diff --git a/board/cb102/Makefile b/board/cb102/Makefile
index 1f1f703..70041dd 100644
--- a/board/cb102/Makefile
+++ b/board/cb102/Makefile
@@ -27,7 +27,7 @@ LIB	= lib$(BOARD).a
 
 AOBJS	= init-$(BOARD).o
 
-COBJS	= $(BOARD).o sconsole.o
+COBJS	= $(BOARD).o
 
 OBJS	= $(COBJS) $(AOBJS)
 
diff --git a/board/cb102/sconsole.c b/board/cb102/sconsole.c
deleted file mode 100644
index af92525..0000000
--- a/board/cb102/sconsole.c
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-
-#include "sconsole.h"
-
-#if 0
-void (*sconsole_putc) (char) = 0;
-void (*sconsole_puts) (const char *) = 0;
-int (*sconsole_getc) (void) = 0;
-int (*sconsole_tstc) (void) = 0;
-void (*sconsole_setbrg) (void) = 0;
-#endif
-
-#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
-int serial_init (void)
-{
-	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-	sb->pos = 0;
-	sb->size = 0;
-	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
-
-	return (0);
-}
-
-void serial_putc (char c)
-{
-	if (sconsole_putc) {
-		(*sconsole_putc) (c);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		if (c) {
-			sb->data[sb->pos++] = c;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-void serial_puts (const char *s)
-{
-	if (sconsole_puts) {
-		(*sconsole_puts) (s);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		while (*s) {
-			sb->data[sb->pos++] = *s++;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-int serial_getc (void)
-{
-	if (sconsole_getc) {
-		return (*sconsole_getc) ();
-	} else {
-		return 0;
-	}
-}
-
-int serial_tstc (void)
-{
-	if (sconsole_tstc) {
-		return (*sconsole_tstc) ();
-	} else {
-		return 0;
-	}
-}
-
-void serial_setbrg (void)
-{
-	if (sconsole_setbrg) {
-		(*sconsole_setbrg) ();
-	}
-}
-
-void sconsole_flush (void)
-{
-	if (sconsole_putc) {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-		unsigned int end = sb->pos < sb->size
-			? sb->pos + sb->max_size - sb->size
-			: sb->pos - sb->size;
-
-		while (sb->size) {
-			(*sconsole_putc) (sb->data[end++]);
-			if (end == sb->max_size) {
-				end = 0;
-			}
-			sb->size--;
-		}
-	}
-}
-#endif
diff --git a/board/cb102/sconsole.h b/board/cb102/sconsole.h
deleted file mode 100644
index 1666f21..0000000
--- a/board/cb102/sconsole.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef _SCONSOLE_H_
-#define _SCONSOLE_H_
-
-#include <config.h>
-
-typedef struct sconsole_buffer_s
-{
-	unsigned long size;
-	unsigned long max_size;
-	unsigned long pos;
-	char data[1];
-} sconsole_buffer_t;
-
-#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
-
-extern void (*sconsole_putc) (char);
-extern void (*sconsole_puts) (const char *);
-extern int (*sconsole_getc) (void);
-extern int (*sconsole_tstc) (void);
-extern void (*sconsole_setbrg) (void);
-
-extern void sconsole_flush (void);
-
-#endif
diff --git a/board/cb103/cb103.romgen b/board/cb103/cb103.romgen
new file mode 100644
index 0000000..5a1c8b7
--- /dev/null
+++ b/board/cb103/cb103.romgen
@@ -0,0 +1,1580 @@
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x2d437041) */
+/* PEEK(0xa5020000) (used target peek value 0x000b000b) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80101400) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+POKE32(0xfd700000, 0x80101400)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000001)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x00181400) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+POKE32(0xfd700000, 0x00180f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+WHILE_NE32(0xfd700000, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+POKE32(0xfd700000, 0x80000f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80100a00) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+POKE32(0xfd700004, 0x80100a00)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000002)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x00180a00) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+POKE32(0xfd700004, 0x00180f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000002) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+WHILE_NE32(0xfd700004, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+POKE32(0xfd700004, 0x80000f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+POKE32(0xfd700008, 0x80102803)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000004)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x00182803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+POKE32(0xfd700008, 0x00182803)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000004) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+WHILE_NE32(0xfd700008, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+POKE32(0xfd700008, 0x80002803)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+POKE32(0xfd70103c, 0x80102803)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+/* PEEK(0xfd701058) (used target peek value 0x00007ff8) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+POKE32(0xfd701058, 0x0000fff8)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x00182803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+POKE32(0xfd70103c, 0x00182803)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+/* PEEK(0xfd701058) (used target peek value 0x0000fff8) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+POKE32(0xfd701058, 0x00007ff8)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+WHILE_NE32(0xfd70103c, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+POKE32(0xfd70103c, 0x80002803)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x00000d28) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x00001d28)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x00001d28) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x000016c0)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x000016c0) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x000006c0)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x2d437041) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+/* PEEK(0xfd704014) (used target peek value 0x1e04402b) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+WHILE_NE32(0xfd704014, 0x00000001, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x2d437041) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x2d437041) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA01
+*/
+/* PEEK(0xfd70400c) (used target peek value 0x00000040) */
+/* PEEK(0xa5000000) (used target peek value 0x00110011) */
+/* PEEK(0xa5020000) (used target peek value 0x000b000b) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x2d437041) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80000f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80000f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80002803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80002803) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x000006c0) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_MUX_CFG
+*/
+/* PEEK(0xfd70000c) (used target peek value 0x00000071) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_MUX_CFG
+*/
+/* PEEK(0xfd70000c) (used target peek value 0x00000071) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+/* PEEK(0xfd7041e8) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+POKE32(0xfd7041e8, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x080006a1)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG15
+*/
+POKE32(0xfd70413c, 0x08000001)
+DELAY(200)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+/* PEEK(0xfd7041e8) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+POKE32(0xfd7041e8, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+/* PEEK(0xfd704014) (used target peek value 0x1e175c6b) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+WHILE_NE32(0xfd704014, 0x00100400, 0x00100400)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA05
+*/
+/* PEEK(0xfd70401c) (used target peek value 0x1e179572) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA05
+*/
+WHILE_NE32(0xfd70401c, 0x00100400, 0x00100400)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG12
+*/
+POKE32(0xfd704130, 0xa200687f)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG16
+*/
+POKE32(0xfd704140, 0xa200687f)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG38
+*/
+POKE32(0xfd704198, 0x002ffd08)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG39
+*/
+POKE32(0xfd70419c, 0x002ffd18)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG13
+*/
+POKE32(0xfd704134, 0x00020000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG14
+*/
+POKE32(0xfd704138, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG17
+*/
+POKE32(0xfd704144, 0x00020000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG18
+*/
+POKE32(0xfd704148, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG55
+*/
+POKE32(0xfd7041dc, 0x07fc0284)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG56
+*/
+POKE32(0xfd7041e0, 0x07fc0284)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG42
+*/
+POKE32(0xfd7041a8, 0x07b7dbed)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG43
+*/
+POKE32(0xfd7041ac, 0x980001ed)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG44
+*/
+POKE32(0xfd7041b0, 0x87b7dbed)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG45
+*/
+POKE32(0xfd7041b4, 0x180001ed)
+/* PEEK(0xfd70412c) (used target peek value 0x080006a1) */
+/* PEEK(0xfd704130) (used target peek value 0xa200687f) */
+/* PEEK(0xfd704134) (used target peek value 0x00020000) */
+/* PEEK(0xfd704138) (used target peek value 0x00000000) */
+/* PEEK(0xfd70413c) (used target peek value 0x08000001) */
+/* PEEK(0xfd704140) (used target peek value 0xa200687f) */
+/* PEEK(0xfd704144) (used target peek value 0x00020000) */
+/* PEEK(0xfd704148) (used target peek value 0x00000000) */
+/* PEEK(0xfd704198) (used target peek value 0x002ffd08) */
+/* PEEK(0xfd70419c) (used target peek value 0x002ffd18) */
+/* PEEK(0xfd7041a8) (used target peek value 0x07b7dbed) */
+/* PEEK(0xfd7041ac) (used target peek value 0x980001ed) */
+/* PEEK(0xfd7041b0) (used target peek value 0x87b7dbed) */
+/* PEEK(0xfd7041b4) (used target peek value 0x180001ed) */
+/* PEEK(0xfd7041cc) (used target peek value 0x00000000) */
+/* PEEK(0xfd7041d0) (used target peek value 0x00000000) */
+/* PEEK(0xfd7041d4) (used target peek value 0x00000000) */
+/* PEEK(0xfd7041d8) (used target peek value 0x00000000) */
+/* PEEK(0xfd7041dc) (used target peek value 0x07fc0284) */
+/* PEEK(0xfd7041e0) (used target peek value 0x07fc0284) */
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfdf00860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfdf00800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfdf00810, 0x00000008)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfdf00820, 0x0000000c)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfdf00830, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfdf00840, 0x00000014)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfdf00100, 0x001016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfdf00108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfdf00110, 0x9d220000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfdf00118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfdf00180, 0x002046f9)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfdf00188, 0xa5a00000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfdf00190, 0xa5a20000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfdf00198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
+*/
+POKE32(0xfdf00200, 0x042086f1)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
+*/
+POKE32(0xfdf00208, 0x8a002200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
+*/
+POKE32(0xfdf00210, 0x8a004200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
+*/
+POKE32(0xfdf00218, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfdf00028, 0x00000050)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd18008, 0x07f6015b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfdd1800c, 0xffff0500)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfdd18018, 0xcd2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfdd1801c, 0x002202d6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfdd18030, 0x18001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfdd18038, 0x18001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd18008, 0x07f6035b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfdd18028, 0x00000000)
+POKE32(0xa8000000, 0x00000000)
+POKE32(0xa8000000, 0xaaaaaaaa)
+/* PEEK(0xa8000000) (used target peek value 0xaaaaaaaa) */
+POKE32(0xa8001000, 0x00000000)
+POKE32(0xa8001000, 0x55555555)
+/* PEEK(0xa8001000) (used target peek value 0x55555555) */
+POKE32(0xa8002000, 0x00000000)
+POKE32(0xa8002000, 0x12345678)
+/* PEEK(0xa8002000) (used target peek value 0x12345678) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd19008, 0x07f6015b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfdd1900c, 0xffff0500)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfdd19018, 0xcd2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfdd1901c, 0x002202d6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfdd19030, 0x1c001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfdd19038, 0x1c001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd19008, 0x07f6035b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfdd19028, 0x00000000)
+POKE32(0xb8000000, 0x00000000)
+POKE32(0xb8000000, 0xaaaaaaaa)
+/* PEEK(0xb8000000) (used target peek value 0xaaaaaaaa) */
+POKE32(0xb8001000, 0x00000000)
+POKE32(0xb8001000, 0x55555555)
+/* PEEK(0xb8001000) (used target peek value 0x55555555) */
+POKE32(0xb8002000, 0x00000000)
+POKE32(0xb8002000, 0x12345678)
+/* PEEK(0xb8002000) (used target peek value 0x12345678) */
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+/* PEEK(0xfd704114) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+POKE32(0xfd704114, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+/* PEEK(0xfd704124) (used target peek value 0x00000a8c) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+POKE32(0xfd704124, 0x08000a8c)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+/* PEEK(0xfd704174) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG28
+*/
+POKE32(0xfd704170, 0x00004001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+/* PEEK(0xfd704174) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+POKE32(0xfd704174, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+/* PEEK(0xfd704174) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+POKE32(0xfd704174, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+/* PEEK(0xfd704114) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+POKE32(0xfd704114, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+/* PEEK(0xfd704124) (used target peek value 0x08000a8c) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+POKE32(0xfd704124, 0x08000a8c)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+/* PEEK(0xfd70416c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG26
+*/
+POKE32(0xfd704168, 0x00004001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+/* PEEK(0xfd70416c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+POKE32(0xfd70416c, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+/* PEEK(0xfd70416c) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+POKE32(0xfd70416c, 0x00000000)
diff --git a/board/cb103/init-cb103.S b/board/cb103/init-cb103.S
new file mode 100644
index 0000000..5a1b661
--- /dev/null
+++ b/board/cb103/init-cb103.S
@@ -0,0 +1,75 @@
+#include "asm/stx7200reg.h"
+#include "../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb671.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:cb103:st40
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "cb103" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
+	 */
+#include "cb103.romgen"
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI0 and LMI1 base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+	POKE_LONG(ST40_LMI_SDRA0_0(0), 0x50001a00)
+	POKE_LONG(ST40_LMI_SDRA1_0(0), 0x50001a00)
+	POKE_LONG(ST40_LMI_SDRA0_0(1), 0x90001a00)
+	POKE_LONG(ST40_LMI_SDRA1_0(1), 0x90001a00)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/hms1/Makefile b/board/hms1/Makefile
index c2c83a3..08e99d9 100644
--- a/board/hms1/Makefile
+++ b/board/hms1/Makefile
@@ -27,7 +27,7 @@ LIB	= lib$(BOARD).a
 
 AOBJS	= init-hms1.o
 
-COBJS	= $(BOARD).o sconsole.o
+COBJS	= $(BOARD).o
 
 OBJS	= $(COBJS) $(AOBJS)
 
diff --git a/board/hms1/sconsole.c b/board/hms1/sconsole.c
deleted file mode 100644
index af92525..0000000
--- a/board/hms1/sconsole.c
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-
-#include "sconsole.h"
-
-#if 0
-void (*sconsole_putc) (char) = 0;
-void (*sconsole_puts) (const char *) = 0;
-int (*sconsole_getc) (void) = 0;
-int (*sconsole_tstc) (void) = 0;
-void (*sconsole_setbrg) (void) = 0;
-#endif
-
-#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
-int serial_init (void)
-{
-	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-	sb->pos = 0;
-	sb->size = 0;
-	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
-
-	return (0);
-}
-
-void serial_putc (char c)
-{
-	if (sconsole_putc) {
-		(*sconsole_putc) (c);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		if (c) {
-			sb->data[sb->pos++] = c;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-void serial_puts (const char *s)
-{
-	if (sconsole_puts) {
-		(*sconsole_puts) (s);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		while (*s) {
-			sb->data[sb->pos++] = *s++;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-int serial_getc (void)
-{
-	if (sconsole_getc) {
-		return (*sconsole_getc) ();
-	} else {
-		return 0;
-	}
-}
-
-int serial_tstc (void)
-{
-	if (sconsole_tstc) {
-		return (*sconsole_tstc) ();
-	} else {
-		return 0;
-	}
-}
-
-void serial_setbrg (void)
-{
-	if (sconsole_setbrg) {
-		(*sconsole_setbrg) ();
-	}
-}
-
-void sconsole_flush (void)
-{
-	if (sconsole_putc) {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-		unsigned int end = sb->pos < sb->size
-			? sb->pos + sb->max_size - sb->size
-			: sb->pos - sb->size;
-
-		while (sb->size) {
-			(*sconsole_putc) (sb->data[end++]);
-			if (end == sb->max_size) {
-				end = 0;
-			}
-			sb->size--;
-		}
-	}
-}
-#endif
diff --git a/board/hms1/sconsole.h b/board/hms1/sconsole.h
deleted file mode 100644
index 1666f21..0000000
--- a/board/hms1/sconsole.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef _SCONSOLE_H_
-#define _SCONSOLE_H_
-
-#include <config.h>
-
-typedef struct sconsole_buffer_s
-{
-	unsigned long size;
-	unsigned long max_size;
-	unsigned long pos;
-	char data[1];
-} sconsole_buffer_t;
-
-#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
-
-extern void (*sconsole_putc) (char);
-extern void (*sconsole_puts) (const char *);
-extern int (*sconsole_getc) (void);
-extern int (*sconsole_tstc) (void);
-extern void (*sconsole_setbrg) (void);
-
-extern void sconsole_flush (void);
-
-#endif
diff --git a/board/mb411/Makefile b/board/mb411/Makefile
index b06feaa..9c17e88 100644
--- a/board/mb411/Makefile
+++ b/board/mb411/Makefile
@@ -27,7 +27,7 @@ LIB	= lib$(BOARD).a
 
 AOBJS	= init-$(BOARD).o
 
-COBJS	= $(BOARD).o sconsole.o
+COBJS	= $(BOARD).o
 
 OBJS	= $(COBJS) $(AOBJS)
 
diff --git a/board/mb411/sconsole.c b/board/mb411/sconsole.c
deleted file mode 100644
index af92525..0000000
--- a/board/mb411/sconsole.c
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-
-#include "sconsole.h"
-
-#if 0
-void (*sconsole_putc) (char) = 0;
-void (*sconsole_puts) (const char *) = 0;
-int (*sconsole_getc) (void) = 0;
-int (*sconsole_tstc) (void) = 0;
-void (*sconsole_setbrg) (void) = 0;
-#endif
-
-#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
-int serial_init (void)
-{
-	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-	sb->pos = 0;
-	sb->size = 0;
-	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
-
-	return (0);
-}
-
-void serial_putc (char c)
-{
-	if (sconsole_putc) {
-		(*sconsole_putc) (c);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		if (c) {
-			sb->data[sb->pos++] = c;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-void serial_puts (const char *s)
-{
-	if (sconsole_puts) {
-		(*sconsole_puts) (s);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		while (*s) {
-			sb->data[sb->pos++] = *s++;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-int serial_getc (void)
-{
-	if (sconsole_getc) {
-		return (*sconsole_getc) ();
-	} else {
-		return 0;
-	}
-}
-
-int serial_tstc (void)
-{
-	if (sconsole_tstc) {
-		return (*sconsole_tstc) ();
-	} else {
-		return 0;
-	}
-}
-
-void serial_setbrg (void)
-{
-	if (sconsole_setbrg) {
-		(*sconsole_setbrg) ();
-	}
-}
-
-void sconsole_flush (void)
-{
-	if (sconsole_putc) {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-		unsigned int end = sb->pos < sb->size
-			? sb->pos + sb->max_size - sb->size
-			: sb->pos - sb->size;
-
-		while (sb->size) {
-			(*sconsole_putc) (sb->data[end++]);
-			if (end == sb->max_size) {
-				end = 0;
-			}
-			sb->size--;
-		}
-	}
-}
-#endif
diff --git a/board/mb411/sconsole.h b/board/mb411/sconsole.h
deleted file mode 100644
index 1666f21..0000000
--- a/board/mb411/sconsole.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef _SCONSOLE_H_
-#define _SCONSOLE_H_
-
-#include <config.h>
-
-typedef struct sconsole_buffer_s
-{
-	unsigned long size;
-	unsigned long max_size;
-	unsigned long pos;
-	char data[1];
-} sconsole_buffer_t;
-
-#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
-
-extern void (*sconsole_putc) (char);
-extern void (*sconsole_puts) (const char *);
-extern int (*sconsole_getc) (void);
-extern int (*sconsole_tstc) (void);
-extern void (*sconsole_setbrg) (void);
-
-extern void sconsole_flush (void);
-
-#endif
diff --git a/board/mb442/Makefile b/board/mb442/Makefile
index b06feaa..9c17e88 100644
--- a/board/mb442/Makefile
+++ b/board/mb442/Makefile
@@ -27,7 +27,7 @@ LIB	= lib$(BOARD).a
 
 AOBJS	= init-$(BOARD).o
 
-COBJS	= $(BOARD).o sconsole.o
+COBJS	= $(BOARD).o
 
 OBJS	= $(COBJS) $(AOBJS)
 
diff --git a/board/mb442/sconsole.c b/board/mb442/sconsole.c
deleted file mode 100644
index af92525..0000000
--- a/board/mb442/sconsole.c
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-
-#include "sconsole.h"
-
-#if 0
-void (*sconsole_putc) (char) = 0;
-void (*sconsole_puts) (const char *) = 0;
-int (*sconsole_getc) (void) = 0;
-int (*sconsole_tstc) (void) = 0;
-void (*sconsole_setbrg) (void) = 0;
-#endif
-
-#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
-int serial_init (void)
-{
-	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-	sb->pos = 0;
-	sb->size = 0;
-	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
-
-	return (0);
-}
-
-void serial_putc (char c)
-{
-	if (sconsole_putc) {
-		(*sconsole_putc) (c);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		if (c) {
-			sb->data[sb->pos++] = c;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-void serial_puts (const char *s)
-{
-	if (sconsole_puts) {
-		(*sconsole_puts) (s);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		while (*s) {
-			sb->data[sb->pos++] = *s++;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-int serial_getc (void)
-{
-	if (sconsole_getc) {
-		return (*sconsole_getc) ();
-	} else {
-		return 0;
-	}
-}
-
-int serial_tstc (void)
-{
-	if (sconsole_tstc) {
-		return (*sconsole_tstc) ();
-	} else {
-		return 0;
-	}
-}
-
-void serial_setbrg (void)
-{
-	if (sconsole_setbrg) {
-		(*sconsole_setbrg) ();
-	}
-}
-
-void sconsole_flush (void)
-{
-	if (sconsole_putc) {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-		unsigned int end = sb->pos < sb->size
-			? sb->pos + sb->max_size - sb->size
-			: sb->pos - sb->size;
-
-		while (sb->size) {
-			(*sconsole_putc) (sb->data[end++]);
-			if (end == sb->max_size) {
-				end = 0;
-			}
-			sb->size--;
-		}
-	}
-}
-#endif
diff --git a/board/mb442/sconsole.h b/board/mb442/sconsole.h
deleted file mode 100644
index 1666f21..0000000
--- a/board/mb442/sconsole.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef _SCONSOLE_H_
-#define _SCONSOLE_H_
-
-#include <config.h>
-
-typedef struct sconsole_buffer_s
-{
-	unsigned long size;
-	unsigned long max_size;
-	unsigned long pos;
-	char data[1];
-} sconsole_buffer_t;
-
-#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
-
-extern void (*sconsole_putc) (char);
-extern void (*sconsole_puts) (const char *);
-extern int (*sconsole_getc) (void);
-extern int (*sconsole_tstc) (void);
-extern void (*sconsole_setbrg) (void);
-
-extern void sconsole_flush (void);
-
-#endif
diff --git a/board/mb448/Makefile b/board/mb448/Makefile
index b06feaa..9c17e88 100644
--- a/board/mb448/Makefile
+++ b/board/mb448/Makefile
@@ -27,7 +27,7 @@ LIB	= lib$(BOARD).a
 
 AOBJS	= init-$(BOARD).o
 
-COBJS	= $(BOARD).o sconsole.o
+COBJS	= $(BOARD).o
 
 OBJS	= $(COBJS) $(AOBJS)
 
diff --git a/board/mb448/sconsole.c b/board/mb448/sconsole.c
deleted file mode 100644
index af92525..0000000
--- a/board/mb448/sconsole.c
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-
-#include "sconsole.h"
-
-#if 0
-void (*sconsole_putc) (char) = 0;
-void (*sconsole_puts) (const char *) = 0;
-int (*sconsole_getc) (void) = 0;
-int (*sconsole_tstc) (void) = 0;
-void (*sconsole_setbrg) (void) = 0;
-#endif
-
-#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
-int serial_init (void)
-{
-	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-	sb->pos = 0;
-	sb->size = 0;
-	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
-
-	return (0);
-}
-
-void serial_putc (char c)
-{
-	if (sconsole_putc) {
-		(*sconsole_putc) (c);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		if (c) {
-			sb->data[sb->pos++] = c;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-void serial_puts (const char *s)
-{
-	if (sconsole_puts) {
-		(*sconsole_puts) (s);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		while (*s) {
-			sb->data[sb->pos++] = *s++;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-int serial_getc (void)
-{
-	if (sconsole_getc) {
-		return (*sconsole_getc) ();
-	} else {
-		return 0;
-	}
-}
-
-int serial_tstc (void)
-{
-	if (sconsole_tstc) {
-		return (*sconsole_tstc) ();
-	} else {
-		return 0;
-	}
-}
-
-void serial_setbrg (void)
-{
-	if (sconsole_setbrg) {
-		(*sconsole_setbrg) ();
-	}
-}
-
-void sconsole_flush (void)
-{
-	if (sconsole_putc) {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-		unsigned int end = sb->pos < sb->size
-			? sb->pos + sb->max_size - sb->size
-			: sb->pos - sb->size;
-
-		while (sb->size) {
-			(*sconsole_putc) (sb->data[end++]);
-			if (end == sb->max_size) {
-				end = 0;
-			}
-			sb->size--;
-		}
-	}
-}
-#endif
diff --git a/board/mb448/sconsole.h b/board/mb448/sconsole.h
deleted file mode 100644
index 1666f21..0000000
--- a/board/mb448/sconsole.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef _SCONSOLE_H_
-#define _SCONSOLE_H_
-
-#include <config.h>
-
-typedef struct sconsole_buffer_s
-{
-	unsigned long size;
-	unsigned long max_size;
-	unsigned long pos;
-	char data[1];
-} sconsole_buffer_t;
-
-#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
-
-extern void (*sconsole_putc) (char);
-extern void (*sconsole_puts) (const char *);
-extern int (*sconsole_getc) (void);
-extern int (*sconsole_tstc) (void);
-extern void (*sconsole_setbrg) (void);
-
-extern void sconsole_flush (void);
-
-#endif
diff --git a/board/mb519/Makefile b/board/mb519/Makefile
index 1f1f703..70041dd 100644
--- a/board/mb519/Makefile
+++ b/board/mb519/Makefile
@@ -27,7 +27,7 @@ LIB	= lib$(BOARD).a
 
 AOBJS	= init-$(BOARD).o
 
-COBJS	= $(BOARD).o sconsole.o
+COBJS	= $(BOARD).o
 
 OBJS	= $(COBJS) $(AOBJS)
 
diff --git a/board/mb519/sconsole.c b/board/mb519/sconsole.c
deleted file mode 100644
index af92525..0000000
--- a/board/mb519/sconsole.c
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-
-#include "sconsole.h"
-
-#if 0
-void (*sconsole_putc) (char) = 0;
-void (*sconsole_puts) (const char *) = 0;
-int (*sconsole_getc) (void) = 0;
-int (*sconsole_tstc) (void) = 0;
-void (*sconsole_setbrg) (void) = 0;
-#endif
-
-#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
-int serial_init (void)
-{
-	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-	sb->pos = 0;
-	sb->size = 0;
-	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
-
-	return (0);
-}
-
-void serial_putc (char c)
-{
-	if (sconsole_putc) {
-		(*sconsole_putc) (c);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		if (c) {
-			sb->data[sb->pos++] = c;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-void serial_puts (const char *s)
-{
-	if (sconsole_puts) {
-		(*sconsole_puts) (s);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		while (*s) {
-			sb->data[sb->pos++] = *s++;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-int serial_getc (void)
-{
-	if (sconsole_getc) {
-		return (*sconsole_getc) ();
-	} else {
-		return 0;
-	}
-}
-
-int serial_tstc (void)
-{
-	if (sconsole_tstc) {
-		return (*sconsole_tstc) ();
-	} else {
-		return 0;
-	}
-}
-
-void serial_setbrg (void)
-{
-	if (sconsole_setbrg) {
-		(*sconsole_setbrg) ();
-	}
-}
-
-void sconsole_flush (void)
-{
-	if (sconsole_putc) {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-		unsigned int end = sb->pos < sb->size
-			? sb->pos + sb->max_size - sb->size
-			: sb->pos - sb->size;
-
-		while (sb->size) {
-			(*sconsole_putc) (sb->data[end++]);
-			if (end == sb->max_size) {
-				end = 0;
-			}
-			sb->size--;
-		}
-	}
-}
-#endif
diff --git a/board/mb519/sconsole.h b/board/mb519/sconsole.h
deleted file mode 100644
index 1666f21..0000000
--- a/board/mb519/sconsole.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef _SCONSOLE_H_
-#define _SCONSOLE_H_
-
-#include <config.h>
-
-typedef struct sconsole_buffer_s
-{
-	unsigned long size;
-	unsigned long max_size;
-	unsigned long pos;
-	char data[1];
-} sconsole_buffer_t;
-
-#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
-
-extern void (*sconsole_putc) (char);
-extern void (*sconsole_puts) (const char *);
-extern int (*sconsole_getc) (void);
-extern int (*sconsole_tstc) (void);
-extern void (*sconsole_setbrg) (void);
-
-extern void sconsole_flush (void);
-
-#endif
diff --git a/board/mb618/Makefile b/board/mb618/Makefile
index ff0f69a..219443a 100644
--- a/board/mb618/Makefile
+++ b/board/mb618/Makefile
@@ -27,7 +27,7 @@ LIB	= lib$(BOARD).a
 
 AOBJS	= init-$(BOARD).o
 
-COBJS	= $(BOARD).o sconsole.o nand.o
+COBJS	= $(BOARD).o nand.o
 
 OBJS	= $(COBJS) $(AOBJS)
 
diff --git a/board/mb618/init-mb618.S b/board/mb618/init-mb618.S
index 273f471..1cc7e31 100644
--- a/board/mb618/init-mb618.S
+++ b/board/mb618/init-mb618.S
@@ -156,9 +156,6 @@ __memory_setup_table:
 
 	/* ----- STX7111 EMI configuration ----- */
 
-//#define APRIL_2008_FILES	/* Define if using targetpacks from April'08 vintage */
-#ifdef APRIL_2008_FILES
-
 	POKE32(ST40_EMI_BANK_ENABLE, 0x00000005)
 
 	/* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
@@ -203,46 +200,6 @@ __memory_setup_table:
 	/* Program other EMI registers */
 	POKE32(ST40_EMI_GENCFG, 0x00000010)
 
-#else	/* else, pre- APRIL_2008_FILES */
-
-	POKE32(ST40_EMI_BANK_ENABLE, 0x00000005)
-
-	/* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
-	POKE32(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
-	POKE32(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
-	POKE32(ST40_EMI_BANK2_BASEADDRESS, 0x0000000c)
-	POKE32(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
-	POKE32(ST40_EMI_BANK4_BASEADDRESS, 0x00000012)
-
-	/* Bank 0 - On-board 32MiB Flash at address 0x00000000 -> 0x01ffffff */
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
-
-	/* Bank 1 - Not configured */
-
-	/* Bank 2 - 16MiB DVB-CI at address 0x03000000 -> 0x03FFFFFF */
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
-
-	/* Bank 3 - EPLD Registers at address 0x04000000 -> 0x04FFFFFF */
-	POKE32(ST40_EMI_BANK3_EMICONFIGDATA0, 0x002016d1)
-	POKE32(ST40_EMI_BANK3_EMICONFIGDATA1, 0x9d222200)
-	POKE32(ST40_EMI_BANK3_EMICONFIGDATA2, 0x9d220044)
-	POKE32(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
-
-	/* Bank 4 - 8MiB STEM at address 0x04800000 -> 0x04ffffff */
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA0, 0x002016d1)
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA1, 0x9d222200)
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA2, 0x9d220044)
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)
-
-	/* Program other EMI registers */
-	POKE32(ST40_EMI_GENCFG, 0x00000000)
-#endif	/* APRIL_2008_FILES */
 
 	/* ----- STX7111 LMI0 configuration ----- */
 
@@ -393,8 +350,11 @@ __memory_setup_table:
 	 */
 	UPDATE_LONG(STX7111_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
 	UPDATE_LONG(STX7111_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
-	POKE_LONG(ST40_LMI_SDRA0_0(), 0x48000a00)
-	POKE_LONG(ST40_LMI_SDRA1_0(), 0x48000a00)
+	/* Change LMI upper bound addresses
+	 * Upper LMI addr=0x40000000 + 128Mbytes=0x48000000, 13x10
+	 */
+	UPDATE32(ST40_LMI_SDRA0_0(), 0x001FFFFF, (0x48000000 & 0xFFE00000))
+	UPDATE32(ST40_LMI_SDRA1_0(), 0x001FFFFF, (0x48000000 & 0xFFE00000))
 #endif	/* CONFIG_SH_SE_MODE */
 
 	END_MARKER
diff --git a/board/mb618/sconsole.c b/board/mb618/sconsole.c
deleted file mode 100644
index af92525..0000000
--- a/board/mb618/sconsole.c
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-
-#include "sconsole.h"
-
-#if 0
-void (*sconsole_putc) (char) = 0;
-void (*sconsole_puts) (const char *) = 0;
-int (*sconsole_getc) (void) = 0;
-int (*sconsole_tstc) (void) = 0;
-void (*sconsole_setbrg) (void) = 0;
-#endif
-
-#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
-int serial_init (void)
-{
-	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-	sb->pos = 0;
-	sb->size = 0;
-	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
-
-	return (0);
-}
-
-void serial_putc (char c)
-{
-	if (sconsole_putc) {
-		(*sconsole_putc) (c);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		if (c) {
-			sb->data[sb->pos++] = c;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-void serial_puts (const char *s)
-{
-	if (sconsole_puts) {
-		(*sconsole_puts) (s);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		while (*s) {
-			sb->data[sb->pos++] = *s++;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-int serial_getc (void)
-{
-	if (sconsole_getc) {
-		return (*sconsole_getc) ();
-	} else {
-		return 0;
-	}
-}
-
-int serial_tstc (void)
-{
-	if (sconsole_tstc) {
-		return (*sconsole_tstc) ();
-	} else {
-		return 0;
-	}
-}
-
-void serial_setbrg (void)
-{
-	if (sconsole_setbrg) {
-		(*sconsole_setbrg) ();
-	}
-}
-
-void sconsole_flush (void)
-{
-	if (sconsole_putc) {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-		unsigned int end = sb->pos < sb->size
-			? sb->pos + sb->max_size - sb->size
-			: sb->pos - sb->size;
-
-		while (sb->size) {
-			(*sconsole_putc) (sb->data[end++]);
-			if (end == sb->max_size) {
-				end = 0;
-			}
-			sb->size--;
-		}
-	}
-}
-#endif
diff --git a/board/mb618/sconsole.h b/board/mb618/sconsole.h
deleted file mode 100644
index 1666f21..0000000
--- a/board/mb618/sconsole.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef _SCONSOLE_H_
-#define _SCONSOLE_H_
-
-#include <config.h>
-
-typedef struct sconsole_buffer_s
-{
-	unsigned long size;
-	unsigned long max_size;
-	unsigned long pos;
-	char data[1];
-} sconsole_buffer_t;
-
-#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
-
-extern void (*sconsole_putc) (char);
-extern void (*sconsole_puts) (const char *);
-extern int (*sconsole_getc) (void);
-extern int (*sconsole_tstc) (void);
-extern void (*sconsole_setbrg) (void);
-
-extern void sconsole_flush (void);
-
-#endif
diff --git a/board/mb628/Makefile b/board/mb628/Makefile
index ff0f69a..219443a 100644
--- a/board/mb628/Makefile
+++ b/board/mb628/Makefile
@@ -27,7 +27,7 @@ LIB	= lib$(BOARD).a
 
 AOBJS	= init-$(BOARD).o
 
-COBJS	= $(BOARD).o sconsole.o nand.o
+COBJS	= $(BOARD).o nand.o
 
 OBJS	= $(COBJS) $(AOBJS)
 
diff --git a/board/mb628/config.mk b/board/mb628/config.mk
index 9e31df5..c23d067 100644
--- a/board/mb628/config.mk
+++ b/board/mb628/config.mk
@@ -1,5 +1,5 @@
 #
-# (C) Copyright 2008 STMicroelectronics.
+# (C) Copyright 2008-2009 STMicroelectronics.
 # Sean McGoogan <Sean.McGoogan@st.com>
 #
 # See file CREDITS for list of people who contributed to this
@@ -24,10 +24,23 @@
 #
 # MB628 board:
 #
+#	Following are *Physical* Addresses:
+#
+#	Region		29-bit		32-bit		Size
+#	------		------		------		----
+#	LMI_BASE	0x0c000000	0x40000000	128MiB
+#	VIDEO_BASE	0x0c000000	0x40000000	  4MiB
+#	AUDIO_BASE	0x0c400000	0x40400000	  4MiB
+#	eSTB_BASE	0x0c800000	0x40800000	 50MiB
+#	eSTB_END	0x0f9fffff	0x439fffff	   ---
+#
+#
+#	Following are *Virtual* Addresses:
+#
 #	Valid values for TEXT_BASE are:
 #
-#	0x8F700000	29-bit mode (Traditional Mode)
-#	0x87F00000	32-bit mode (Space-Enhancement Mode)	QQQ
+#	0x8F900000	29-bit mode (Traditional Mode)
+#	0x83900000	32-bit mode (Space-Enhancement Mode)
 #
 # Note:	Alternative definitions of TEXT_BASE are put into
 #	'config.tmp' from the top-level 'Makefile'.
@@ -36,8 +49,8 @@
 sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
 
 ifndef TEXT_BASE
-# Installs at eSTB BASE + 47MB in P1 (cachable)
-TEXT_BASE = 0x8F700000
+# Installs at eSTB BASE + 49MB in P1 (cachable)
+TEXT_BASE = 0x8F900000
 endif
 
 PLATFORM_LDFLAGS +=
diff --git a/board/mb628/init-mb628.S b/board/mb628/init-mb628.S
index b315e05..9f65bb5 100644
--- a/board/mb628/init-mb628.S
+++ b/board/mb628/init-mb628.S
@@ -29,15 +29,43 @@
 #define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
 #define DELAY(VAL)				/* do nothing */
 
-.balign 32
 
+	.balign 32
 
 __memory_setup_table:
 
-/* QQQ - TO DO */
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:mb628:estb
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "mb628" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
+	 */
+#include "mb628.romgen"
 
 #ifdef CONFIG_SH_SE_MODE
-#error QQQ
+	/*
+	 * Note that we also manually need to move the LMI0 and LMI1 base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE32(STX7141_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	UPDATE32(STX7141_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+	UPDATE32(ST40_LMI_SDRA0_0(0), 0x001FFFFF, 0x48000000)
+	UPDATE32(ST40_LMI_SDRA1_0(0), 0x001FFFFF, 0x48000000)
+	UPDATE32(ST40_LMI_SDRA0_0(1), 0x001FFFFF, 0x88000000)
+	UPDATE32(ST40_LMI_SDRA1_0(1), 0x001FFFFF, 0x88000000)
 #endif	/* CONFIG_SH_SE_MODE */
 
 	END_MARKER
diff --git a/board/mb628/mb628.c b/board/mb628/mb628.c
index 71e7c20..0a72207 100644
--- a/board/mb628/mb628.c
+++ b/board/mb628/mb628.c
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2008 STMicroelectronics.
+ * (C) Copyright 2008-2009 STMicroelectronics.
  *
  * Sean McGoogan <Sean.McGoogan@st.com>
  *
@@ -31,7 +31,7 @@
 
 /* EPLD registers */
 #ifdef CONFIG_SH_SE_MODE
-#define EPLD_BASE		0xb5000000	/* Phys 0x05050000 */
+#define EPLD_BASE		0xb5000000	/* Phys 0x05000000 */
 #else
 #define EPLD_BASE		0xa5000000
 #endif	/* CONFIG_SH_SE_MODE */
diff --git a/board/mb628/mb628.romgen b/board/mb628/mb628.romgen
new file mode 100644
index 0000000..6b96f99
--- /dev/null
+++ b/board/mb628/mb628.romgen
@@ -0,0 +1,2423 @@
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x0d43c041) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x0d43c041) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+/* PEEK(0xfe21301c) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+WHILE_NE32(0xfe21301c, 0xffffffff, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+/* PEEK(0xfe213020) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+WHILE_NE32(0xfe213020, 0xffffffff, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80003805) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80103805)
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000001)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x00183805) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x00180f01)
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000001) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+WHILE_NE32(0xfe213000, 0x80000000, 0x80000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80000f01)
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80004a05) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80104a05)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV0_CFG
+*/
+POKE32(0xfe213b00, 0x00000103)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV1_CFG
+*/
+POKE32(0xfe213b04, 0x00000001)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV2_CFG
+*/
+POKE32(0xfe213b08, 0x00000001)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV3_CFG
+*/
+POKE32(0xfe213b0c, 0x00000001)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0LS_DIV4_CFG
+*/
+POKE32(0xfe213a10, 0x00010100)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0LS_DIV5_CFG
+*/
+POKE32(0xfe213a14, 0x00010100)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0LS_DIV6_CFG
+*/
+POKE32(0xfe213a18, 0x00010100)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0LS_DIV7_CFG
+*/
+POKE32(0xfe213a1c, 0x00010100)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV8_CFG
+*/
+POKE32(0xfe213b20, 0x00000103)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV9_CFG
+*/
+POKE32(0xfe213b24, 0x00000103)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV10_CFG
+*/
+POKE32(0xfe213b28, 0x00000307)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV11_CFG
+*/
+POKE32(0xfe213b2c, 0x00000103)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV12_CFG
+*/
+POKE32(0xfe213b30, 0x00000102)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0LS_DIV13_CFG
+*/
+POKE32(0xfe213a34, 0x00000811)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV14_CFG
+*/
+POKE32(0xfe213b38, 0x0000050b)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV15_CFG
+*/
+POKE32(0xfe213b3c, 0x00000307)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV16_CFG
+*/
+POKE32(0xfe213b40, 0x00000103)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV17_CFG
+*/
+POKE32(0xfe213b44, 0x00000103)
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000002)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x00184a05) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x00182803)
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000002) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+WHILE_NE32(0xfe213004, 0x80000000, 0x80000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80002803)
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0xa6aa55aa)
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x0000000a)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00000d28) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x00001d28)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00001d28) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000016a0)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000016a0) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000006a0)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00000001, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213a10) (used target peek value 0x00010100) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213a14) (used target peek value 0x00010100) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213a18) (used target peek value 0x00010100) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213a1c) (used target peek value 0x00010100) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b04) (used target peek value 0x00000001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b08) (used target peek value 0x00000001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b0c) (used target peek value 0x00000001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b00) (used target peek value 0x00000103) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b20) (used target peek value 0x00000103) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b24) (used target peek value 0x00000103) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b40) (used target peek value 0x00000103) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b44) (used target peek value 0x00000103) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b28) (used target peek value 0x00000307) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b2c) (used target peek value 0x00000103) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b30) (used target peek value 0x00000102) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213a34) (used target peek value 0x00000811) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b38) (used target peek value 0x0000050b) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b3c) (used target peek value 0x00000307) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000006) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x00000002)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x081b06a1)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG15
+*/
+/* PEEK(0xfe00113c) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG15
+*/
+POKE32(0xfe00113c, 0x081b0001)
+DELAY(200)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000002) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x00000006)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000787f)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG16
+*/
+POKE32(0xfe001140, 0xa000787f)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x000f000c)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG39
+*/
+POKE32(0xfe00119c, 0x000f0014)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x0042000a)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG17
+*/
+POKE32(0xfe001144, 0x0042000a)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG18
+*/
+POKE32(0xfe001148, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x0800239e)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG37
+*/
+POKE32(0xfe001194, 0x0800039e)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x0000d068)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG44
+*/
+POKE32(0xfe0011b0, 0x0000d068)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG45
+*/
+POKE32(0xfe0011b4, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG53
+*/
+POKE32(0xfe0011d4, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG54
+*/
+POKE32(0xfe0011d8, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfe700860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfe700800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfe700810, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfe700820, 0x00000012)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfe700830, 0x00000014)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfe700840, 0x0000001c)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfe700100, 0x001016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfe700108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfe700110, 0x9d220000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfe700118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
+*/
+POKE32(0xfe700140, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
+*/
+POKE32(0xfe700148, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
+*/
+POKE32(0xfe700150, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
+*/
+POKE32(0xfe700158, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfe700180, 0x002046f9)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfe700188, 0xa5a00000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfe700190, 0xa5a20000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfe700198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA0
+*/
+POKE32(0xfe7001c0, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA1
+*/
+POKE32(0xfe7001c8, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA2
+*/
+POKE32(0xfe7001d0, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA3
+*/
+POKE32(0xfe7001d8, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
+*/
+POKE32(0xfe700200, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
+*/
+POKE32(0xfe700208, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
+*/
+POKE32(0xfe700210, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
+*/
+POKE32(0xfe700218, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfe700028, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x081b06a1) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30013b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfe90100c, 0xffff0500)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfe901018, 0x4d2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfe90101c, 0x00222ed6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfe901030, 0x14001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfe901038, 0x14001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30013b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30033b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30033b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30031b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfe901028, 0x00000000)
+POKE32(0xac000000, 0x00000000)
+POKE32(0xac000000, 0xaaaaaaaa)
+/* PEEK(0xac000000) (used target peek value 0xaaaaaaaa) */
+POKE32(0xac001000, 0x00000000)
+POKE32(0xac001000, 0x55555555)
+/* PEEK(0xac001000) (used target peek value 0x55555555) */
+POKE32(0xac002000, 0x00000000)
+POKE32(0xac002000, 0x12345678)
+/* PEEK(0xac002000) (used target peek value 0x12345678) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x081b06a1) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe902008, 0x0b30013b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfe90200c, 0xffff0500)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfe902018, 0x4d2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfe90201c, 0x00222ed6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfe902030, 0x1c001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfe902038, 0x1c001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe902048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe902048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe902048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe902048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe902048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe902008) (used target peek value 0x0b30013b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe902008, 0x0b30033b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe902008) (used target peek value 0x0b30033b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe902008, 0x0b30031b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfe902028, 0x00000000)
+POKE32(0xb4000000, 0x00000000)
+POKE32(0xb4000000, 0xaaaaaaaa)
+/* PEEK(0xb4000000) (used target peek value 0xaaaaaaaa) */
+POKE32(0xb4001000, 0x00000000)
+POKE32(0xb4001000, 0x55555555)
+/* PEEK(0xb4001000) (used target peek value 0x55555555) */
+POKE32(0xb4002000, 0x00000000)
+POKE32(0xb4002000, 0x12345678)
+/* PEEK(0xb4002000) (used target peek value 0x12345678) */
+POKE32(0xfe2410fc, 0x00000001)
+POKE32(0xfe20a0ec, 0x00000002)
+POKE32(0xfe20a0f0, 0x00000005)
+POKE32(0xfe20a0f4, 0x00000003)
+POKE32(0xfe20a0f8, 0x00000003)
+POKE32(0xfe20a1ec, 0x00000002)
+POKE32(0xfe20a1f0, 0x00000005)
+POKE32(0xfe20a1f4, 0x00000003)
+POKE32(0xfe20a1f8, 0x00000003)
+POKE32(0xfe20a2ec, 0x00000002)
+POKE32(0xfe20a2f0, 0x00000005)
+POKE32(0xfe20a2f4, 0x00000003)
+POKE32(0xfe20a2f8, 0x00000003)
+POKE32(0xfe20a3ec, 0x00000002)
+POKE32(0xfe20a3f0, 0x00000005)
+POKE32(0xfe20a3f4, 0x00000003)
+POKE32(0xfe20a3f8, 0x00000003)
+POKE32(0xfe20aefc, 0x00000005)
+POKE32(0xfe540034, 0x00000003)
+POKE32(0xfe540038, 0x00000000)
+POKE32(0xfe540110, 0x00010303)
+POKE32(0xfe540114, 0x00000000)
+POKE32(0xfe20bb04, 0x00000005)
+POKE32(0xfe20bb08, 0x00000003)
+POKE32(0xfe20bb0c, 0x00000000)
+POKE32(0xfe20bb10, 0x00000002)
+POKE32(0xfe20bb24, 0x00000005)
+POKE32(0xfe20bb28, 0x00000003)
+POKE32(0xfe20bb2c, 0x00000000)
+POKE32(0xfe20bb30, 0x00000002)
+POKE32(0xfe20bb44, 0x00000005)
+POKE32(0xfe20bb48, 0x00000003)
+POKE32(0xfe20bb4c, 0x00000000)
+POKE32(0xfe20bb50, 0x00000002)
+POKE32(0xfe20bb84, 0x00000005)
+POKE32(0xfe20bb88, 0x00000003)
+POKE32(0xfe20bb8c, 0x00000000)
+POKE32(0xfe20bb90, 0x00000002)
+POKE32(0xfe231010, 0x00000008)
+POKE32(0xfe231080, 0x00000221)
+POKE32(0xfd101024, 0x0003c000)
+POKE32(0xfd101824, 0x0003c000)
+POKE32(0xfd104d24, 0x0003c000)
+POKE32(0xfd102024, 0x0003c000)
+POKE32(0xfd103024, 0x0003c000)
+/* PEEK(0xfe001180) (used target peek value 0x00000015) */
+POKE32(0xfe001180, 0x00000015)
+POKE32(0xfe1fff04, 0x00254608)
+/* PEEK(0xfe001180) (used target peek value 0x00000015) */
+POKE32(0xfe001180, 0x00000015)
+POKE32(0xfe209000, 0x00000013)
+POKE32(0xfe209004, 0x00000003)
+POKE32(0xfe209008, 0x00000000)
+/* PEEK(0xfe00111c) (used target peek value 0x08081000) */
+POKE32(0xfe00111c, 0x080b1000)
+POKE32(0xfd117000, 0x0025c608)
+POKE32(0xfd111000, 0x00201004)
+POKE32(0xfd11f000, 0x0025c608)
+POKE32(0xfd119000, 0x00201004)
+/* PEEK(0xfe001180) (used target peek value 0x00000015) */
+POKE32(0xfe001180, 0x00000011)
+POKE32(0xfe401744, 0x0025c005)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000000)
+POKE32(0xfe000010, 0x0000c0de)
+POKE32(0xfe0000b8, 0x00000000)
+POKE32(0xfe000010, 0x0000c1a0)
+/* PEEK(0xfe210000) (used target peek value 0x00000000) */
+POKE32(0xfe210000, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x00000001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x00000001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x00008001)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x00008001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x00008001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x00008011)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x00008011) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x0000a011)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x0000a011) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x0000a091)
+DELAY(360000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x0000a091) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x0000a891)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x0000a891) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x0000a811)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x0000a811) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x0000a011)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x0000a011) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x00008011)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x00008011) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x00008013)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x10000a8c) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x18000a8c)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG28
+*/
+POKE32(0xfe001170, 0xfe604001)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcd)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcd) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcc)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x18000a8c) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x18000a8c)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x3f800000) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x3f800000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG26
+*/
+POKE32(0xfe001168, 0xfe804001)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd1)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd1) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd0)
diff --git a/board/mb628/sconsole.c b/board/mb628/sconsole.c
deleted file mode 100644
index af92525..0000000
--- a/board/mb628/sconsole.c
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-
-#include "sconsole.h"
-
-#if 0
-void (*sconsole_putc) (char) = 0;
-void (*sconsole_puts) (const char *) = 0;
-int (*sconsole_getc) (void) = 0;
-int (*sconsole_tstc) (void) = 0;
-void (*sconsole_setbrg) (void) = 0;
-#endif
-
-#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
-int serial_init (void)
-{
-	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-	sb->pos = 0;
-	sb->size = 0;
-	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
-
-	return (0);
-}
-
-void serial_putc (char c)
-{
-	if (sconsole_putc) {
-		(*sconsole_putc) (c);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		if (c) {
-			sb->data[sb->pos++] = c;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-void serial_puts (const char *s)
-{
-	if (sconsole_puts) {
-		(*sconsole_puts) (s);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		while (*s) {
-			sb->data[sb->pos++] = *s++;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-int serial_getc (void)
-{
-	if (sconsole_getc) {
-		return (*sconsole_getc) ();
-	} else {
-		return 0;
-	}
-}
-
-int serial_tstc (void)
-{
-	if (sconsole_tstc) {
-		return (*sconsole_tstc) ();
-	} else {
-		return 0;
-	}
-}
-
-void serial_setbrg (void)
-{
-	if (sconsole_setbrg) {
-		(*sconsole_setbrg) ();
-	}
-}
-
-void sconsole_flush (void)
-{
-	if (sconsole_putc) {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-		unsigned int end = sb->pos < sb->size
-			? sb->pos + sb->max_size - sb->size
-			: sb->pos - sb->size;
-
-		while (sb->size) {
-			(*sconsole_putc) (sb->data[end++]);
-			if (end == sb->max_size) {
-				end = 0;
-			}
-			sb->size--;
-		}
-	}
-}
-#endif
diff --git a/board/mb628/sconsole.h b/board/mb628/sconsole.h
deleted file mode 100644
index 1666f21..0000000
--- a/board/mb628/sconsole.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef _SCONSOLE_H_
-#define _SCONSOLE_H_
-
-#include <config.h>
-
-typedef struct sconsole_buffer_s
-{
-	unsigned long size;
-	unsigned long max_size;
-	unsigned long pos;
-	char data[1];
-} sconsole_buffer_t;
-
-#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
-
-extern void (*sconsole_putc) (char);
-extern void (*sconsole_puts) (const char *);
-extern int (*sconsole_getc) (void);
-extern int (*sconsole_tstc) (void);
-extern void (*sconsole_setbrg) (void);
-
-extern void sconsole_flush (void);
-
-#endif
diff --git a/board/mb671/Makefile b/board/mb671/Makefile
index 1f1f703..70041dd 100644
--- a/board/mb671/Makefile
+++ b/board/mb671/Makefile
@@ -27,7 +27,7 @@ LIB	= lib$(BOARD).a
 
 AOBJS	= init-$(BOARD).o
 
-COBJS	= $(BOARD).o sconsole.o
+COBJS	= $(BOARD).o
 
 OBJS	= $(COBJS) $(AOBJS)
 
diff --git a/board/mb671/init-mb671.S b/board/mb671/init-mb671.S
index 2fd9536..89c6597 100644
--- a/board/mb671/init-mb671.S
+++ b/board/mb671/init-mb671.S
@@ -1,4 +1,3 @@
-
 #include "asm/stx7200reg.h"
 #include "../../cpu/sh/init_ram.S"
 
@@ -10,12 +9,11 @@
 /*
  * The poke table is a series of long words, in the format
  *
- *       opcode, address, operand, ...
+ *	opcode, address, operand, ...
  *
  * An opcode of 0 marks the table end
  */
 
-#ifndef CONFIG_STM_NEW_POKE_TABLE_PARADIGM
 /*
  * For compatibility with old poke table code, we define some of the
  * new names, to map onto the old names. Ultimately, the old poke table
@@ -30,420 +28,31 @@
 #define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
 #define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
 #define DELAY(VAL)				/* do nothing */
-#endif /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
 
-.balign 32
 
+	.balign 32
 
 __memory_setup_table:
 
-	/* ----- STx7200 Clocks ----- */
-
-	/* Set CLOCKGENA PLL0 into BYPASS... */
-	OR32(STX7200_CLOCKGENA_PLL0_CFG, 0x00100000)
-
-	/* Power down CLOCKGENA PLL0... */
-	OR32(STX7200_CLOCKGENA_POWER_CFG, 0x00000001)
-
-	/* Configure CLOCKGENA PLL0... */
-#ifdef CONFIG_STM_NEW_POKE_TABLE_PARADIGM
-	IF_EQ32(1, STX7200_SYSCONF_DEVICEID_0, 0x0fffffff, 0x0d437041)
-	  /* On STx7200 cut 2, we can go faster - set to 900MHz */
-	  UPDATE32(STX7200_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
-	ELSE(1)
-	  UPDATE32(STX7200_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x01 | (0x0f << 8) | (0x00 << 16))
-	ENDIF(1)
-#else /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
-	IF_DEVID(STX7200_CUT1)
-	  UPDATE32(STX7200_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x01 | (0x0f << 8) | (0x00 << 16))
-	ENDIF
-	IF_DEVID(STX7200_CUT2)
-	  /* On STx7200 cut 2, we can go faster - set to 900MHz */
-	  UPDATE32(STX7200_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
-	ENDIF
-#endif /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
-
-	/* Enable CLOCKGENA PLL0... */
-	UPDATE32(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffe, 0)
-
-	/* Wait for CLOCKGENA PLL0 to lock... */
-	WHILE_NE32(STX7200_CLOCKGENA_PLL0_CFG, 0x80000000, 0x80000000)
-
-	/* Clear CLOCKGENA PLL0 from BYPASS... */
-	UPDATE32(STX7200_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
-
-	/* Set CLOCKGENA PLL1 into BYPASS... */
-	OR32(STX7200_CLOCKGENA_PLL1_CFG, 0x00100000)
-
-	/* Power down CLOCKGENA PLL1... */
-	OR32(STX7200_CLOCKGENA_POWER_CFG, 0x00000002)
-
-	/* Configure CLOCKGENA PLL1... */
-	UPDATE32(STX7200_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x01 | (0x0f << 8))
-
-	/* Enable CLOCKGENA PLL1... */
-	UPDATE32(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffd, 0)
-
-	/* Wait for CLOCKGENA PLL1 to lock... */
-	WHILE_NE32(STX7200_CLOCKGENA_PLL1_CFG, 0x80000000, 0x80000000)
-
-	/* Clear CLOCKGENA PLL1 from BYPASS... */
-	UPDATE32(STX7200_CLOCKGENA_PLL1_CFG, 0xffefffff, 0)
-
-	/* Set CLOCKGENA PLL2 into BYPASS... */
-	OR32(STX7200_CLOCKGENA_PLL2_CFG, 0x00100000)
-
-	/* Power down CLOCKGENA PLL2... */
-	OR32(STX7200_CLOCKGENA_POWER_CFG, 0x00000004)
-
-	/* Configure CLOCKGENA PLL2... */
-	UPDATE32(STX7200_CLOCKGENA_PLL2_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
-
-	/* Enable CLOCKGENA PLL2... */
-	UPDATE32(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffb, 0)
-
-	/* Wait for CLOCKGENA PLL2 to lock... */
-	WHILE_NE32(STX7200_CLOCKGENA_PLL2_CFG, 0x80000000,  0x80000000)
-
-	/* Clear CLOCKGENA PLL2 from BYPASS... */
-	UPDATE32(STX7200_CLOCKGENA_PLL2_CFG, 0xffefffff, 0)
-
-	/* Set CLOCKGENB PLL0 into BYPASS... */
-	OR32(STX7200_CLOCKGENB_PLL0_CFG, 0x00100000)
-
-	/* Power down CLOCKGENB PLL0... */
-	OR32(STX7200_CLOCKGENB_POWER_CFG, 0x00008000)
-
-	/* Configure CLOCKGENB PLL0... */
-	UPDATE32(STX7200_CLOCKGENB_PLL0_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
-
-	/* Enable CLOCKGENB PLL0... */
-	UPDATE32(STX7200_CLOCKGENB_POWER_CFG, 0xffff7fff, 0)
-
-	/* Wait for CLOCKGENB PLL0 to lock... */
-	WHILE_NE32(STX7200_CLOCKGENB_PLL0_CFG, 0x80000000, 0x80000000)
-
-	/* Clear CLOCKGENB PLL0 from BYPASS... */
-	UPDATE32(STX7200_CLOCKGENB_PLL0_CFG, 0xffefffff, 0)
-
-	/* Power down PLL... */
-	OR32(STX7200_SYSCONF_SYS_CFG11, 0x00001000)
-
-	/* Configure PLL... */
-#ifdef CONFIG_STM_NEW_POKE_TABLE_PARADIGM
-	IF_EQ32(1, STX7200_SYSCONF_DEVICEID_0, 0x0fffffff, 0x0d437041)
-	  /* On cut 2 set LMI clock to 800MHz */
-	  UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x50 << 1))
-	ELSE(1)
-	  /* For cut 1 */
-	  IF_EQ32(2, 0xa5020000, 0x000000ff, 0x0000000a)
-	    /* On PCB rev A, we have a limitation on LMI1: Set LMI clock to 400MHz */
-	    UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x28 << 1))
-	  ELSE(2)
-	    /* Set LMI clock to 666MHz */
-	    UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x05 << 9) | (0x6f << 1))
-	  ENDIF(2)
-	ENDIF(1)
-#else /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
-	IF_DEVID(STX7200_CUT1)
-	    /* on cut 1, set LMI clock to 666MHz */
-	  UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x05 << 9) | (0x6f << 1))
-	    /* On PCB rev A, we have a limitation on LMI1: Set LMI clock to 400MHz */
-	  IF(0xa5020000, 0x000000ff, 0x0000000a, UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x28 << 1)))
-	ENDIF
-	IF_DEVID(STX7200_CUT2)
-	  /* On cut 2, set LMI clock to 800MHz */
-	  UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x50 << 1))
-	ENDIF
-#endif /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
-
-	/* Enable CLOCKGENA PLL1... */
-	UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xffffefff, 0)
-
-	/* Wait for CLOCKGENA PLL1 to lock... */
-#ifdef CONFIG_STM_NEW_POKE_TABLE_PARADIGM
-	IF_EQ32(1, STX7200_SYSCONF_DEVICEID_0, 0x0fffffff, 0x0d437041)
-	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 1)
-	ELSE(1)
-	  /* On cut 1 polarity inverted on lock bit */
-	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 0)
-	ENDIF(1)
-#else /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
-	IF_DEVID(STX7200_CUT1)
-	  /* On cut 1 polarity inverted on lock bit */
-	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 0)
-	ENDIF
-	IF_DEVID(STX7200_CUT2)
-	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 1)
-	ENDIF
-#endif /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
-
-	/* ----- STx7200 Sysconf ----- */
-
-	/* PLI_CLOCK_ENABLE set to 0 */
-	UPDATE32(STX7200_SYSCONF_SYS_CFG58, ~(1 << 0), 0)
-
-	/* LMI sub-sys & pl exit from reset */
-	OR32(STX7200_SYSCONF_SYS_CFG11, 0x1 | (1 << 27))
-	OR32(STX7200_SYSCONF_SYS_CFG15, 0x1 | (1 << 27))
-
-	/* Delay ~ 200 uS (assumes 400MHz CPU clock) */
-	DELAY(200 * 400)
-
-	/* PLI_CLOCK_ENABLE set to 1 */
-	OR32(STX7200_SYSCONF_SYS_CFG58, (1 << 0))
-
-	/* Check both DLL on LMI0 are locked */
-	WHILE_NE32(STX7200_SYSCONF_SYS_STA03, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
-
-	/* Check both DLL on LMI1 are locked */
-	WHILE_NE32(STX7200_SYSCONF_SYS_STA05, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
-
-	/* Adjust proga, progb, zoutproga, and receiver mode for LMI0 */
-	POKE32(STX7200_SYSCONF_SYS_CFG12, 0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10))
-
-	/* Adjust proga, progb, zoutproga, and receiver mode for LMI1 */
-	POKE32(STX7200_SYSCONF_SYS_CFG16, 0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10))
-
-	/* Enable AutoPrecharge */
-	POKE32(STX7200_SYSCONF_SYS_CFG38, 0x000ffd08)
-	POKE32(STX7200_SYSCONF_SYS_CFG39, 0x000ffd18)
-
-	/* Force DLL1 and DLL2 command of LMI0 */
-	POKE32(STX7200_SYSCONF_SYS_CFG13, 0x00000002)
-	POKE32(STX7200_SYSCONF_SYS_CFG14, 0x00000002)
-
-	/* Force DLL1 and DLL2 command of LMI1 */
-	POKE32(STX7200_SYSCONF_SYS_CFG17, 0x00000002)
-	POKE32(STX7200_SYSCONF_SYS_CFG18, 0x00000002)
-
-	/* Set cfg55 and cfg56 */
-	POKE32(STX7200_SYSCONF_SYS_CFG55, 0x03fc2004 | (0 << 10) | (0x7 << 7))
-	POKE32(STX7200_SYSCONF_SYS_CFG56, 0x03fc2004 | (0 << 10) | (0x7 << 7))
-
-	/* PDL offsets
-	 # -11=1F5 => 42=0x07D7EBF5, 43=0x000001F5
-	 # -21=1EB => 42=0x07afd7eb, 43=0x000001eb
-	 #sysconf.SYSCONF_CFG42.poke(0x07D7EBF5)
-	 #sysconf.SYSCONF_CFG43.poke(0x000001F5)
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:mb671:st40
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "mb671" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
 	 */
-
-	/* TO BE UPDATED FOR 7200/MB671 */
-	POKE32(STX7200_SYSCONF_SYS_CFG42, 0x00000000)
-	POKE32(STX7200_SYSCONF_SYS_CFG43, 0x00000000)
-
-	POKE32(STX7200_SYSCONF_SYS_CFG44, 0x00000000)
-	POKE32(STX7200_SYSCONF_SYS_CFG45, 0x00000000)
-
-	/* ----- STx7200 EMI configuration ----- */
-
-	POKE32(ST40_EMI_BANK_ENABLE, 0x00000005)
-
-	/* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
-	POKE32(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
-	POKE32(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
-	POKE32(ST40_EMI_BANK2_BASEADDRESS, 0x0000000c)
-	POKE32(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
-	POKE32(ST40_EMI_BANK4_BASEADDRESS, 0x00000014)
-
-	/* Bank 0 - On-board 32MiB Flash at address 0x00000000 -> 0x01ffffff */
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
-
-	/* Bank 2 - DVB-CI at address 0x03000000 -> 0x03FFFFFF */
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
-
-	/* Bank 4 - EPLD Registers at address 0x05000000 -> 0x05FFFFFF */
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA0, 0x042086f1)
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA1, 0x8a002200)
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA2, 0x8a004200)
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)
-
-	/* Program other EMI registers */
-	POKE32(ST40_EMI_GENCFG, 0x00000050)
-
-	/* ----- STx7200 LMI0 configuration ----- */
-
-	/* "Refresh Interval" is set equal to 0xA28=2600 => 2600*3ns=7.8us */
-	POKE32(ST40_LMI_MIM_0(0), 0x07f6015b)
-	POKE32(ST40_LMI_MIM_1(0), 0x000000b0)
-
-	POKE32(ST40_LMI_STR_0(0), 0xcd2db41b)
-	POKE32(ST40_LMI_STR_1(0), 0x002202d6)
-
-	/* lmi base address 0x08000000 + 256MiB */
-	POKE32(ST40_LMI_SDRA0_0(0), 0x18001a20)
-
-	/* lmi base address 0x08000000 + 256MiB */
-	POKE32(ST40_LMI_SDRA1_0(0), 0x18001a20)
-
-	/* Delay ~ 200 uS (assumes 400MHz CPU clock) */
-	DELAY(200 * 400)
-
-	/* Enable clock with NOP command */
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020023)
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-
-	/* Precharge all */
-	POKE32(ST40_LMI_SCR_0(0), 0x00020022)
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-
-	/* Issue EMRS2 */
-	POKE32(ST40_LMI_SDMR0(0), 0x00010000)
-
-	/* Issue EMRS3 */
-	POKE32(ST40_LMI_SDMR0(0), 0x00018000)
-
-	/* Issue EMRS1 to enable DLL */
-	POKE32(ST40_LMI_SDMR0(0), 0x00008004)
-
-	/* Issue MRS with DLL reset, CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
-	POKE32(ST40_LMI_SDMR0(0), 0x00000b53)
-
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-
-	/* Precharge all */
-	POKE32(ST40_LMI_SCR_0(0), 0x00020022)
-	/* 2 CBR (auto refresh) */
-	POKE32(ST40_LMI_SCR_0(0), 0x00020024)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020024)
-
-	/* Issue MRS with CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
-	POKE32(ST40_LMI_SDMR0(0), 0x00000a53)
-
-	/* Enable auto refresh */
-	POKE32(ST40_LMI_MIM_0(0), 0x07f6035b)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
-
-	POKE32(ST40_LMI_GCC_0(0), 0x00000000)
-
-	/* ----- STx7200 LMI1 configuration ----- */
-
-	POKE32(ST40_LMI_MIM_0(1), 0x07f6015b)
-	POKE32(ST40_LMI_MIM_1(1), 0x000000b0)
-
-	/* SDRAM Timing Register */
-	POKE32(ST40_LMI_STR_0(1), 0xcd2db41b)
-	POKE32(ST40_LMI_STR_1(1), 0x002202d6)
-
-	/* SDRAM Row Attribute 0 */
-	/* lmi base address 0x18000000 + 64MiB */
-	POKE32(ST40_LMI_SDRA0_0(1), 0x1c001a20)
-
-	/* SDRAM Row Attribute 1 */
-	/* lmi base address 0x18000000 + 64MiB */
-	POKE32(ST40_LMI_SDRA1_0(1), 0x1c001a20)
-
-	/* Delay ~ 200 uS (assumes 400MHz CPU clock) */
-	DELAY(200 * 400)
-
-	/* Enable clock with NOP command */
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020023)
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-
-	/* Precharge all */
-	POKE32(ST40_LMI_SCR_0(1), 0x00020022)
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-
-	/* Issue EMRS2 */
-	POKE32(ST40_LMI_SDMR0(1), 0x00010000)
-
-	/* Issue EMRS3 */
-	POKE32(ST40_LMI_SDMR0(1), 0x00018000)
-
-	/* Issue EMRS1 to enable DLL */
-	POKE32(ST40_LMI_SDMR0(1), 0x00008004)
-
-	/* Issue MRS with DLL reset, CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
-	POKE32(ST40_LMI_SDMR0(1), 0x00000b53)
-
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-
-	/* Precharge all */
-	POKE32(ST40_LMI_SCR_0(1), 0x00020022)
-	/* 2 CBR (auto refresh) */
-	POKE32(ST40_LMI_SCR_0(1), 0x00020024)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020024)
-
-	/* Issue MRS with CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
-	POKE32(ST40_LMI_SDMR0(1), 0x00000a53)
-
-	/* Enable auto refresh */
-	POKE32(ST40_LMI_MIM_0(1), 0x07f6035b)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
-
-	POKE32(ST40_LMI_GCC_0(1), 0x00000000)
+#include "mb671.romgen"
 
 #ifdef CONFIG_SH_SE_MODE
 	/*
diff --git a/board/mb671/mb671.romgen b/board/mb671/mb671.romgen
new file mode 100644
index 0000000..17b91e0
--- /dev/null
+++ b/board/mb671/mb671.romgen
@@ -0,0 +1,1572 @@
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x1d437041) */
+/* PEEK(0xa5020000) (used target peek value 0x000b000b) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80101400) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+POKE32(0xfd700000, 0x80101400)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000001)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x00181400) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+POKE32(0xfd700000, 0x00180f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+WHILE_NE32(0xfd700000, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+POKE32(0xfd700000, 0x80000f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80100a00) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+POKE32(0xfd700004, 0x80100a00)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000002)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x00180a00) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+POKE32(0xfd700004, 0x00180f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000002) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+WHILE_NE32(0xfd700004, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+POKE32(0xfd700004, 0x80000f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+POKE32(0xfd700008, 0x80102803)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000004)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x00182803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+POKE32(0xfd700008, 0x00182803)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000004) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+WHILE_NE32(0xfd700008, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+POKE32(0xfd700008, 0x80002803)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+POKE32(0xfd70103c, 0x80102803)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+/* PEEK(0xfd701058) (used target peek value 0x00007ff8) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+POKE32(0xfd701058, 0x0000fff8)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x00182803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+POKE32(0xfd70103c, 0x00182803)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+/* PEEK(0xfd701058) (used target peek value 0x0000fff8) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+POKE32(0xfd701058, 0x00007ff8)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+WHILE_NE32(0xfd70103c, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+POKE32(0xfd70103c, 0x80002803)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x00000d28) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x00001d28)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x00001d28) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x000016a0)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x000016a0) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x000006a0)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x1d437041) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+/* PEEK(0xfd704014) (used target peek value 0x1f10e795) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+WHILE_NE32(0xfd704014, 0x00000001, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x1d437041) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x1d437041) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA01
+*/
+/* PEEK(0xfd70400c) (used target peek value 0x00000040) */
+/* PEEK(0xa5000000) (used target peek value 0x00110011) */
+/* PEEK(0xa5020000) (used target peek value 0x000b000b) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x1d437041) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80000f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80000f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80002803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80002803) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x000006a0) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_MUX_CFG
+*/
+/* PEEK(0xfd70000c) (used target peek value 0x00000071) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_MUX_CFG
+*/
+/* PEEK(0xfd70000c) (used target peek value 0x00000071) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+/* PEEK(0xfd7041e8) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+POKE32(0xfd7041e8, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x000006a0) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x080006a1)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG15
+*/
+/* PEEK(0xfd70413c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG15
+*/
+POKE32(0xfd70413c, 0x08000001)
+DELAY(200)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+/* PEEK(0xfd7041e8) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+POKE32(0xfd7041e8, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+/* PEEK(0xfd704014) (used target peek value 0x1f13ef95) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+WHILE_NE32(0xfd704014, 0x00100400, 0x00100400)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA05
+*/
+/* PEEK(0xfd70401c) (used target peek value 0x1f1bd47a) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA05
+*/
+WHILE_NE32(0xfd70401c, 0x00100400, 0x00100400)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG12
+*/
+POKE32(0xfd704130, 0xa200780f)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG16
+*/
+POKE32(0xfd704140, 0xa200780f)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG38
+*/
+POKE32(0xfd704198, 0x000ffd08)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG39
+*/
+POKE32(0xfd70419c, 0x000ffd18)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG13
+*/
+POKE32(0xfd704134, 0x00000002)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG14
+*/
+POKE32(0xfd704138, 0x00000002)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG17
+*/
+POKE32(0xfd704144, 0x00000002)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG18
+*/
+POKE32(0xfd704148, 0x00000002)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG55
+*/
+POKE32(0xfd7041dc, 0x03fc2380)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG56
+*/
+POKE32(0xfd7041e0, 0x03fc2380)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG42
+*/
+POKE32(0xfd7041a8, 0x07b7dbed)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG43
+*/
+POKE32(0xfd7041ac, 0x000001ed)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG44
+*/
+POKE32(0xfd7041b0, 0x07b7dbed)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG45
+*/
+POKE32(0xfd7041b4, 0x000001ed)
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfdf00860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfdf00800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfdf00810, 0x00000008)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfdf00820, 0x0000000c)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfdf00830, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfdf00840, 0x00000014)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfdf00100, 0x001016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfdf00108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfdf00110, 0x9d220000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfdf00118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfdf00180, 0x002046f9)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfdf00188, 0xa5a00000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfdf00190, 0xa5a20000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfdf00198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
+*/
+POKE32(0xfdf00200, 0x042086f1)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
+*/
+POKE32(0xfdf00208, 0x8a002200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
+*/
+POKE32(0xfdf00210, 0x8a004200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
+*/
+POKE32(0xfdf00218, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfdf00028, 0x00000050)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd18008, 0x07f6015b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfdd1800c, 0x000000b0)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfdd18018, 0xcd2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfdd1801c, 0x002202d6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfdd18030, 0x18001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfdd18038, 0x18001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd18008, 0x07f6035b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfdd18028, 0x00000000)
+POKE32(0xa8000000, 0x00000000)
+POKE32(0xa8000000, 0xaaaaaaaa)
+/* PEEK(0xa8000000) (used target peek value 0xaaaaaaaa) */
+POKE32(0xa8001000, 0x00000000)
+POKE32(0xa8001000, 0x55555555)
+/* PEEK(0xa8001000) (used target peek value 0x55555555) */
+POKE32(0xa8002000, 0x00000000)
+POKE32(0xa8002000, 0x12345678)
+/* PEEK(0xa8002000) (used target peek value 0x12345678) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd19008, 0x07f6015b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfdd1900c, 0x000000b0)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfdd19018, 0xcd2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfdd1901c, 0x002202d6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfdd19030, 0x1c001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfdd19038, 0x1c001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd19008, 0x07f6035b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfdd19028, 0x00000000)
+POKE32(0xb8000000, 0x00000000)
+POKE32(0xb8000000, 0xaaaaaaaa)
+/* PEEK(0xb8000000) (used target peek value 0xaaaaaaaa) */
+POKE32(0xb8001000, 0x00000000)
+POKE32(0xb8001000, 0x55555555)
+/* PEEK(0xb8001000) (used target peek value 0x55555555) */
+POKE32(0xb8002000, 0x00000000)
+POKE32(0xb8002000, 0x12345678)
+/* PEEK(0xb8002000) (used target peek value 0x12345678) */
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+/* PEEK(0xfd704114) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+POKE32(0xfd704114, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+/* PEEK(0xfd704124) (used target peek value 0x00000a8c) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+POKE32(0xfd704124, 0x08000a8c)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+/* PEEK(0xfd704174) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG28
+*/
+POKE32(0xfd704170, 0x00004001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+/* PEEK(0xfd704174) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+POKE32(0xfd704174, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+/* PEEK(0xfd704174) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+POKE32(0xfd704174, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+/* PEEK(0xfd704114) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+POKE32(0xfd704114, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+/* PEEK(0xfd704124) (used target peek value 0x08000a8c) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+POKE32(0xfd704124, 0x08000a8c)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+/* PEEK(0xfd70416c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG26
+*/
+POKE32(0xfd704168, 0x00004001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+/* PEEK(0xfd70416c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+POKE32(0xfd70416c, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+/* PEEK(0xfd70416c) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+POKE32(0xfd70416c, 0x00000000)
diff --git a/board/mb671/sconsole.c b/board/mb671/sconsole.c
deleted file mode 100644
index af92525..0000000
--- a/board/mb671/sconsole.c
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-
-#include "sconsole.h"
-
-#if 0
-void (*sconsole_putc) (char) = 0;
-void (*sconsole_puts) (const char *) = 0;
-int (*sconsole_getc) (void) = 0;
-int (*sconsole_tstc) (void) = 0;
-void (*sconsole_setbrg) (void) = 0;
-#endif
-
-#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
-int serial_init (void)
-{
-	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-	sb->pos = 0;
-	sb->size = 0;
-	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
-
-	return (0);
-}
-
-void serial_putc (char c)
-{
-	if (sconsole_putc) {
-		(*sconsole_putc) (c);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		if (c) {
-			sb->data[sb->pos++] = c;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-void serial_puts (const char *s)
-{
-	if (sconsole_puts) {
-		(*sconsole_puts) (s);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		while (*s) {
-			sb->data[sb->pos++] = *s++;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-int serial_getc (void)
-{
-	if (sconsole_getc) {
-		return (*sconsole_getc) ();
-	} else {
-		return 0;
-	}
-}
-
-int serial_tstc (void)
-{
-	if (sconsole_tstc) {
-		return (*sconsole_tstc) ();
-	} else {
-		return 0;
-	}
-}
-
-void serial_setbrg (void)
-{
-	if (sconsole_setbrg) {
-		(*sconsole_setbrg) ();
-	}
-}
-
-void sconsole_flush (void)
-{
-	if (sconsole_putc) {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-		unsigned int end = sb->pos < sb->size
-			? sb->pos + sb->max_size - sb->size
-			: sb->pos - sb->size;
-
-		while (sb->size) {
-			(*sconsole_putc) (sb->data[end++]);
-			if (end == sb->max_size) {
-				end = 0;
-			}
-			sb->size--;
-		}
-	}
-}
-#endif
diff --git a/board/mb671/sconsole.h b/board/mb671/sconsole.h
deleted file mode 100644
index 1666f21..0000000
--- a/board/mb671/sconsole.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef _SCONSOLE_H_
-#define _SCONSOLE_H_
-
-#include <config.h>
-
-typedef struct sconsole_buffer_s
-{
-	unsigned long size;
-	unsigned long max_size;
-	unsigned long pos;
-	char data[1];
-} sconsole_buffer_t;
-
-#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
-
-extern void (*sconsole_putc) (char);
-extern void (*sconsole_puts) (const char *);
-extern int (*sconsole_getc) (void);
-extern int (*sconsole_tstc) (void);
-extern void (*sconsole_setbrg) (void);
-
-extern void sconsole_flush (void);
-
-#endif
diff --git a/board/mb680/Makefile b/board/mb680/Makefile
index ff0f69a..219443a 100644
--- a/board/mb680/Makefile
+++ b/board/mb680/Makefile
@@ -27,7 +27,7 @@ LIB	= lib$(BOARD).a
 
 AOBJS	= init-$(BOARD).o
 
-COBJS	= $(BOARD).o sconsole.o nand.o
+COBJS	= $(BOARD).o nand.o
 
 OBJS	= $(COBJS) $(AOBJS)
 
diff --git a/board/mb680/init-mb680.S b/board/mb680/init-mb680.S
index 21a4d67..811b362 100644
--- a/board/mb680/init-mb680.S
+++ b/board/mb680/init-mb680.S
@@ -29,340 +29,34 @@
 #define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
 #define DELAY(VAL)				/* do nothing */
 
-.balign 32
 
+	.balign 32
 
 __memory_setup_table:
 
-	/* ----- STx7105 Clocks ----- */
-
-	/* Set source clocks to OSC */
-	POKE32(STX7105_CLOCKGENA_CLKOPSRC_SWITCH_CFG, 0x00000000)
-	POKE32(STX7105_CLOCKGENA_CLKOPSRC_SWITCH_CFG2, 0x00000000)
-
-	/* Wait for CLOCKGENA PLL0 to stop ... */
-	WHILE_NE32(STX7105_CLOCKGENA_PLL0_ENABLE_FB, 0xFFFFFFFF, 0x00000000)
-
-	/* Wait for CLOCKGENA PLL1 to stop ... */
-	WHILE_NE32(STX7105_CLOCKGENA_PLL1_ENABLE_FB, 0xFFFFFFFF, 0x00000000)
-
-	/*  Clockgen A PLL0 setup */
-
-	/* Set CLOCKGENA PLL0 into BYPASS... */
-	OR32(STX7105_CLOCKGENA_PLL0_CFG, 0x00100000)
-
-	/* Power down CLOCKGENA PLL0... */
-	OR32(STX7105_CLOCKGENA_POWER_CFG, 0x00000001)
-
-	/* Configure CLOCKGENA PLL0LS to 450MHz (PLL0HS to 900MHz): mdiv = 0x01, ndiv = 0x0f */
-	UPDATE32(STX7105_CLOCKGENA_PLL0_CFG, 0xfff80000, (0xf << 8) | (0x01 & 0x7))
-
-	/* Enable CLOCKGENA PLL0... */
-	UPDATE32(STX7105_CLOCKGENA_POWER_CFG, 0xfffffffe, 0)
-
-	/* Wait for CLOCKGENA PLL0 to lock... */
-	WHILE_NE32(STX7105_CLOCKGENA_PLL0_CFG, 0x80000000, 0x80000000)
-
-	/* Clear CLOCKGENA PLL0 from BYPASS... */
-	UPDATE32(STX7105_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
-
-	/*  Clockgen A PLL1 setup */
-
-	/* Set CLOCKGENA PLL1 into BYPASS... */
-	OR32(STX7105_CLOCKGENA_PLL1_CFG, 0x00100000)
-
-	/* Power down CLOCKGENA PLL1... */
-	OR32(STX7105_CLOCKGENA_POWER_CFG, 0x00000002)
-
-	/* Configure CLOCKGENA PLL1 to 800MHz: mdiv = 0x03, ndiv = 0x28, pdiv = 0x0 */
-	/* UPDATE32(STX7105_CLOCKGENA_PLL1_CFG, 0xfff80000, (0 << 16) | (0x28 << 8) | (0x03)) */
-	/* Configure CLOCKGENA PLL1 to 400MHz: mdiv = 0x09, ndiv = 0x78, pdiv = 0x1 */
-	UPDATE32(STX7105_CLOCKGENA_PLL1_CFG, 0xfff80000, (1 << 16) | (0x78 << 8) | (0x09))
-
-	/* Enable CLOCKGENA PLL1... */
-	UPDATE32(STX7105_CLOCKGENA_POWER_CFG, 0xfffffffd, 0)
-
-	/* Wait for CLOCKGENA PLL1 to lock... */
-	WHILE_NE32(STX7105_CLOCKGENA_PLL1_CFG, 0x80000000, 0x80000000)
-
-	/* Clear CLOCKGENA PLL1 from BYPASS... */
-	UPDATE32(STX7105_CLOCKGENA_PLL1_CFG, 0xffefffff, 0)
-
-
-	/*  Clockgen A divider setup */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV0_CFG, 0x00000001)    /* STNOC=200 */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV1_CFG, 0x00000000)    /* FDMA0=400 */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV2_CFG, 0x00000000)    /* FDMA1=400 */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV3_CFG, 0x00000103)    /* Not used */
-	POKE32(STX7105_CLOCKGENA_PLL0LS_DIV4_CFG, 0x00010100)  /* ST40_ICK=450 */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV5_CFG, 0x00000103)    /* IC_IF_100=100  - for Comms */
-	POKE32(STX7105_CLOCKGENA_PLL0LS_DIV6_CFG, 0x00010100)  /* LX_DMU_CPU=450 */
-	POKE32(STX7105_CLOCKGENA_PLL0LS_DIV7_CFG, 0x00010100)  /* LX_AUD_CPU=450 */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV8_CFG, 0x00000001)    /* IC_BDISP_200=200 */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV9_CFG, 0x00000001)    /* IC_DISP_200=200 */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV10_CFG, 0x00000001)   /* IC_TS_200=200  - for Crypto */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV11_CFG, 0x00000001)   /* DISP_PIPE_200=200 */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV12_CFG, 0x00000001)   /* BLIT_PROC/IC_DELTA_200=266 */
-	POKE32(STX7105_CLOCKGENA_PLL0LS_DIV13_CFG, 0x00000811) /* ETH_PHY=25 */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV14_CFG, 0x0000050B)   /* PCI=33.3 */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV15_CFG, 0x00000103)   /* EMI_MASTER=100 */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV16_CFG, 0x00000001)   /* IC_COMPO_200=200 */
-	POKE32(STX7105_CLOCKGENA_PLL1_DIV17_CFG, 0x00000001)   /* IC_IF_200=200 */
-
-	/* Route clocks to ... */
-	POKE32(STX7105_CLOCKGENA_CLKOPSRC_SWITCH_CFG, 0xA6AA59AA)
-	POKE32(STX7105_CLOCKGENA_CLKOPSRC_SWITCH_CFG2, 0x0000000A)
-
-	/* SPI.CLOCK_DIV: divide emi_master_clk by 4 for spi boot clock */
-	POKE32(0xfe702010, 0x00000004)
-
-	/* ClockGen B for Audio */
-	/*  No setup            */
-
-
-	/* ClockGen D for LMI */
-
-	/* Power down PLL... */
-	OR32(STX7105_SYSCONF_SYS_CFG11, 0x00001000)
-
-	/* Configure PLL... */
-	/* Set LMI clock to 800MHz */
-	/* UPDATE32(STX7105_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x50 << 1)) */
-	/* Cut 1.0 restriction -> Set LMI clock to 400MHz */
-	UPDATE32(STX7105_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x28 << 1))
-
-	/* Enable CLOCKGENA PLL1... */
-	UPDATE32(STX7105_SYSCONF_SYS_CFG11, 0xffffefff, 0)
-
-	/* Wait for CLOCKGENA PLL1 to lock... (polarity inverted on lock bit) */
-	WHILE_NE32(STX7105_SYSCONF_SYS_STA03, 0x00000001, 0)
-
-
-	/* ----- STx7105 SysConf ----- */
-
-	/* PLI_CLOCK_ENABLE set to 0 */
-	/* OR32(STX7105_SYSCONF_SYS_CFG04, ~(1 << 2))	- Steve Punter misinterpretted? */
-	UPDATE32(STX7105_SYSCONF_SYS_CFG04, ~(1 << 2), 0)
-
-	/* LMI sub-sys & pl exit from reset */
-	OR32(STX7105_SYSCONF_SYS_CFG11, (0x00000001 | (1 << 14) | 1 << 27))
-
-	/* Delay ~ 200 microseconds (assume 400MHz CPU clock) */
-	DELAY(200 * 400)
-
-	/* PLI_CLOCK_ENABLE set to 1 */
-	OR32(STX7105_SYSCONF_SYS_CFG04, (1 << 2))
-
-	/* Check both DLL on LMI0 are locked */
-	WHILE_NE32(STX7105_SYSCONF_SYS_STA03, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
-
-	/* Adjust proga, progb, zoutproga, and receiver mode for LMI0 */
-	POKE32(STX7105_SYSCONF_SYS_CFG12, (0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10)))
-
-	/* Enable AutoPrecharge */
-	POKE32(STX7105_SYSCONF_SYS_CFG38, 0x002FFE0C)
-
-	/* Force DLL1 and DLL2 commands of LMI0 */
-	/* POKE32(STX7105_SYSCONF_SYS_CFG13, 0x00000000) */
-	/* POKE32(STX7105_SYSCONF_SYS_CFG14, 0x00000000) */
-
-	/* LMI Padlogic Control */
-	POKE32(STX7105_SYSCONF_SYS_CFG55, 0x03fc2384)
-
-	/* Include DUMMY PCB track */
-	OR32(STX7105_SYSCONF_SYS_CFG55, (1 << 6))
-
-	/* TO BE UPDATED FOR 7105/MB680 */
-	/* sysconf.SYSCONF_CFG42.poke(sysconf.SYSCONF_CFG42.peek() | (0 << 18) | (0 << 9) | (0 << 0) ) */
-	UPDATE32(STX7105_SYSCONF_SYS_CFG42, 0xfffbfdfe, 0)
-	/* sysconf.SYSCONF_CFG43.poke(sysconf.SYSCONF_CFG43.peek() | (0) ) */
-	UPDATE32(STX7105_SYSCONF_SYS_CFG43, 0xfffffffe, 0)
-
-	/* Coarse settings (-T/4) */
-	OR32(STX7105_SYSCONF_SYS_CFG42, (5 << 27))
-	OR32(STX7105_SYSCONF_SYS_CFG13, (1 << 22))
-
-	/* DQS Valid Window */
-	/* sysconf.SYSCONF_CFG43.poke(sysconf.SYSCONF_CFG43.peek() | (0 << 18)) */
-	UPDATE32(STX7105_SYSCONF_SYS_CFG43, 0xfffbffff, 0)
-
-	/* DQS270_DEL offsets */
-	/* sysconf.SYSCONF_CFG51.poke(sysconf.SYSCONF_CFG51.peek() | (0 << 16) | (0 << 0)) */
-	UPDATE32(STX7105_SYSCONF_SYS_CFG51, 0xfffefffe, 0)
-	/* sysconf.SYSCONF_CFG52.poke(sysconf.SYSCONF_CFG52.peek() | (0 << 16) | (0 << 0)) */
-	UPDATE32(STX7105_SYSCONF_SYS_CFG52, 0xfffefffe, 0)
-
-
-	/* ----- STx7105 EMI configuration ----- */
-
-	POKE32(ST40_EMI_BANK_ENABLE, 0x00000005)
-
-	/* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
-	POKE32(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
-	POKE32(ST40_EMI_BANK1_BASEADDRESS, 0x00000010)
-	POKE32(ST40_EMI_BANK2_BASEADDRESS, 0x00000012)
-	POKE32(ST40_EMI_BANK3_BASEADDRESS, 0x00000014)
-	POKE32(ST40_EMI_BANK4_BASEADDRESS, 0x0000001c)
-
-	/* Bank 0 - 32MiB: NOR, NAND & Serial Flash at address 0x00000000 -> 0x03ffffff */
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
-	POKE32(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
-
-	/* Bank 1 - 8MiB at address 0x04000000 -> 0x047fffff */
-	POKE32(ST40_EMI_BANK1_EMICONFIGDATA0, 0x002016d1)
-	POKE32(ST40_EMI_BANK1_EMICONFIGDATA1, 0x9d222200)
-	POKE32(ST40_EMI_BANK1_EMICONFIGDATA2, 0x9d220044)
-	POKE32(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000)
-
-	/* Bank 2 - 8MiB at address 0x04800000 -> 0x04FFFFFF */
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
-	POKE32(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
-
-	/* Bank 3 - 32MiB at address 0x05000000 -> 0x06FFFFFF */
-	POKE32(ST40_EMI_BANK3_EMICONFIGDATA0, 0x002016d1)
-	POKE32(ST40_EMI_BANK3_EMICONFIGDATA1, 0x9d222200)
-	POKE32(ST40_EMI_BANK3_EMICONFIGDATA2, 0x9d220044)
-	POKE32(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
-
-	/* Bank 4 - 16MiB EPLD Registers at address 0x07000000 -> 0x07FFFFFF */
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA0, 0x002016d1)
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA1, 0x9d222200)
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA2, 0x9d220044)
-	POKE32(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)
-
-	/* Program other EMI registers */
-	POKE32(ST40_EMI_GENCFG, 0x00000010)
-
-
-	/* ----- STx7105 LMI0 configuration ----- */
-
-	/* Configuring LMI0 for DDR2 SDRAM Elpida EDE5116AHBG-8E-E
-
-	   SDRAM Mode Register
-	   Refresh Interval:  NOTE: Using Lmi=200 (LMI2X=400).
-	 # 300 Mhz --->  T=3.4ns => MIM[28:16]=2038=0x7F6 ((2294-256)+ACo-3.4ns<+AH4-7.8us)
-	 # 330 Mhz --->  T=3.1ns => MIM[28:16]=2260 ((2516-256)+ACo-3.1ns<+AH4-7.8us)
-	 # 360 Mhz --->  T=2.8ns => MIM[28:16]=2529 ((2785-256)+ACo-2.8ns<+AH4-7.8us)
-	 # 400 Mhz --->  T=2.5ns => MIM[28:16]=2864 ((3120-256)+ACo-2.5ns=7.8us)
-	 */
-	POKE32(ST40_LMI_MIM_0(), 0x07F6017b)
-
-	/* set bandwidth limiter */
-	POKE32(ST40_LMI_MIM_1(), 0xffff0000)
-
-	/* SDRAM Timing Register */
-	POKE32(ST40_LMI_STR_0(), 0xcd2db41b)
-	POKE32(ST40_LMI_STR_1(), 0x00202ed6)
-
-	/* SDRAM Row Attribute 0 */
-	/* lmi base address 0x0C000000 +
-	    256 MiB   0x10000000
-	              ----------
-	              0x1C000000
-	   Size: 13x10, 8 banks
-	 */
-	POKE32(ST40_LMI_SDRA0_0(), 0x1c001a20)
-
-	/* SDRAM Row Attribute 1 */
-	/* lmi base address 0x0C000000 +
-	    256 MiB   0x10000000
-	              ----------
-	              0x1C000000
-	   Size: 13x10, 8 banks
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:mb680:st40
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "mb680" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
 	 */
-	POKE32(ST40_LMI_SDRA1_0(), 0x1c001a20)
-
-	/* SDRAM Control Register */
-	/* Delay ~ 200 milliseconds (assume 400MHz CPU clock) */
-	DELAY(200000 * 400)
-	/* Enable clock with NOP command */
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020023)
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-
-	/* Precharge all */
-	POKE32(ST40_LMI_SCR_0(), 0x00020022)
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-
-	/* Issue EMRS2 */
-	POKE32(ST40_LMI_SDMR0(), 0x00010000)
-
-	/* Issue EMRS3 */
-	POKE32(ST40_LMI_SDMR0(), 0x00018000)
-
-	/* Issue EMRS1 to enable DLL */
-	POKE32(ST40_LMI_SDMR0(), 0x00008004)
-
-	/* Issue MRS with DLL reset, CAS 5, Write recovery 5, Sequential, Burst length 8 */
-	POKE32(ST40_LMI_SDMR0(), 0x00000b53)
-
-	/* Wait NOP command for 400 nsec */
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-
-	/* Precharge all */
-	POKE32(ST40_LMI_SCR_0(), 0x00020022)
-
-	/* 2 CBR (auto refresh) */
-	POKE32(ST40_LMI_SCR_0(), 0x00020024)
-	POKE32(ST40_LMI_SCR_0(), 0x00020024)
-
-	/* Issue MRS with CAS 5, Write recovery 5, Sequential, Burst length 8 */
-	POKE32(ST40_LMI_SDMR0(), 0x00000a53)
-
-	/* Issue EMRS1 for OCD calibration default */
-	/* lmi.LMI_SDMR0_0.poke(0x000007c4) */
-
-	/* Issue EMRS1 for OCD calibration exit */
-	/* lmi.LMI_SDMR0_0.poke(0x00000444) */
-
-	/* Enable auto refresh */
-	OR32(ST40_LMI_MIM_0(), (1 << 9))
-
-	/* DQS recovery mechanism (bit 5) */
-	/* OR32(ST40_LMI_MIM_0(), (1 << 5)) - Steve Punter misinterpretted? */
-	UPDATE32(ST40_LMI_MIM_0(), ~(1 << 5), 0)
-	/* NO DQS recovery */
-	/* UPDATE32(ST40_LMI_MIM_0(), 0xffffffdf, 0) */
-
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-	POKE32(ST40_LMI_SCR_0(), 0x00020021)
-
-	POKE32(ST40_LMI_GCC_0(), 0x00000000)
+#if 1
+#include "mb680-stx7105c2.romgen"	/* for STx7105 cut 2.x */
+#else
+#include "mb680-stx7105c1.romgen"	/* for STx7105 cut 1.x */
+#endif
 
 #ifdef CONFIG_SH_SE_MODE
 	/*
diff --git a/board/mb680/mb680-stx7105c1.romgen b/board/mb680/mb680-stx7105c1.romgen
new file mode 100644
index 0000000..e93eb56
--- /dev/null
+++ b/board/mb680/mb680-stx7105c1.romgen
@@ -0,0 +1,1653 @@
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x0d43e041) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000004)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x0d43e041) */
+POKE32(0xfe000010, 0x0000c0de)
+POKE32(0xfe0000b8, 0x00000001)
+POKE32(0xfe000010, 0x0000c1a0)
+/* PEEK(0xfe210000) (used target peek value 0x00000000) */
+POKE32(0xfe210000, 0x00800000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000005)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x0d43e041) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+/* PEEK(0xfe21301c) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+WHILE_NE32(0xfe21301c, 0xffffffff, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+/* PEEK(0xfe213020) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+WHILE_NE32(0xfe213020, 0xffffffff, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80001e02) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80101e02)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x00181e02) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x00180f01)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+WHILE_NE32(0xfe213000, 0x80000000, 0x80000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80000f01)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80102803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV0_CFG
+*/
+POKE32(0xfe213b00, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV1_CFG
+*/
+POKE32(0xfe213b04, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV2_CFG
+*/
+POKE32(0xfe213b08, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV3_CFG
+*/
+POKE32(0xfe213b0c, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV4_CFG
+*/
+POKE32(0xfe213a10, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV5_CFG
+*/
+POKE32(0xfe213b14, 0x00000307)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV6_CFG
+*/
+POKE32(0xfe213a18, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV7_CFG
+*/
+POKE32(0xfe213a1c, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV8_CFG
+*/
+POKE32(0xfe213b20, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV9_CFG
+*/
+POKE32(0xfe213b24, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV10_CFG
+*/
+POKE32(0xfe213b28, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV11_CFG
+*/
+POKE32(0xfe213b2c, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV12_CFG
+*/
+POKE32(0xfe213b30, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV13_CFG
+*/
+POKE32(0xfe213a34, 0x00000811)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV14_CFG
+*/
+POKE32(0xfe213b38, 0x0000050b)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV15_CFG
+*/
+POKE32(0xfe213b3c, 0x00000307)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV16_CFG
+*/
+POKE32(0xfe213b40, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV17_CFG
+*/
+POKE32(0xfe213b44, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000002)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x00182803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x00182803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000002) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+WHILE_NE32(0xfe213004, 0x80000000, 0x80000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80002803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0xa6aa59aa)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x0000000a)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00000d28) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x00001d28)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00001d28) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000016a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000016a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000006a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1f032c9c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00000001, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a10) (used target peek value 0x00010100) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a18) (used target peek value 0x00010100) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a1c) (used target peek value 0x00010100) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b04) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b08) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b00) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b20) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b24) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b28) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b40) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b44) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b14) (used target peek value 0x00000307) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b2c) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b30) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a34) (used target peek value 0x00000811) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b38) (used target peek value 0x0000050b) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b3c) (used target peek value 0x00000307) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000126) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x00000122)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x080246a1)
+DELAY(200)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000122) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x00000126)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1f13ac9c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00100400, 0x00100400)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000787f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x002f000c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00400002)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000002)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc23dc)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x07afd7eb)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x00b001eb)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x01eb01eb)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x01eb01eb)
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfe700860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfe700800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfe700810, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfe700820, 0x00000012)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfe700830, 0x00000014)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfe700840, 0x0000001c)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfe700100, 0x001016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfe700108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfe700110, 0x9d220000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfe700118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
+*/
+POKE32(0xfe700140, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
+*/
+POKE32(0xfe700148, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
+*/
+POKE32(0xfe700150, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
+*/
+POKE32(0xfe700158, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfe700180, 0x002046f9)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfe700188, 0xa5a00000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfe700190, 0xa5a20000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfe700198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA0
+*/
+POKE32(0xfe7001c0, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA1
+*/
+POKE32(0xfe7001c8, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA2
+*/
+POKE32(0xfe7001d0, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA3
+*/
+POKE32(0xfe7001d8, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
+*/
+POKE32(0xfe700200, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
+*/
+POKE32(0xfe700208, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
+*/
+POKE32(0xfe700210, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
+*/
+POKE32(0xfe700218, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfe700028, 0x00000010)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080246a1) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30017b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfe90100c, 0x000000b0)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfe901018, 0xcd2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfe90101c, 0x00222ed6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfe901030, 0x1c001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfe901038, 0x1c001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30017b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30037b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfe901028, 0x00000000)
+POKE32(0xfe20d200, 0x00000005)
+POKE32(0xfe20d204, 0x00000004)
+POKE32(0xfe20d208, 0x00000003)
+POKE32(0xfe20d20c, 0x00000002)
+POKE32(0xfe20d210, 0x00000001)
+POKE32(0xfe20d214, 0x00000001)
+POKE32(0xfe20d218, 0x00000001)
+POKE32(0xfe20d21c, 0x00000001)
+POKE32(0xfe20d220, 0x00000001)
+POKE32(0xfe2410fc, 0x00000005)
+POKE32(0xfe20a0ec, 0x00000002)
+POKE32(0xfe20a0f0, 0x00000005)
+POKE32(0xfe20a0f4, 0x00000003)
+POKE32(0xfe20a0f8, 0x00000003)
+POKE32(0xfe20a1ec, 0x00000002)
+POKE32(0xfe20a1f0, 0x00000005)
+POKE32(0xfe20a1f4, 0x00000003)
+POKE32(0xfe20a1f8, 0x00000003)
+POKE32(0xfe20a1fc, 0x00000000)
+POKE32(0xfe20a2ec, 0x00000002)
+POKE32(0xfe20a2f0, 0x00000005)
+POKE32(0xfe20a2f4, 0x00000003)
+POKE32(0xfe20a2f8, 0x00000003)
+POKE32(0xfe20a2fc, 0x00000000)
+POKE32(0xfe20a3ec, 0x00000002)
+POKE32(0xfe20a3f0, 0x00000005)
+POKE32(0xfe20a3f4, 0x00000003)
+POKE32(0xfe20a3f8, 0x00000003)
+POKE32(0xfe20a3fc, 0x00000000)
+POKE32(0xfe20aefc, 0x00000005)
+POKE32(0xfe540034, 0x00000003)
+POKE32(0xfe540038, 0x00000000)
+POKE32(0xfe540110, 0x00010303)
+POKE32(0xfe540114, 0x00000000)
+POKE32(0xfe540030, 0x00000005)
+POKE32(0xfe54010c, 0x00000005)
+POKE32(0xfe540600, 0x00000006)
+POKE32(0xfe540604, 0x00000005)
+POKE32(0xfe540608, 0x00000004)
+POKE32(0xfe54060c, 0x00000003)
+POKE32(0xfe540610, 0x00000002)
+POKE32(0xfe540614, 0x00000001)
+POKE32(0xfe540618, 0x00000000)
+POKE32(0xfe540680, 0x00000001)
+POKE32(0xfe540684, 0x00000000)
+POKE32(0xfe20bb04, 0x00000005)
+POKE32(0xfe20bb08, 0x00000003)
+POKE32(0xfe20bb10, 0x00000002)
+POKE32(0xfe20bb24, 0x00000005)
+POKE32(0xfe20bb28, 0x00000003)
+POKE32(0xfe20bb2c, 0x00000000)
+POKE32(0xfe20bb30, 0x00000002)
+POKE32(0xfe20bb44, 0x00000005)
+POKE32(0xfe20bb48, 0x00000003)
+POKE32(0xfe20bb4c, 0x00000000)
+POKE32(0xfe20bb50, 0x00000002)
+POKE32(0xfe20bb84, 0x00000005)
+POKE32(0xfe20bb88, 0x00000003)
+POKE32(0xfe20bb8c, 0x00000000)
+POKE32(0xfe20bb90, 0x00000002)
+POKE32(0xfe20a0fc, 0x00000000)
+POKE32(0xfe20bb0c, 0x00000000)
+POKE32(0xfe231010, 0x00000008)
+POKE32(0xfe231080, 0x00000221)
+POKE32(0xfe261010, 0x00000008)
+POKE32(0xfe261080, 0x00000221)
+POKE32(0xfd101024, 0x0003c000)
+POKE32(0xfd101824, 0x0003c000)
+POKE32(0xfd104d24, 0x0003c000)
+POKE32(0xfd102024, 0x0003c000)
+/* PEEK(0xfe001180) (used target peek value 0x00000b35) */
+POKE32(0xfe001180, 0x00000b05)
+POKE32(0xfe1fff04, 0x00254608)
+POKE32(0xfeafff04, 0x00254608)
+/* PEEK(0xfe00111c) (used target peek value 0x08081000) */
+POKE32(0xfe00111c, 0x08091000)
+POKE32(0xfd117000, 0x0025c608)
+POKE32(0xfd111000, 0x00201004)
+/* PEEK(0xfe001180) (used target peek value 0x00000b05) */
+POKE32(0xfe001180, 0x00000b01)
+POKE32(0xfe401744, 0x0025c005)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x00000a8c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x00000040) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x00000040)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG26
+*/
+POKE32(0xfe001168, 0xfe804001)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd1)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x08000a8c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x00000040) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x00000040)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG28
+*/
+POKE32(0xfe001170, 0xfe604001)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcd)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcd) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcc)
diff --git a/board/mb680/mb680-stx7105c2.romgen b/board/mb680/mb680-stx7105c2.romgen
new file mode 100644
index 0000000..fc88679
--- /dev/null
+++ b/board/mb680/mb680-stx7105c2.romgen
@@ -0,0 +1,1665 @@
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000004)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000126) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a6)
+POKE32(0xfe000010, 0x0000c0de)
+POKE32(0xfe0000b8, 0x00000001)
+POKE32(0xfe000010, 0x0000c1a0)
+/* PEEK(0xfe210000) (used target peek value 0x00000000) */
+POKE32(0xfe210000, 0x00800000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000005)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+/* PEEK(0xfe21301c) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+WHILE_NE32(0xfe21301c, 0xffffffff, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+/* PEEK(0xfe213020) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+WHILE_NE32(0xfe213020, 0xffffffff, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80001e02) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80101e02)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x00181e02) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x00180f01)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+WHILE_NE32(0xfe213000, 0x80000000, 0x80000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80000f01)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80102803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000002)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x00182803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x00182803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000002) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+WHILE_NE32(0xfe213004, 0x80000000, 0x80000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80002803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV0_CFG
+*/
+POKE32(0xfe213b00, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV1_CFG
+*/
+POKE32(0xfe213b04, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV2_CFG
+*/
+POKE32(0xfe213b08, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV3_CFG
+*/
+POKE32(0xfe213b0c, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV4_CFG
+*/
+POKE32(0xfe213a10, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV5_CFG
+*/
+POKE32(0xfe213b14, 0x00000307)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV6_CFG
+*/
+POKE32(0xfe213a18, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV7_CFG
+*/
+POKE32(0xfe213a1c, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV8_CFG
+*/
+POKE32(0xfe213b20, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV9_CFG
+*/
+POKE32(0xfe213b24, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV10_CFG
+*/
+POKE32(0xfe213b28, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV11_CFG
+*/
+POKE32(0xfe213b2c, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV12_CFG
+*/
+POKE32(0xfe213b30, 0x00000102)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV13_CFG
+*/
+POKE32(0xfe213a34, 0x00000811)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV14_CFG
+*/
+POKE32(0xfe213b38, 0x0000050b)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV15_CFG
+*/
+POKE32(0xfe213b3c, 0x00000307)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV16_CFG
+*/
+POKE32(0xfe213b40, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV17_CFG
+*/
+POKE32(0xfe213b44, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0xa6aa59aa)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x0000000a)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00000d28) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x00001d28)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00001d28) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000016a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000016a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000006a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1e020380) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00000001, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a10) (used target peek value 0x00010100) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a18) (used target peek value 0x00010100) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a1c) (used target peek value 0x00010100) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b04) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b08) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b00) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b20) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b24) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b28) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b40) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b44) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b14) (used target peek value 0x00000307) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b2c) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b30) (used target peek value 0x00000102) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a34) (used target peek value 0x00000811) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b38) (used target peek value 0x0000050b) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b3c) (used target peek value 0x00000307) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x000001a6) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a2)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x080246a1)
+DELAY(200)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x000001a2) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a6)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1e161fca) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00100400, 0x00100400)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000787f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x002f000c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00400002)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000002)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc23dc)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x07afd7eb)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x00b001eb)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x01eb01eb)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x01eb01eb)
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfe700860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfe700800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfe700810, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfe700820, 0x00000012)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfe700830, 0x00000014)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfe700840, 0x0000001c)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfe700100, 0x001016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfe700108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfe700110, 0x9d220000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfe700118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
+*/
+POKE32(0xfe700140, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
+*/
+POKE32(0xfe700148, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
+*/
+POKE32(0xfe700150, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
+*/
+POKE32(0xfe700158, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfe700180, 0x002046f9)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfe700188, 0xa5a00000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfe700190, 0xa5a20000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfe700198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA0
+*/
+POKE32(0xfe7001c0, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA1
+*/
+POKE32(0xfe7001c8, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA2
+*/
+POKE32(0xfe7001d0, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA3
+*/
+POKE32(0xfe7001d8, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
+*/
+POKE32(0xfe700200, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
+*/
+POKE32(0xfe700208, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
+*/
+POKE32(0xfe700210, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
+*/
+POKE32(0xfe700218, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfe700028, 0x00000010)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080246a1) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30017b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfe90100c, 0x000000b0)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfe901018, 0xcd2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfe90101c, 0x00222ed6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfe901030, 0x1c001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfe901038, 0x1c001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30017b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30037b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfe901028, 0x00000000)
+POKE32(0xfe20d200, 0x00000005)
+POKE32(0xfe20d204, 0x00000004)
+POKE32(0xfe20d208, 0x00000003)
+POKE32(0xfe20d20c, 0x00000002)
+POKE32(0xfe20d210, 0x00000001)
+POKE32(0xfe20d214, 0x00000001)
+POKE32(0xfe20d218, 0x00000001)
+POKE32(0xfe20d21c, 0x00000001)
+POKE32(0xfe20d220, 0x00000001)
+POKE32(0xfe2410fc, 0x00000005)
+POKE32(0xfe20a0ec, 0x00000002)
+POKE32(0xfe20a0f0, 0x00000005)
+POKE32(0xfe20a0f4, 0x00000003)
+POKE32(0xfe20a0f8, 0x00000003)
+POKE32(0xfe20a1ec, 0x00000002)
+POKE32(0xfe20a1f0, 0x00000005)
+POKE32(0xfe20a1f4, 0x00000003)
+POKE32(0xfe20a1f8, 0x00000003)
+POKE32(0xfe20a1fc, 0x00000000)
+POKE32(0xfe20a2ec, 0x00000002)
+POKE32(0xfe20a2f0, 0x00000005)
+POKE32(0xfe20a2f4, 0x00000003)
+POKE32(0xfe20a2f8, 0x00000003)
+POKE32(0xfe20a2fc, 0x00000000)
+POKE32(0xfe20a3ec, 0x00000002)
+POKE32(0xfe20a3f0, 0x00000005)
+POKE32(0xfe20a3f4, 0x00000003)
+POKE32(0xfe20a3f8, 0x00000003)
+POKE32(0xfe20a3fc, 0x00000000)
+POKE32(0xfe20aefc, 0x00000005)
+POKE32(0xfe540034, 0x00000003)
+POKE32(0xfe540038, 0x00000000)
+POKE32(0xfe540110, 0x00010303)
+POKE32(0xfe540114, 0x00000000)
+POKE32(0xfe540030, 0x00000005)
+POKE32(0xfe54010c, 0x00000005)
+POKE32(0xfe540600, 0x00000006)
+POKE32(0xfe540604, 0x00000005)
+POKE32(0xfe540608, 0x00000004)
+POKE32(0xfe54060c, 0x00000003)
+POKE32(0xfe540610, 0x00000002)
+POKE32(0xfe540614, 0x00000001)
+POKE32(0xfe540618, 0x00000000)
+POKE32(0xfe540680, 0x00000001)
+POKE32(0xfe540684, 0x00000000)
+POKE32(0xfe20bb04, 0x00000005)
+POKE32(0xfe20bb08, 0x00000003)
+POKE32(0xfe20bb10, 0x00000002)
+POKE32(0xfe20bb24, 0x00000005)
+POKE32(0xfe20bb28, 0x00000003)
+POKE32(0xfe20bb2c, 0x00000000)
+POKE32(0xfe20bb30, 0x00000002)
+POKE32(0xfe20bb44, 0x00000005)
+POKE32(0xfe20bb48, 0x00000003)
+POKE32(0xfe20bb4c, 0x00000000)
+POKE32(0xfe20bb50, 0x00000002)
+POKE32(0xfe20bb84, 0x00000005)
+POKE32(0xfe20bb88, 0x00000003)
+POKE32(0xfe20bb8c, 0x00000000)
+POKE32(0xfe20bb90, 0x00000002)
+POKE32(0xfe20a0fc, 0x00000000)
+POKE32(0xfe20bb0c, 0x00000000)
+POKE32(0xfe231010, 0x00000008)
+POKE32(0xfe231080, 0x00000221)
+POKE32(0xfe261010, 0x00000008)
+POKE32(0xfe261080, 0x00000221)
+POKE32(0xfd101024, 0x0003c000)
+POKE32(0xfd101824, 0x0003c000)
+POKE32(0xfd104d24, 0x0003c000)
+POKE32(0xfd102024, 0x0003c000)
+/* PEEK(0xfe001180) (used target peek value 0x00000b35) */
+POKE32(0xfe001180, 0x00000b05)
+POKE32(0xfe1fff04, 0x00254608)
+POKE32(0xfeafff04, 0x00254608)
+/* PEEK(0xfe00111c) (used target peek value 0x08081508) */
+POKE32(0xfe00111c, 0x08091508)
+POKE32(0xfd117000, 0x0025c608)
+POKE32(0xfd111000, 0x00201004)
+/* PEEK(0xfe001180) (used target peek value 0x00000b05) */
+POKE32(0xfe001180, 0x00000b01)
+POKE32(0xfe401744, 0x0025c005)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x00000a8c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x04000040) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x04000040)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG26
+*/
+POKE32(0xfe001168, 0xfe804001)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd1)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x08000a8c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x04000040) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x04000040)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG28
+*/
+POKE32(0xfe001170, 0xfe604001)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcd)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcd) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcc)
diff --git a/board/mb680/mb680.c b/board/mb680/mb680.c
index ed8d87a..c7cd953 100644
--- a/board/mb680/mb680.c
+++ b/board/mb680/mb680.c
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2008 STMicroelectronics.
+ * (C) Copyright 2008-2009 STMicroelectronics.
  *
  * Sean McGoogan <Sean.McGoogan@st.com>
  *
@@ -36,6 +36,7 @@
  * in the STB Peripheral board (MB705)*/
 #define EPLD_IDENT		0x00	/* EPLD Identifier Register */
 #define EPLD_TEST		0x02	/* EPLD Test Register */
+#define EPLD_SWITCH		0x04	/* EPLD Switch Register */
 #define EPLD_MISC		0x0a	/* Miscellaneous Control Register */
 
 #ifdef CONFIG_SH_SE_MODE
@@ -109,6 +110,21 @@ static int mb680_init_epld(void)
 	return 0;
 }
 
+#ifdef CONFIG_STMAC_LAN8700
+static void phy_reset(void)
+{
+	/* Reset the SMSC LAN8700 PHY */
+	STPIO_SET_PIN(PIO_PORT(5), 5, 1);
+	STPIO_SET_PIN(PIO_PORT(11), 2, 1);
+	udelay(1);
+	STPIO_SET_PIN(PIO_PORT(5), 5, 0);
+	udelay(100);
+	STPIO_SET_PIN(PIO_PORT(5), 5, 1);
+	udelay(1);
+	STPIO_SET_PIN(PIO_PORT(11), 2, 0);
+}
+#endif	/* CONFIG_STMAC_LAN8700 */
+
 static void configPIO(void)
 {
 	unsigned long sysconf;
@@ -143,12 +159,23 @@ static void configPIO(void)
 	sysconf &= ~0x0f0ful;	/* 3,3,3,3 */
 	sysconf |=  0x000ful;	/* 1,1,1,1 */
 	*STX7105_SYSCONF_SYS_CFG35 = sysconf;
+
+#ifdef CONFIG_STMAC_LAN8700
+	/* Configure SMSC LAN8700 PHY Reset signals */
+	SET_PIO_PIN(PIO_PORT(5), 5, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(11), 2, STPIO_OUT);
+#endif	/* CONFIG_STMAC_LAN8700 */
 }
 
 extern int board_init(void)
 {
 	configPIO();
 
+	/* Reset the PHY */
+#ifdef CONFIG_STMAC_LAN8700
+	phy_reset();
+#endif	/* CONFIG_STMAC_LAN8700 */
+
 	return 0;
 }
 
@@ -167,5 +194,19 @@ int checkboard (void)
 	 */
 	mb680_init_epld();
 
+#if 0	/* QQQ - DELETE */
+{
+const unsigned long nand_reg = *ST40_EMI_NAND_VERSION_REG;
+const unsigned long epld_reg = epld_read(EPLD_SWITCH);
+	printf ("*ST40_EMI_NAND_VERSION_REG = %u.%u.%u\n",
+		(nand_reg>>8)&0x0ful,
+		(nand_reg>>4)&0x0ful,
+		(nand_reg>>0)&0x0ful);
+	printf("*EPLD_SWITCH = 0x%08x  -->  boot-from-%s\n",
+		epld_reg,
+		(epld_reg & (1ul<<8)) ? "NAND" : "NOR");
+}
+#endif	/* QQQ - DELETE */
+
 	return 0;
 }
diff --git a/board/mb680/nand.c b/board/mb680/nand.c
index c013fe1..7abfbf6 100644
--- a/board/mb680/nand.c
+++ b/board/mb680/nand.c
@@ -1,6 +1,6 @@
 /*
  * (C) Copyright 2006 DENX Software Engineering
- * (C) Copyright 2008 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ * (C) Copyright 2008-2009 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -30,14 +30,16 @@
 #include <asm/io.h>
 #include <asm/pio.h>
 #include <asm/stx7105reg.h>
+#include <asm/stm-nand.h>
 
 
 /*
- * hardware specific access to control-lines
+ * hardware specific access to control-lines for "bit-banging".
  *	CL -> Emi_Addr(17)
  *	AL -> Emi_Addr(18)
  *	nCE is handled by EMI (not s/w controlable)
  */
+#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
 static void mb680_hwcontrol(struct mtd_info *mtdinfo, int cmd)
 {
 	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
@@ -61,6 +63,20 @@ static void mb680_hwcontrol(struct mtd_info *mtdinfo, int cmd)
 		break;
 	}
 }
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+/*
+ * hardware specific access to the Ready/not_Busy signal.
+ * Signal is routed through the EMI NAND Controller block.
+ */
+#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
+static int mb680_device_ready(struct mtd_info *mtd)
+{
+	/* extract bit 1: status of RBn pin on boot bank */
+	return ((*ST40_EMI_NAND_RBN_STA) & (1ul<<1)) ? 1 : 0;
+}
+#endif /* CFG_NAND_FLEX_MODE */
 
 
 /*
@@ -83,11 +99,32 @@ static void mb680_hwcontrol(struct mtd_info *mtdinfo, int cmd)
  */
 extern int board_nand_init(struct nand_chip *nand)
 {
-	nand->hwcontrol = mb680_hwcontrol;
-	nand->eccmode = NAND_ECC_SOFT;
-	nand->chip_delay = 25;
-	nand->options = NAND_NO_AUTOINCR;
+	nand->eccmode       = NAND_ECC_SOFT;
+	nand->options       = NAND_NO_AUTOINCR;
+
+#ifdef CFG_NAND_FLEX_MODE	/* for STM "flex-mode" (c.f. "bit-banging") */
+	nand->select_chip   = stm_flex_select_chip;
+	nand->dev_ready     = stm_flex_device_ready;
+	nand->hwcontrol     = stm_flex_hwcontrol;
+	nand->read_byte     = stm_flex_read_byte;
+	nand->write_byte    = stm_flex_write_byte;
+	nand->read_buf      = stm_flex_read_buf;
+	nand->write_buf     = stm_flex_write_buf;
+#else				/* for "bit-banging" (c.f. STM "flex-mode")  */
+	nand->dev_ready     = mb680_device_ready;
+	nand->hwcontrol     = mb680_hwcontrol;
+#endif /* CFG_NAND_FLEX_MODE */
+
+#if 1
+	/* Enable the following to use a Bad Block Table (BBT) */
+	nand->options      |= NAND_USE_FLASH_BBT;
+	nand->scan_bbt      = stm_nand_default_bbt;
+#endif
+
 	return 0;
 }
+
+
 #endif	/* CONFIG_CMD_NAND */
 
+
diff --git a/board/mb680/sconsole.c b/board/mb680/sconsole.c
deleted file mode 100644
index af92525..0000000
--- a/board/mb680/sconsole.c
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-
-#include "sconsole.h"
-
-#if 0
-void (*sconsole_putc) (char) = 0;
-void (*sconsole_puts) (const char *) = 0;
-int (*sconsole_getc) (void) = 0;
-int (*sconsole_tstc) (void) = 0;
-void (*sconsole_setbrg) (void) = 0;
-#endif
-
-#if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
-int serial_init (void)
-{
-	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-	sb->pos = 0;
-	sb->size = 0;
-	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
-
-	return (0);
-}
-
-void serial_putc (char c)
-{
-	if (sconsole_putc) {
-		(*sconsole_putc) (c);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		if (c) {
-			sb->data[sb->pos++] = c;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-void serial_puts (const char *s)
-{
-	if (sconsole_puts) {
-		(*sconsole_puts) (s);
-	} else {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-
-		while (*s) {
-			sb->data[sb->pos++] = *s++;
-			if (sb->pos == sb->max_size) {
-				sb->pos = 0;
-			}
-			if (sb->size < sb->max_size) {
-				sb->size++;
-			}
-		}
-	}
-}
-
-int serial_getc (void)
-{
-	if (sconsole_getc) {
-		return (*sconsole_getc) ();
-	} else {
-		return 0;
-	}
-}
-
-int serial_tstc (void)
-{
-	if (sconsole_tstc) {
-		return (*sconsole_tstc) ();
-	} else {
-		return 0;
-	}
-}
-
-void serial_setbrg (void)
-{
-	if (sconsole_setbrg) {
-		(*sconsole_setbrg) ();
-	}
-}
-
-void sconsole_flush (void)
-{
-	if (sconsole_putc) {
-		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
-		unsigned int end = sb->pos < sb->size
-			? sb->pos + sb->max_size - sb->size
-			: sb->pos - sb->size;
-
-		while (sb->size) {
-			(*sconsole_putc) (sb->data[end++]);
-			if (end == sb->max_size) {
-				end = 0;
-			}
-			sb->size--;
-		}
-	}
-}
-#endif
diff --git a/board/mb680/sconsole.h b/board/mb680/sconsole.h
deleted file mode 100644
index 1666f21..0000000
--- a/board/mb680/sconsole.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * (C) Copyright 2002
- * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef _SCONSOLE_H_
-#define _SCONSOLE_H_
-
-#include <config.h>
-
-typedef struct sconsole_buffer_s
-{
-	unsigned long size;
-	unsigned long max_size;
-	unsigned long pos;
-	char data[1];
-} sconsole_buffer_t;
-
-#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
-
-extern void (*sconsole_putc) (char);
-extern void (*sconsole_puts) (const char *);
-extern int (*sconsole_getc) (void);
-extern int (*sconsole_tstc) (void);
-extern void (*sconsole_setbrg) (void);
-
-extern void sconsole_flush (void);
-
-#endif
diff --git a/board/pdk7105/Makefile b/board/pdk7105/Makefile
new file mode 100644
index 0000000..219443a
--- /dev/null
+++ b/board/pdk7105/Makefile
@@ -0,0 +1,44 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+AOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o nand.o
+
+OBJS	= $(COBJS) $(AOBJS)
+
+$(LIB):	.depend $(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
+		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/pdk7105/config.mk b/board/pdk7105/config.mk
new file mode 100644
index 0000000..86ff620
--- /dev/null
+++ b/board/pdk7105/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2008 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# PDK-7105 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x9BF00000	29-bit mode (Traditional Mode)
+#	0x8FF00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 255MB in P1 (cachable)
+TEXT_BASE = 0x9BF00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/pdk7105/init-pdk7105.S b/board/pdk7105/init-pdk7105.S
new file mode 100644
index 0000000..25bca4d
--- /dev/null
+++ b/board/pdk7105/init-pdk7105.S
@@ -0,0 +1,75 @@
+#include "asm/stx7105reg.h"
+#include "../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb680.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:sdk7105:st40
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "sdk7105" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
+	 */
+#include "pdk7105.romgen"
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE32(STX7105_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	/* Change LMI upper bound addresses
+	 * Upper LMI addr=0x40000000 + 512MiB=0x60000000
+	 */
+	UPDATE32(ST40_LMI_SDRA0_0(), 0x001FFFFF, 0x60000000)
+	UPDATE32(ST40_LMI_SDRA1_0(), 0x001FFFFF, 0x60000000)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/pdk7105/nand.c b/board/pdk7105/nand.c
new file mode 100644
index 0000000..3c2f513
--- /dev/null
+++ b/board/pdk7105/nand.c
@@ -0,0 +1,130 @@
+/*
+ * (C) Copyright 2006 DENX Software Engineering
+ * (C) Copyright 2008-2009 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+
+#if defined(CONFIG_CMD_NAND)
+
+#include <nand.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stx7105reg.h>
+#include <asm/stm-nand.h>
+
+
+/*
+ * hardware specific access to control-lines for "bit-banging".
+ *	CL -> Emi_Addr(17)
+ *	AL -> Emi_Addr(18)
+ *	nCE is handled by EMI (not s/w controlable)
+ */
+#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
+static void pdk7105_hwcontrol(struct mtd_info *mtdinfo, int cmd)
+{
+	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
+
+	switch(cmd) {
+
+	case NAND_CTL_SETCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 17));
+		break;
+
+	case NAND_CTL_CLRCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 17));
+		break;
+
+	case NAND_CTL_SETALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 18));
+		break;
+
+	case NAND_CTL_CLRALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 18));
+		break;
+	}
+}
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+/*
+ * hardware specific access to the Ready/not_Busy signal.
+ * Signal is routed through the EMI NAND Controller block.
+ */
+#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
+static int pdk7105_device_ready(struct mtd_info *mtd)
+{
+	/* extract bit 1: status of RBn pin on boot bank */
+	return ((*ST40_EMI_NAND_RBN_STA) & (1ul<<1)) ? 1 : 0;
+}
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+extern int board_nand_init(struct nand_chip *nand)
+{
+	nand->eccmode       = NAND_ECC_SOFT;
+	nand->options       = NAND_NO_AUTOINCR;
+
+#ifdef CFG_NAND_FLEX_MODE	/* for STM "flex-mode" (c.f. "bit-banging") */
+	nand->select_chip   = stm_flex_select_chip;
+	nand->dev_ready     = stm_flex_device_ready;
+	nand->hwcontrol     = stm_flex_hwcontrol;
+	nand->read_byte     = stm_flex_read_byte;
+	nand->write_byte    = stm_flex_write_byte;
+	nand->read_buf      = stm_flex_read_buf;
+	nand->write_buf     = stm_flex_write_buf;
+#else				/* for "bit-banging" (c.f. STM "flex-mode")  */
+	nand->dev_ready     = pdk7105_device_ready;
+	nand->hwcontrol     = pdk7105_hwcontrol;
+#endif /* CFG_NAND_FLEX_MODE */
+
+#if 1
+	/* Enable the following to use a Bad Block Table (BBT) */
+	nand->options      |= NAND_USE_FLASH_BBT;
+	nand->scan_bbt      = stm_nand_default_bbt;
+#endif
+
+	return 0;
+}
+
+
+#endif	/* CONFIG_CMD_NAND */
+
+
diff --git a/board/pdk7105/pdk7105.c b/board/pdk7105/pdk7105.c
new file mode 100644
index 0000000..29df917
--- /dev/null
+++ b/board/pdk7105/pdk7105.c
@@ -0,0 +1,182 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stx7105reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+
+#define PIO_BASE  0xfd020000	/* Base of PIO block in COMMs block */
+
+
+void flashWriteEnable(void)
+{
+	/* Enable Vpp for writing to flash */
+	/* FLASH_WP# = PIO6[4] = 1 */
+	STPIO_SET_PIN(PIO_PORT(6), 4, 1);
+}
+
+void flashWriteDisable(void)
+{
+	/* Disable Vpp for writing to flash */
+	/* FLASH_WP# = PIO6[4] = 0 */
+	STPIO_SET_PIN(PIO_PORT(6), 4, 0);
+}
+
+static void configEthernet(void)
+{
+	unsigned long sysconf;
+
+	/* Configure & Reset the Ethernet PHY */
+
+	/* Set the GMAC in MII mode */
+	sysconf = *STX7105_SYSCONF_SYS_CFG07;
+	sysconf &= ~0x060f0000ul;
+	sysconf |=  0x08010000ul;
+	*STX7105_SYSCONF_SYS_CFG07 = sysconf;
+
+	sysconf = *STX7105_SYSCONF_SYS_CFG37;
+	/* PIO7[4] CFG37[12,4]  AltFunction = 1 */
+	/* PIO7[5] CFG37[13,5]  AltFunction = 1 */
+	/* PIO7[6] CFG37[14,6]  AltFunction = 1 */
+	/* PIO7[7] CFG37[15,7]  AltFunction = 1 */
+	sysconf &= ~0xf0f0ul;	/* 3,3,3,3,0,0,0,0 */
+	*STX7105_SYSCONF_SYS_CFG37 = sysconf;
+
+	sysconf = *STX7105_SYSCONF_SYS_CFG46;
+	/* PIO8[0] CFG46[8,0]   AltFunction = 1 */
+	/* PIO8[1] CFG46[9,1]   AltFunction = 1 */
+	/* PIO8[2] CFG46[10,2]  AltFunction = 1 */
+	/* PIO8[3] CFG46[11,3]  AltFunction = 1 */
+	/* PIO8[4] CFG46[12,4]  AltFunction = 1 */
+	/* PIO8[5] CFG46[13,5]  AltFunction = 1 */
+	/* PIO8[6] CFG46[14,6]  AltFunction = 1 */
+	/* PIO8[7] CFG46[15,7]  AltFunction = 1 */
+	sysconf &= ~0xfffful;	/* 3,3,3,3,3,3,3,3 */
+	*STX7105_SYSCONF_SYS_CFG46 = sysconf;
+
+	sysconf = *STX7105_SYSCONF_SYS_CFG47;
+	/* PIO9[0] CFG47[8,0]   AltFunction = 1 */
+	/* PIO9[1] CFG47[9,1]   AltFunction = 1 */
+	/* PIO9[2] CFG47[10,2]  AltFunction = 1 */
+	/* PIO9[3] CFG47[11,3]  AltFunction = 1 */
+	/* PIO9[4] CFG47[12,4]  AltFunction = 1 */
+	/* PIO9[5] CFG47[13,5]  AltFunction = 1 */
+	/* PIO9[6] CFG47[14,6]  AltFunction = 1 */
+	sysconf &= ~0x7f7ful;	/* 0,3,3,3,3,3,3,3 */
+	*STX7105_SYSCONF_SYS_CFG47 = sysconf;
+
+	/* Setup PIO for the Ethernet's MII bus */
+	SET_PIO_PIN(PIO_PORT(7),4,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(7),5,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(7),6,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(7),7,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8),0,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8),1,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8),2,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8),3,STPIO_ALT_BIDIR);
+	SET_PIO_PIN(PIO_PORT(8),4,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8),5,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(8),6,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(8),7,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9),0,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9),1,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9),2,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9),3,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9),4,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9),5,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(9),6,STPIO_IN);
+
+	/* Setup PIO for the PHY's reset */
+	SET_PIO_PIN(PIO_PORT(15), 5, STPIO_OUT);
+
+	/* Finally, toggle the PHY Reset pin ("RST#") */
+	STPIO_SET_PIN(PIO_PORT(15), 5, 0);
+	udelay(100);	/* small delay */
+	STPIO_SET_PIN(PIO_PORT(15), 5, 1);
+}
+
+static void configPIO(void)
+{
+	unsigned long sysconf;
+
+	/* Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(4), 0, 1, 2, 3);  /* UART2 - AS0 */
+	SET_PIO_ASC(PIO_PORT(5), 0, 1, 3, 2);  /* UART3 - AS1 */
+
+	/* Setup PIO for FLASH_WP# (Active-Low WriteProtect) */
+	SET_PIO_PIN(PIO_PORT(6), 4, STPIO_OUT);
+
+	/* Select UART2 via PIO4 */
+	sysconf = *STX7105_SYSCONF_SYS_CFG07;
+	/* CFG07[1] = UART2_RXD_SRC_SELECT = 0 */
+	/* CFG07[2] = UART2_CTS_SRC_SELECT = 0 */
+	sysconf &= ~(1ul<<2 | 1ul<<1);
+	*STX7105_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART2 via PIO4 for TX, RX, CTS & RTS */
+	sysconf = *STX7105_SYSCONF_SYS_CFG34;
+	/* PIO4[0] CFG34[8,0]   AltFunction = 3 */
+	/* PIO4[1] CFG34[9,1]   AltFunction = 3 */
+	/* PIO4[2] CFG34[10,2]  AltFunction = 3 */
+	/* PIO4[3] CFG34[11,3]  AltFunction = 3 */
+	sysconf &= ~0x0f0ful;	/* 3,3,3,3 */
+	sysconf |=  0x0f00ul;	/* 2,2,2,2 */
+	*STX7105_SYSCONF_SYS_CFG34 = sysconf;
+
+	/* Route UART3 via PIO5 for TX, RX, CTS & RTS */
+	sysconf = *STX7105_SYSCONF_SYS_CFG35;
+	/* PIO5[0] CFG35[8,0]   AltFunction = 3 */
+	/* PIO5[1] CFG35[9,1]   AltFunction = 3 */
+	/* PIO5[2] CFG35[10,2]  AltFunction = 3 */
+	/* PIO5[3] CFG35[11,3]  AltFunction = 3 */
+	sysconf &= ~0x0f0ful;	/* 3,3,3,3 */
+	sysconf |=  0x000ful;	/* 1,1,1,1 */
+	*STX7105_SYSCONF_SYS_CFG35 = sysconf;
+
+	/* Configure & Reset the Ethernet PHY */
+	configEthernet();
+}
+
+extern int board_init(void)
+{
+	configPIO();
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STx7105-PDK"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	return 0;
+}
diff --git a/board/pdk7105/pdk7105.romgen b/board/pdk7105/pdk7105.romgen
new file mode 100644
index 0000000..4c79ca4
--- /dev/null
+++ b/board/pdk7105/pdk7105.romgen
@@ -0,0 +1,2787 @@
+/* sdk7105 connect start - parameters {'no_devid_validate': '1', 'no_convertor_abort': '1', 'no_devid_abort': '1'}
+ */
+/* Initialization TCK frequency set to 1562500 Hz
+ */
+/* Device id  0x1d43e041
+ */
+/* tapmux connect(): boot mode single core setup
+ */
+/* tapmux setup to bypass to core st40, channel 1
+ */
+/* sdk7105 initialization start ...
+ */
+/* sdk7105_setup - parameters {'tapmux_bypass_init': u'st40', 'no_devid_validate': '1', 'no_convertor_abort': '1', 'reset_low_period': 360000, 'no_devid_abort': '1'}
+ */
+/* Chip infos
+ */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+/*   Device ID = 0x1D43E041 ==> STi7105 cut 2
+ */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+/*   Mode pins = 0x00001015 ==> ClockgenA ref : SYSCLKIN/OSC
+ */
+/*                              Boot mode ... : ST40 first
+ */
+/*                              Boot port size: 16-bits
+ */
+/*                              Boot device . : NOR flash
+ */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000005)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000005) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000005)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000126) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a6)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+/* PEEK(0xfe21301c) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+WHILE_NE32(0xfe21301c, 0xffffffff, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+/* PEEK(0xfe213020) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+WHILE_NE32(0xfe213020, 0xffffffff, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80001e02) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80101e02)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x00181e02) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x00180f01)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+WHILE_NE32(0xfe213000, 0x80000000, 0x80000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80000f01)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80102803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV0_CFG
+*/
+POKE32(0xfe213b00, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV1_CFG
+*/
+POKE32(0xfe213b04, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV2_CFG
+*/
+POKE32(0xfe213b08, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV3_CFG
+*/
+POKE32(0xfe213b0c, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV4_CFG
+*/
+POKE32(0xfe213a10, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV5_CFG
+*/
+POKE32(0xfe213b14, 0x00000307)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV6_CFG
+*/
+POKE32(0xfe213a18, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV7_CFG
+*/
+POKE32(0xfe213a1c, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV8_CFG
+*/
+POKE32(0xfe213b20, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV9_CFG
+*/
+POKE32(0xfe213b24, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV10_CFG
+*/
+POKE32(0xfe213b28, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV11_CFG
+*/
+POKE32(0xfe213b2c, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV12_CFG
+*/
+POKE32(0xfe213b30, 0x00000102)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV13_CFG
+*/
+POKE32(0xfe213a34, 0x00000811)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV14_CFG
+*/
+POKE32(0xfe213b38, 0x0000050b)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV15_CFG
+*/
+POKE32(0xfe213b3c, 0x00000307)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV16_CFG
+*/
+POKE32(0xfe213b40, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV17_CFG
+*/
+POKE32(0xfe213b44, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000002)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x00182803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x00182803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000002) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+WHILE_NE32(0xfe213004, 0x80000000, 0x80000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80002803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0xa6aa59aa)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x0000000a)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00000d28) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x00001d28)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00001d28) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000016a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000016a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000006a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1f1016a4) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00000001, 0x00000000)
+/* set_lmi2x_freq: freq=800.000 rdiv=0x3, ddiv=0x50
+ */
+/* Clock frequencies
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+/*   CKGA_PLL0HS     = 900.0 MHz
+ */
+/*   CKGA_PLL0LS     = 450.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+/*   CKGA_PLL1       = 800.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a10) (used target peek value 0x00010100) */
+/*   ST40 ICK        = 450.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a18) (used target peek value 0x00010100) */
+/*   LX DMU          = 450.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a1c) (used target peek value 0x00010100) */
+/*   LX AUD          = 450.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b04) (used target peek value 0x00000001) */
+/*   FDMA0           = 400.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b08) (used target peek value 0x00000001) */
+/*   FDMA1           = 400.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b00) (used target peek value 0x00000001) */
+/*   STNOC           = 400.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b20) (used target peek value 0x00000103) */
+/*   IC_BDISP_200    = 200.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b24) (used target peek value 0x00000103) */
+/*   IC_DISP_200     = 200.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b28) (used target peek value 0x00000103) */
+/*   IC_TS_200       = 200.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b40) (used target peek value 0x00000103) */
+/*   IC_COMPO_200    = 200.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b44) (used target peek value 0x00000103) */
+/*   IC_IF_200       = 200.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b14) (used target peek value 0x00000307) */
+/*   IC_IF_100       = 100.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b2c) (used target peek value 0x00000103) */
+/*   DISP_PIPE_200   = 200.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b30) (used target peek value 0x00000102) */
+/*   BLIT_PROC       = 266.7 MHz
+ */
+/*   IC_DELTA_200    = 266.7 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a34) (used target peek value 0x00000811) */
+/*   ETHERNET        = 25.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b38) (used target peek value 0x0000050b) */
+/*   PCI             = 66.7 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b3c) (used target peek value 0x00000307) */
+/*   EMI MASTER      = 100.0 MHz
+ */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+/*   LMI2X           = 800.0 MHz
+ */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x000001a6) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a2)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x080006a1)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200780f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200780f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200780f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200780f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200680f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200680f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200680f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200680f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200680f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200680f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200680f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200680f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200680f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200680f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200684f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200684f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200686f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200686f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200687f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200687f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200687f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200687f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200687f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200687f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200687f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200687f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200687f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00400000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00400000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x0000fe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x0000fe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x0000fe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x0000fe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x0000fe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x0000fe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x0020fe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x0020fe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x0020fe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x0020fe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x002cfe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x002cfe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x002ffe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x002ffe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x002ffe0c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000005) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000005)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x20000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x20000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x28000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x28000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x2fb80000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x2fb80000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x2fbbdc00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x2fbbdc00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x2fbbddee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+/* PEEK(0xfe0011ac) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+/* PEEK(0xfe0011ac) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x18000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+/* PEEK(0xfe0011ac) (used target peek value 0x18000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x18a00000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+/* PEEK(0xfe0011ac) (used target peek value 0x18a00000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x18a001ee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+/* PEEK(0xfe0011cc) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+/* PEEK(0xfe0011cc) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+/* PEEK(0xfe0011d0) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+/* PEEK(0xfe0011d0) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x00002000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x00002000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x00002000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x00002000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x00002000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x00002000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x00002000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc2000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc2000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc2000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc2000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc2000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc2000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc2000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc2000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc2280)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc2280) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc22c0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc22c0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc22c0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc22c0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc22c4)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x000001a2) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a6)
+DELAY(10)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1e166c50) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1e166450) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080006a1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080006a1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x2fbbddee) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x2fbbddee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x2fbbddee) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x2fbbddee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x2fbbddee) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x2fbbddee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+/* PEEK(0xfe0011ac) (used target peek value 0x18a001ee) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x18a001ee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+/* PEEK(0xfe0011ac) (used target peek value 0x18a001ee) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x18a001ee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+/* PEEK(0xfe0011cc) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+/* PEEK(0xfe0011cc) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+/* PEEK(0xfe0011d0) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+/* PEEK(0xfe0011d0) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc22c4) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc22c4)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x000001a6) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a2)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080006a1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000006a1)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000006a0)
+DELAY(10)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x080006a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x080006a1)
+DELAY(10)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x000001a2) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a6)
+DELAY(10)
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfe700860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfe700800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfe700810, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfe700820, 0x00000018)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfe700830, 0x0000001a)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfe700840, 0x0000001c)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfe700100, 0x001016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfe700108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfe700110, 0x9d220000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfe700118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
+*/
+POKE32(0xfe700140, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
+*/
+POKE32(0xfe700148, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
+*/
+POKE32(0xfe700150, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
+*/
+POKE32(0xfe700158, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfe700180, 0x002046f9)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfe700188, 0xa5a00000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfe700190, 0xa5a20000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfe700198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA0
+*/
+POKE32(0xfe7001c0, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA1
+*/
+POKE32(0xfe7001c8, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA2
+*/
+POKE32(0xfe7001d0, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA3
+*/
+POKE32(0xfe7001d8, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
+*/
+POKE32(0xfe700200, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
+*/
+POKE32(0xfe700208, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
+*/
+POKE32(0xfe700210, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
+*/
+POKE32(0xfe700218, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfe700028, 0x00000010)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080006a1) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30017b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfe90100c, 0x000000b0)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfe901018, 0xcf35b424)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfe90101c, 0x00242ed8)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfe901030, 0x2c001e20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfe901038, 0x2c001e20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00004363)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00004263)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30017b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30037b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfe901028, 0x00000000)
+/* Info: correcting interco reset setup
+ */
+POKE32(0xfe20d200, 0x00000005)
+POKE32(0xfe20d204, 0x00000004)
+POKE32(0xfe20d208, 0x00000003)
+POKE32(0xfe20d20c, 0x00000002)
+POKE32(0xfe20d210, 0x00000001)
+POKE32(0xfe20d214, 0x00000001)
+POKE32(0xfe20d218, 0x00000001)
+POKE32(0xfe20d21c, 0x00000001)
+POKE32(0xfe20d220, 0x00000001)
+POKE32(0xfe2410fc, 0x00000005)
+POKE32(0xfe20a0ec, 0x00000002)
+POKE32(0xfe20a0f0, 0x00000005)
+POKE32(0xfe20a0f4, 0x00000003)
+POKE32(0xfe20a0f8, 0x00000003)
+POKE32(0xfe20a1ec, 0x00000002)
+POKE32(0xfe20a1f0, 0x00000005)
+POKE32(0xfe20a1f4, 0x00000003)
+POKE32(0xfe20a1f8, 0x00000003)
+POKE32(0xfe20a1fc, 0x00000000)
+POKE32(0xfe20a2ec, 0x00000002)
+POKE32(0xfe20a2f0, 0x00000005)
+POKE32(0xfe20a2f4, 0x00000003)
+POKE32(0xfe20a2f8, 0x00000003)
+POKE32(0xfe20a2fc, 0x00000000)
+POKE32(0xfe20a3ec, 0x00000002)
+POKE32(0xfe20a3f0, 0x00000005)
+POKE32(0xfe20a3f4, 0x00000003)
+POKE32(0xfe20a3f8, 0x00000003)
+POKE32(0xfe20a3fc, 0x00000000)
+POKE32(0xfe20aefc, 0x00000005)
+POKE32(0xfe540034, 0x00000003)
+POKE32(0xfe540038, 0x00000000)
+POKE32(0xfe540110, 0x00010303)
+POKE32(0xfe540114, 0x00000000)
+POKE32(0xfe540030, 0x00000005)
+POKE32(0xfe54010c, 0x00000005)
+POKE32(0xfe540600, 0x00000006)
+POKE32(0xfe540604, 0x00000005)
+POKE32(0xfe540608, 0x00000004)
+POKE32(0xfe54060c, 0x00000003)
+POKE32(0xfe540610, 0x00000002)
+POKE32(0xfe540614, 0x00000001)
+POKE32(0xfe540618, 0x00000000)
+POKE32(0xfe540680, 0x00000001)
+POKE32(0xfe540684, 0x00000000)
+POKE32(0xfe20bb04, 0x00000005)
+POKE32(0xfe20bb08, 0x00000003)
+POKE32(0xfe20bb10, 0x00000002)
+POKE32(0xfe20bb24, 0x00000005)
+POKE32(0xfe20bb28, 0x00000003)
+POKE32(0xfe20bb2c, 0x00000000)
+POKE32(0xfe20bb30, 0x00000002)
+POKE32(0xfe20bb44, 0x00000005)
+POKE32(0xfe20bb48, 0x00000003)
+POKE32(0xfe20bb4c, 0x00000000)
+POKE32(0xfe20bb50, 0x00000002)
+POKE32(0xfe20bb84, 0x00000005)
+POKE32(0xfe20bb88, 0x00000003)
+POKE32(0xfe20bb8c, 0x00000000)
+POKE32(0xfe20bb90, 0x00000002)
+POKE32(0xfe20a0fc, 0x00000000)
+POKE32(0xfe20bb0c, 0x00000000)
+POKE32(0xfe231010, 0x00000008)
+POKE32(0xfe231080, 0x00000221)
+POKE32(0xfe261010, 0x00000008)
+POKE32(0xfe261080, 0x00000221)
+POKE32(0xfd101024, 0x0003c000)
+POKE32(0xfd101824, 0x0003c000)
+POKE32(0xfd104d24, 0x0003c000)
+POKE32(0xfd102024, 0x0003c000)
+/* PEEK(0xfe001180) (used target peek value 0x00000b35) */
+POKE32(0xfe001180, 0x00000b05)
+POKE32(0xfe1fff04, 0x00254608)
+POKE32(0xfeafff04, 0x00254608)
+/* PEEK(0xfe00111c) (used target peek value 0x08081508) */
+POKE32(0xfe00111c, 0x08091508)
+POKE32(0xfd117000, 0x0025c608)
+POKE32(0xfd111000, 0x00201004)
+/* PEEK(0xfe001180) (used target peek value 0x00000b05) */
+POKE32(0xfe001180, 0x00000b01)
+POKE32(0xfe401744, 0x0025c005)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x00000a8c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x04000040) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x04000040)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG26
+*/
+POKE32(0xfe001168, 0xfe804001)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd1)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd0)
+/* stx7105: booted audio companion
+ */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x08000a8c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x04000040) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x04000040)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG28
+*/
+POKE32(0xfe001170, 0xfe604001)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcd)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcd) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcc)
+/* stx7105: booted video companion
+ */
+/* TCK frequency set to 12500000 Hz
+ */
+/* tapmux complete_connect(): single core setup
+ */
+/* sdk7105 initialization complete
+ */
diff --git a/board/pdk7105/u-boot.lds b/board/pdk7105/u-boot.lds
new file mode 100644
index 0000000..3a1e91b
--- /dev/null
+++ b/board/pdk7105/u-boot.lds
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2007 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(sh4)
+ENTRY(_start)
+
+SECTIONS
+{
+	.text ALIGN(0x4):
+	{
+		__text_start = .;
+		cpu/sh/start.o (.text)
+		*(.text)
+		__text_end = .;
+	}
+
+	.rodata ALIGN(0x4):
+	{
+		__rodata_start = .;
+		*(.rodata)
+		__rodata_end = .;
+	}
+
+	.data ALIGN(0x4):
+	{
+		__data_start = .;
+		*(.data)
+		__data_end = .;
+	}
+
+	.u_boot_cmd ALIGN(0x4):
+	{
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	_uboot_end_data = .;
+
+	.bss ALIGN(0x4):
+	{
+		__bss_start = .;
+		*(.bss)
+		__bss_end = .;
+	}
+	_uboot_end = .;
+}
diff --git a/common/cmd_bdinfo.c b/common/cmd_bdinfo.c
index 49cf608..0fb7229 100644
--- a/common/cmd_bdinfo.c
+++ b/common/cmd_bdinfo.c
@@ -2,6 +2,9 @@
  * (C) Copyright 2003
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
+ * (C) Copyright 2009 STMicroelectronics.
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -294,8 +297,15 @@ int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	DECLARE_GLOBAL_DATA_PTR;
-
-	int i;
+#if defined(CONFIG_CMD_BDI_DUMP_EMI_BANKS)
+	#define MAX_EMI_BANKS	6	/* Maximum of 6 EMI Banks */
+	const u32 emi_base = 0xa0000000u;
+	u32 base[MAX_EMI_BANKS+1];	/* Base address for each bank */
+	u32 enabled;			/* number of enabled EMI banks */
+#endif	/* CONFIG_CMD_BDI_DUMP_EMI_BANKS */
+#if defined(CONFIG_CMD_NET) || defined(CONFIG_CMD_BDI_DUMP_EMI_BANKS)
+	unsigned int i;
+#endif
 	bd_t *bd = gd->bd;
 
 	print_num ("boot_params",	(ulong)bd->bi_boot_params);
@@ -358,6 +368,44 @@ int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	print_mhz ("EMI",		bd->bi_emifrq);
 #endif	/* CONFIG_SH_STB7100 */
 
+#if defined(CONFIG_CMD_BDI_DUMP_EMI_BANKS)
+	enabled = *ST40_EMI_BANK_ENABLE;
+	printf("#EMI Banks  = %u\n", enabled);
+	if (enabled > MAX_EMI_BANKS)
+	{
+		printf("Error: Maximum Number of Enabled Banks should be %u\n", MAX_EMI_BANKS);
+		enabled = MAX_EMI_BANKS;
+	}
+
+	/*
+	 * EmiBaseAddress[5:0] == Address[27:22] (Multiple of 4MiB)
+	 *
+	 * Retreive all the configured EMI bank bases into base[].
+	 */
+	for(i=0; i<enabled; i++)
+	{
+		const u32 start = *ST40_EMI_BASEADDRESS(i) & 0x3fu;
+		base[i] = emi_base + (start << (22));
+	}
+	/* last valid bank occupies all remaining space */
+	base[i] = emi_base + (128u << (20));	/* total size of EMI is 128MiB */
+
+	/*
+	 * Print out the ranges of each bank.
+	 */
+	for(i=0; i<enabled; i++)
+	{
+		const u32 lower = base[i];
+		const u32 upper = base[i+1];
+		printf ("EMI #%u CS%c  = 0x%08X ... 0x%08X (",
+			i,
+			'A' + i,
+			lower,
+			upper-1u);
+		print_size (upper-lower, ")\n");
+	}
+#endif	/* CONFIG_CMD_BDI_DUMP_EMI_BANKS */
+
 	return 0;
 }
 
diff --git a/cpu/sh/Makefile b/cpu/sh/Makefile
index 71308cc..b66a274 100644
--- a/cpu/sh/Makefile
+++ b/cpu/sh/Makefile
@@ -26,7 +26,7 @@ include $(TOPDIR)/config.mk
 LIB	= lib$(CPU).a
 
 START	= start.o
-OBJS	= cpu.o interrupts.o usb.o cmd_pmb.o
+OBJS	= cpu.o interrupts.o usb.o cmd_pmb.o ecc.o stm-nand.o
 SOBJS	=
 
 all:	.depend $(START) $(LIB)
diff --git a/cpu/sh/ecc.c b/cpu/sh/ecc.c
new file mode 100644
index 0000000..1f17e8c
--- /dev/null
+++ b/cpu/sh/ecc.c
@@ -0,0 +1,489 @@
+/*
+ * Synopsis : Error Correction Codes (ECC) Algorithms.
+ *
+ * Copyright (c) 2008-2009 STMicroelectronics Limited.  All right reserved.
+ *
+ * See ecc.h for a description of this module.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#if defined(CONFIG_CMD_NAND)
+
+#include <asm/ecc.h>
+
+
+static const unsigned char byte_parity_table[] =   /* Parity look up table */
+{
+  0x00, 0x2B, 0x2D, 0x06, 0x33, 0x18, 0x1E, 0x35,
+  0x35, 0x1E, 0x18, 0x33, 0x06, 0x2D, 0x2B, 0x00,
+  0x4B, 0x60, 0x66, 0x4D, 0x78, 0x53, 0x55, 0x7E,
+  0x7E, 0x55, 0x53, 0x78, 0x4D, 0x66, 0x60, 0x4B,
+  0x4D, 0x66, 0x60, 0x4B, 0x7E, 0x55, 0x53, 0x78,
+  0x78, 0x53, 0x55, 0x7E, 0x4B, 0x60, 0x66, 0x4D,
+  0x06, 0x2D, 0x2B, 0x00, 0x35, 0x1E, 0x18, 0x33,
+  0x33, 0x18, 0x1E, 0x35, 0x00, 0x2B, 0x2D, 0x06,
+  0x53, 0x78, 0x7E, 0x55, 0x60, 0x4B, 0x4D, 0x66,
+  0x66, 0x4D, 0x4B, 0x60, 0x55, 0x7E, 0x78, 0x53,
+  0x18, 0x33, 0x35, 0x1E, 0x2B, 0x00, 0x06, 0x2D,
+  0x2D, 0x06, 0x00, 0x2B, 0x1E, 0x35, 0x33, 0x18,
+  0x1E, 0x35, 0x33, 0x18, 0x2D, 0x06, 0x00, 0x2B,
+  0x2B, 0x00, 0x06, 0x2D, 0x18, 0x33, 0x35, 0x1E,
+  0x55, 0x7E, 0x78, 0x53, 0x66, 0x4D, 0x4B, 0x60,
+  0x60, 0x4B, 0x4D, 0x66, 0x53, 0x78, 0x7E, 0x55,
+  0x55, 0x7E, 0x78, 0x53, 0x66, 0x4D, 0x4B, 0x60,
+  0x60, 0x4B, 0x4D, 0x66, 0x53, 0x78, 0x7E, 0x55,
+  0x1E, 0x35, 0x33, 0x18, 0x2D, 0x06, 0x00, 0x2B,
+  0x2B, 0x00, 0x06, 0x2D, 0x18, 0x33, 0x35, 0x1E,
+  0x18, 0x33, 0x35, 0x1E, 0x2B, 0x00, 0x06, 0x2D,
+  0x2D, 0x06, 0x00, 0x2B, 0x1E, 0x35, 0x33, 0x18,
+  0x53, 0x78, 0x7E, 0x55, 0x60, 0x4B, 0x4D, 0x66,
+  0x66, 0x4D, 0x4B, 0x60, 0x55, 0x7E, 0x78, 0x53,
+  0x06, 0x2D, 0x2B, 0x00, 0x35, 0x1E, 0x18, 0x33,
+  0x33, 0x18, 0x1E, 0x35, 0x00, 0x2B, 0x2D, 0x06,
+  0x4D, 0x66, 0x60, 0x4B, 0x7E, 0x55, 0x53, 0x78,
+  0x78, 0x53, 0x55, 0x7E, 0x4B, 0x60, 0x66, 0x4D,
+  0x4B, 0x60, 0x66, 0x4D, 0x78, 0x53, 0x55, 0x7E,
+  0x7E, 0x55, 0x53, 0x78, 0x4D, 0x66, 0x60, 0x4B,
+  0x00, 0x2B, 0x2D, 0x06, 0x33, 0x18, 0x1E, 0x35,
+  0x35, 0x1E, 0x18, 0x33, 0x06, 0x2D, 0x2B, 0x00
+};
+
+static const unsigned char  bit_count_table[] =   /* Parity look up table */
+{
+  0, 1, 1, 2, 1, 2, 2, 3,
+  1, 2, 2, 3, 2, 3, 3, 4,
+  1, 2, 2, 3, 2, 3, 3, 4,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  1, 2, 2, 3, 2, 3, 3, 4,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  1, 2, 2, 3, 2, 3, 3, 4,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  4, 5, 5, 6, 5, 6, 6, 7,
+  1, 2, 2, 3, 2, 3, 3, 4,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  4, 5, 5, 6, 5, 6, 6, 7,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  4, 5, 5, 6, 5, 6, 6, 7,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  4, 5, 5, 6, 5, 6, 6, 7,
+  4, 5, 5, 6, 5, 6, 6, 7,
+  5, 6, 6, 7, 6, 7, 7, 8
+};
+
+/*******************************************************************************/
+#define COL_LOOP_STEP(c__f, c__e, c__o, c__t) \
+  c__o ^= (c__f ? c__t : 1); \
+  c__e ^= (c__f ? 1 : c__t);
+
+/* Generate 3 byte ECC code for ecc_size block p_data.
+   "p_data" is a pointer to the data and must be 4-byte aligned.
+   "size" gives length of "p_data" - one of enum ecc_size.
+ */
+ecc_t ecc_gen(const unsigned char* p_data, const enum ecc_size size)
+{
+  const unsigned long* const p_data_long = (unsigned long*)p_data;
+  unsigned long parity_bits[18];  /* maximum number */
+  unsigned long reg32;
+  unsigned long temp;
+  unsigned long int_cnt;
+  unsigned long bit_cnt;
+
+  unsigned int num_parity_bits;
+
+  unsigned char* p_byt;
+  unsigned char byte_reg;
+  unsigned char byte_a;
+  unsigned char byte_b;
+  unsigned char byte_c;
+  unsigned char byte_d;
+
+  ecc_t result;
+  if ( (size!=128) || (((unsigned long)p_data)%4!=0) )	/* QQQ - DELETE */
+  {							/* QQQ - DELETE */
+	printf("ERROR: %s(p_data=%p, size=%u)\n",	/* QQQ - DELETE */
+		__FUNCTION__, p_data, (unsigned)size);	/* QQQ - DELETE */
+  }							/* QQQ - DELETE */
+
+  switch (size)
+  {
+    case ECC_128:
+    default:
+      num_parity_bits = 14;
+      break;
+    case ECC_256:
+      num_parity_bits = 16;
+      break;
+    case ECC_512:
+      num_parity_bits = 18;
+      break;
+  }
+
+  /* Initialize variables */
+  byte_reg = 0;
+  reg32 = 0;
+
+  result.byte[0] = result.byte[1] = result.byte[2] = 0;
+
+  for(bit_cnt = 0; bit_cnt < num_parity_bits; bit_cnt ++)
+  {
+    parity_bits[bit_cnt] = 0;
+  } /* for bit_cnt */
+
+  /* Build up column parity */
+  for(int_cnt = 0; int_cnt < size/sizeof(unsigned long); int_cnt++)
+  {
+    temp = p_data_long[int_cnt];
+
+    switch (size)
+    {
+      case ECC_512:
+        COL_LOOP_STEP((int_cnt & 0x40), parity_bits[16], parity_bits[17], temp);
+        /* fall through */
+      case ECC_256:
+        COL_LOOP_STEP((int_cnt & 0x20), parity_bits[14], parity_bits[15], temp);
+        /* fall through */
+      case ECC_128:
+        COL_LOOP_STEP((int_cnt & 0x01), parity_bits[4], parity_bits[5], temp);
+        COL_LOOP_STEP((int_cnt & 0x02), parity_bits[6], parity_bits[7], temp);
+        COL_LOOP_STEP((int_cnt & 0x04), parity_bits[8], parity_bits[9], temp);
+        COL_LOOP_STEP((int_cnt & 0x08), parity_bits[10], parity_bits[11], temp);
+        COL_LOOP_STEP((int_cnt & 0x10), parity_bits[12], parity_bits[13], temp);
+    }
+  } /* for int_cnt */
+
+  reg32 = parity_bits[12] ^ parity_bits[13];
+
+  p_byt = (unsigned char*)&reg32;
+#if __LITTLE_ENDIAN__
+  byte_a = p_byt[3];
+  byte_b = p_byt[2];
+  byte_c = p_byt[1];
+  byte_d = p_byt[0];
+#else
+  byte_a = p_byt[0];
+  byte_b = p_byt[1];
+  byte_c = p_byt[2];
+  byte_d = p_byt[3];
+#endif
+
+  byte_reg = byte_a ^ byte_b ^ byte_c ^ byte_d;
+
+  byte_reg = byte_parity_table[byte_reg] >> 1;
+
+
+  /* Create line parity */
+  parity_bits[0] = byte_d ^ byte_b;
+  parity_bits[1] = byte_c ^ byte_a;
+  parity_bits[2] = byte_d ^ byte_c;
+  parity_bits[3] = byte_b ^ byte_a;
+
+  for(bit_cnt = 4; bit_cnt < num_parity_bits; bit_cnt++)
+  {
+    p_byt = (unsigned char*)(parity_bits + bit_cnt);
+    p_byt[0] ^= (p_byt[1] ^ p_byt[2] ^ p_byt[3]); /* NB Only LS Byte of parity_bits used from now on */
+  } /* for bit_cnt */
+
+  /* Calculate final ECC code */
+  for(bit_cnt = 0; bit_cnt < 8; bit_cnt ++)
+    result.byte[0] |= (byte_parity_table[ (unsigned char)parity_bits[bit_cnt] ] & 0x01) << bit_cnt;
+  for(; bit_cnt < 16 && bit_cnt < num_parity_bits; bit_cnt ++)
+    result.byte[1] |= (byte_parity_table[ (unsigned char)parity_bits[bit_cnt] ] & 0x01) << (bit_cnt - 8);
+  for(; bit_cnt < num_parity_bits; bit_cnt ++)
+    result.byte[2] |= (byte_parity_table[ (unsigned char)parity_bits[bit_cnt] ] & 0x01) << (bit_cnt - 16);
+
+  result.byte[2] = (unsigned char)(byte_reg << 2) | (result.byte[2] & 0x03);
+
+  return result;
+} /* ecc_gen */
+
+
+/*******************************************************************************/
+/* Detect and correct a 1 bit error in a 128, 256 or 512 byte block.
+   "p_data" is a pointer to the data.
+   "old_ecc" is the proper ECC for the data.
+   "new_ecc" is the ECC generated from the (possibly) corrupted data.
+   The size of the block is given in "size".
+
+   Returns whether the data needed correcting, or was not correctable.
+   If the result code is E_D1_CHK, then the data will have been modified.
+ */
+enum ecc_check ecc_correct(unsigned char* p_data,
+                           ecc_t old_ecc,
+                           ecc_t new_ecc,
+                           enum ecc_size size)
+{
+  unsigned char bit_cnt02;
+  unsigned char bit_addr02;
+  unsigned int byte_addr02;
+
+  unsigned char ecc_xor[3];
+
+  unsigned char error_bit_count;
+  switch (size)
+  {
+    case ECC_128:
+    default:
+      error_bit_count = 10;
+      break;
+    case ECC_256:
+      error_bit_count = 11;
+      break;
+    case ECC_512:
+      error_bit_count = 12;
+      break;
+  }
+
+  /* Basic Error Detection phase */
+  ecc_xor[0] = new_ecc.byte[0] ^ old_ecc.byte[0];
+  ecc_xor[1] = new_ecc.byte[1] ^ old_ecc.byte[1];
+  ecc_xor[2] = new_ecc.byte[2] ^ old_ecc.byte[2];
+
+  if ((ecc_xor[0] | ecc_xor[1] | ecc_xor[2]) == 0)
+  {
+    return E_NO_CHK;  /* No errors */
+  }
+  /* If we get here then there were errors */
+
+  if (size == ECC_512)
+  {
+    /* 512-byte error correction requires a little more than 128 or 256.
+       If there is a correctable error then the xor will have 12 bits set,
+       but there can also be 12 bits set in some uncorrectable errors.
+       This can be solved by xoring the odd and even numbered bits.
+
+       0xAA = 10101010
+       0x55 = 01010101
+     */
+    bit_cnt02  = bit_count_table[ ((ecc_xor[0] & 0xAA) >> 1) ^ (ecc_xor[0] & 0x55) ];
+    bit_cnt02 += bit_count_table[ ((ecc_xor[1] & 0xAA) >> 1) ^ (ecc_xor[1] & 0x55) ];
+    bit_cnt02 += bit_count_table[ ((ecc_xor[2] & 0xAA) >> 1) ^ (ecc_xor[2] & 0x55) ];
+  }
+  else
+  {
+    /* Counts the number of bits set in ecc code */
+    bit_cnt02  = bit_count_table[ ecc_xor[0] ];
+    bit_cnt02 += bit_count_table[ ecc_xor[1] ];
+    bit_cnt02 += bit_count_table[ ecc_xor[2] ];
+  }
+
+  if (bit_cnt02 == error_bit_count)
+  {
+    /* Set the bit address */
+    bit_addr02 = ((ecc_xor[2] >> 3) & 0x01) |
+                 ((ecc_xor[2] >> 4) & 0x02) |
+                 ((ecc_xor[2] >> 5) & 0x04);
+
+    /* Evaluate 2 LS bits of address */
+    byte_addr02 = ((ecc_xor[0] >> 1) & 0x01) | ((ecc_xor[0] >> 2) & 0x02);
+
+    /* Add in remaining bits of address */
+    switch (size)
+    {
+      case ECC_512:
+        byte_addr02 |= (((unsigned int)ecc_xor[2]) << 7) & 0x100;
+        /* Fall through */
+      case ECC_256:
+        byte_addr02 |= (ecc_xor[1] & 0x80);
+        /* Fall through */
+      case ECC_128:
+        byte_addr02 |= ((ecc_xor[0] >> 3) & 0x04) |
+                       ((ecc_xor[0] >> 4) & 0x08) |
+                       ((ecc_xor[1] << 3) & 0x10) |
+                       ((ecc_xor[1] << 2) & 0x20) |
+                       ((ecc_xor[1] << 1) & 0x40);
+    }
+
+
+    /* Correct bit error in the data */
+    p_data[byte_addr02] ^= (0x01 << bit_addr02);
+
+    /* NB p_old_code is okay, p_new_code is corrupt */
+
+    return E_D1_CHK;  /* Data had 1-bit error (now corrected) */
+  } /* if (bit_cnt02 == 11) */
+  else
+  {
+    if (bit_cnt02 == 1)
+    {
+      return E_C1_CHK;  /* ECC code has 1-bit error, data is okay */
+    } /* if (bit_cnt02 == 1) */
+    else
+    {
+      return E_UN_CHK;  /* Uncorrectable Error */
+    } /* else !(bit_cnt02 == 1) */
+  } /* else !(bit_cnt02 == 11) */
+} /* ecc_correct */
+/*******************************************************************************/
+
+
+#ifdef TESTING
+/* To test this code, compile as follows:
+
+       sh4gcc -mboard=<board> -g ecc.c -DTESTING
+
+   This provides a sanity test ONLY. It gives complete coverage of the code,
+   but does not fully exercise the mathmatics behind the algorithm.
+ */
+#include <stdlib.h>
+#include <time.h>
+
+int main()
+{
+  unsigned char data[512];
+  ecc_t ecc1;
+  ecc_t ecc2;
+  int i, size;
+
+  for (size = 128; size <= 512; size *= 2)
+  {
+    /* Create a data set */
+    for (i = 0; i < size; i++)
+      data[i] = i & 0xFF;
+
+    /* Create the initial ecc */
+    ecc1 = ecc_gen(data, size);
+
+    /* Make sure that it doesn't try to "correct" it before it's corrupted */
+    if (ecc_correct(data, ecc1, ecc1, size) != E_NO_CHK)
+    {
+      printf("Error: failed to detect good data.\n");
+      exit(1);
+    }
+
+    for (i = 0; i < size; i++)
+      if (data[i] != (i & 0xFF))
+      {
+  printf("Error: corrupted good data.\n");
+  exit(1);
+      }
+
+    /* Deliberately corrupt the data with 1 bit error only */
+    data[size-42] ^= 1;
+
+    /* Create a new ecc for the bad data */
+    ecc2 = ecc_gen(data, size);
+
+    /* Make sure that it can fix the issues */
+    if (ecc_correct(data, ecc1, ecc2, size) != E_D1_CHK)
+    {
+      printf("Error: failed to diagnose 1 bit data error.\n");
+      exit(1);
+    }
+
+    for (i = 0; i < size; i++)
+      if (data[i] != (i & 0xFF))
+      {
+        printf("Error: did not correct bad data.\n");
+        exit(1);
+      }
+    /* Data is now GOOD */
+
+    /* Deliberately corrupt the ECC with 1 bit error */
+    ecc2.byte[0] = ecc1.byte[0];
+    ecc2.byte[1] = ecc1.byte[1] ^ 4;
+    ecc2.byte[2] = ecc1.byte[2];
+
+    /* Simulate reading bad ECC from flash, but calculating good ECC from data */
+    if (ecc_correct(data, ecc2, ecc1, size) != E_C1_CHK)
+    {
+      printf("Error: failed to diagnose 1 bit ECC error.\n");
+      exit(1);
+    }
+
+    /* Deliberately corrupt the data with a 2-bit error */
+    data[size-42] ^= 3;
+
+    /* Create a new ecc for the bad data */
+    ecc2 = ecc_gen(data, size);
+
+    /* Check that it reports that it cannot correct the issue */
+    if (ecc_correct(data, ecc1, ecc2, size) != E_UN_CHK)
+    {
+      printf("Error: failed to diagnose 2-bit corruption.\n");
+      exit(1);
+    }
+
+    printf("ECC %d working as expected\n", size);
+  }
+
+  /* The above tests show that all is well with the various code paths.
+     However, it does not test detection of 2-bit error detection so well.
+     These tests generate and corrupt random data sets and ensures that
+     the algorithm does not mis-diagnose the condition.
+
+     Notes:
+     1. There is nothing to stop it corrupting the same bit twice - in which
+     case it will correctly diagnose a 1-bit error.
+     2. 3-bit errors and worse cause undefined behaviour, so we don't test those.
+   */
+  printf("\nECC 512 random data tests (interrupt when satisfied)\n");
+
+  srand(time(NULL));
+  while (1)
+  {
+    for (i = 0; i < 512; i++)
+      /* Random number 0..255 */
+      data[i] = (unsigned char)(256.0 * rand() / (RAND_MAX + 1.0));
+
+    ecc1 = ecc_gen(data, ECC_512);
+
+    for (i = 0; i < 2; i++)
+    {
+      /* Random number 0..514 */
+      int corruptbyte = (int)(515.0 * rand() / (RAND_MAX + 1.0));
+      /* Random number 0..7 */
+      int corruptbit = (int)(8.0 * rand() / (RAND_MAX + 1.0));
+
+      if (corruptbyte < 512)
+        data[corruptbyte] ^= 1 << corruptbit;
+      else
+        ecc1.byte[corruptbyte - 512] ^= 1 << corruptbit;
+
+      printf("%3d:%d ", corruptbyte, corruptbit);
+    }
+
+    ecc2 = ecc_gen(data, ECC_512);
+
+    if (ecc_correct(data, ecc1, ecc2, ECC_512) != E_UN_CHK)
+      printf("Error: failed to diagnose 2-bit-corruption\n");
+    else
+      printf("OK\n");
+  }
+
+  return 0;
+}
+#endif
+#endif	/* CONFIG_CMD_NAND */
diff --git a/cpu/sh/start.S b/cpu/sh/start.S
index 5ee33f7..590d9db 100644
--- a/cpu/sh/start.S
+++ b/cpu/sh/start.S
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2004-2008 STMicroelectronics.
+ * (C) Copyright 2004-2009 STMicroelectronics.
  *
  * Andy Sturges <andy.sturges@st.com>
  * Sean McGoogan <Sean.McGoogan@st.com>
@@ -71,6 +71,31 @@ disable_watchdog:
 	MOV_CONST16_R0 0xA500	/* WTCSR.TME=0 */
 	mov.w   r0, @r1
 
+
+	/*
+	 * If were are going to boot U-boot from NAND flash, then
+	 * we need add a special "signature" pattern in the first
+	 * logical block (block zero).
+	 */
+#ifdef CFG_BOOT_FROM_NAND
+skip_signature:
+	bra	skipped_signature	/* skip over the "block 0 signature" */
+	 nop
+
+	/*
+	 * Write out the 64-byte preamble signature pattern, to identify
+	 * the current NAND flash block, as the good "logical block ZERO".
+	 * This signature must start at offset +0x0080 in the block.
+	 */
+	.balign 0x80, 0x00		/* starts 128 bytes into "Block Zero" */
+preamble_signature_pattern:
+	bytes 0x00 0x3f			/* 64-bytes: 0x00, 0x01, ..., 0x3f */
+
+skipped_signature:
+					/* resume from here */
+#endif	/* CFG_BOOT_FROM_NAND */
+
+
 	/*
 	 * Determine if we are in the correct location ? (i.e. RAM)
 	 *  r8 == 1 in RAM, assume initialization already done by GDB.
@@ -132,6 +157,9 @@ set_pmb:
 #if defined(CONFIG_SH_STB7100)
 	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI-Sys UN-cached */
 	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI-Sys UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	#error Need to configure PMBs properly when more than 128MiB.
+	#endif
 	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
 	SH4_SET_PMB 5 0xa8 0x00  16		/* NOR FLASH CACHED */
 	SH4_SET_PMB 6 0xb2 0x02  16 0 0 1	/* OFF-chip  Peripherals UN-cached */
@@ -144,15 +172,43 @@ set_pmb:
 	SH4_SET_PMB 1 0x88 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
 	SH4_SET_PMB 3 0x98 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
 	#endif
+	#ifdef CFG_BOOT_FROM_NAND /* booting from NAND, so CSA and CSB swapped in EPLD */
+	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NAND FLASH UN-cached */
+	SH4_SET_PMB 5 0xa4 0x04  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 6 0xa5 0x05  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 7 0xa8 0x04  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 8 0xa9 0x05  16		/* NOR FLASH CACHED */
+	#else	/* else, CSA and CSB are not swapped in EPLD */
 	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
 	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR FLASH UN-cached */
 	SH4_SET_PMB 6 0xa4 0x04  16 0 0 1	/* NAND FLASH UN-cached */
 	SH4_SET_PMB 7 0xa8 0x00  16		/* NOR FLASH CACHED */
 	SH4_SET_PMB 8 0xa9 0x01  16		/* NOR FLASH CACHED */
+	#endif	/* CFG_BOOT_FROM_NAND */
 	SH4_SET_PMB 9 0xb7 0x07  16 0 0 1	/* EPLD UN-cached */
+#elif defined(CONFIG_SH_STX7105) && defined(CONFIG_SH_PDK7105)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	SH4_SET_PMB 1 0x88 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	SH4_SET_PMB 3 0x98 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	#endif
+	SH4_SET_PMB  4 0xa0 0x00  64 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB  5 0xa4 0x04  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB  6 0xa5 0x05  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB  7 0xa6 0x06  16 0 0 1	/* NAND + CI UN-cached */
+	SH4_SET_PMB  8 0xa7 0x07  16 0 0 1	/* PCI UN-cached */
+	SH4_SET_PMB  9 0xa8 0x00  64		/* NOR FLASH CACHED */
+	SH4_SET_PMB 10 0xac 0x04  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 11 0xad 0x05  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 12 0xae 0x06  16		/* NAND + CI CACHED */
+	SH4_SET_PMB 13 0xaf 0x07  16		/* PCI CACHED */
 #elif defined(CONFIG_SH_STX7111) && defined(CONFIG_SH_MB618)
 	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI UN-cached */
 	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	#error Need to configure PMBs properly when more than 128MiB.
+	#endif
 	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR/NAND FLASH UN-cached */
 	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR/NAND FLASH UN-cached */
 	SH4_SET_PMB 6 0xa8 0x00  16		/* NOR/NAND FLASH CACHED */
@@ -161,10 +217,22 @@ set_pmb:
 	SH4_SET_PMB 8 0xb6 0x06  16 0 0 1	/* EPLD UN-cached */
 #endif	/* CONFIG_SH_NO_EPLD */
 #elif defined(CONFIG_SH_STX7141) && defined(CONFIG_SH_MB628)
-#error QQQ - to do!
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	#error Need to configure PMBs properly when more than 128MiB.
+	#endif
+	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR/NAND FLASH UN-cached */
+	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR/NAND FLASH UN-cached */
+	SH4_SET_PMB 6 0xa8 0x00  16		/* NOR/NAND FLASH CACHED */
+	SH4_SET_PMB 7 0xa9 0x01  16		/* NOR/NAND FLASH CACHED */
+	SH4_SET_PMB 8 0xb5 0x05  16 0 0 1	/* EPLD UN-cached */
 #elif defined(CONFIG_SH_STX7200) && defined(CONFIG_SH_MB519)
 	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 UN-cached */
 	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	#error Need to configure PMBs properly when more than 128MiB.
+	#endif
 	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
 	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR FLASH UN-cached */
 	SH4_SET_PMB 6 0xa8 0x00  16		/* NOR FLASH CACHED */
@@ -173,6 +241,9 @@ set_pmb:
 #elif defined(CONFIG_SH_STX7200) && defined(CONFIG_SH_CB101)
 	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 UN-cached */
 	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	#error Need to configure PMBs properly when more than 128MiB.
+	#endif
 	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
 	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR FLASH UN-cached */
 	SH4_SET_PMB 6 0xa8 0x00  16		/* NOR FLASH CACHED */
diff --git a/cpu/sh/stm-nand.c b/cpu/sh/stm-nand.c
new file mode 100644
index 0000000..ae7880c
--- /dev/null
+++ b/cpu/sh/stm-nand.c
@@ -0,0 +1,1040 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <malloc.h>
+
+
+#if defined(CONFIG_CMD_NAND)
+
+#include <nand.h>
+#include <asm/stm-nand.h>
+#include <asm/ecc.h>
+#include <asm/errno.h>
+#include <asm/st40reg.h>
+#include <asm/io.h>
+
+#if defined(CONFIG_SH_STB7100)
+#include <asm/stb7100reg.h>
+#elif defined(CONFIG_SH_STX7105)
+#include <asm/stx7105reg.h>
+#elif defined(CONFIG_SH_STX7111)
+#include <asm/stx7111reg.h>
+#elif defined(CONFIG_SH_STX7141)
+#include <asm/stx7141reg.h>
+#elif defined(CONFIG_SH_STX7200)
+#include <asm/stx7200reg.h>
+#else
+#error Missing Device Definitions!
+#endif
+
+
+#define isprint(x)	( ((x)>=0x20u) && ((x)<0x7fu) )
+
+
+#define DEBUG_FLEX		0	/* Enable additional debugging of the FLEX controller */
+#define VERBOSE_ECC		0	/* Enable for verbose ECC information  */
+
+
+/*
+ * Define the bad/good block scan pattern which are used while scanning
+ * the NAND device for any factory marked good/bad blocks.
+ *
+ * For small page devices, factory bad block markers are in byte 5.
+ * For large page devices, factory bad block markers are in bytes 0 & 1.
+ * Any bit in those bytes being a zero, implies the entire block is bad.
+ *
+ * Using "SCANALLPAGES" takes a significant performance hit - tens of seconds!
+ * So, we override the default structures (which is to scan *all* pages),
+ * and instead, we only scan the first & 2nd pages in each block.
+ * However, we do also check the entire data area in those 2 pages,
+ * to see if they are properly erased. Improperly erased pages
+ * result in the entire bock also being treated as bad.
+ */
+static uint8_t scan_pattern[] = { 0xffu, 0xffu };
+
+struct nand_bbt_descr stm_nand_badblock_pattern_16 = {
+	.pattern = scan_pattern,
+	.options = NAND_BBT_SCANEMPTY /* | NAND_BBT_SCANALLPAGES */ | NAND_BBT_SCAN2NDPAGE,
+	.offs = 5,	/* Byte 5 */
+	.len = 1
+};
+
+struct nand_bbt_descr stm_nand_badblock_pattern_64 = {
+	.pattern = scan_pattern,
+	.options = NAND_BBT_SCANEMPTY /* | NAND_BBT_SCANALLPAGES */ | NAND_BBT_SCAN2NDPAGE,
+	.offs = 0,	/* Bytes 0-1 */
+	.len = 2
+};
+
+
+#ifdef CFG_NAND_ECC_HW3_128	/* for STM "boot-mode" */
+
+	/* for SMALL-page devices */
+static struct nand_oobinfo stm_nand_oobinfo_16 = {
+	.useecc = MTD_NANDECC_AUTOPLACE,
+	.eccbytes = 12,
+	.eccpos = {
+		 0,  1,  2,	/* ECC for 1st 128-byte record */
+		 4,  5,  6,	/* ECC for 2nd 128-byte record */
+		 8,  9, 10,	/* ECC for 3rd 128-byte record */
+		12, 13, 14},	/* ECC for 4th 128-byte record */
+	.oobfree = { {3, 1}, {7, 1}, {11, 1}, {15, 1} }
+};
+
+	/* for LARGE-page devices */
+static struct nand_oobinfo stm_nand_oobinfo_64 = {
+	.useecc = MTD_NANDECC_AUTOPLACE,
+	.eccbytes = 48,
+	.eccpos = {
+		 0,  1,  2,	/* ECC for  1st 128-byte record */
+		 4,  5,  6,	/* ECC for  2nd 128-byte record */
+		 8,  9, 10,	/* ECC for  3rd 128-byte record */
+		12, 13, 14,	/* ECC for  4th 128-byte record */
+		16, 17, 18,	/* ECC for  5th 128-byte record */
+		20, 21, 22,	/* ECC for  6th 128-byte record */
+		24, 25, 26,	/* ECC for  7th 128-byte record */
+		28, 29, 30,	/* ECC for  8th 128-byte record */
+		32, 33, 34,	/* ECC for  9th 128-byte record */
+		36, 37, 38,	/* ECC for 10th 128-byte record */
+		40, 41, 42,	/* ECC for 11th 128-byte record */
+		44, 45, 46,	/* ECC for 12th 128-byte record */
+		48, 49, 50,	/* ECC for 13th 128-byte record */
+		52, 53, 54,	/* ECC for 14th 128-byte record */
+		56, 57, 58,	/* ECC for 15th 128-byte record */
+		60, 61, 62},	/* ECC for 16th 128-byte record */
+	.oobfree = {
+		{ 3, 1}, { 7, 1}, {11, 1}, {15, 1},
+		{19, 1}, {23, 1}, {27, 1}, {31, 1},
+		{35, 1}, {39, 1}, {43, 1}, {47, 1},
+		{51, 1}, {55, 1}, {59, 1}, {63, 1} },
+};
+
+
+/*
+ * define a structure to hold the fields in the "struct mtd_info"
+ * and "struct nand_chip" structures that we need to over-write
+ * to allow 2 (incompatible) ECC configurations to exist on
+ * the same physical NAND flash device at the same time!
+ *
+ * This is required as some of the STi7xxx devices, have a property
+ * that when in NAND "boot-mode" (i.e. boot-from-NAND) that an ECC
+ * configuration of 3 ECC bytes per 128 byte record *must* be used.
+ * However, when not in "boot-mode", less aggressive ECC configuration
+ * of either 3 ECC bytes per 256 or 512 bytes may be used.
+ *
+ * When using this "hybrid" of 2 different ECC configurations on the
+ * same physical device, we use 2 instances of this structure:
+ *	1) based on the normal (default) configuration (e.g. S/W ECC)
+ *	2) the "boot-mode" 'special' with 3/128 H/W compatibility.
+ *
+ * Various functions are intercepted to ensure that the mtd_info
+ * and nand_chip structures always have the correct "view" of the ECC
+ * configurations, then the default functions can be safely used as is.
+ */
+struct stm_mtd_nand_ecc
+{
+	struct	/* holds differences in "struct nand_chip" */
+	{
+		int			eccmode;
+		int			eccsize;
+		int			eccsteps;
+		struct nand_oobinfo	*autooob;
+		int (*calculate_ecc)(struct mtd_info *, const u_char *, u_char *);
+		int (*correct_data)(struct mtd_info *, u_char *, u_char *, u_char *);
+	}	nand;
+	struct	/* holds differences in "struct mtd_info" */
+	{
+		u_int32_t		oobavail;
+		u_int32_t		eccsize;
+		struct nand_oobinfo	oobinfo;
+	}	mtd;
+};
+
+
+static struct stm_mtd_nand_ecc default_ecc;	/* ECC diffs for the normal SW case */
+static struct stm_mtd_nand_ecc special_ecc;	/* ECC diffs for the "special" hybrid case */
+static int done_ecc_info = 0;			/* are the 2 ECC structures initialized ? */
+
+
+#endif	/* CFG_NAND_ECC_HW3_128 */
+
+
+#ifdef CFG_NAND_FLEX_MODE	/* for STM "flex-mode" (c.f. "bit-banging") */
+
+/* Flex-Mode Data {Read,Write} Config Registers & Flex-Mode {Command,Address} Registers */
+#define FLEX_WAIT_RBn			( 1u << 27 )	/* wait for RBn to be asserted (i.e. ready) */
+#define FLEX_BEAT_COUNT_1		( 1u << 28 )	/* One Beat */
+#define FLEX_BEAT_COUNT_2		( 2u << 28 )	/* Two Beats */
+#define FLEX_BEAT_COUNT_3		( 3u << 28 )	/* Three Beats */
+#define FLEX_BEAT_COUNT_4		( 0u << 28 )	/* Four Beats */
+#define FLEX_CSn_STATUS			( 1u << 31 )	/* Deasserts CSn after current operation completes */
+
+/* Flex-Mode Data-{Read,Write} Config Registers */
+#define FLEX_1_BYTE_PER_BEAT		( 0u << 30 )	/* One Byte per Beat */
+#define FLEX_2_BYTES_PER_BEAT		( 1u << 30 )	/* Two Bytes per Beat */
+
+/* Flex-Mode Configuration Register */
+#define FLEX_CFG_ENABLE_FLEX_MODE	( 1u <<  0 )	/* Enable Flex-Mode operations */
+#define FLEX_CFG_ENABLE_AFM		( 2u <<  0 )	/* Enable Advanced-Flex-Mode operations */
+#define FLEX_CFG_SW_RESET		( 1u <<  3 )	/* Enable Software Reset */
+#define FLEX_CFG_CSn_STATUS		( 1u <<  4 )	/* Deasserts CSn in current Flex bank */
+
+
+enum stm_nand_flex_mode {
+	flex_quiecent,		/* next byte_write is *UNEXPECTED* */
+	flex_command,		/* next byte_write is a COMMAND */
+	flex_address		/* next byte_write is a ADDRESS */
+};
+
+
+/*
+ * NAND device connected to STM NAND Controller operating in FLEX mode.
+ * There may be several NAND device connected to the NAND controller.
+ */
+struct stm_nand_flex_device {
+	int			csn;
+	struct nand_chip	*chip;
+	struct mtd_info		*mtd;
+	struct nand_timing_data *timing_data;
+};
+
+
+/*
+ * STM NAND Controller operating in FLEX mode.
+ * There is only a single one of these.
+ */
+static struct stm_nand_flex_controller {
+	int			initialized;	/* is the FLEX controller initialized ? */
+	int			current_csn;	/* Currently Selected Device (CSn) */
+	int			next_csn;	/* First free NAND Device (CSn) */
+	enum stm_nand_flex_mode mode;
+	struct stm_nand_flex_device device[CFG_MAX_NAND_DEVICE];
+	uint8_t			*buf;		/* Bounce buffer for non-aligned xfers */
+} flex;
+
+
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+extern int stm_nand_default_bbt (struct mtd_info *mtd)
+{
+	struct nand_chip * const this = (struct nand_chip *)(mtd->priv);
+
+	/* over-write the default "badblock_pattern", with our one */
+	/* choose the correct pattern struct, depending on the OOB size */
+	if (mtd->oobsize > 16)
+		this->badblock_pattern = &stm_nand_badblock_pattern_64;	/* LARGE-page */
+	else
+		this->badblock_pattern = &stm_nand_badblock_pattern_16;	/* SMALL-page */
+
+	/* now call the generic BBT function */
+	return nand_default_bbt (mtd);
+}
+
+
+#ifdef CFG_NAND_ECC_HW3_128	/* for STM "boot-mode" */
+
+
+extern int stm_nand_calculate_ecc (
+	struct mtd_info * const mtd,
+	const u_char * const dat,
+	u_char * const ecc_code)
+{
+	const struct nand_chip const * this = mtd->priv;
+
+	if (this->eccmode!=NAND_ECC_HW3_128)
+	{
+		printf("ERROR: Can not calculate ECC: Internal Error (eccmode=%u)\n",
+			this->eccmode);
+		BUG();
+		return -1;	/* Note: caller ignores this value! */
+	}
+	else if ((((unsigned long)dat)%4)!=0)	/* data *must* be 4-bytes aligned */
+	{
+		/* QQQ: change this case to use a properly aligned bounce buffer */
+		printf("ERROR: Can not calculate ECC: data (%08lx) must be 4-byte aligned!\n",
+			(unsigned long)dat);
+		ecc_code[0] = 'B';
+		ecc_code[1] = 'A';
+		ecc_code[2] = 'D';
+		return -1;	/* Note: caller ignores this value! */
+	}
+	else
+	{	/* calculate 3 ECC bytes per 128 bytes of data */
+		const ecc_t computed_ecc = ecc_gen(dat, ECC_128);
+		/* poke them into the right place */
+		ecc_code[0] = computed_ecc.byte[0];
+		ecc_code[1] = computed_ecc.byte[1];
+		ecc_code[2] = computed_ecc.byte[2];
+	}
+
+	return 0;
+}
+
+
+extern int stm_nand_correct_data (
+	struct mtd_info *mtd,
+	u_char *dat,
+	u_char *read_ecc,
+	u_char *calc_ecc)
+{
+	ecc_t read, calc;
+	enum ecc_check result;
+	const struct nand_chip const * this = mtd->priv;
+
+	if (this->eccmode!=NAND_ECC_HW3_128)
+	{
+		printf("ERROR: Can not correct ECC: Internal Error (eccmode=%u)\n",
+			this->eccmode);
+		BUG();
+		return -1;
+	}
+
+	/* do we need to try and correct anything ? */
+	if (    (read_ecc[0] == calc_ecc[0]) &&
+		(read_ecc[1] == calc_ecc[1]) &&
+		(read_ecc[2] == calc_ecc[2])    )
+	{
+		return 0;		/* ECCs agree, nothing to do */
+	}
+
+#if VERBOSE_ECC
+	printf("warning: ECC error detected!  "
+		"read_ecc %02x:%02x:%02x (%c%c%c) != "
+		"calc_ecc %02x:%02x:%02x (%c%c%c)\n",
+		(unsigned)read_ecc[0],
+		(unsigned)read_ecc[1],
+		(unsigned)read_ecc[2],
+		isprint(read_ecc[0]) ? read_ecc[0] : '.',
+		isprint(read_ecc[1]) ? read_ecc[1] : '.',
+		isprint(read_ecc[2]) ? read_ecc[2] : '.',
+		(unsigned)calc_ecc[0],
+		(unsigned)calc_ecc[1],
+		(unsigned)calc_ecc[2],
+		isprint(calc_ecc[0]) ? calc_ecc[0] : '.',
+		isprint(calc_ecc[1]) ? calc_ecc[1] : '.',
+		isprint(calc_ecc[2]) ? calc_ecc[2] : '.');
+#endif	/* VERBOSE_ECC */
+
+	/* put ECC bytes into required structure */
+	read.byte[0] = read_ecc[0];
+	read.byte[1] = read_ecc[1];
+	read.byte[2] = read_ecc[2];
+	calc.byte[0] = calc_ecc[0];
+	calc.byte[1] = calc_ecc[1];
+	calc.byte[2] = calc_ecc[2];
+
+	/* correct a 1-bit error (if we can) */
+	result = ecc_correct(dat, read, calc, ECC_128);
+
+	/* let the user know if we were able to recover it or not! */
+	switch (result)
+	{
+		case E_D1_CHK:
+			printf("info: 1-bit error in data was corrected\n");
+			break;
+		case E_C1_CHK:
+			printf("info: 1-bit error in ECC ignored (data was okay)\n");
+			break;
+		default:
+#if VERBOSE_ECC
+			/* QQQ: filter out genuinely ERASED pages - TO DO */
+			printf("ERROR: uncorrectable ECC error not corrected!\n");
+#endif	/* VERBOSE_ECC */
+			break;
+	}
+
+	/* return zero if all okay, and -1 if we have an uncorrectable issue */
+	if ((result==E_D1_CHK)||(result==E_C1_CHK))
+	{
+		return 0;	/* okay (correctable) */
+	}
+	else
+	{
+		return -1;	/* uncorrectable */
+	}
+}
+
+
+/*
+ * fill in the "default_ecc" and "special_ecc" structures.
+ */
+static void initialize_ecc_diffs (
+	const struct mtd_info * const mtd)
+{
+	const struct nand_chip * const this = (struct nand_chip *)(mtd->priv);
+	struct nand_oobinfo * autooob;
+
+	/* choose the correct OOB info struct, depending on the OOB size */
+	if (mtd->oobsize > 16)
+		autooob = &stm_nand_oobinfo_64;	/* LARGE-page */
+	else
+		autooob = &stm_nand_oobinfo_16;	/* SMALL-page */
+
+	/* fill in "default_ecc" from the current "live" (default) structures */
+	default_ecc.nand.eccmode	= this->eccmode;
+	default_ecc.nand.eccsize	= this->eccsize;
+	default_ecc.nand.eccsteps	= this->eccsteps;
+	default_ecc.nand.autooob	= this->autooob;
+	default_ecc.nand.calculate_ecc	= this->calculate_ecc;
+	default_ecc.nand.correct_data	= this->correct_data;
+	default_ecc.mtd.oobavail	= mtd->oobavail;
+	default_ecc.mtd.eccsize		= mtd->eccsize;
+	memcpy(&default_ecc.mtd.oobinfo, &mtd->oobinfo, sizeof(struct nand_oobinfo));
+
+	/* fill in "special_ecc" for our special "hybrid" ECC paradigm */
+	special_ecc.nand.eccmode	= NAND_ECC_HW3_128;
+	special_ecc.nand.eccsize	= 128;
+	special_ecc.nand.eccsteps	= mtd->oobblock / special_ecc.nand.eccsize;
+	special_ecc.nand.autooob	= autooob;
+	special_ecc.nand.calculate_ecc	= stm_nand_calculate_ecc;
+	special_ecc.nand.correct_data	= stm_nand_correct_data;
+	if (this->options & NAND_BUSWIDTH_16) {
+		special_ecc.mtd.oobavail= mtd->oobsize - (autooob->eccbytes + 2);
+		special_ecc.mtd.oobavail= special_ecc.mtd.oobavail & ~0x01;
+	} else {
+		special_ecc.mtd.oobavail= mtd->oobsize - (autooob->eccbytes + 1);
+	}
+	special_ecc.mtd.eccsize		= special_ecc.nand.eccsize;
+	memcpy(&special_ecc.mtd.oobinfo, autooob, sizeof(struct nand_oobinfo));
+}
+
+
+/*
+ * Make the "live" MTD structures use the ECC configuration
+ * as described in the passed "diffs" structure.
+ */
+static void set_ecc_diffs (
+	struct mtd_info * const mtd,
+	const struct stm_mtd_nand_ecc * const diffs)
+{
+	struct nand_chip * const this = (struct nand_chip *)(mtd->priv);
+
+	this->eccmode		= diffs->nand.eccmode;
+	this->eccsize		= diffs->nand.eccsize;
+	this->eccsteps		= diffs->nand.eccsteps;
+	this->autooob		= diffs->nand.autooob;
+	this->calculate_ecc	= diffs->nand.calculate_ecc;
+	this->correct_data	= diffs->nand.correct_data;
+
+	mtd->oobavail		= diffs->mtd.oobavail;
+	mtd->eccsize		= diffs->mtd.eccsize;
+	memcpy(&mtd->oobinfo, &diffs->mtd.oobinfo, sizeof(struct nand_oobinfo));
+
+	/* also, we need to reinitialize oob_buf */
+	this->oobdirty		= 1;
+
+#if VERBOSE_ECC
+	printf("info: switching to NAND \"%s\" ECC (%u/%u)\n",
+		(diffs==&special_ecc) ? "BOOT-mode" : "NON-boot-mode",
+		this->eccbytes,
+		this->eccsize);
+#endif	/* VERBOSE_ECC */
+}
+
+
+static int set_ecc_mode (
+	struct mtd_info * const mtd,
+	const loff_t addr,
+	const size_t len)
+{
+	struct nand_chip * const this = (struct nand_chip *)(mtd->priv);
+
+	if (!done_ecc_info)		/* first time ? */
+	{
+		initialize_ecc_diffs (mtd);
+		done_ecc_info = 1;	/* do not do this again */
+	}
+
+	/* do we need to switch ECC mode ? */
+	if ( addr >= CFG_NAND_STM_BOOT_MODE_BOUNDARY )
+	{	/* entire range is *not* in "boot-mode" (i.e. default ECC) */
+		if (this->eccmode == NAND_ECC_HW3_128)
+		{	/* we are in the wrong ECC mode, so change */
+			set_ecc_diffs (mtd, &default_ecc);
+		}
+	}
+	else if ( addr + len <= CFG_NAND_STM_BOOT_MODE_BOUNDARY )
+	{	/* entire range is in "boot-mode" (i.e. 3 bytes of ECC per 128 record */
+		if (this->eccmode != NAND_ECC_HW3_128)
+		{	/* we are in the wrong ECC mode, so change */
+			set_ecc_diffs (mtd, &special_ecc);
+		}
+	}
+	else
+	{	/* the range is split over *both* "boot" and "non-boot" modes! */
+		printf("ERROR: NAND range crosses \"boot-mode\" boundary (0x%08x)\n",
+			CFG_NAND_STM_BOOT_MODE_BOUNDARY);
+		return -EINVAL;
+	}
+
+	return 0;	/* success */
+}
+
+
+extern void stm_nand_enable_hwecc (
+	struct mtd_info *mtd,
+	int mode)
+{
+	/* do nothing - we are only emulating HW in SW */
+}
+
+
+extern int stm_nand_read (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
+{
+	int result;
+
+	result = set_ecc_mode (mtd, from, len);
+	if (result != 0)
+	{
+		*retlen = 0;
+	}
+	else
+	{
+		result = nand_read_ecc (mtd, from, len, retlen, buf, NULL, NULL);
+	}
+
+	return result;
+}
+
+
+extern int stm_nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+	size_t * retlen, u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel)
+{
+	int result;
+
+	result = set_ecc_mode (mtd, from, len);
+	if (result != 0)
+	{
+		*retlen = 0;
+	}
+	else
+	{
+		result = nand_read_ecc (mtd, from, len, retlen, buf, eccbuf, oobsel);
+	}
+
+	return result;
+}
+
+
+extern int stm_nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
+{
+	int result;
+
+	result = set_ecc_mode (mtd, from, len);
+	if (result != 0)
+	{
+		*retlen = 0;
+	}
+	else
+	{
+		result = nand_read_oob (mtd, from, len, retlen, buf);
+	}
+
+	return result;
+}
+
+
+extern int stm_nand_write (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * buf)
+{
+	int result;
+
+	result = set_ecc_mode (mtd, to, len);
+	if (result != 0)
+	{
+		*retlen = 0;
+	}
+	else
+	{
+		result = nand_write_ecc (mtd, to, len, retlen, buf, NULL, NULL);
+	}
+
+	return result;
+}
+
+
+extern int stm_nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
+	size_t * retlen, const u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel)
+{
+	int result;
+
+	result = set_ecc_mode (mtd, to, len);
+	if (result != 0)
+	{
+		*retlen = 0;
+	}
+	else
+	{
+		result = nand_write_ecc (mtd, to, len, retlen, buf, eccbuf, oobsel);
+	}
+
+	return result;
+}
+
+
+extern int stm_nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char *buf)
+{
+	int result;
+
+	result = set_ecc_mode (mtd, to, len);
+	if (result != 0)
+	{
+		*retlen = 0;
+	}
+	else
+	{
+		result = nand_write_oob (mtd, to, len, retlen, buf);
+	}
+
+	return result;
+}
+
+
+#endif	/* CFG_NAND_ECC_HW3_128 */
+
+
+#ifdef CFG_NAND_FLEX_MODE	/* for STM "flex-mode" (c.f. "bit-banging") */
+
+
+/* Configure NAND controller timing registers */
+/* QQQ: to write & use this function (for performance reasons!) */
+#ifdef QQQ
+static void flex_set_timings(struct nand_timing_data * const tm)
+{
+	uint32_t n;
+	uint32_t reg;
+	uint32_t emi_clk;
+	uint32_t emi_t_ns;
+
+	/* Timings are set in units of EMI clock cycles */
+	emi_clk = clk_get_rate(clk_get(NULL, "emi_master"));
+	emi_t_ns = 1000000000UL / emi_clk;
+
+	/* CONTROL_TIMING */
+	n = (tm->sig_setup + emi_t_ns - 1u)/emi_t_ns;
+	reg = (n & 0xffu) << 0;
+
+	n = (tm->sig_hold + emi_t_ns - 1u)/emi_t_ns;
+	reg |= (n & 0xffu) << 8;
+
+	n = (tm->CE_deassert + emi_t_ns - 1u)/emi_t_ns;
+	reg |= (n & 0xffu) << 16;
+
+	n = (tm->WE_to_RBn + emi_t_ns - 1u)/emi_t_ns;
+	reg |= (n & 0xffu) << 24;
+
+#if DEBUG_FLEX
+	printf("info: CONTROL_TIMING = 0x%08x\n", reg);
+#endif
+	*ST40_EMI_NAND_CTL_TIMING = reg;
+
+	/* WEN_TIMING */
+	n = (tm->wr_on + emi_t_ns - 1u)/emi_t_ns;
+	reg = (n & 0xffu) << 0;
+
+	n = (tm->wr_off + emi_t_ns - 1u)/emi_t_ns;
+	reg |= (n & 0xffu) << 8;
+
+#if DEBUG_FLEX
+	printf("info: WEN_TIMING = 0x%08x\n", reg);
+#endif
+	*ST40_EMI_NAND_WEN_TIMING = reg;
+
+	/* REN_TIMING */
+	n = (tm->rd_on + emi_t_ns - 1u)/emi_t_ns;
+	reg = (n & 0xffu) << 0;
+
+	n = (tm->rd_off + emi_t_ns - 1u)/emi_t_ns;
+	reg |= (n & 0xffu) << 8;
+
+#if DEBUG_FLEX
+	printf("info: REN_TIMING = 0x%08x\n", reg);
+#endif
+	*ST40_EMI_NAND_REN_TIMING = reg;
+}
+#endif
+
+
+/*
+ * hardware specific access to the Ready/not_Busy signal.
+ * Signal is routed through the EMI NAND Controller block.
+ */
+extern int stm_flex_device_ready(struct mtd_info * const mtd)
+{
+	/* Apply a small delay before sampling the RBn signal */
+#if 1
+	ndelay(500);	/* QQQ: do we really need this ??? */
+#endif
+	/* extract bit 2: status of RBn pin on the FLEX bank */
+	return ((*ST40_EMI_NAND_RBN_STA) & (1ul<<2)) ? 1 : 0;
+}
+
+
+static void init_flex_mode(void)
+{
+	u_int32_t reg;
+
+	/* Disable the BOOT-mode controller */
+	*ST40_EMI_NAND_BOOTBANK_CFG = 0;
+
+	/* Perform a S/W reset the FLEX-mode controller */
+	/* need to assert it for at least one (EMI) clock cycle. */
+	*ST40_EMI_NAND_FLEXMODE_CFG = FLEX_CFG_SW_RESET;
+	udelay(1);	/* QQQ: can we do something shorter ??? */
+	*ST40_EMI_NAND_FLEXMODE_CFG = 0;
+
+	/* Disable all interrupts in FLEX mode */
+	*ST40_EMI_NAND_INT_EN = 0;
+
+	/* Set FLEX-mode controller to enable FLEX-mode */
+	*ST40_EMI_NAND_FLEXMODE_CFG = FLEX_CFG_ENABLE_FLEX_MODE;
+
+	/*
+	 * Configure (pervading) FLEX_DATA to write 4-bytes at a time.
+	 * DATA is only written by write_buf(), not write_byte().
+	 * Hence, we only need to configure this once (ever)!
+	 * As we may be copying directly from NOR flash to NAND flash,
+	 * we need to deassert the CSn after *each* access, as we
+	 * can not guarantee the buffer is in RAM (or not in the EMI).
+	 * Note: we could run memcpy() in write_buf() instead.
+	 */
+	reg = FLEX_BEAT_COUNT_4 | FLEX_1_BYTE_PER_BEAT;
+	reg |= FLEX_CSn_STATUS;		/* deassert CSn after each flex data write */
+#if 0
+	reg |= FLEX_WAIT_RBn;		/* QQQ: do we want this ??? */
+#endif
+	*ST40_EMI_NAND_FLEX_DATAWRT_CFG = reg;
+}
+
+
+/* FLEX mode chip select: For now we only support 1 chip per
+ * 'stm_nand_flex_device' so chipnr will be 0 for select, -1 for deselect.
+ *
+ * So, if we change device:
+ *   - Set bank in mux_control_reg to data->csn
+ *   - Update read/write timings (to do)
+ */
+extern void stm_flex_select_chip(
+	struct mtd_info * const mtd,
+	const int chipnr)
+{
+	struct nand_chip * const chip = mtd->priv;
+	struct stm_nand_flex_device * data = chip->priv;
+
+#if DEBUG_FLEX
+	printf("\t\t\t\t---- SELECT = %2d ----\n", chipnr);
+#endif
+
+	if (!flex.initialized)		/* is the H/W yet to be initialized ? */
+	{
+		/* initialize the FLEX mode controller H/W */
+		init_flex_mode();
+		/* initialize the "flex" software structure */
+		flex.mode          = flex_quiecent;	/* nothing pending */
+		flex.next_csn      = 0;			/* start with first EMI CSn */
+		flex.current_csn   = -1;		/* no NAND device selected */
+							/* allocate a bounce buffer */
+		flex.buf = malloc(NAND_MAX_PAGESIZE + NAND_MAX_OOBSIZE);
+		if (flex.buf==NULL)
+		{
+			printf("ERROR: Unable to allocate memory for a bounce buffer\n");
+			BUG();
+		}
+		flex.initialized   = 1;			/* initialization done */
+	}
+
+	if (data == NULL)		/* device not yet scanned ? */
+	{
+#ifdef CFG_NAND_FLEX_CSn_MAP
+		const int csn_map[CFG_MAX_NAND_DEVICE] = CFG_NAND_FLEX_CSn_MAP;
+#endif	/* CFG_NAND_FLEX_CSn_MAP */
+		int csn            = flex.next_csn++;		/* first free CSn */
+		chip->priv = data  = &(flex.device[csn]);	/* first free "private" structure */
+		if (csn >= CFG_MAX_NAND_DEVICE) BUG();
+#ifdef CFG_NAND_FLEX_CSn_MAP
+		csn                = csn_map[csn];		/* Re-map to different CSn if needed */
+#endif	/* CFG_NAND_FLEX_CSn_MAP */
+#if DEBUG_FLEX
+		printf("info: stm_nand_flex_device.csn = %u\n", csn);
+#endif
+
+		data->csn          = csn;			/* fill in the private structure ... */
+		data->mtd          = mtd;
+		data->chip         = chip;
+		data->timing_data  = NULL;			/* QQQ: to do */
+#ifdef CFG_NAND_ECC_HW3_128
+		mtd->read          = stm_nand_read;
+		mtd->write         = stm_nand_write;
+		mtd->read_ecc      = stm_nand_read_ecc;
+		mtd->write_ecc     = stm_nand_write_ecc;
+		mtd->read_oob      = stm_nand_read_oob;
+		mtd->write_oob     = stm_nand_write_oob;
+		chip->enable_hwecc = stm_nand_enable_hwecc;
+#endif /* CFG_NAND_ECC_HW3_128 */
+	}
+
+	/* Deselect, do nothing */
+	if (chipnr == -1) {
+		return;
+
+	} else if (chipnr == 0) {
+		/* If same chip as last time, no need to change anything */
+		if (data->csn == flex.current_csn)
+			return;
+
+		/* Set correct EMI Chip Select (CSn) on FLEX controller */
+		flex.current_csn = data->csn;
+		*ST40_EMI_NAND_FLEX_MUXCTRL = 1ul << data->csn;
+
+		/* Set up timing parameters */
+#if 0
+		/* The default times will work for 200MHz (or slower) */
+		/* QQQ: to do - BUT this is also the WRONG place to do this! */
+		flex_set_timings(data->timing_data);
+#endif
+
+	} else {
+		printf("ERROR: In %s() attempted to select chipnr = %d\n",
+			__FUNCTION__,
+			chipnr);
+	}
+}
+
+
+extern void stm_flex_hwcontrol (
+	struct mtd_info * const mtd,
+	int control)
+{
+	switch(control) {
+
+	case NAND_CTL_SETCLE:
+#if DEBUG_FLEX
+		printf("\t\t\t\t\t\t----START COMMAND----\n");
+		if (flex.mode != flex_quiecent) BUG();
+#endif
+		flex.mode = flex_command;
+		break;
+
+#if DEBUG_FLEX
+	case NAND_CTL_CLRCLE:
+		printf("\t\t\t\t\t\t---- end  command----\n");
+		if (flex.mode != flex_command) BUG();
+		flex.mode = flex_quiecent;
+		break;
+#endif
+
+	case NAND_CTL_SETALE:
+#if DEBUG_FLEX
+		printf("\t\t\t\t\t\t----START ADDRESS----\n");
+		if (flex.mode != flex_quiecent) BUG();
+#endif
+		flex.mode = flex_address;
+		break;
+
+#if DEBUG_FLEX
+	case NAND_CTL_CLRALE:
+		printf("\t\t\t\t\t\t---- end  address----\n");
+		if (flex.mode != flex_address) BUG();
+		flex.mode = flex_quiecent;
+		break;
+#endif
+
+#if DEBUG_FLEX
+	default:
+		printf("ERROR: Unexpected parameter (control=0x%x) in %s()\n",
+			control,
+			__FUNCTION__);
+		BUG();
+#endif
+	}
+}
+
+
+/**
+ * nand_read_byte - [DEFAULT] read one byte from the chip
+ * @mtd:	MTD device structure
+ */
+extern u_char stm_flex_read_byte(
+	struct mtd_info * const mtd)
+{
+	u_char byte;
+	u_int32_t reg;
+
+	/* read 1-byte at a time */
+	reg = FLEX_BEAT_COUNT_1 | FLEX_1_BYTE_PER_BEAT;
+	reg |= FLEX_CSn_STATUS;		/* deassert CSn after each flex data read */
+#if 0
+	reg |= FLEX_WAIT_RBn;		/* QQQ: do we want this ??? */
+#endif
+	*ST40_EMI_NAND_FLEX_DATA_RD_CFG = reg;
+
+	/* read it */
+	byte = (u_char)*ST40_EMI_NAND_FLEX_DATA;
+
+#if DEBUG_FLEX
+	printf("\t\t\t\t\t\t\t\t\t READ = 0x%02x\n", byte);
+#endif
+
+	/* return it */
+	return byte;
+}
+
+
+/**
+ * nand_write_byte - [DEFAULT] write one byte to the chip
+ * @mtd:	MTD device structure
+ * @byte:	pointer to data byte to write
+ */
+extern void stm_flex_write_byte(
+	struct mtd_info * const mtd,
+	u_char byte)
+{
+	u_int32_t reg;
+
+#if DEBUG_FLEX
+	printf("\t\t\t\t\t\t\t\t\tWRITE = 0x%02x\t%s\n", byte,
+		(flex.mode==flex_command) ? "command" :
+		((flex.mode==flex_address) ? "address" : "*UNKNOWN*"));
+#endif
+
+	switch (flex.mode)
+	{
+		case flex_command:
+			reg = byte | FLEX_BEAT_COUNT_1;
+			reg |= FLEX_CSn_STATUS;	/* deassert CSn after each flex command write */
+#if 0
+			reg |= FLEX_WAIT_RBn;		/* QQQ: do we want this ??? */
+#endif
+			*ST40_EMI_NAND_FLEX_CMD = reg;
+			break;
+
+		case flex_address:
+			reg = byte | FLEX_BEAT_COUNT_1;
+			reg |= FLEX_CSn_STATUS;	/* deassert CSn after each flex address write */
+#if 0
+			reg |= FLEX_WAIT_RBn;		/* QQQ: do we want this ??? */
+#endif
+			*ST40_EMI_NAND_FLEX_ADD_REG = reg;
+#if 0			/* QQQ: do we need this - I think not! */
+			while (!nand_device_ready()) ;	/* wait till NAND is ready */
+#endif
+			break;
+
+		default:
+			BUG();
+	}
+}
+
+
+/**
+ * nand_read_buf - [DEFAULT] read chip data into buffer
+ * @mtd:	MTD device structure
+ * @buf:	buffer to store data
+ * @len:	number of bytes to read
+ */
+extern void stm_flex_read_buf(
+	struct mtd_info * const mtd,
+	u_char * const buf,
+	const int len)
+{
+	int i;
+	uint32_t *p;
+	u_int32_t reg;
+
+	/* our buffer needs to be 4-byte aligned, for the FLEX controller */
+	p = ((uint32_t)buf & 0x3) ? (void*)flex.buf : (void*)buf;
+
+#if DEBUG_FLEX
+	printf("info: stm_flex_read_buf( buf=%p, len=0x%x )\t\tp=%p%s\n",
+		buf, len, p,
+		((uint32_t)buf & 0x3) ? "\t\t**** UN-ALIGNED *****" : "");
+#endif
+
+	/* configure to read 4-bytes at a time */
+	reg = FLEX_BEAT_COUNT_4 | FLEX_1_BYTE_PER_BEAT;
+	reg |= FLEX_CSn_STATUS;		/* deassert CSn after each flex data read */
+#if 0
+	reg |= FLEX_WAIT_RBn;		/* QQQ: do we want this ??? */
+#endif
+	*ST40_EMI_NAND_FLEX_DATA_RD_CFG = reg;
+
+	/* copy the data (from NAND) as 4-byte words ... */
+	for(i=0; i<len/4; i++)
+	{
+		p[i] = *ST40_EMI_NAND_FLEX_DATA;
+	}
+
+	/* copy back into user-supplied buffer, if it was unaligned */
+	if ((void*)p != (void*)buf)
+		memcpy(buf, p, len);
+
+#if DEBUG_FLEX
+	printf("READ BUF\t\t\t\t");
+	for (i=0; i<16; i++)
+		printf("%02x ", buf[i]);
+	printf("...\n");
+#endif
+}
+
+
+/**
+ * nand_write_buf - [DEFAULT] write buffer to chip
+ * @mtd:	MTD device structure
+ * @buf:	data buffer
+ * @len:	number of bytes to write
+ */
+extern void stm_flex_write_buf(
+	struct mtd_info * const mtd,
+	const u_char * const buf,
+	const int len)
+{
+	int i;
+	uint32_t *p;
+
+#if DEBUG_FLEX
+	printf("WRITE BUF\t\t");
+	for (i=0; i<16; i++)
+		printf("%02x ", buf[i]);
+	printf("...\n");
+#endif
+
+	/* our buffer needs to be 4-byte aligned, for the FLEX controller */
+	p = ((uint32_t)buf & 0x3) ? (void*)flex.buf : (void*)buf;
+
+	/* copy from user-supplied buffer, if it is unaligned */
+	if ((void*)p != (void*)buf)
+		memcpy(p, buf, len);
+
+	/* configured to write 4-bytes at a time */
+	/* copy the data (to NAND) as 32-bit words ... */
+	for(i=0; i<len/4; i++)
+	{
+		*ST40_EMI_NAND_FLEX_DATA = p[i];
+	}
+}
+
+
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+#endif	/* CONFIG_CMD_NAND */
diff --git a/cpu/sh/stx7105/stx7105.c b/cpu/sh/stx7105/stx7105.c
index 8306f37..7d56225 100644
--- a/cpu/sh/stx7105/stx7105.c
+++ b/cpu/sh/stx7105/stx7105.c
@@ -91,16 +91,18 @@ static void stmac_eth_hw_setup( int reverse_mii, int rmii_mode, int mode,
 		sysconf |= (EXT_MDIO);
 	else
 		sysconf &= ~(EXT_MDIO);
-	/* RMII pin multiplexing: 0: RMII interface active, 1: MII interface */
+	/* RMII pin multiplexing: 0: MII interface active, 1: RMII interface */
+	/* cut 1: This register was not connected, so only MII available */
 	if (rmii_mode)
-		sysconf &= ~(RMII_MODE);
-	else
 		sysconf |= (RMII_MODE);
-	/* PHY EXT CLOCK: 0: provided by STx7105; 1: external */
-	if (ext_clk)
-		sysconf |= (PHY_CLK_EXT);
 	else
-		sysconf &= ~(PHY_CLK_EXT);
+		sysconf &= ~(RMII_MODE);
+	/*
+	 * PHY EXT CLOCK: 0: provided by STx7105; 1: external
+	 * cut 1: sysconf7[19], however this was not connected, so only
+	 * input supported.
+	 * cut 2: direction now based on PIO direction, so this code removed.
+	 */
 	/* Default GMII/MII selection */
 	sysconf &= ~(PHY_INTF_SEL_MASK);
 	sysconf |= ((mode&3ul)<<25);
@@ -121,8 +123,8 @@ static void stmac_eth_hw_setup( int reverse_mii, int rmii_mode, int mode,
 	sysconf &= ~(0xf0f0ul);	/* Mask=3,3,3,3 */
 	sysconf |=   0x0000ul;	/* OR  =0,0,0,0 */
 	*STX7105_SYSCONF_SYS_CFG37 = sysconf;
-	SET_PIO_PIN(PIO_PORT(7), 4, STPIO_ALT_BIDIR);
-	SET_PIO_PIN(PIO_PORT(7), 5, STPIO_ALT_BIDIR);
+	SET_PIO_PIN(PIO_PORT(7), 4, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(7), 5, STPIO_IN);
 	SET_PIO_PIN(PIO_PORT(7), 6, STPIO_ALT_OUT);
 	SET_PIO_PIN(PIO_PORT(7), 7, STPIO_ALT_OUT);
 
@@ -143,9 +145,9 @@ static void stmac_eth_hw_setup( int reverse_mii, int rmii_mode, int mode,
 	SET_PIO_PIN(PIO_PORT(8), 2, STPIO_ALT_OUT);
 	SET_PIO_PIN(PIO_PORT(8), 3, STPIO_ALT_BIDIR);
 	SET_PIO_PIN(PIO_PORT(8), 4, STPIO_ALT_OUT);
-	SET_PIO_PIN(PIO_PORT(8), 5, STPIO_ALT_BIDIR);
-	SET_PIO_PIN(PIO_PORT(8), 6, STPIO_ALT_BIDIR);
-	SET_PIO_PIN(PIO_PORT(8), 7, STPIO_ALT_BIDIR);
+	SET_PIO_PIN(PIO_PORT(8), 5, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(8), 6, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(8), 7, STPIO_IN);
 
 	/* PIO9[0] CFG47[8+0,0] = Alternate1 = MIIRXD[2] */
 	/* PIO9[1] CFG47[8+1,1] = Alternate1 = MIIRXD[3] */
@@ -158,13 +160,19 @@ static void stmac_eth_hw_setup( int reverse_mii, int rmii_mode, int mode,
 	sysconf &= ~(0x7f7ful);	/* Mask=3,3,3,3,3,3,3 */
 	sysconf |=   0x0000ul;	/* OR  =0,0,0,0,0,0,0 */
 	*STX7105_SYSCONF_SYS_CFG47 = sysconf;
-	SET_PIO_PIN(PIO_PORT(9), 0, STPIO_ALT_BIDIR);
-	SET_PIO_PIN(PIO_PORT(9), 1, STPIO_ALT_BIDIR);
-	SET_PIO_PIN(PIO_PORT(9), 2, STPIO_ALT_BIDIR);
-	SET_PIO_PIN(PIO_PORT(9), 3, STPIO_ALT_BIDIR);
-	SET_PIO_PIN(PIO_PORT(9), 4, STPIO_ALT_BIDIR);
-	SET_PIO_PIN(PIO_PORT(9), 5, STPIO_ALT_OUT);
-	SET_PIO_PIN(PIO_PORT(9), 6, STPIO_ALT_BIDIR);
+	SET_PIO_PIN(PIO_PORT(9), 0, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9), 1, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9), 2, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9), 3, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9), 4, STPIO_IN);
+	/* MIIPHYCLK */
+	/* Not implemented in cut 1 (DDTS GNBvd69906) - clock never output */
+	/* In cut 2 PIO direction used to control input or output. */
+	if (ext_clk)
+		SET_PIO_PIN(PIO_PORT(9), 5, STPIO_IN);
+	else
+		SET_PIO_PIN(PIO_PORT(9), 5, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(9), 6, STPIO_IN);
 }
 #endif	/* CONFIG_DRIVER_NET_STM_GMAC */
 
@@ -176,15 +184,20 @@ int soc_init(void)
 	stx7105_clocks();
 
 #ifdef CONFIG_DRIVER_NET_STM_GMAC
-	stmac_eth_hw_setup (0, 0, 0, 1, 0, 0);
+	stmac_eth_hw_setup (0, 0, 0, 0, 1, 0);
 #endif	/* CONFIG_DRIVER_NET_STM_GMAC */
 
 	bd->bi_devid = *STX7105_SYSCONF_DEVICEID_0;
 
-#if QQQ	/* QQQ - TO FIX */
-	/*  Make sure reset period is shorter than WDT timeout */
-	*STX7105_SYSCONF_SYS_CFG09 = (*STX7105_SYSCONF_SYS_CFG09 & 0xFF000000) | 0x000A8C;
-#endif	/* QQQ - TO FIX */
+	/*
+	 * Make sure the reset period is shorter than WDT time-out,
+	 * and that the reset loop-back chain is *not* bypassed.
+	 *	SYS_CFG09[29]    = long_reset_mode
+	 *	SYS_CFG09[28:27] = cpu_rst_out_bypass(1:0)
+	 *	SYS_CFG09[25:0]  = ResetOut_period
+	 */
+//QQQ	*STX7105_SYSCONF_SYS_CFG09 = (*STX7105_SYSCONF_SYS_CFG09 & 0xF7000000) | 0x000A8C;
+	*STX7105_SYSCONF_SYS_CFG09 = (*STX7105_SYSCONF_SYS_CFG09 & 0xF4000000ul) | 0x000A8Cul;
 
 	return 0;
 }
diff --git a/cpu/sh/stx7141/stx7141.c b/cpu/sh/stx7141/stx7141.c
index 51af6d8..cdd42ae 100644
--- a/cpu/sh/stx7141/stx7141.c
+++ b/cpu/sh/stx7141/stx7141.c
@@ -117,6 +117,7 @@ int soc_init(void)
 {
 	DECLARE_GLOBAL_DATA_PTR;
 	bd_t *bd = gd->bd;
+	unsigned long reg;
 
 	stx7141_clocks();
 
@@ -126,11 +127,40 @@ int soc_init(void)
 
 	bd->bi_devid = *STX7141_SYSCONF_DEVICEID_0;
 
-#ifdef QQQ	/* QQQ - TO DO */
-	/*  Make sure reset period is shorter than WDT timeout */
-	*STX7141_SYSCONF_SYS_CFG09 = (*STX7141_SYSCONF_SYS_CFG09 & 0xFF000000) | 0x000A8C;
+	/*
+	 * Reset Generation Configuration
+	 * Make sure reset period is shorter than WDT time-out,
+	 * and that the reset is not bypassed.
+	 *
+	 *	[28:27] = CPU_RST_OUT_BYPASS[1:0]
+	 *	[25:0]  = RESETOUT_PERIOD
+	 */
+	reg = *STX7141_SYSCONF_SYS_CFG09;
+	/* Propagate the reset signal */
+	reg = (reg & (~(3ul<<27))) | ((0ul)<<27);
+	/* use the default "short" reset time of 100us */
+	reg = (reg & (~0x03FFFFFFul)) | 0x00000A8Cul;
+	*STX7141_SYSCONF_SYS_CFG09 = reg;
+
+	/*
+	 * SH4 Boot Configuration
+	 * Unmask the reset signal from the SH4 core.
+	 *
+	 *	[4:3] = SH4_MASK_RST_OUT[1:0]
+	 *
+	 * SH4_MASK_RST_OUT[1]: mask rst_out signal from SH4-eCM core
+	 * SH4_MASK_RST_OUT[0]: mask rst_out signal from SH4-eSTB core
+	 */
+	reg = *STX7141_SYSCONF_SYS_CFG08;
+#if 1
+	/* Unmask the reset signal from the SH4-eSTB core */
+	reg = (reg & (~(1ul<<3))) | ((0ul)<<3);
+#else
+	/* Unmask the reset signal from the SH4-eCM core */
+	reg = (reg & (~(1ul<<4))) | ((0ul)<<4);
+#endif
+	*STX7141_SYSCONF_SYS_CFG08 = reg;
 
-#endif		/* QQQ - TO DO */
 	return 0;
 }
 
diff --git a/drivers/mtd/cfi_flash.c b/drivers/mtd/cfi_flash.c
index 1362ed0..b552e0a 100644
--- a/drivers/mtd/cfi_flash.c
+++ b/drivers/mtd/cfi_flash.c
@@ -1293,6 +1293,20 @@ ulong flash_get_size (ulong base, int banknum)
 			erase_region_count = (tmp & 0xffff) + 1;
 			debug ("erase_region_count = %d erase_region_size = %d\n",
 				erase_region_count, erase_region_size);
+
+				/*
+				 * ensure we do not violate array bounds, specifically:
+				 *	flash_info_t.start[CFG_MAX_FLASH_SECT];
+				 *	flash_info_t.protect[CFG_MAX_FLASH_SECT];
+				 */
+			if (erase_region_count > CFG_MAX_FLASH_SECT) {
+				printf ("Error: Number of Sectors (%d) > CFG_MAX_FLASH_SECT (%d)\n",
+					erase_region_count,
+					CFG_MAX_FLASH_SECT);
+				flash_write_cmd (info, 0, 0, info->cmd_reset);
+				return 0;	/* return, to avoid corrupting any memory */
+			}
+
 			for (j = 0; j < erase_region_count; j++) {
 				info->start[sect_cnt] = sector;
 				sector += (erase_region_size * size_ratio);
diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index 151f535..810f92e 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -11,6 +11,10 @@
  *
  *  Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com)
  * 		  2002 Thomas Gleixner (tglx@linutronix.de)
+ *		  2009 STMicroelectronics. (Sean McGoogan <Sean.McGoogan@st.com>)
+ *
+ *
+ *  02-06-2009  SMG: added support for 3 bytes of ECC per 128 byte record.
  *
  *  02-08-2004  tglx: support for strange chips, which cannot auto increment
  *		pages on read / read_oob
@@ -133,13 +137,8 @@ static void nand_read_buf(struct mtd_info *mtd, u_char *buf, int len);
 static int nand_verify_buf(struct mtd_info *mtd, const u_char *buf, int len);
 
 static int nand_read (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf);
-static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
-			  size_t * retlen, u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel);
-static int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf);
 static int nand_write (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * buf);
-static int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
-			   size_t * retlen, const u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel);
-static int nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char *buf);
+
 /* XXX U-BOOT XXX */
 #if 0
 static int nand_writev (struct mtd_info *mtd, const struct kvec *vecs,
@@ -538,6 +537,11 @@ static void nand_command (struct mtd_info *mtd, unsigned command, int column, in
 {
 	register struct nand_chip *this = mtd->priv;
 
+#if 0									/* QQQ - DELETE */
+	printf("QQQ: %s( command=0x%02x,  column=0x%x,  page=0x%x\n",	/* QQQ - DELETE */
+		__FUNCTION__, command, column, page_addr);		/* QQQ - DELETE */
+#endif									/* QQQ - DELETE */
+
 	/* Begin command latch cycle */
 	this->hwcontrol(mtd, NAND_CTL_SETCLE);
 	/*
@@ -643,6 +647,11 @@ static void nand_command_lp (struct mtd_info *mtd, unsigned command, int column,
 {
 	register struct nand_chip *this = mtd->priv;
 
+#if 0									/* QQQ - DELETE */
+	printf("QQQ: %s( command=0x%02x,  column=0x%x,  page=0x%x\n",	/* QQQ - DELETE */
+		__FUNCTION__, command, column, page_addr);		/* QQQ - DELETE */
+#endif									/* QQQ - DELETE */
+
 	/* Emulate NAND_CMD_READOOB */
 	if (command == NAND_CMD_READOOB) {
 		column += mtd->oobblock;
@@ -891,7 +900,7 @@ static int nand_write_page (struct mtd_info *mtd, struct nand_chip *this, int pa
 	u_char *oob_buf,  struct nand_oobinfo *oobsel, int cached)
 {
 	int 	i, status;
-	u_char	ecc_code[32];
+	u_char	ecc_code[MTD_NANDECC_MAX_ECCPOS];
 	int	eccmode = oobsel->useecc ? this->eccmode : NAND_ECC_NONE;
 	uint  	*oob_config = oobsel->eccpos;
 	int	datidx = 0, eccidx = 0, eccsteps = this->eccsteps;
@@ -1105,15 +1114,15 @@ static int nand_read (struct mtd_info *mtd, loff_t from, size_t len, size_t * re
  *
  * NAND read with ECC
  */
-static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+extern int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
 			  size_t * retlen, u_char * buf, u_char * oob_buf, struct nand_oobinfo *oobsel)
 {
 	int i, j, col, realpage, page, end, ecc, chipnr, sndcmd = 1;
 	int read = 0, oob = 0, ecc_status = 0, ecc_failed = 0;
 	struct nand_chip *this = mtd->priv;
 	u_char *data_poi, *oob_data = oob_buf;
-	u_char ecc_calc[32];
-	u_char ecc_code[32];
+	u_char ecc_calc[MTD_NANDECC_MAX_ECCPOS];
+	u_char ecc_code[MTD_NANDECC_MAX_ECCPOS];
 	int eccmode, eccsteps;
 	unsigned *oob_config;
 	int	datidx;
@@ -1122,7 +1131,6 @@ static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
 	int	compareecc = 1;
 	int	oobreadlen;
 
-
 	DEBUG (MTD_DEBUG_LEVEL3, "nand_read_ecc: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);
 
 	/* Do not allow reads past end of device */
@@ -1374,7 +1382,7 @@ static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
  *
  * NAND read out-of-band data from the spare area
  */
-static int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
+extern int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
 {
 	int i, col, page, chipnr;
 	struct nand_chip *this = mtd->priv;
@@ -1609,7 +1617,7 @@ static int nand_write (struct mtd_info *mtd, loff_t to, size_t len, size_t * ret
  *
  * NAND write with ECC
  */
-static int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
+extern int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
 			   size_t * retlen, const u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel)
 {
 	int startpage, page, ret = -EIO, oob = 0, written = 0, chipnr;
@@ -1762,7 +1770,7 @@ out:
  *
  * NAND write out-of-band
  */
-static int nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * buf)
+extern int nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * buf)
 {
 	int column, page, status, ret = -EIO, chipnr;
 	struct nand_chip *this = mtd->priv;
@@ -2528,6 +2536,10 @@ int nand_scan (struct mtd_info *mtd, int maxchips)
 	case NAND_ECC_HW3_256:
 		break;
 
+	case NAND_ECC_HW3_128:
+		this->eccsize = 128;	/* set eccsize to 128 bytes/record */
+		break;
+
 	case NAND_ECC_NONE:
 		printk (KERN_WARNING "NAND_ECC_NONE selected by board driver. This is not recommended !!\n");
 		this->eccmode = NAND_ECC_NONE;
@@ -2555,6 +2567,7 @@ int nand_scan (struct mtd_info *mtd, int maxchips)
 		this->eccbytes += 3;
 	case NAND_ECC_HW3_512:
 	case NAND_ECC_HW3_256:
+	case NAND_ECC_HW3_128:
 		if (this->calculate_ecc && this->correct_data && this->enable_hwecc)
 			break;
 		printk (KERN_WARNING "No ECC functions supplied, Hardware ECC not possible\n");
@@ -2578,6 +2591,10 @@ int nand_scan (struct mtd_info *mtd, int maxchips)
 		this->eccsteps = mtd->oobblock / 256;
 		break;
 
+	case NAND_ECC_HW3_128:
+		this->eccsteps = mtd->oobblock / 128;
+		break;
+
 	case NAND_ECC_NONE:
 		this->eccsteps = 1;
 		break;
@@ -2604,12 +2621,20 @@ int nand_scan (struct mtd_info *mtd, int maxchips)
 	mtd->erase = nand_erase;
 	mtd->point = NULL;
 	mtd->unpoint = NULL;
-	mtd->read = nand_read;
-	mtd->write = nand_write;
-	mtd->read_ecc = nand_read_ecc;
-	mtd->write_ecc = nand_write_ecc;
-	mtd->read_oob = nand_read_oob;
-	mtd->write_oob = nand_write_oob;
+	/* allow board-specific init to overwrite some MTD functions */
+	if (!mtd->read)
+		mtd->read = nand_read;
+	if (!mtd->write)
+		mtd->write = nand_write;
+	if (!mtd->read_ecc)
+		mtd->read_ecc = nand_read_ecc;
+	if (!mtd->write_ecc)
+		mtd->write_ecc = nand_write_ecc;
+	if (!mtd->read_oob)
+		mtd->read_oob = nand_read_oob;
+	if (!mtd->write_oob)
+		mtd->write_oob = nand_write_oob;
+
 /* XXX U-BOOT XXX */
 #if 0
 	mtd->readv = NULL;
@@ -2633,6 +2658,7 @@ int nand_scan (struct mtd_info *mtd, int maxchips)
 #if 0
 	mtd->owner = THIS_MODULE;
 #endif
+
 	/* Build bad block table */
 	return this->scan_bbt (mtd);
 }
diff --git a/drivers/net/stm-stmac.c b/drivers/net/stm-stmac.c
index cd8034a..d7504c0 100644
--- a/drivers/net/stm-stmac.c
+++ b/drivers/net/stm-stmac.c
@@ -1,5 +1,5 @@
 /*
- *  Copyright (c) 2006-2008  STMicroelectronics Limited
+ *  Copyright (c) 2006-2009 STMicroelectronics Limited
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -140,9 +140,9 @@ static void *rx_packets[CONFIG_DMA_RX_SIZE];
 #define LAN8700_PHY_ID		0x0007c0c0u
 #define LAN8700_PHY_ID_MASK	0xfffffff0u
 
-#define SPECIAL_MODE_REG	0x12		/* Special Modes Register */
-#define PHY_ADDR_MSK		0x001f		/* PHY Address Mask */
-#define PHY_ADDR_SHIFT		0		/* PHY Address Mask */
+#define SPECIAL_MODE_REG	0x12	/* Special Modes Register */
+#define PHY_ADDR_MSK		0x001f	/* PHY Address Mask */
+#define PHY_ADDR_SHIFT		0	/* PHY Address Mask */
 
 #elif defined(CONFIG_STMAC_DP83865)	/* Nat Semi DP83865 */
 
@@ -150,9 +150,15 @@ static void *rx_packets[CONFIG_DMA_RX_SIZE];
 #define DP83865_PHY_ID		0x20005c70u
 #define DP83865_PHY_ID_MASK	0xfffffff0u
 
-#define PHY_SUP_REG		0x1f		/* PHY Support Register */
-#define PHY_ADDR_MSK		0x001f		/* PHY Address Mask */
-#define PHY_ADDR_SHIFT		0		/* PHY Address Mask */
+#define PHY_SUP_REG		0x1f	/* PHY Support Register */
+#define PHY_ADDR_MSK		0x001f	/* PHY Address Mask */
+#define PHY_ADDR_SHIFT		0	/* PHY Address Mask */
+
+#elif defined(CONFIG_STMAC_KSZ8041FTL)	/* Micrel KSZ8041FTL */
+
+/* Micrel KSZ8041FTL phy identifier values */
+#define KSZ8041FTL_PHY_ID	0x00221512u
+#define KSZ8041FTL_PHY_ID_MASK	0x01ffffffu
 
 #else
 #error Need to define which PHY to use
@@ -271,6 +277,11 @@ static unsigned int stmac_phy_get_addr (void)
 			printf (STMAC "NS DP83865 found\n");
 			return phyaddr;
 		}
+#elif defined(CONFIG_STMAC_KSZ8041FTL)
+		if ((id & KSZ8041FTL_PHY_ID_MASK) == KSZ8041FTL_PHY_ID) {
+			printf (STMAC "KSZ8041FTL found\n");
+			return phyaddr;
+		}
 #endif	/* CONFIG_STMAC_STE10XP */
 	}
 
@@ -300,15 +311,22 @@ static int stmac_phy_init (void)
 	value = stmac_mii_read (eth_phy_addr, SPECIAL_MODE_REG);
 #elif defined(CONFIG_STMAC_DP83865)
 	value = stmac_mii_read (eth_phy_addr, PHY_SUP_REG);
+#elif defined(CONFIG_STMAC_KSZ8041FTL)
+	/* The Micrel KSZ8041FTL does not appear to support
+	 * reading the H/W PHY address from any register.
+	 * So, we bypass the following test.
+	 */
 #else
 #error Need to define PHY
 #endif
+#if !defined(CONFIG_STMAC_KSZ8041FTL)
 	value = (value & PHY_ADDR_MSK) >> PHY_ADDR_SHIFT;
 	if (value != eth_phy_addr) {
 		printf (STMAC "PHY address mismatch with hardware (hw %d != %d)\n",
 			value,
 			eth_phy_addr);
 	}
+#endif
 
 	/* Read the ANE Advertisement register */
 	advertised_caps = stmac_mii_read (eth_phy_addr, MII_ADVERTISE);
diff --git a/drivers/serial/Makefile b/drivers/serial/Makefile
index d95f67b..d5b35c6 100644
--- a/drivers/serial/Makefile
+++ b/drivers/serial/Makefile
@@ -37,6 +37,7 @@ COBJS-y += serial_pl011.o
 COBJS-y += serial_xuartlite.o
 COBJS-y += sh-sci.o
 COBJS-y += stm-asc.o
+COBJS-y += stm-dtf.o
 COBJS-y += usbtty.o
 
 COBJS	:= $(COBJS-y)
diff --git a/drivers/serial/stm-dtf.c b/drivers/serial/stm-dtf.c
new file mode 100644
index 0000000..700cfeb
--- /dev/null
+++ b/drivers/serial/stm-dtf.c
@@ -0,0 +1,187 @@
+/*
+ * drivers/serial/stm-dtf.c
+ *
+ * Support for emulated serial console I/O using STMicroelectronics'
+ * DTF (Data Transfer Format) mechanism, over a JTAG link, to
+ * a remote GDB debugger on a host machine.
+ *
+ *  Copyright (c) 2009  STMicroelectronics Limited
+ *  Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "common.h"
+
+
+#ifdef CONFIG_STM_DTF_SERIAL
+
+
+#ifdef CONFIG_SH_SCIF_SERIAL
+#error Can not define CONFIG_SH_SCIF_SERIAL and CONFIG_STM_DTF_SERIAL at same time!
+#endif
+
+#ifdef CONFIG_STM_ASC_SERIAL
+#error Can not define CONFIG_STM_ASC_SERIAL and CONFIG_STM_DTF_SERIAL at same time!
+#endif
+
+
+static int dtf_transfer(
+	volatile void * const data,
+	volatile int * const numBytes,
+	const size_t maxPacketSize)
+{
+	static unsigned char dtfPacket[8+sizeof(short)] __attribute__((aligned(4)));
+	unsigned short pktSize = *numBytes;
+
+	/* Ensure our DTF packet buffer is big enough */
+	if (pktSize+sizeof(short) > sizeof(dtfPacket))
+	{
+		*numBytes = 0; /* Error */
+		return -1;
+	}
+
+	/* pack the DTF request */
+	*(unsigned short *)dtfPacket = pktSize;
+	memcpy((char*)dtfPacket+sizeof(short), (void*)data, pktSize);
+
+	/*
+	 * Signal to the host that an I/O request is ready. When control returns
+	 * the packet will have been updated with the result of the request.
+	 */
+	__asm__ __volatile__ (
+		"	mov	%0, r8;"
+		".short	0x003b;"
+		".short	0x0000;"
+		"1:	mov.w	@%0, r8;"
+		"	tst	r8, r8;"
+		"	bt	1b"
+		: : "r" (dtfPacket) : "r8", "t");
+
+	/*
+	 * Unpack the DTF response packet.
+	 * Check that the packet size is valid, if not then return immediately.
+	 */
+	pktSize = *(unsigned short *)dtfPacket;
+	if (pktSize > maxPacketSize)
+	{
+		*numBytes = 0; /* Error */
+		return -1;
+	}
+
+	/* Extract results */
+	*numBytes = pktSize;
+	memcpy((void*)data, (char*)dtfPacket+sizeof(short), pktSize);
+
+	return 0;	/* Okay */
+}
+
+
+/*
+ * The following are used to retain results whilst
+ * polling for a key-stroke in tstc() and getc().
+ */
+static int CachedKeyCode;	/* Key-stroke that is cached */
+static int CachedKey = 0;	/* is "CachedKeyCode" valid */
+
+
+/* returns TRUE if a char is available, ready to be read */
+extern int serial_tstc (void)
+{
+	volatile unsigned char buff[8] __attribute__((aligned(4))) = {24};
+	int buffLen = 1;
+
+	/* have we already got one key-stroke cached ? */
+	if (CachedKey)
+	{
+		return 1;	/* cached key ready to be read */
+	}
+
+	/* Send request to and receive reply from host */
+	if (dtf_transfer(buff, &buffLen, sizeof(buff)) == -1)
+	{
+		return 0;	/* Error */
+	}
+
+	/* Extract result */
+	CachedKey     = *(volatile int*)&buff[0];
+	CachedKeyCode = *(volatile unsigned int*)&buff[4];
+
+	/* return TRUE if a char is available, else FALSE */
+	return CachedKey;
+}
+
+
+/* blocking function, that returns next char */
+extern int serial_getc (void)
+{
+	/* have we already got one key-stroke cached ? */
+	if (CachedKey)
+	{
+		CachedKey = 0;		/* empty the cache */
+		return CachedKeyCode;	/* cached key ready to be read */
+	}
+
+	/* polling wait: for a char to be read */
+	while (!serial_tstc ());
+
+	/* return the key just read */
+	CachedKey = 0;			/* empty the cache */
+	return CachedKeyCode;		/* return it */
+}
+
+
+/* write out a single char */
+extern void serial_putc (const char ch)
+{
+	unsigned char buff[6] = { 7, 1, 0, 0, 0 };
+	int buffLen = sizeof(buff);
+
+	/* put the char to write in buffer */
+	buff[5] = ch;
+
+	/* Send DTF request to the host */
+	dtf_transfer (buff, &buffLen, sizeof(buff));
+}
+
+
+/* write an entire (NUL-terminated) string */
+extern void serial_puts (const char *s)
+{
+	while (*s) {
+		serial_putc (*s++);
+	}
+}
+
+/* initialize the serial device */
+extern int serial_init (void)
+{
+	/* do nothing */
+	return 0;
+}
+
+
+/* called to adjust baud-rate */
+extern void serial_setbrg (void)
+{
+	/* do nothing */
+}
+
+
+#endif	/* CONFIG_STM_DTF_SERIAL */
diff --git a/include/asm-sh/asmdefs.h b/include/asm-sh/asmdefs.h
index 7163fd5..3f6385c 100644
--- a/include/asm-sh/asmdefs.h
+++ b/include/asm-sh/asmdefs.h
@@ -1,7 +1,8 @@
 /*
- * (C) Copyright 2004 STMicroelectronics.
+ * (C) Copyright 2004, 2007, 2009 STMicroelectronics.
  *
  * Andy Sturges <andy.sturges@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -182,3 +183,21 @@ where <index> is the PMB entry
 	MOV_CONST32_R0	(P4SEG_PMB_DATA | (\i<<8))
 	mov.l	r1,@r0
 .endm
+
+/*
+ * Write out a series of bytes, monotonically increasing
+ * in value from "first" to "last" (inclusive).
+ *
+ * Usage:	BYTES <first> <last>
+ * where <first> is the first byte to generate
+ * where <last>  is the last byte to generate
+ *
+ * Note: this macro uses recursion (one level per byte)
+ */
+.macro BYTES first=0, last=63
+	.byte \first
+	.if \last-\first
+	BYTES "(\first+1)",\last	/* note: recursion */
+	.endif
+.endm
+
diff --git a/include/asm-sh/ecc.h b/include/asm-sh/ecc.h
new file mode 100644
index 0000000..014601c
--- /dev/null
+++ b/include/asm-sh/ecc.h
@@ -0,0 +1,168 @@
+/*
+ * Synopsis : Error Correction Codes (ECC) Algorithms.
+ *
+ * Copyright (c) 2008-2009 STMicroelectronics Limited.  All right reserved.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* An ECC is a 3-byte code which can be used to detect and correct 1-bit
+ * errors (perhaps introduced by NAND flash defects) in a 128, 256, or
+ * 512-byte block of data.
+ *
+ * Features:
+ *   - Correction of any 1-bit error in the data.
+ *   - Detection of any 1-bit error in the ECC and whether the data is OK.
+ *   - Detection of any 2-bit error in the data.
+ *
+ * Limitations:
+ *   - CANNOT correct 2-bit errors.
+ *   - Results for 3-bit errors (or worse) are UNDEFINED.
+ *
+ * This algorithm is only intended for use with data corrupted by a NAND
+ * flash - in which anything more than a 1-bit error is highly unlikely.
+ *
+ * DO NOT attempt to use it where the data may be more seriously corrupted.
+ * The algorithm WILL NOT always correct serious defects and may even report
+ * that the data is good.
+ *
+ * Usage
+ * =====
+ *
+ * Writing flash:
+ *
+ *   1) Prepare the data.
+ *   2) Generate an ECC for each 128, 256, or 512 bytes.
+ *        ecc = ecc_gen (data, ECC_256)
+ *   3) Write both to flash.
+ *
+ * Reading flash:
+ *
+ *   1) Read both data and ECC from flash.
+ *   2) Generate a fresh ECC for the read data.
+ *        new_ecc = ecc_gen (read_data, ECC_256)
+ *   3) Compare the two ECCs and correct the data, if necessary.
+ *        ecc_correct (read_data, read_ecc, new_ecc, ECC_256)
+ *   4) Check the return code:
+ *        E_UN_CHK
+ *            Data cannot be used - too badly corrupted.
+ *        E_NO_CHK
+ *            All is well.
+ *        E_D1_CHK
+ *            Data has been corrected, but the flash block contains an error.
+ *        E_C1_CHK
+ *            Data is OK, but the flash block contains an error in the ECC.
+ *
+ * If a read error occurs then you may want to consider moving the data to
+ * another flash block. If the read error is in the ECC then don't forget
+ * to generate a correct ECC before rewriting.
+ *
+ * ECC Format
+ * ==========
+ *
+ * Basic Format:
+ *
+ *      		byte 0		byte 1		byte2
+ *
+ *      bit 0		LP0		LP8		LP16
+ *      bit 1		LP1		LP9		LP17
+ *      bit 2		LP2		LP10	`	CP0
+ *      bit 3		LP3		LP11		CP1
+ *      bit 4		LP4		LP12		CP2
+ *      bit 5		LP5		LP13		CP3
+ *      bit 6		LP6		LP14		CP4
+ *      bit 7		LP7		LP15		CP5
+ *
+ *      CP = Column parity
+ *      LP = Line parity
+ *
+ * ECC_128:
+ *
+ *      LP14-17 are not used. The unused bits are set to zero.
+ *
+ *      This format is designed to match the format used by the error
+ *      correcting EMI NAND Controller. It may NOT be compatible with other
+ *      128 byte ECCs.
+ *
+ * ECC_256:
+ *
+ *      LP16-17 are not used. The unused bits are set to zero.
+ *
+ * ECC_512:
+ *
+ *      All bits are used.
+ *
+ *      This format is NOT compatible with the 512 byte ECC used by OSPlus.
+ *      (At the time of writing, this can be resolved merely by inverting each
+ *      bit in the ECC, but this may not be the case in future.)
+ *
+ */
+
+#ifndef ECC_H
+#define ECC_H
+
+/* The ECC algorithms support three different data sizes. */
+enum ecc_size
+{
+  ECC_128 = 128,
+  ECC_256 = 256,
+  ECC_512 = 512
+};
+
+/* This type represents a 3-byte ECC. */
+typedef struct ecc
+{
+  unsigned char byte[3];
+} ecc_t;
+
+/* Return values from check function */
+enum ecc_check 
+{
+  E_UN_CHK = -1, /* uncorrectable error. */
+  E_NO_CHK = 0,  /* No Errors. */
+  E_D1_CHK = 1,  /* 1-bit data error. */
+  E_C1_CHK = 2   /* 1-bit code error. */
+};
+
+
+/* Generate 3 byte ECC code for ecc_size block p_data.
+   "p_data" is a pointer to the data and must be 4-byte aligned.
+   "size" gives length of "p_data" - one of enum ecc_size.
+ */
+extern ecc_t ecc_gen(
+	const unsigned char* p_data,
+	const enum ecc_size size);
+
+/* Detect and correct a 1 bit error in a 128, 256 or 512 byte block.
+   "p_data" is a pointer to the data.
+   "old_ecc" is the proper ECC for the data.
+   "new_ecc" is the ECC generated from the (possibly) corrupted data.
+   The size of the block is given in "size".
+
+   Returns whether the data needed correcting, or was not correctable.
+   If the result code is E_D1_CHK, then the data will have been modified.
+ */
+extern enum ecc_check ecc_correct(
+	unsigned char *p_data,
+	ecc_t old_ecc,
+	ecc_t new_ecc,
+	enum ecc_size size);
+
+#endif /* ifndef ECC_H */
+
diff --git a/include/asm-sh/io.h b/include/asm-sh/io.h
index 96458d7..62d17eb 100644
--- a/include/asm-sh/io.h
+++ b/include/asm-sh/io.h
@@ -50,16 +50,17 @@
 
 #define __WANT_IO_DEF
 
-#if defined(CONFIG_SH_MB411)	|| \
-       defined(CONFIG_SH_MB442)	|| \
-       defined(CONFIG_SH_MB448)	|| \
-       defined(CONFIG_SH_HMS1)	|| \
-       defined(CONFIG_SH_MB519)	|| \
-       defined(CONFIG_SH_MB618)	|| \
-       defined(CONFIG_SH_MB628)	|| \
-       defined(CONFIG_SH_MB671)	|| \
-       defined(CONFIG_SH_MB680)	|| \
-       defined(CONFIG_SH_CB101)	|| \
+#if defined(CONFIG_SH_MB411)		|| \
+       defined(CONFIG_SH_MB442)		|| \
+       defined(CONFIG_SH_MB448)		|| \
+       defined(CONFIG_SH_HMS1)		|| \
+       defined(CONFIG_SH_MB519)		|| \
+       defined(CONFIG_SH_MB618)		|| \
+       defined(CONFIG_SH_MB628)		|| \
+       defined(CONFIG_SH_MB671)		|| \
+       defined(CONFIG_SH_MB680)		|| \
+       defined(CONFIG_SH_PDK7105)	|| \
+       defined(CONFIG_SH_CB101)		|| \
        defined(CONFIG_SH_CB102)
 #  include "asm/io_stb1eval.h"
 #else
diff --git a/include/asm-sh/st40reg.h b/include/asm-sh/st40reg.h
index 796e39d..c807842 100644
--- a/include/asm-sh/st40reg.h
+++ b/include/asm-sh/st40reg.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) STMicroelectronics Ltd. 2002, 2003, 2007, 2008
+ * Copyright (C) STMicroelectronics Ltd. 2002, 2003, 2007-2009
  *
  * andy.sturges@st.com
  * Sean McGoogan <Sean.McGoogan@st.com>
@@ -383,14 +383,60 @@
 #define ST40_EMI_BANK5_EMICONFIGDATA2	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0250)
 #define ST40_EMI_BANK5_EMICONFIGDATA3	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0258)
 
-#define ST40_EMI_BANK0_BASEADDRESS	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0800)
-#define ST40_EMI_BANK1_BASEADDRESS	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0810)
-#define ST40_EMI_BANK2_BASEADDRESS	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0820)
-#define ST40_EMI_BANK3_BASEADDRESS	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0830)
-#define ST40_EMI_BANK4_BASEADDRESS	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0840)
-#define ST40_EMI_BANK5_BASEADDRESS	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0850)
+#define ST40_EMI_BASEADDRESS(bank)	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0800 + (bank)*0x0010)
+#define ST40_EMI_BANK0_BASEADDRESS	ST40_EMI_BASEADDRESS(0)
+#define ST40_EMI_BANK1_BASEADDRESS	ST40_EMI_BASEADDRESS(1)
+#define ST40_EMI_BANK2_BASEADDRESS	ST40_EMI_BASEADDRESS(2)
+#define ST40_EMI_BANK3_BASEADDRESS	ST40_EMI_BASEADDRESS(3)
+#define ST40_EMI_BANK4_BASEADDRESS	ST40_EMI_BASEADDRESS(4)
+#define ST40_EMI_BANK5_BASEADDRESS	ST40_EMI_BASEADDRESS(5)
 #define ST40_EMI_BANK_ENABLE		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0860)
 
+/* EMI NAND flash registers */
+#define ST40_EMI_NAND_REGS_BASE			(ST40_EMI_REGS_BASE + 0x1000)
+#define ST40_EMI_NAND_BOOTBANK_CFG		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0000)
+#define ST40_EMI_NAND_RBN_STA			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0004)
+#define ST40_EMI_NAND_INT_EN			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0010)
+#define ST40_EMI_NAND_INT_STA			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0014)
+#define ST40_EMI_NAND_INT_CLR			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0018)
+#define ST40_EMI_NAND_INT_EDGE_CFG		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x001c)
+#define ST40_EMI_NAND_CTL_TIMING		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0040)
+#define ST40_EMI_NAND_WEN_TIMING		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0044)
+#define ST40_EMI_NAND_REN_TIMING		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0048)
+#define ST40_EMI_NAND_BLOCK_ZERO_REMAP_REG	SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x004C)
+#define ST40_EMI_NAND_FLEXMODE_CFG		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0100)
+#define ST40_EMI_NAND_FLEX_MUXCTRL		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0104)
+#define ST40_EMI_NAND_FLEX_CS_ALT		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0108)
+#define ST40_EMI_NAND_FLEX_DATAWRT_CFG		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x010c)
+#define ST40_EMI_NAND_FLEX_DATA_RD_CFG		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0110)
+#define ST40_EMI_NAND_FLEX_CMD			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0114)
+#define ST40_EMI_NAND_FLEX_ADD_REG		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0118)
+#define ST40_EMI_NAND_FLEX_DATA			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0120)
+#define ST40_EMI_NAND_VERSION_REG		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0144)
+#define ST40_EMI_NAND_ADDRESS_REG_1		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x01E0)
+#define ST40_EMI_NAND_ADDRESS_REG_2		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x01E4)
+#define ST40_EMI_NAND_ADDRESS_REG_3		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x01E8)
+#define ST40_EMI_NAND_MULTI_CS_CONFIG_REG	SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x01EC)
+#define ST40_EMI_NAND_SEQ_REG1			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0200)
+#define ST40_EMI_NAND_SEQ_REG2			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0204)
+#define ST40_EMI_NAND_SEQ_REG3			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0208)
+#define ST40_EMI_NAND_SEQ_REG4			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x020c)
+#define ST40_EMI_NAND_ADD			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0210)
+#define ST40_EMI_NAND_EXTRA_REG			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0214)
+#define ST40_EMI_NAND_CMD			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0218)
+#define ST40_EMI_NAND_SEQ_CFG			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x021c)
+#define ST40_EMI_NAND_GEN_CFG			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0220)
+#define ST40_EMI_NAND_SEQ_STA			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0240)
+#define ST40_EMI_NAND_ECC_CHECKCODE_0		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0280)
+#define ST40_EMI_NAND_ECC_CHECKCODE_1		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0284)
+#define ST40_EMI_NAND_ECC_CHECKCODE_2		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0288)
+#define ST40_EMI_NAND_ECC_CHECKCODE_3		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x028c)
+#define ST40_EMI_NAND_ECC_CHECKCODE_2X8_0	SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0290)
+#define ST40_EMI_NAND_ECC_CHECKCODE_2X8_1	SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0294)
+#define ST40_EMI_NAND_ECC_CHECKCODE_2X8_2	SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0298)
+#define ST40_EMI_NAND_ECC_CHECKCODE_2X8_3	SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x029C)
+#define ST40_EMI_NAND_DATA_FIFO_REG		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0300)
+
 /* Peripheral Component Interconnect control registers (all ST40 variants) */
 /* PCI Local Registers */
 #define ST40_PCI_VCR_STATUS	SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000000)
diff --git a/include/asm-sh/stm-nand.h b/include/asm-sh/stm-nand.h
new file mode 100644
index 0000000..e0136a0
--- /dev/null
+++ b/include/asm-sh/stm-nand.h
@@ -0,0 +1,139 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <nand.h>
+
+
+extern struct nand_bbt_descr stm_nand_badblock_pattern_16;
+extern struct nand_bbt_descr stm_nand_badblock_pattern_64;
+
+extern int stm_nand_default_bbt (
+	struct mtd_info *mtd);
+
+
+#ifdef CFG_NAND_ECC_HW3_128	/* for STM "boot-mode" */
+
+
+extern int stm_nand_calculate_ecc (
+	struct mtd_info * const mtd,
+	const u_char * const dat,
+	u_char * const ecc_code);
+
+extern int stm_nand_correct_data (
+	struct mtd_info *mtd,
+	u_char *dat,
+	u_char *read_ecc,
+	u_char *calc_ecc);
+
+extern void stm_nand_enable_hwecc (
+	struct mtd_info *mtd,
+	int mode);
+
+
+extern int stm_nand_read (
+	struct mtd_info *mtd,
+	loff_t from,
+	size_t len,
+	size_t * retlen,
+	u_char * buf);
+
+extern int stm_nand_read_ecc (
+	struct mtd_info *mtd,
+	loff_t from,
+	size_t len,
+	size_t * retlen,
+	u_char * buf,
+	u_char * eccbuf,
+	struct nand_oobinfo *oobsel);
+
+extern int stm_nand_read_oob (
+	struct mtd_info *mtd,
+	loff_t from,
+	size_t len,
+	size_t * retlen,
+	u_char * buf);
+
+
+extern int stm_nand_write (
+	struct mtd_info *mtd,
+	loff_t to,
+	size_t len,
+	size_t * retlen,
+	const u_char * buf);
+
+extern int stm_nand_write_ecc (
+	struct mtd_info *mtd,
+	loff_t to,
+	size_t len,
+	size_t * retlen,
+	const u_char * buf,
+	u_char * eccbuf,
+	struct nand_oobinfo *oobsel);
+
+extern int stm_nand_write_oob (
+	struct mtd_info *mtd,
+	loff_t to,
+	size_t len,
+	size_t * retlen,
+	const u_char *buf);
+
+
+#endif	/* CFG_NAND_ECC_HW3_128 */
+
+
+#ifdef CFG_NAND_FLEX_MODE	/* for STM "flex-mode" (c.f. "bit-banging") */
+
+
+extern int stm_flex_device_ready(
+	struct mtd_info * const mtd);
+
+extern void stm_flex_select_chip (
+	struct mtd_info * const mtd,
+	const int chipnr);
+
+extern void stm_flex_hwcontrol (
+	struct mtd_info * const mtd,
+	int control);
+
+
+extern u_char stm_flex_read_byte(
+	struct mtd_info * const mtd);
+
+extern void stm_flex_write_byte(
+	struct mtd_info * const mtd,
+	u_char byte);
+
+
+extern void stm_flex_read_buf(
+	struct mtd_info * const mtd,
+	u_char * const buf,
+	const int len);
+
+extern void stm_flex_write_buf(
+	struct mtd_info * const mtd,
+	const u_char *buf,
+	const int len);
+
+
+#endif /* CFG_NAND_FLEX_MODE */
+
+
diff --git a/include/configs/mb411.h b/include/configs/mb411.h
index 7f6cb1f..d92710a 100644
--- a/include/configs/mb411.h
+++ b/include/configs/mb411.h
@@ -102,10 +102,19 @@
  * Serial console info
  */
 
-/* we are using the internal ST ASC UART */
-#define CONFIG_STM_ASC_SERIAL	1
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
 
-/* choose which UART to use */
+/* choose which ST ASC UART to use */
 #if 1
 #	define CFG_STM_ASC_BASE		0xb8032000ul	/* UART2 */
 #else
diff --git a/include/configs/mb442.h b/include/configs/mb442.h
index b95c9d9..9620048 100644
--- a/include/configs/mb442.h
+++ b/include/configs/mb442.h
@@ -112,10 +112,19 @@
  * Serial console info
  */
 
-/* we are using the internal ST ASC UART */
-#define CONFIG_STM_ASC_SERIAL	1
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
 
-/* choose which UART to use */
+/* choose which ST ASC UART to use */
 #if 1
 #	define CFG_STM_ASC_BASE		0xb8032000ul	/* UART2 */
 #else
diff --git a/include/configs/mb448.h b/include/configs/mb448.h
index 342a49e..cdbcf20 100644
--- a/include/configs/mb448.h
+++ b/include/configs/mb448.h
@@ -101,10 +101,19 @@
  * Serial console info
  */
 
-/* we are using the internal ST ASC UART */
-#define CONFIG_STM_ASC_SERIAL	1
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
 
-/* choose which UART to use */
+/* choose which ST ASC UART to use */
 #define CFG_STM_ASC_BASE	0xb8032000ul	/* UART2 */
 
 /*---------------------------------------------------------------
diff --git a/include/configs/mb519.h b/include/configs/mb519.h
index 3723d9d..2cb7da9 100644
--- a/include/configs/mb519.h
+++ b/include/configs/mb519.h
@@ -108,10 +108,19 @@
  * Serial console info
  */
 
-/* we are using the internal ST ASC UART */
-#define CONFIG_STM_ASC_SERIAL	1
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
 
-/* choose which UART to use */
+/* choose which ST ASC UART to use */
 #define CFG_STM_ASC_BASE	0xfd032000ul	/* UART2 (lower) */
 //#define CFG_STM_ASC_BASE	0xfd033000ul	/* UART3 (upper) */
 
diff --git a/include/configs/mb618.h b/include/configs/mb618.h
index fdd9a13..faa67d5 100644
--- a/include/configs/mb618.h
+++ b/include/configs/mb618.h
@@ -71,10 +71,16 @@
 
 #define BOARD mb618
 
-#if CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
+#if CFG_MONITOR_LEN == 0x00008000		/* 32 KiB */
 #	define MONITOR_SECTORS	"1:0"		/* 1 sector */
-#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
+#elif CFG_MONITOR_LEN == 0x00010000		/* 64 KiB */
 #	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#elif CFG_MONITOR_LEN == 0x00018000		/* 96 KiB */
+#	define MONITOR_SECTORS	"1:0-2"		/* 3 sectors */
+#elif CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
+#	define MONITOR_SECTORS	"1:0-3"		/* 4 sectors */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
+#	define MONITOR_SECTORS	"1:0-4"		/* 5 sectors */
 #else						/* unknown */
 #	error "Unable to determine sectors for monitor"
 #endif
@@ -108,10 +114,19 @@
  * Serial console info
  */
 
-/* we are using the internal ST ASC UART */
-#define CONFIG_STM_ASC_SERIAL	1
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
 
-/* choose which UART to use */
+/* choose which ST ASC UART to use */
 #if 1
 #	define CFG_STM_ASC_BASE		0xfd032000ul	/* UART2 */
 #else
diff --git a/include/configs/mb628.h b/include/configs/mb628.h
index ccfc5ad..ef5f65e 100644
--- a/include/configs/mb628.h
+++ b/include/configs/mb628.h
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2008 STMicroelectronics.
+ * (C) Copyright 2008-2009 STMicroelectronics.
  *
  * Sean McGoogan <Sean.McGoogan@st.com>
  *
@@ -39,12 +39,14 @@
 /*-----------------------------------------------------------------------
  * Start addresses for the final memory configuration
  * Assume we run out of uncached memory for the moment
+ *
+ * See board/mb628/config.mk for details of the memory map.
  */
 
 #ifdef CONFIG_SH_SE_MODE
 #define CFG_FLASH_BASE		0xA0000000	/* FLASH (uncached) via PMB */
 #define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI Physical Address */
-#define CFG_SDRAM_BASE		0x80000000      /* LMI    Cached addr via PMB */
+#define CFG_SDRAM_BASE		0x80800000      /* LMI    Cached addr via PMB */
 #define CFG_SE_UNACHED_BASE	0x90000000	/* LMI UN-cached addr via PMB */
 #define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
 #else
@@ -52,7 +54,7 @@
 #define CFG_SDRAM_BASE		0x8C800000      /* SDRAM in P1 region */
 #endif
 
-#define CFG_SDRAM_SIZE		0x03000000	/* 48 MiB of LMI SDRAM */
+#define CFG_SDRAM_SIZE		0x03200000	/* 50 MiB of LMI SDRAM */
 
 #define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
 #define CFG_MONITOR_BASE        CFG_FLASH_BASE
@@ -114,10 +116,19 @@
  * Serial console info
  */
 
-/* we are using the internal ST ASC UART */
-#define CONFIG_STM_ASC_SERIAL	1
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
 
-/* choose which UART to use */
+/* choose which ST ASC UART to use */
 #if 1
 	/* ASC1	(left-most)	"RS232 1" */
 #	define CFG_STM_ASC_BASE		0xfd031000
diff --git a/include/configs/mb671.h b/include/configs/mb671.h
index ef0ebf3..a3626c9 100644
--- a/include/configs/mb671.h
+++ b/include/configs/mb671.h
@@ -108,10 +108,19 @@
  * Serial console info
  */
 
-/* we are using the internal ST ASC UART */
-#define CONFIG_STM_ASC_SERIAL	1
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
 
-/* choose which UART to use */
+/* choose which ST ASC UART to use */
 #define CFG_STM_ASC_BASE	0xfd032000ul	/* UART2 (lower) */
 //#define CFG_STM_ASC_BASE	0xfd033000ul	/* UART3 (upper) */
 
diff --git a/include/configs/mb680.h b/include/configs/mb680.h
index 6700e1b..cb89d0e 100644
--- a/include/configs/mb680.h
+++ b/include/configs/mb680.h
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2008 STMicroelectronics.
+ * (C) Copyright 2008-2009 STMicroelectronics.
  *
  * Sean McGoogan <Sean.McGoogan@st.com>
  *
@@ -37,18 +37,42 @@
 #define P_CLOCK_RATE	87500000	/* clock rate for CSP		*/
 
 /*-----------------------------------------------------------------------
+ * Are we booting directly from a NAND Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_NAND" macro,
+ * otherwise (e.g. NOR/SPI Flash booting), do not define it.
+ */
+#undef CFG_BOOT_FROM_NAND		/* define to build a NAND-bootable image */
+
+
+/*-----------------------------------------------------------------------
  * Start addresses for the final memory configuration
  * Assume we run out of uncached memory for the moment
  */
 
+#ifdef CFG_BOOT_FROM_NAND	/* we are booting from NAND, so *DO* swap CSA and CSB in EPLD */
+		/*
+		 * QQQ: do we want to make sizeof(CSA) = 8MiB, and sizeof(CSB) = 64MiB ?
+		 * If so, then who takes responsibility for this???
+		 * Is this implicit in the GDB pokes, or explicit in U-Boot's init code?
+		 * Should U-Boot read SW8(1) on the MB705, and do something?
+		 */
+#define CFG_EMI_NAND_BASE	0xA0000000	/* CSA: NAND Flash, Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NOR_BASE	0xA4000000	/* CSB: NOR Flash,  Physical 0x04000000 (8MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 0 }		/* NAND is on Chip Select CSA */
+#else		/* else, do *NOT* swap CSA and CSB in EPLD */
+#define CFG_EMI_NOR_BASE	0xA0000000	/* CSA: NOR Flash,  Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NAND_BASE	0xA4000000	/* CSB: NAND Flash, Physical 0x04000000 (8MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 1 }		/* NAND is on Chip Select CSB */
+#endif /* CFG_BOOT_FROM_NAND */
+
 #ifdef CONFIG_SH_SE_MODE
-#define CFG_FLASH_BASE		0xA0000000	/* NOR FLASH (uncached) via PMB */
+#define CFG_FLASH_BASE		CFG_EMI_NOR_BASE/* NOR FLASH (uncached) via PMB */
 #define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI Physical Address */
 #define CFG_SDRAM_BASE		0x80000000      /* LMI    Cached addr via PMB */
 #define CFG_SE_UNACHED_BASE	0x90000000	/* LMI UN-cached addr via PMB */
 #define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
 #else
-#define CFG_FLASH_BASE		0xA0000000	/* NOR FLASH in P2 region */
+#define CFG_FLASH_BASE		CFG_EMI_NOR_BASE/* NOR FLASH in P2 region */
 #define CFG_SDRAM_BASE		0x8C000000      /* SDRAM in P1 region */
 #endif
 
@@ -114,10 +138,19 @@
  * Serial console info
  */
 
-/* we are using the internal ST ASC UART */
-#define CONFIG_STM_ASC_SERIAL	1
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
 
-/* choose which UART to use */
+/* choose which ST ASC UART to use */
 #if 1
 #	define CFG_STM_ASC_BASE		0xfd032000ul	/* UART2 = AS0 */
 #else
@@ -129,9 +162,10 @@
  */
 
 /*
- * There are 2 options for ethernet, both use the on-chip ST-GMAC.
+ * There are 3 options for ethernet, all use the on-chip ST-GMAC.
  * The choice in PHYs are:
- *    The on-board Nat Semi DP83865
+ *    The on-board Nat Semi DP83865	(only on Rev A, B)
+ *    The on-board SMSC LAN8700		(only on Rev C)		(NOW the DEFAULT)
  *    External PHY connected via the MII off-board connector.
  */
 
@@ -144,7 +178,11 @@
  */
 #ifdef CONFIG_DRIVER_NET_STM_GMAC
 #	define CFG_STM_STMAC_BASE	 0xfd110000ul	/* MAC = STM GMAC0 */
-#	define CONFIG_STMAC_DP83865			/* PHY = NS DP83865 */
+#if 0							/* Choose NS or SMSC PHY */
+#	define CONFIG_STMAC_DP83865	/* Rev A,B */	/* PHY = NS DP83865 */
+#else
+#	define CONFIG_STMAC_LAN8700	/* Rev C */	/* PHY = SMSC LAN8700 */
+#endif
 #endif	/* CONFIG_DRIVER_NET_STM_GMAC */
 
 /*  If this board does not have eeprom for ethernet address so allow the user
@@ -254,7 +292,7 @@
 #ifdef CONFIG_CMD_NAND				/* NAND flash present ? */
 #	define CFG_MAX_NAND_DEVICE	1
 #	define NAND_MAX_CHIPS		CFG_MAX_NAND_DEVICE
-#	define CFG_NAND0_BASE		0xA4000000	/* Physical 0x04000000 */
+#	define CFG_NAND0_BASE		CFG_EMI_NAND_BASE
 #	define CFG_NAND_BASE_LIST	{ CFG_NAND0_BASE }
 #	define MTDPARTS_NAND						\
 	"gen_nand.1:"		/* First NAND flash device */		\
@@ -264,6 +302,45 @@
 		",-(RestOfNand0)"	/* last partition */
 #	define MTDIDS_NAND						\
 	"nand0=gen_nand.1"	/* First NAND flash device */
+
+	/*
+	 * Currently, there are 2 main modes to read/write from/to
+	 * NAND devices on STM SoCs:
+	 *	a) "bit-banging" (can NOT be used in boot-from-NAND)
+	 *	b) FLEX-mode (only supported means for boot-from-NAND)
+	 * If CFG_NAND_FLEX_MODE is defined, then FLEX-mode will be
+	 * used, otherwise, "bit-banging" will be used.
+	 */
+#	define CFG_NAND_FLEX_MODE	/* define to use NAND FLEX-MODE */
+
+	/*
+	 * Do we want to read/write NAND Flash compatible with the ST40's
+	 * NAND Controller H/W IP block for "boot-mode"? If we want
+	 * to read/write NAND flash that is meant to support booting
+	 * from NAND, then we need to use 3 bytes of ECC per 128 byte
+	 * record.  If so, then define the "CFG_NAND_ECC_HW3_128" macro.
+	 */
+#	define CFG_NAND_ECC_HW3_128	/* define for "boot-from-NAND" compatibility */
+
+	/*
+	 * If using CFG_NAND_ECC_HW3_128, then we must also define
+	 * where the (high watermark) boundary is. That is, the
+	 * NAND offset, below which we are in "boot-mode", and
+	 * must use 3 bytes of ECC for each 128 byte record.
+	 * For this offset (and above) we can use any supported
+	 * ECC configuration (e.g 3/256 S/W, or 3/512 H/W).
+	 */
+#	define CFG_NAND_STM_BOOT_MODE_BOUNDARY (1ul << 20)	/* 1 MiB */
+
+	/*
+	 * If we want to store the U-boot environment variables in
+	 * the NAND device, then we also need to specify *where* the
+	 * environment variables will be stored. Typically this
+	 * would be immediately after the U-boot monitor itself.
+	 * However, that *may* be a bad block. Define the following
+	 * to place the environment in an appropriate good block.
+	 */
+#	define CFG_NAND_ENV_OFFSET (CFG_MONITOR_LEN + 0x0)	/* immediately after u-boot.bin */
 #endif	/* CONFIG_CMD_NAND */
 
 /*-----------------------------------------------------------------------
@@ -278,7 +355,7 @@
 #	define CFG_ENV_SECT_SIZE	0x20000	/* 128 KiB Sector size */
 #elif defined(CONFIG_CMD_NAND)			/* NAND flash present ? */
 #	define CFG_ENV_IS_IN_NAND		/* environment in NAND flash */
-#	define CFG_ENV_OFFSET	0		/* beginning of NAND flash */
+#	define CFG_ENV_OFFSET	CFG_NAND_ENV_OFFSET
 #else
 #	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
 #endif	/* CONFIG_CMD_NAND */
diff --git a/include/configs/pdk7105.h b/include/configs/pdk7105.h
new file mode 100644
index 0000000..b0c16f1
--- /dev/null
+++ b/include/configs/pdk7105.h
@@ -0,0 +1,380 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
+
+/* This should really be replaced with something which uses bd->...	*/
+#define P_CLOCK_RATE	87500000	/* clock rate for CSP		*/
+
+/*-----------------------------------------------------------------------
+ * Are we booting directly from a NAND Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_NAND" macro,
+ * otherwise (e.g. NOR/SPI Flash booting), do not define it.
+ */
+#undef CFG_BOOT_FROM_NAND		/* define to build a NAND-bootable image */
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#ifdef CFG_BOOT_FROM_NAND	/* we are booting from NAND, so *DO* swap CSA and CSC with JE2 */
+#define CFG_EMI_NAND_BASE	0xA0000000	/* CSA: NAND Flash, Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NOR_BASE	0xA4000000	/* CSB: NOR Flash,  Physical 0x04000000 (32MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 0 }		/* NAND is on Chip Select CSA */
+#else		/* else, do *NOT* swap CSA and CSC using JE2 */
+#define CFG_EMI_NOR_BASE	0xA0000000	/* CSA: NOR Flash,  Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NAND_BASE	0xA6000000	/* CSC: NAND Flash, Physical 0x06000000 (8MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 2 }		/* NAND is on Chip Select CSC */
+#endif /* CFG_BOOT_FROM_NAND */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_FLASH_BASE		CFG_EMI_NOR_BASE/* NOR FLASH (uncached) via PMB */
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI Physical Address */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI    Cached addr via PMB */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI UN-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_FLASH_BASE		CFG_EMI_NOR_BASE/* NOR FLASH in P2 region */
+#define CFG_SDRAM_BASE		0x8C000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x10000000	/* 256 MiB of LMI SDRAM */
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
+#define CFG_MONITOR_BASE        CFG_FLASH_BASE
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD pdk7105
+
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
+
+/* choose which ST ASC UART to use */
+#if 1
+	/* 9-pin D-type connector on STi7105-SDK-SB daughter board */
+#	define CFG_STM_ASC_BASE		0xfd032000ul	/* UART2 = AS0 */
+#else
+	/* JN5, 6-way connector - QQQ NOT TESTED */
+#	define CFG_STM_ASC_BASE		0xfd033000ul	/* UART3 = AS1 */
+#endif
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 2 options for ethernet, both use the on-chip ST-GMAC.
+ * The choice in PHYs are:
+ *    The on-board Micrel KSZ8041FTL
+ *    External PHY connected via the MII off-board 15x2 header.
+ */
+
+/* are we using the internal ST GMAC device ? */
+#define CONFIG_DRIVER_NET_STM_GMAC
+
+/*
+ * Select the appropriate base address for the GMAC.
+ * Also, choose which PHY to use.
+ */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+#	define CFG_STM_STMAC_BASE	0xfd110000ul	/* MAC = STM GMAC0 */
+#	define CONFIG_STMAC_KSZ8041FTL			/* PHY = Micrel KSZ8041FTL */
+#else
+#	undef CONFIG_CMD_NET		/* undefine if no networking at all */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB0_BASE			0xfe100000	/* rear (adjacent to RJ-45) */
+#	define CFG_USB1_BASE			0xfea00000	/* front (near corner) */
+#	define CFG_USB_BASE			CFG_USB0_BASE
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+#if defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CFG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"PDK7105> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			(P_CLOCK_RATE/1024) /* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* Choose if we want FLASH Support (NAND &/or NOR devices)
+ * With the PDK7105 combination, we may use *both*
+ * NOR and NAND flash, at the same time, if we want.
+ *
+ * Note: by default CONFIG_CMD_FLASH is defined in config_cmd_default.h
+ */
+#undef CONFIG_CMD_FLASH		/* undefine it, define only if needed */
+#define CONFIG_CMD_FLASH	/* define for NOR flash */
+#define CONFIG_CMD_NAND		/* define for NAND flash */
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+/* S29GL01GP: 128MiB, 1024 blocks * 128KiB block size */
+#ifdef CONFIG_CMD_FLASH				/* NOR flash present ? */
+#	define CFG_FLASH_CFI_DRIVER
+#	define CFG_FLASH_CFI
+#	define CONFIG_FLASH_PROTECT_SINGLE_CELL
+#	define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#	define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#	define CFG_MAX_FLASH_SECT	1024	/* max number of sectors on one chip	*/
+#	define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+#	define MTDPARTS_NOR						\
+	"physmap-flash:"	/* First NOR flash device */		\
+		"256k(U-Boot)"		/* first partition */		\
+		",128k(Environment)"					\
+		",4M(Kernel)"						\
+		",-(RestOfNor0)"	/* last partition */
+#	define MTDIDS_NOR						\
+	"nor0=physmap-flash"	/* First NOR flash device */
+#else
+#	undef CONFIG_CMD_IMLS			/* NOR-flash specific */
+#	define CFG_NO_FLASH			/* NOR-flash specific */
+#endif	/* CONFIG_CMD_FLASH */
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH organization
+ */
+
+/* HY27UH08AG5B : 2GiB  8-bit, 16384 Blocks (128KiB+4KiB) of 64 Pages (2048+64) */
+#ifdef CONFIG_CMD_NAND				/* NAND flash present ? */
+#	define CFG_MAX_NAND_DEVICE	1
+#	define NAND_MAX_CHIPS		CFG_MAX_NAND_DEVICE
+#	define CFG_NAND0_BASE		CFG_EMI_NAND_BASE
+#	define CFG_NAND_BASE_LIST	{ CFG_NAND0_BASE }
+#	define MTDPARTS_NAND						\
+	"gen_nand.1:"		/* First NAND flash device */		\
+		"128k(env-nand0)"	/* first partition */		\
+		",4M(kernel-nand0)"					\
+		",32M(root-nand0)"					\
+		",-(RestOfNand0)"	/* last partition */
+#	define MTDIDS_NAND						\
+	"nand0=gen_nand.1"	/* First NAND flash device */
+
+	/*
+	 * Currently, there are 2 main modes to read/write from/to
+	 * NAND devices on STM SoCs:
+	 *	a) "bit-banging" (can NOT be used in boot-from-NAND)
+	 *	b) FLEX-mode (only supported means for boot-from-NAND)
+	 * If CFG_NAND_FLEX_MODE is defined, then FLEX-mode will be
+	 * used, otherwise, "bit-banging" will be used.
+	 */
+#	define CFG_NAND_FLEX_MODE	/* define to use NAND FLEX-MODE */
+
+	/*
+	 * Do we want to read/write NAND Flash compatible with the ST40's
+	 * NAND Controller H/W IP block for "boot-mode"? If we want
+	 * to read/write NAND flash that is meant to support booting
+	 * from NAND, then we need to use 3 bytes of ECC per 128 byte
+	 * record.  If so, then define the "CFG_NAND_ECC_HW3_128" macro.
+	 */
+#	define CFG_NAND_ECC_HW3_128	/* define for "boot-from-NAND" compatibility */
+
+	/*
+	 * If using CFG_NAND_ECC_HW3_128, then we must also define
+	 * where the (high watermark) boundary is. That is, the
+	 * NAND offset, below which we are in "boot-mode", and
+	 * must use 3 bytes of ECC for each 128 byte record.
+	 * For this offset (and above) we can use any supported
+	 * ECC configuration (e.g 3/256 S/W, or 3/512 H/W).
+	 */
+#	define CFG_NAND_STM_BOOT_MODE_BOUNDARY (1ul << 20)	/* 1 MiB */
+
+	/*
+	 * If we want to store the U-boot environment variables in
+	 * the NAND device, then we also need to specify *where* the
+	 * environment variables will be stored. Typically this
+	 * would be immediately after the U-boot monitor itself.
+	 * However, that *may* be a bad block. Define the following
+	 * to place the environment in an appropriate good block.
+	 */
+#	define CFG_NAND_ENV_OFFSET (CFG_MONITOR_LEN + 0x0)	/* immediately after u-boot.bin */
+#endif	/* CONFIG_CMD_NAND */
+
+/*-----------------------------------------------------------------------
+ * Address, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_SIZE			0x4000	/* 16 KiB of environment data */
+
+#ifdef CONFIG_CMD_FLASH				/* NOR flash present ? */
+#	define CFG_ENV_IS_IN_FLASH		/* environment in NOR flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
+#	define CFG_ENV_SECT_SIZE	0x20000	/* 128 KiB Sector size */
+#elif defined(CONFIG_CMD_NAND)			/* NAND flash present ? */
+#	define CFG_ENV_IS_IN_NAND		/* environment in NAND flash */
+#	define CFG_ENV_OFFSET	CFG_NAND_ENV_OFFSET
+#else
+#	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#endif	/* CONFIG_CMD_NAND */
+
+/*----------------------------------------------------------------------
+ * JFFS2 + MTD Partition support
+ */
+
+#if 1 && (defined(CONFIG_CMD_FLASH) || defined(CONFIG_CMD_NAND))
+#	define CONFIG_CMD_JFFS2			/* enable JFFS2 support */
+#endif
+
+#if defined(CONFIG_CMD_JFFS2)
+#	define CONFIG_JFFS2_CMDLINE		/* mtdparts command line support */
+#	define CONFIG_JFFS2_NAND		/* JFFS2 support on NAND Flash */
+#	if defined(CONFIG_CMD_FLASH) && defined(CONFIG_CMD_NAND) /* Both NOR + NAND */
+#		define MTDPARTS_DEFAULT						\
+		"mtdparts="							\
+			MTDPARTS_NOR	/* NOR flash devices */			\
+			";"		/* delimiter */				\
+			MTDPARTS_NAND	/* NAND flash devices */
+#		define MTDIDS_DEFAULT						\
+			MTDIDS_NOR	/* NOR flash devices */			\
+			","		/* delimiter */				\
+			MTDIDS_NAND	/* NAND flash devices */
+#	elif defined(CONFIG_CMD_FLASH)		/* Only NOR flash devices */
+#		define MTDPARTS_DEFAULT	"mtdparts=" MTDPARTS_NOR
+#		define MTDIDS_DEFAULT	MTDIDS_NOR
+#	elif defined(CONFIG_CMD_NAND)		/* Only NAND flash devices */
+#		define MTDPARTS_DEFAULT	"mtdparts=" MTDPARTS_NAND
+#		define MTDIDS_DEFAULT	MTDIDS_NAND
+#	endif	/* defined(CONFIG_CMD_FLASH) && defined(CONFIG_CMD_NAND) */
+#endif	/* CONFIG_CMD_JFFS2 */
+
+#endif	/* __CONFIG_H */
diff --git a/include/linux/mtd/mtd-abi.h b/include/linux/mtd/mtd-abi.h
index 3d1d416..4ba5cd2 100644
--- a/include/linux/mtd/mtd-abi.h
+++ b/include/linux/mtd/mtd-abi.h
@@ -89,11 +89,13 @@ struct region_info_user {
 #define MEMGETBADBLOCK		_IOW('M', 11, loff_t)
 #define MEMSETBADBLOCK		_IOW('M', 12, loff_t)
 
+#define MTD_NANDECC_MAX_OOBFREE	16	/* 16 for STMicroelectronics STi7xxx */
+#define MTD_NANDECC_MAX_ECCPOS	48	/* 48 for STMicroelectronics STi7xxx */
 struct nand_oobinfo {
 	uint32_t useecc;
 	uint32_t eccbytes;
-	uint32_t oobfree[8][2];
-	uint32_t eccpos[32];
+	uint32_t oobfree[MTD_NANDECC_MAX_OOBFREE][2];
+	uint32_t eccpos[MTD_NANDECC_MAX_ECCPOS];
 };
 
 #endif /* __MTD_ABI_H__ */
diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 49ff80f..95f2bd1 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -64,12 +64,20 @@ extern void nand_release (struct mtd_info *mtd);
 /* Read raw data from the device without ECC */
 extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_t len, size_t ooblen);
 
+/* read/write with ECC functions */
+extern int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+			  size_t * retlen, u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel);
+extern int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf);
+extern int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
+			   size_t * retlen, const u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel);
+extern int nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char *buf);
 
 /* This constant declares the max. oobsize / page, which
  * is supported now. If you add a chip with bigger oobsize/page
  * adjust this accordingly.
  */
 #define NAND_MAX_OOBSIZE	64
+#define NAND_MAX_PAGESIZE	2048
 
 /*
  * Constants for hardware specific CLE/ALE/NCE function
@@ -135,6 +143,8 @@ extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_
 #define NAND_ECC_HW8_512	6
 /* Hardware ECC 12 byte ECC per 2048 Byte data */
 #define NAND_ECC_HW12_2048	7
+/* Hardware ECC 3 byte ECC per 128 Byte data */
+#define NAND_ECC_HW3_128	8
 
 /*
  * Constants for Hardware ECC
diff --git a/lib_sh/Makefile b/lib_sh/Makefile
index 5ee9b8e..e1b477f 100644
--- a/lib_sh/Makefile
+++ b/lib_sh/Makefile
@@ -27,7 +27,7 @@ LIB	= lib$(ARCH).a
 
 AOBJS	= memchr.o memcpy.o memmove.o memset.o strlen.o cacheops.o div64.o
 
-COBJS	= board.o sh_linux.o time.o io_generic.o udivdi3.o
+COBJS	= board.o sh_linux.o time.o io_generic.o udivdi3.o sconsole.o
 
 OBJS	= $(AOBJS) $(COBJS)
 
diff --git a/lib_sh/sconsole.c b/lib_sh/sconsole.c
new file mode 100644
index 0000000..4408e86
--- /dev/null
+++ b/lib_sh/sconsole.c
@@ -0,0 +1,127 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2009 STMicroelectronics.
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+
+#include "sconsole.h"
+
+#if	!defined(CONFIG_SH_SCIF_SERIAL) &&	\
+	!defined(CONFIG_STM_ASC_SERIAL) &&	\
+	!defined(CONFIG_STM_DTF_SERIAL)
+
+int serial_init (void)
+{
+	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+	sb->pos = 0;
+	sb->size = 0;
+	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
+
+	return (0);
+}
+
+void serial_putc (char c)
+{
+	if (sconsole_putc) {
+		(*sconsole_putc) (c);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		if (c) {
+			sb->data[sb->pos++] = c;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+void serial_puts (const char *s)
+{
+	if (sconsole_puts) {
+		(*sconsole_puts) (s);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		while (*s) {
+			sb->data[sb->pos++] = *s++;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+int serial_getc (void)
+{
+	if (sconsole_getc) {
+		return (*sconsole_getc) ();
+	} else {
+		return 0;
+	}
+}
+
+int serial_tstc (void)
+{
+	if (sconsole_tstc) {
+		return (*sconsole_tstc) ();
+	} else {
+		return 0;
+	}
+}
+
+void serial_setbrg (void)
+{
+	if (sconsole_setbrg) {
+		(*sconsole_setbrg) ();
+	}
+}
+
+void sconsole_flush (void)
+{
+	if (sconsole_putc) {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+		unsigned int end = sb->pos < sb->size
+			? sb->pos + sb->max_size - sb->size
+			: sb->pos - sb->size;
+
+		while (sb->size) {
+			(*sconsole_putc) (sb->data[end++]);
+			if (end == sb->max_size) {
+				end = 0;
+			}
+			sb->size--;
+		}
+	}
+}
+#endif
diff --git a/lib_sh/sconsole.h b/lib_sh/sconsole.h
new file mode 100644
index 0000000..a387584
--- /dev/null
+++ b/lib_sh/sconsole.h
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2009 STMicroelectronics.
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SCONSOLE_H_
+#define _SCONSOLE_H_
+
+#include <config.h>
+
+
+/*
+ * set the address and size of the SCONSOLE_BUFFER,
+ * if not explicitly defined in the config.h file.
+ */
+#ifndef CFG_SCONSOLE_ADDR
+#define CFG_SCONSOLE_ADDR		CFG_SDRAM_BASE
+#endif	/* CFG_SCONSOLE_ADDR */
+#ifndef CFG_SCONSOLE_SIZE
+#define CFG_SCONSOLE_SIZE		0x2000	/* 8 KiB */
+#endif	/* CFG_SCONSOLE_SIZE */
+
+
+typedef struct sconsole_buffer_s
+{
+	unsigned long size;
+	unsigned long max_size;
+	unsigned long pos;
+	char data[1];
+} sconsole_buffer_t;
+
+#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
+
+extern void (*sconsole_putc) (char);
+extern void (*sconsole_puts) (const char *);
+extern int (*sconsole_getc) (void);
+extern int (*sconsole_tstc) (void);
+extern void (*sconsole_setbrg) (void);
+
+extern void sconsole_flush (void);
+
+#endif
diff --git a/sh_config.mk b/sh_config.mk
index 30b7ecb..6129e52 100644
--- a/sh_config.mk
+++ b/sh_config.mk
@@ -27,7 +27,7 @@
 # for actual build number, in the following identifier.
 # Regular Expression for string is:
 # 	"stm[2-9][0-9]-[2-9][0-9][0-9][0-9]-[01][0-9]-[0-3][0-9]"
-SH_IDENT_STRING="\"stm23-2008-10-13\""
+SH_IDENT_STRING="\"stm23-2009-04-27\""
 
 PLATFORM_CPPFLAGS += -DCONFIG_SH4 -D__SH4__ -DCONFIG_IDENT_STRING=$(SH_IDENT_STRING)
 PLATFORM_LDFLAGS  += -n
diff -Naur include/configs/dummy.h.orig include/configs/dummy.h
--- include/configs/dummy.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ include/configs/dummy.h	2008-04-01 11:39:54.000000000 +0100
@@ -0,0 +1,5 @@
+/*
+ * Usual setting for our environment size
+ */
+#define CFG_ENV_SIZE            0x10000
+
diff -Naur Makefile.orig Makefile
--- a/Makefile.orig	2008-03-31 11:18:13.000000000 +0100
+++ b/Makefile	2008-04-01 11:40:16.000000000 +0100
@@ -310,7 +310,7 @@
 		$(MAKE) -C $(dir $(subst $(obj),,$@))
 
 $(SUBDIRS):
-		$(MAKE) -C $@ all
+		$(MAKE) -C $@ 
 
 $(NAND_SPL):	version
 		$(MAKE) -C nand_spl/board/$(BOARDDIR) all
