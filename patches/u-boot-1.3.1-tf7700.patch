diff -Nur u-boot-sh4-1.3.1_stm23_0043_orig/common/main.c u-boot-sh4-1.3.1_stm23_0043/common/main.c
--- u-boot-sh4-1.3.1_stm23_0043_orig/common/main.c	2011-07-02 21:08:15.700078411 +0200
+++ u-boot-sh4-1.3.1_stm23_0043/common/main.c	2011-07-02 21:07:24.584080807 +0200
@@ -48,7 +48,7 @@
  * Board-specific Platform code can reimplement show_boot_progress () if needed
  */
 void inline __show_boot_progress (int val) {}
-void inline show_boot_progress (int val) __attribute__((weak, alias("__show_boot_progress")));
+void inline show_boot_progress (int val) __attribute__((alias("__show_boot_progress")));
 
 #if defined(CONFIG_BOOT_RETRY_TIME) && defined(CONFIG_RESET_TO_RETRY)
 extern int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);		/* for do_reset() prototype */
diff -Nur u-boot-sh4-1.3.1_stm23_0043_orig/common/cmd_ide.c.orig u-boot-sh4-1.3.1_stm23_0043/common/cmd_ide.c
--- u-boot-sh4-1.3.1_stm23_0043_orig/common/cmd_ide.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-sh4-1.3.1_stm23_0043/common/cmd_ide.c	2011-07-02 21:06:32.379078873 +0200
@@ -816,19 +816,19 @@
 	outb(val, (ATA_CURR_BASE(dev)+CFG_ATA_PORT_ADDR(port)));
 }
 void inline ide_outb (int dev, int port, unsigned char val)
-		__attribute__((weak, alias("__ide_outb")));
+		__attribute__((alias("__ide_outb")));
 
 unsigned char inline
 __ide_inb(int dev, int port)
 {
 	uchar val;
 	val = inb((ATA_CURR_BASE(dev)+CFG_ATA_PORT_ADDR(port)));
 	debug ("ide_inb (dev= %d, port= 0x%x) : @ 0x%08lx -> 0x%02x\n",
 		dev, port, (ATA_CURR_BASE(dev)+CFG_ATA_PORT_ADDR(port)), val);
 	return val;
 }
 unsigned char inline ide_inb(int dev, int port)
-			__attribute__((weak, alias("__ide_inb")));
+			__attribute__((alias("__ide_inb")));
 
 #ifdef __PPC__
 # ifdef CONFIG_AMIGAONEG3SE
diff -rcN u-boot-sh4-1.3.1_stm23_0043_orig/board/tf7700/config.mk u-boot-sh4-1.3.1_stm23_0043/board/tf7700/config.mk
*** u-boot-sh4-1.3.1_stm23_0043_orig/board/tf7700/config.mk	1970-01-01 01:00:00.000000000 +0100
--- u-boot-sh4-1.3.1_stm23_0043/board/tf7700/config.mk	2010-01-30 00:30:21.000000000 +0100
***************
*** 0 ****
--- 1,25 ----
+ # This program is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU General Public License as
+ # published by the Free Software Foundation; either version 2 of
+ # the License, or (at your option) any later version.
+ #
+ # This program is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ # GNU General Public License for more details.
+ #
+ # You should have received a copy of the GNU General Public License
+ # along with this program; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ # MA 02111-1307 USA
+ #
+ 
+ #
+ # TF7700
+ #
+ 
+ # Executes at SDRAM BASE  + 127M in cache region
+ #TEXT_BASE = 0x84601000
+ TEXT_BASE = 0x8bf00000
+ #TEXT_BASE = 0x88000000
+ PLATFORM_LDFLAGS +=
diff -rcN u-boot-sh4-1.3.1_stm23_0043_orig/board/tf7700/fp_port.c u-boot-sh4-1.3.1_stm23_0043/board/tf7700/fp_port.c
*** u-boot-sh4-1.3.1_stm23_0043_orig/board/tf7700/fp_port.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-sh4-1.3.1_stm23_0043/board/tf7700/fp_port.c	2010-01-30 00:33:05.000000000 +0100
***************
*** 0 ****
--- 1,266 ----
+ /*
+  * Driver for the second serial port for communication with the TF7700
+  * front panel (e.g. to display something on VFD).
+  *
+  * copied from drivers/serial/stm-asc.c
+  *
+  * Support for Serial I/O using STMicroelectronics' on-chip ASC.
+  *
+  *  Copyright (c) 2004,2008  STMicroelectronics Limited
+  *  Sean McGoogan <Sean.McGoogan@st.com>
+  *  Copyright (C) 1999  Takeshi Yaegachi & Niibe Yutaka
+  *
+  * This file is subject to the terms and conditions of the GNU Lesser
+  * General Public License.  See the file "COPYING.LIB" in the main
+  * directory of this archive for more details.
+  *
+  */
+ 
+ #include "common.h"
+ 
+ #ifdef CONFIG_STM_ASC_SERIAL
+ 
+ #include "asm/termbits.h"
+ #include "asm/io.h"
+ #include "asm/pio.h"
+ 
+ #define CS7		0000040
+ #define CS8		0000060
+ #define CSIZE		0000060
+ #define CSTOPB		0000100
+ #define CREAD		0000200
+ #define PARENB		0000400
+ #define PARODD		0001000
+ #define HUPCL		0002000
+ #define CLOCAL		0004000
+ 
+ #define BAUDMODE	0x00001000
+ #define CTSENABLE	0x00000800
+ #define RXENABLE	0x00000100
+ #define RUN		0x00000080
+ #define STOPBIT		0x00000008
+ #define MODE		0x00000001
+ #define MODE_7BIT_PAR	0x0003
+ #define MODE_8BIT_PAR	0x0007
+ #define MODE_8BIT	0x0001
+ #define STOP_1BIT	0x0008
+ #define PARITYODD	0x0020
+ 
+ #define STA_NKD		0x0400
+ #define STA_TF		0x0200
+ #define STA_RHF		0x0100
+ #define STA_TOI		0x0080
+ #define STA_TNE		0x0040
+ #define STA_OE		0x0020
+ #define STA_FE		0x0010
+ #define STA_PE		0x0008
+ #define	STA_THE		0x0004
+ #define STA_TE		0x0002
+ #define STA_RBF		0x0001
+ 
+ 
+ #define UART_BAUDRATE_OFFSET	0x00
+ #define UART_TXBUFFER_OFFSET	0x04
+ #define UART_RXBUFFER_OFFSET	0x08
+ #define UART_CONTROL_OFFSET	0x0C
+ #define UART_INTENABLE_OFFSET	0x10
+ #define UART_STATUS_OFFSET	0x14
+ #define UART_GUARDTIME_OFFSET	0x18
+ #define UART_TIMEOUT_OFFSET	0x1C
+ #define UART_TXRESET_OFFSET	0x20
+ #define UART_RXRESET_OFFSET	0x24
+ #define UART_RETRIES_OFFSET	0x28
+ 
+ #define CFG_STM_ASC3_BASE 0xb8033000ul
+ 
+ #define UART_BAUDRATE_REG	(CFG_STM_ASC3_BASE + UART_BAUDRATE_OFFSET)
+ #define UART_TXBUFFER_REG	(CFG_STM_ASC3_BASE + UART_TXBUFFER_OFFSET)
+ #define UART_RXBUFFER_REG	(CFG_STM_ASC3_BASE + UART_RXBUFFER_OFFSET)
+ #define UART_CONTROL_REG	(CFG_STM_ASC3_BASE + UART_CONTROL_OFFSET)
+ #define UART_INTENABLE_REG	(CFG_STM_ASC3_BASE + UART_INTENABLE_OFFSET)
+ #define UART_STATUS_REG		(CFG_STM_ASC3_BASE + UART_STATUS_OFFSET)
+ #define UART_GUARDTIME_REG	(CFG_STM_ASC3_BASE + UART_GUARDTIME_OFFSET)
+ #define UART_TIMEOUT_REG	(CFG_STM_ASC3_BASE + UART_TIMEOUT_OFFSET)
+ #define UART_TXRESET_REG	(CFG_STM_ASC3_BASE + UART_TXRESET_OFFSET)
+ #define UART_RXRESET_REG	(CFG_STM_ASC3_BASE + UART_RXRESET_OFFSET)
+ #define UART_RETRIES_REG	(CFG_STM_ASC3_BASE + UART_RETRIES_OFFSET)
+ 
+ 
+ /*---- Values for the BAUDRATE Register -----------------------*/
+ 
+ #if defined(__SH4__)
+ #define PCLK			(gd->bd->bi_emifrq*1000000)
+ #define BAUDRATE_VAL_M0(bps)	(PCLK / (16 * (bps)))
+ #define BAUDRATE_VAL_M1(bps)	((((bps * (1 << 14))+ (1<<13)) / (PCLK/(1 << 6))))
+ #else	/* !defined(__SH4__) */
+ #define PCLK			B_CLOCK_RATE
+ #define BAUDRATE_VAL_M0(bps)	(PCLK / (16 * (bps)))
+ #define BAUDRATE_VAL_M1(bps)	(int)((((double)bps * (1 << 20))/ PCLK)+0.5)
+ #endif	/* defined(__SH4__) */
+ 
+ /*
+  * MODE 0
+  *                       ICCLK
+  * ASCBaudRate =   ----------------
+  *                   baudrate * 16
+  *
+  * MODE 1
+  *                   baudrate * 16 * 2^16
+  * ASCBaudRate =   ------------------------
+  *                          ICCLK
+  *
+  * NOTE:
+  * Mode 1 should be used for baudrates of 19200, and above, as it
+  * has a lower deviation error than Mode 0 for higher frequencies.
+  * Mode 0 should be used for all baudrates below 19200.
+  */
+ 
+ 
+ #if defined(CONFIG_STM_ST231)
+ #define p2_outl(addr,b) writel(b,addr)
+ #define p2_inl(addr)    readl(addr)
+ #endif
+ 
+ 
+ #ifdef CONFIG_HWFLOW
+ static int hwflow = 0;		/* turned off by default */
+ #endif	/* CONFIG_HWFLOW */
+ 
+ 
+ /* busy wait until it is safe to send a char */
+ static inline void TxCharReady (void)
+ {
+ 	unsigned long status;
+ 
+ 	do {
+ 		status = p2_inl (UART_STATUS_REG);
+ 	} while (status & STA_TF);
+ }
+ 
+ /* initialize the ASC */
+ extern int fp_serial_init (void)
+ {
+ 	DECLARE_GLOBAL_DATA_PTR;
+ 	const int cflag = CREAD | HUPCL | CLOCAL | CSTOPB | CS8 | PARODD;
+ 	unsigned long val;
+ 	int t = BAUDRATE_VAL_M1(19200), mode=1;
+ 
+ 	/* wait for end of current transmission */
+ 	TxCharReady ();
+ 
+ 	/* disable the baudrate generator */
+ 	val = p2_inl (UART_CONTROL_REG);
+ 	p2_outl (UART_CONTROL_REG, (val & ~RUN));
+ 
+ 	/* set baud generator reload value */
+ 	p2_outl (UART_BAUDRATE_REG, t);
+ 
+ 	/* reset the RX & TX buffers */
+ 	p2_outl (UART_TXRESET_REG, 1);
+ 	p2_outl (UART_RXRESET_REG, 1);
+ 
+ 	/* build up the value to be written to CONTROL */
+ 	val = RXENABLE | RUN;
+ 
+ 	/* set character length */
+ 	if ((cflag & CSIZE) == CS7)
+ 		val |= MODE_7BIT_PAR;
+ 	else {
+ 		if (cflag & PARENB)
+ 			val |= MODE_8BIT_PAR;
+ 		else
+ 			val |= MODE_8BIT;
+ 	}
+ 
+ 	/* set stop bit */
+ 	/* it seems no '0 stop bits' option is available: by default
+ 	 * we get 0.5 stop bits */
+ 	if (cflag & CSTOPB)
+ 		val |= STOP_1BIT;
+ 
+ 	/* odd parity */
+ 	if (cflag & PARODD)
+ 		val |= PARITYODD;
+ 
+ #ifdef CONFIG_HWFLOW
+ 	/*  set flow control */
+ 	if (hwflow)
+ 		val |= CTSENABLE;
+ #endif	/* CONFIG_HWFLOW */
+ 
+ 	/* set baud generator mode */
+ 	if (mode)
+ 		val |= BAUDMODE;
+ 
+ 	/* finally, write value and enable ASC */
+ 	p2_outl (UART_CONTROL_REG, val);
+ 	return 0;
+ }
+ 
+ /* returns TRUE if a char is available, ready to be read */
+ extern int fp_serial_tstc (void)
+ {
+ 	unsigned long status;
+ 
+ 	status = p2_inl (UART_STATUS_REG);
+ 	return (status & STA_RBF);
+ }
+ 
+ /* blocking function, that returns next char */
+ extern int fp_serial_getc (void)
+ {
+ 	char ch;
+ 
+ 	/* polling wait: for a char to be read */
+ 	while (!fp_serial_tstc ());
+ 
+ 	/* read char, now that we know we have one */
+ 	ch = p2_inl (UART_RXBUFFER_REG);
+ 
+ 	/* return consumed char to the caller */
+ 	return ch;
+ }
+ 
+ /* send a character to FP  */
+ static inline void fp_serial_putc (char ch)
+ {
+ 	/* wait till safe to write next char */
+ 	TxCharReady ();
+ 
+ 	/* finally, write next char */
+ 	p2_outl (UART_TXBUFFER_REG, ch);
+ }
+ 
+ /* send a message to the FP  */
+ extern void fp_serial_tx_msg (char *data)
+ {
+ 	int i;
+ 
+ 	fp_serial_putc(0x02);
+ 	fp_serial_putc(data[0]);
+ 	for (i = 1; i <= (data[0] & 0x0f); i++)
+ 		fp_serial_putc (data[i]);
+ 	fp_serial_putc(0x03);
+ }
+ 
+ #ifdef CONFIG_HWFLOW
+ extern int hwflow_onoff (int on)
+ {
+ 	switch (on) {
+ 	case 0:
+ 	default:
+ 		break;		/* return current */
+ 	case 1:
+ 		hwflow = 1;	/* turn on */
+ 		fp_serial_init ();
+ 		break;
+ 	case -1:
+ 		hwflow = 0;	/* turn off */
+ 		fp_serial_init ();
+ 		break;
+ 	}
+ 	return hwflow;
+ }
+ #endif	/* CONFIG_HWFLOW */
+ 
+ #endif	/* CONFIG_STM_ASC_SERIAL */
diff -rcN u-boot-sh4-1.3.1_stm23_0043_orig/board/tf7700/init-tf7700.S u-boot-sh4-1.3.1_stm23_0043/board/tf7700/init-tf7700.S
*** u-boot-sh4-1.3.1_stm23_0043_orig/board/tf7700/init-tf7700.S	1970-01-01 01:00:00.000000000 +0100
--- u-boot-sh4-1.3.1_stm23_0043/board/tf7700/init-tf7700.S	2010-01-30 00:30:21.000000000 +0100
***************
*** 0 ****
--- 1,206 ----
+ 
+ #include "asm/stb7100reg.h"
+ #include "../../cpu/sh/init_ram.S"
+ 
+ /*
+  * The poke table is a series of long words, in the format
+  *
+  *       opcode, address, operand, ...
+  *
+  * An opcode of 0 marks the table end
+  */
+ 
+ .balign 32
+ 
+ __memory_setup_table:
+ 
+ 	/*
+ 	 * CLOCKGENA setup PLL0
+ 	 */
+ 
+ 	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+ 	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00100000)
+ 	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff7ffff, 0)
+ 	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x06 | (0x3b << 8) | (0x0 << 16))
+ 	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00080000)
+ 	WHILE_NE(STB7100_CLOCKGENA_PLL0_STATUS, 0x00000001, 0x00000001)
+ 	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+ 	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+ 
+ 	/*
+ 	 * CLOCKGENA setup PLL1
+ 	 */
+ 
+ 	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+ 	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000002)
+ 	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff7ffff, 0)
+ #if CONFIG_SH_STB7100_V1_1
+ 	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0x85 << 8) | (0x0 << 16))
+ #else
+ 	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x09 | (0x80 << 8) | (0x1 << 16)) /* 384MHz */
+ 	IF_DEVID(STB7100_CUT3) /* 400MHz */
+ 	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+ 	ENDIF
+ 	IF_DEVID(STB7109_CUT2) /* 400MHz */
+ 	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+ 	ENDIF
+ 	IF_DEVID(STB7109_CUT3) /* 400MHz */
+ 	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+ 	ENDIF
+ #endif
+ 	OR_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0x00080000)
+ 	WHILE_NE(STB7100_CLOCKGENA_PLL1_STATUS, 0x00000001, 0x00000001)
+ 	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000000)
+ 	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+ 
+ 	/*
+ 	 * SYSCONF setup
+ 	 */
+ 	IF_DEVID(STB7109_CUT1)
+ 	  POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x0807fec0)
+ 	ELSE
+ 	  POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x080780c0)
+ 	  WHILE_NE(STB7100_SYSCONF_SYS_STA12, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+ 	ENDIF
+ 	WHILE_NE(STB7100_SYSCONF_SYS_STA13, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+ 
+ 	POKE_LONG(STB7100_SYSCONF_SYS_CFG12, 0x4000000f | (0xf << 12) | (0xf << 23))
+ 	POKE_LONG(STB7100_SYSCONF_SYS_CFG13, 0x4000000f | (0xf << 12) | (0xf << 23))
+ 
+ #ifdef  CONFIG_SH_STB7100_V1_1
+ 	POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x5a << 20))
+ 	POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0xa9 << 20))
+ 	POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x5a << 20))
+ 	POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0xa9 << 20))
+ #else
+ 	IF_DEVID(STB7100_CUT1)
+ 	  POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x50 << 20))
+ 	  POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0x40 << 20))
+ 	  POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x50 << 20))
+ 	  POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0x40 << 20))
+ 	ENDIF
+ #endif
+ 	/*
+ 	 * LMI SYS setup
+ 	 */
+ #ifdef CONFIG_SH_STB7100_V1_1
+ 	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a0247)
+ 	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010000)
+ #else
+ 	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a0247)
+ 	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010022)
+ #endif
+ 	POKE_LONG(ST40_LMI_STR(SYS), 0x35b06455)
+ 
+ 	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x08001900)
+ 	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x08001900)
+ 
+ 	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+ 	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000003)
+ 	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+ 	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+ 	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000402)
+ 	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000133)
+ 
+ 	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+ 	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+ 	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+ 	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+ 	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000033)
+ 	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000000)
+ 
+ 	/*
+ 	 * LMI VID setup
+ 	 */
+ #ifdef CONFIG_SH_STB7100_V1_1
+ 	POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a0247)
+ 	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010000)
+ #else
+ 	POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a0247)
+ 	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010022)
+ #endif
+ 	POKE_LONG(ST40_LMI_STR(VID), 0x35b06455)
+ 	POKE_LONG(ST40_LMI_SDRA0(VID), 0x14001900)
+ 	POKE_LONG(ST40_LMI_SDRA1(VID), 0x14001900)
+ 	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+ 	POKE_LONG(ST40_LMI_SCR(VID), 0x00000003)
+ 	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+ 	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+ 	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000402)
+ 	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000133)
+ 	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+ 	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+ 	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+ 	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+ 	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000033)
+ 	POKE_LONG(ST40_LMI_SCR(VID), 0x00000000)
+ 
+ 	/*
+ 	 * EMI setup
+ 	 */
+ 	POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000005)
+ 	POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+ 	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000004)
+ 	POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x00000008)
+ 	POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x0000000a)
+ 	POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x0000000c)
+ 	/* FLASH */
+ 	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
+ 	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+ 	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+ 	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+ 	/* STEM Module */
+ 	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA0, 0x041086f1)
+ 	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA1, 0x0e024400)
+ 	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA2, 0x0e024400)
+ 	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000)
+ 	/* DVBCI */
+ 	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
+ 	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
+ 	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
+ 	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+ 	/* ATAPI */
+ #if defined(CONFIG_SH_STB7100_V1_1)
+ 	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00021791)
+ 	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x08004141)
+ 	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x08004141)
+ 	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
+ #else
+ 	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00021791)
+ 	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x0c006700)
+ 	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x0c006700)
+ 	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
+ #endif
+ 
+ 	/* EPLD & LAN91C111 */
+ 
+ 	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA0, 0x042086f1)
+ 	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA1, 0x88112111)
+ 	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA2, 0x88112211)
+ 	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)
+ 
+ 	/* Program other EMI registers */
+ 	IF_DEVID(STB7100_CUT1)
+ 	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+ 	ENDIF
+ 	IF_DEVID(STB7100_CUT2)
+ 	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+ 	ENDIF
+ 	IF_DEVID(STB7100_CUT3)
+ 	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+ 	ENDIF
+ 	IF_DEVID(STB7109_CUT1)
+ 	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+ 	ENDIF
+ 	IF_DEVID(STB7109_CUT2)
+ 	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+ 	ENDIF
+ 	IF_DEVID(STB7109_CUT3)
+ 	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+ 	ENDIF
+ 
+ 	END_MARKER
+ 
+ __memory_setup_table_end:
+ 
+ 	.end
diff -rcN u-boot-sh4-1.3.1_stm23_0043_orig/board/tf7700/Makefile u-boot-sh4-1.3.1_stm23_0043/board/tf7700/Makefile
*** u-boot-sh4-1.3.1_stm23_0043_orig/board/tf7700/Makefile	1970-01-01 01:00:00.000000000 +0100
--- u-boot-sh4-1.3.1_stm23_0043/board/tf7700/Makefile	2010-01-30 00:33:35.000000000 +0100
***************
*** 0 ****
--- 1,44 ----
+ #
+ # (C) Copyright 2003
+ # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ #
+ # See file CREDITS for list of people who contributed to this
+ # project.
+ #
+ # This program is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU General Public License as
+ # published by the Free Software Foundation; either version 2 of
+ # the License, or (at your option) any later version.
+ #
+ # This program is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ # GNU General Public License for more details.
+ #
+ # You should have received a copy of the GNU General Public License
+ # along with this program; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ # MA 02111-1307 USA
+ #
+ 
+ include $(TOPDIR)/config.mk
+ 
+ LIB	= lib$(BOARD).a
+ 
+ AOBJS	= init-$(BOARD).o
+ 
+ COBJS	= $(BOARD).o sconsole.o fp_port.o
+ 
+ OBJS	= $(COBJS) $(AOBJS)
+ 
+ $(LIB):	.depend $(OBJS)
+ 	$(AR) crv $@ $(OBJS)
+ 
+ #########################################################################
+ 
+ .depend:	Makefile $(AOBJS:.o=.S) $(COBJS:.o=.c)
+ 		$(CC) -M $(CFLAGS) $(AOBJS:.o=.S) $(COBJS:.o=.c) > $@
+ 
+ sinclude .depend
+ 
+ #########################################################################
diff -rcN u-boot-sh4-1.3.1_stm23_0043_orig/board/tf7700/sconsole.c u-boot-sh4-1.3.1_stm23_0043/board/tf7700/sconsole.c
*** u-boot-sh4-1.3.1_stm23_0043_orig/board/tf7700/sconsole.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-sh4-1.3.1_stm23_0043/board/tf7700/sconsole.c	2010-01-30 00:30:21.000000000 +0100
***************
*** 0 ****
--- 1,129 ----
+ /*
+  * (C) Copyright 2002
+  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+  *
+  * See file CREDITS for list of people who contributed to this
+  * project.
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License as
+  * published by the Free Software Foundation; either version 2 of
+  * the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+  * MA 02111-1307 USA
+  */
+ 
+ #include <config.h>
+ #include <common.h>
+ 
+ #include "sconsole.h"
+ 
+ #if 0
+ void (*sconsole_putc) (char) = 0;
+ void (*sconsole_puts) (const char *) = 0;
+ int (*sconsole_getc) (void) = 0;
+ int (*sconsole_tstc) (void) = 0;
+ void (*sconsole_setbrg) (void) = 0;
+ #endif
+ 
+ #if !defined(CONFIG_SH_SCIF_SERIAL) && !defined(CONFIG_STM_ASC_SERIAL)
+ int serial_init (void)
+ {
+ 	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+ 
+ 	sb->pos = 0;
+ 	sb->size = 0;
+ 	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
+ 
+ 	return (0);
+ }
+ 
+ void serial_putc (char c)
+ {
+ 	if (sconsole_putc) {
+ 		(*sconsole_putc) (c);
+ 	} else {
+ 		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+ 
+ 		if (c) {
+ 			sb->data[sb->pos++] = c;
+ 			if (sb->pos == sb->max_size) {
+ 				sb->pos = 0;
+ 			}
+ 			if (sb->size < sb->max_size) {
+ 				sb->size++;
+ 			}
+ 		}
+ 	}
+ }
+ 
+ void serial_puts (const char *s)
+ {
+ 	if (sconsole_puts) {
+ 		(*sconsole_puts) (s);
+ 	} else {
+ 		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+ 
+ 		while (*s) {
+ 			sb->data[sb->pos++] = *s++;
+ 			if (sb->pos == sb->max_size) {
+ 				sb->pos = 0;
+ 			}
+ 			if (sb->size < sb->max_size) {
+ 				sb->size++;
+ 			}
+ 		}
+ 	}
+ }
+ 
+ int serial_getc (void)
+ {
+ 	if (sconsole_getc) {
+ 		return (*sconsole_getc) ();
+ 	} else {
+ 		return 0;
+ 	}
+ }
+ 
+ int serial_tstc (void)
+ {
+ 	if (sconsole_tstc) {
+ 		return (*sconsole_tstc) ();
+ 	} else {
+ 		return 0;
+ 	}
+ }
+ 
+ void serial_setbrg (void)
+ {
+ 	if (sconsole_setbrg) {
+ 		(*sconsole_setbrg) ();
+ 	}
+ }
+ 
+ void sconsole_flush (void)
+ {
+ 	if (sconsole_putc) {
+ 		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+ 		unsigned int end = sb->pos < sb->size
+ 			? sb->pos + sb->max_size - sb->size
+ 			: sb->pos - sb->size;
+ 
+ 		while (sb->size) {
+ 			(*sconsole_putc) (sb->data[end++]);
+ 			if (end == sb->max_size) {
+ 				end = 0;
+ 			}
+ 			sb->size--;
+ 		}
+ 	}
+ }
+ #endif
diff -rcN u-boot-sh4-1.3.1_stm23_0043_orig/board/tf7700/sconsole.h u-boot-sh4-1.3.1_stm23_0043/board/tf7700/sconsole.h
*** u-boot-sh4-1.3.1_stm23_0043_orig/board/tf7700/sconsole.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-sh4-1.3.1_stm23_0043/board/tf7700/sconsole.h	2010-01-30 00:30:21.000000000 +0100
***************
*** 0 ****
--- 1,47 ----
+ /*
+  * (C) Copyright 2002
+  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+  *
+  * See file CREDITS for list of people who contributed to this
+  * project.
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License as
+  * published by the Free Software Foundation; either version 2 of
+  * the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+  * MA 02111-1307 USA
+  */
+ 
+ #ifndef _SCONSOLE_H_
+ #define _SCONSOLE_H_
+ 
+ #include <config.h>
+ 
+ typedef struct sconsole_buffer_s
+ {
+ 	unsigned long size;
+ 	unsigned long max_size;
+ 	unsigned long pos;
+ 	char data[1];
+ } sconsole_buffer_t;
+ 
+ #define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
+ 
+ extern void (*sconsole_putc) (char);
+ extern void (*sconsole_puts) (const char *);
+ extern int (*sconsole_getc) (void);
+ extern int (*sconsole_tstc) (void);
+ extern void (*sconsole_setbrg) (void);
+ 
+ extern void sconsole_flush (void);
+ 
+ #endif
diff -rcN u-boot-sh4-1.3.1_stm23_0043_orig/board/tf7700/tf7700.c u-boot-sh4-1.3.1_stm23_0043/board/tf7700/tf7700.c
*** u-boot-sh4-1.3.1_stm23_0043_orig/board/tf7700/tf7700.c	1970-01-01 01:00:00.000000000 +0100
--- u-boot-sh4-1.3.1_stm23_0043/board/tf7700/tf7700.c	2010-01-30 00:30:21.000000000 +0100
***************
*** 0 ****
--- 1,193 ----
+ /*
+  * (C) Copyright 2004 STMicroelectronics.
+  *
+  * Andy Sturges <andy.sturges@st.com>
+  *
+  * See file CREDITS for list of people who contributed to this
+  * project.
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License as
+  * published by the Free Software Foundation; either version 2 of
+  * the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+  * MA 02111-1307 USA
+  */
+ 
+ #include <common.h>
+ #include <command.h>
+ #include <asm/stb7100reg.h>
+ #include <asm/io.h>
+ #include <asm/pio.h>
+ 
+ #if defined CFG_JFFS_CUSTOM_PART
+ #include <jffs2/jffs2.h>
+ #endif
+ 
+ void stb7100_reset(void);
+ void stb7100_clocks(void);
+ 
+ #define EPLD_FLASH *(volatile unsigned char *)(0xa3400000)
+ #define EPLD_ATAPI *(volatile unsigned char *)(0xa3900000)
+ 
+ #define LED *(volatile unsigned char *)(0xa2000000 + 0x00100010)
+ 
+ #define ASC2_INTEN ((volatile unsigned int*)(0xb8032010))
+ #define ASC3_INTEN ((volatile unsigned int*)(0xb8033010))
+ 
+ void flashWriteEnable(void)
+ {
+   /*  Enable vpp for writing to flash */
+   EPLD_FLASH = 3;	/* bits: 0 = VPP ON; 1 = RESET	*/
+ }
+ 
+ void flashWriteDisable(void)
+ {
+   /*  Disable vpp for writing to flash */
+   EPLD_FLASH = 2;	/* bits: 0 = VPP ON; 1 = RESET	*/
+ }
+ 
+ #define PIO_BASE  0xb8020000
+ 
+ static void configPIO(void)
+ {
+   /*  Setup PIO of ASC device */
+   SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
+   SET_PIO_ASC(PIO_PORT(5), 0, 1, 2, 3);  /* UART3 - AS1 */
+   *ASC2_INTEN = *ASC2_INTEN & ~0x000001fe;
+   *ASC3_INTEN = *ASC3_INTEN & ~0x000001fe;
+ }
+ 
+ #if defined(CONFIG_CMD_IDE)
+ 
+ #ifdef CONFIG_SH_STB7100_IDE
+ static void stb7100mboard_init_ide(void)
+ {
+   EPLD_ATAPI = 1; /* Enable ATAPI mode of EMI */
+ }
+ #endif
+ 
+ #ifdef CONFIG_SH_STB7100_SATA
+ extern void stb7100_sata_init(void);
+ #endif
+ 
+ #endif
+ 
+ int board_init(void)
+ {
+ 	unsigned long sysconf;
+ 	/* Route UART2 instead of SCI to PIO4 */
+ 	/* Set ssc2_mux_sel = 0 */
+ 	sysconf = *STB7100_SYSCONF_SYS_CFG07;
+ 	sysconf &= ~(1<<3);
+ 	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
+ 
+ 	*(long*)0xb8000400 = 0;
+ 	*(long*)0xb8000404 = 0;
+ 	*(long*)0xb8000408 = 0;
+ 
+ 	configPIO();
+ 
+ #if defined(CONFIG_CMD_IDE)
+ #ifdef CONFIG_SH_STB7100_IDE
+ 	stb7100mboard_init_ide();
+ #endif
+ #ifdef CONFIG_SH_STB7100_SATA
+ 	stb7100_sata_init();
+ #endif
+ #endif
+ 
+ #if defined(CONFIG_STMAC_STE10XP)
+         SET_PIO_PIN(PIO_PORT(5), 3, STPIO_OUT);
+         STPIO_SET_PIN(PIO_PORT(5), 3, 0);
+         udelay(100000);
+         STPIO_SET_PIN(PIO_PORT(5), 3, 1);
+ #endif
+ 
+         SET_PIO_PIN(PIO_PORT(5), 7, STPIO_OUT);
+         STPIO_SET_PIN(PIO_PORT(5), 7, 0);
+ 
+ 	return 0;
+ }
+ 
+ int checkboard (void)
+ {
+ 	printf ("\n\nBoard: TF7700"
+ #ifdef CONFIG_SH_SE_MODE
+ 		"  [32-bit mode]"
+ #else
+ 		"  [29-bit mode]"
+ #endif
+ 		"\n");
+ 
+ 	LED = 0;
+ 
+ 	return 0;
+ }
+ 
+ #if defined CFG_JFFS_CUSTOM_PART
+ 
+ /*
+  * jffs2_part_info - get information about a JFFS2 partition
+  *
+  * @part_num: number of the partition you want to get info about
+  * @return:   struct part_info* in case of success, 0 if failure
+  *
+  * Reads env variable jff2part for partition info
+  *
+  */
+ 
+ static struct part_info part;
+ static int current_part = -1;
+ 
+ struct part_info* jffs2_part_info(int part_num) {
+ 	void *jffs2_priv_saved = part.jffs2_priv;
+ 
+ 	printf("jffs2_part_info: part_num=%i\n",part_num);
+ 
+ 	if (current_part == part_num)
+ 		return &part;
+ 
+ 	/* u-boot partition                                                 */
+ 	if(part_num==0){
+ 		ulong offset, size=0;
+ 		char *f;
+ 
+ 		if ((f=getenv("jffs2part"))) {
+ 			char *p;
+ 			offset = simple_strtoul(f, &p, 16);
+ 			size   = simple_strtoul(p+1, NULL, 16);
+ 		}
+ 
+ 		if (size) {
+ 			memset(&part, 0, sizeof(part));
+ 
+ 			part.offset=offset;
+ 			part.size=size;
+ 
+ 			/* Mark the struct as ready */
+ 			current_part = part_num;
+ 
+ 			printf("part.offset = 0x%08x\n",(unsigned int)part.offset);
+ 			printf("part.size   = 0x%08x\n",(unsigned int)part.size);
+ 		}
+ 	}
+ 
+ 	if (current_part == part_num) {
+ /*QQQ-HACK:	part.usr_priv = &current_part;	*/
+ 		part.jffs2_priv = jffs2_priv_saved;
+ 		return &part;
+ 	}
+ 
+ 	printf("jffs2_part_info: end of partition table\n");
+ 	return 0;
+ }
+ #endif
diff -rcN u-boot-sh4-1.3.1_stm23_0043_orig/board/tf7700/u-boot.lds u-boot-sh4-1.3.1_stm23_0043/board/tf7700/u-boot.lds
*** u-boot-sh4-1.3.1_stm23_0043_orig/board/tf7700/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
--- u-boot-sh4-1.3.1_stm23_0043/board/tf7700/u-boot.lds	2010-01-30 00:30:21.000000000 +0100
***************
*** 0 ****
--- 1,68 ----
+ /*
+  * (C) Copyright 2004 STMicroelectronics.
+  *
+  * Andy Sturges <andy.sturges@st.com>
+  *
+  * See file CREDITS for list of people who contributed to this
+  * project.
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License as
+  * published by the Free Software Foundation; either version 2 of
+  * the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+  * MA 02111-1307 USA
+  */
+ 
+ OUTPUT_ARCH(sh4)
+ ENTRY(_start)
+ 
+ SECTIONS
+ {
+ 	.text ALIGN(0x4):
+ 	{
+ 		__text_start = .;
+ 		cpu/sh/start.o (.text)
+ 		*(.text)
+ 		__text_end = .;
+ 	}
+ 
+ 	.rodata ALIGN(0x4):
+ 	{
+ 		__rodata_start = .;
+ 		*(.rodata)
+ 		__rodata_end = .;
+ 	}
+ 
+ 	.data ALIGN(0x4):
+ 	{
+ 		__data_start = .;
+ 		*(.data)
+ 		__data_end = .;
+ 	}
+ 
+ 	.u_boot_cmd ALIGN(0x4):
+ 	{
+ 		__u_boot_cmd_start = .;
+ 		*(.u_boot_cmd)
+ 		__u_boot_cmd_end = .;
+ 	}
+ 
+ 	_uboot_end_data = .;
+ 
+ 	.bss ALIGN(0x4):
+ 	{
+ 		__bss_start = .;
+ 		*(.bss)
+ 		__bss_end = .;
+ 	}
+ 	_uboot_end = .;
+ }
diff -rcN u-boot-sh4-1.3.1_stm23_0043_orig/common/cmd_nvedit.c u-boot-sh4-1.3.1_stm23_0043/common/cmd_nvedit.c
*** u-boot-sh4-1.3.1_stm23_0043_orig/common/cmd_nvedit.c	2007-12-06 10:21:19.000000000 +0100
--- u-boot-sh4-1.3.1_stm23_0043/common/cmd_nvedit.c	2010-01-30 00:30:21.000000000 +0100
***************
*** 552,557 ****
--- 552,564 ----
  	return (-1);
  }
  
+ #if defined(CFG_ENV_IS_NOWHERE)
+ int saveenv()
+ {
+ 	return 0;
+ }
+ #endif
+ 
  #if defined(CFG_ENV_IS_IN_NVRAM) || defined(CFG_ENV_IS_IN_EEPROM) \
      || (defined(CONFIG_CMD_ENV) && defined(CONFIG_CMD_FLASH)) \
      || (defined(CONFIG_CMD_ENV) && defined(CONFIG_CMD_NAND)) \
***************
*** 560,568 ****
--- 567,580 ----
  {
  	extern char * env_name_spec;
  
+ #if defined(CFG_ENV_IS_NOWHERE)
+ 	printf ("No environment storage defined\n");
+ 	return 0;
+ #else
  	printf ("Saving Environment to %s...\n", env_name_spec);
  
  	return (saveenv() ? 1 : 0);
+ #endif
  }
  
  #endif
diff -rcN u-boot-sh4-1.3.1_stm23_0043_orig/common/cmd_usb.c u-boot-sh4-1.3.1_stm23_0043/common/cmd_usb.c
*** u-boot-sh4-1.3.1_stm23_0043_orig/common/cmd_usb.c	2010-01-27 21:46:31.000000000 +0100
--- u-boot-sh4-1.3.1_stm23_0043/common/cmd_usb.c	2010-01-30 00:30:21.000000000 +0100
***************
*** 450,455 ****
--- 450,460 ----
  #ifdef CONFIG_USB_STORAGE
  	block_dev_desc_t *stor_dev;
  #endif
+ 	if(argc < 2)
+ 	{
+ 		printf ("Usage:\n%s\n", cmdtp->usage);
+ 		return 1;
+ 	}
  
  	if ((strncmp(argv[1], "reset", 5) == 0) ||
  		 (strncmp(argv[1], "start", 5) == 0)){
diff -rcN u-boot-sh4-1.3.1_stm23_0043_orig/cpu/sh/start.S u-boot-sh4-1.3.1_stm23_0043/cpu/sh/start.S
*** u-boot-sh4-1.3.1_stm23_0043_orig/cpu/sh/start.S	2010-01-27 21:46:32.000000000 +0100
--- u-boot-sh4-1.3.1_stm23_0043/cpu/sh/start.S	2010-01-30 00:30:21.000000000 +0100
***************
*** 54,59 ****
--- 54,94 ----
  	nop
  	nop
  
+ #ifdef CONFIG_SH_TF7700
+ 	/* There is no need for memory initialization when running on
+ 	   a TF7700 because everything has been done by the primary
+ 	   bootloader. The cache operations used for evaluation
+ 	   boards lead to undesired side effects so that all cache
+ 	   operations have been removed from TF7700 code.
+ 	   U-Boot is started in 32-bit mode in the P1 region.
+ 
+ 	   Relocation is required if TEXT_BASE deviates from the load
+ 	   address.
+ 	*/
+ 
+ 	/*
+ 	 * Determine if we are in the correct location ? (i.e. RAM)
+ 	 *  r8 == 1 in RAM, assume initialization already done by GDB.
+ 	 *  r8 == 0 in FLASH, need to relocate, set up memory, etc...
+ 	 *  r9 == where we actualy ARE       (PIC relocate source).
+ 	 * r10 == were we WANT to be [BEGIN] (PIC relocate target).
+ 	 * r11 == were we WANT to be [END]   (PIC relocate target).
+ 	 */
+ 	mova    _start_offset, r0       /* Load source address in r9 */
+ 	mov     r0, r9                  /* i.e. where we actualy ARE */
+ 	mov.l   @r9, r10
+ 	sub     r10, r9
+ 	mov.l   target_addr, r10        /* Load target address in r10 */
+ 					/* i.e. were we WANT to be */
+ 	mov.l   bss_start, r11          /* load target END address in r11 */
+ 	cmp/eq  r9, r10                 /* Are we in correct place already ? */
+ 	movt    r8                      /* save SR.T in r8. */
+ 
+ 	cmp/pl  r8                      /* Are we in correct place already ? */
+ 	bt      hyperspace
+ 
+ #else /* !CONFIG_SH_TF7700 */
+ 
  	/* Set SR:	MD=1, RB=0, BL=0, FD=0, IMASK=0xF */
  set_sr:
  	MOV_CONST32_R0 0x400000F0
***************
*** 338,343 ****
--- 373,380 ----
  .balign 4
  #endif	/* CONFIG_SH_SE_MODE */
  
+ #endif /* CONFIG_SH_TF7700 */
+ 
  	/*
  	 * relocate code: r1=source, r2=dest, r3=dest_end
  	 * QQQ: in 32-bit mode, "dest" is UN-cached - should optimize this.
diff -rcN u-boot-sh4-1.3.1_stm23_0043_orig/cpu/sh/stb7100/stb7100.c u-boot-sh4-1.3.1_stm23_0043/cpu/sh/stb7100/stb7100.c
*** u-boot-sh4-1.3.1_stm23_0043_orig/cpu/sh/stb7100/stb7100.c	2010-01-27 21:46:31.000000000 +0100
--- u-boot-sh4-1.3.1_stm23_0043/cpu/sh/stb7100/stb7100.c	2010-01-30 00:30:21.000000000 +0100
***************
*** 264,269 ****
--- 264,270 ----
  	return;
  }
  
+ #ifdef CONFIG_SH_STB7100_IDE
  extern ulong ide_bus_offset[CFG_IDE_MAXBUS];
  
  	/*
***************
*** 299,304 ****
--- 300,306 ----
  	else
  	  return readl(ATA_CURR_BASE(dev)+port);
  }
+ #endif
  
  #endif /* defined(CONFIG_SH_STB7100_SATA) */
  
***************
*** 352,358 ****
  	 */
  	/* Setup PIO for USB power */
  	SET_PIO_PIN(PIO_PORT(5), 7, STPIO_OUT);
! 	STPIO_SET_PIN(PIO_PORT(5), 7, 1);
  
  	/* Make sure PLL is on */
  #define SYS_CFG2_PLL_POWER_DOWN_BIT	1
--- 354,360 ----
  	 */
  	/* Setup PIO for USB power */
  	SET_PIO_PIN(PIO_PORT(5), 7, STPIO_OUT);
! 	STPIO_SET_PIN(PIO_PORT(5), 7, 0);
  
  	/* Make sure PLL is on */
  #define SYS_CFG2_PLL_POWER_DOWN_BIT	1
***************
*** 365,371 ****
  	}
  
  	/* Set strap mode */
! #define STRAP_MODE	AHB2STBUS_STRAP_16_BIT
  	reg = readl(AHB2STBUS_STRAP);
  #if STRAP_MODE == 0
  	reg &= ~AHB2STBUS_STRAP_16_BIT;
--- 367,373 ----
  	}
  
  	/* Set strap mode */
! #define STRAP_MODE	0 //AHB2STBUS_STRAP_16_BIT
  	reg = readl(AHB2STBUS_STRAP);
  #if STRAP_MODE == 0
  	reg &= ~AHB2STBUS_STRAP_16_BIT;
diff -rcN u-boot-sh4-1.3.1_stm23_0043_orig/drivers/mtd/cfi_flash.c u-boot-sh4-1.3.1_stm23_0043/drivers/mtd/cfi_flash.c
*** u-boot-sh4-1.3.1_stm23_0043_orig/drivers/mtd/cfi_flash.c	2010-01-27 21:46:32.000000000 +0100
--- u-boot-sh4-1.3.1_stm23_0043/drivers/mtd/cfi_flash.c	2010-01-30 00:30:21.000000000 +0100
***************
*** 398,403 ****
--- 398,408 ----
  
  	/* Monitor protection ON by default */
  #if (CFG_MONITOR_BASE >= CFG_FLASH_BASE)
+ 	/* protect the Topfield bootloader */
+ 	flash_protect (FLAG_PROTECT_SET,
+ 		       CFG_FLASH_BASE,
+ 		       CFG_MONITOR_BASE - 1,
+ 		       flash_get_info(CFG_FLASH_BASE));
  	flash_protect (FLAG_PROTECT_SET,
  		       CFG_MONITOR_BASE,
  		       CFG_MONITOR_BASE + monitor_flash_len  - 1,
diff -rcN u-boot-sh4-1.3.1_stm23_0043_orig/drivers/usb/usb_ohci.c u-boot-sh4-1.3.1_stm23_0043/drivers/usb/usb_ohci.c
*** u-boot-sh4-1.3.1_stm23_0043_orig/drivers/usb/usb_ohci.c	2010-01-27 21:46:31.000000000 +0100
--- u-boot-sh4-1.3.1_stm23_0043/drivers/usb/usb_ohci.c	2010-01-30 00:30:21.000000000 +0100
***************
*** 89,94 ****
--- 89,95 ----
  	((__u32)(addr) ? ((0x1ffffffful&(__u32)(addr))|0x40000000ul) : 0ul)
  #else
  #	define PHYSICAL_ADDR(addr)	( 0x1ffffffful & (__u32)(addr) )
+ #	define VIRTUAL_ADDR(addr)       ( 0x80000000ul | (__u32)(addr) )
  #endif	/* CONFIG_SH_SE_MODE */
  #else	/* __SH4__ */
  #	define PHYSICAL_ADDR(addr)	(addr)
***************
*** 871,877 ****
  	td_pt->hwNextTD = 0;
  
  	/* fill the old dummy TD */
! 	td = urb_priv->td [index] = (td_t *)(m32_swap (urb_priv->ed->hwTailP) & ~0xf);
  
  	td->ed = urb_priv->ed;
  	td->next_dl_td = NULL;
--- 872,878 ----
  	td_pt->hwNextTD = 0;
  
  	/* fill the old dummy TD */
! 	td = urb_priv->td [index] = (td_t *)VIRTUAL_ADDR(m32_swap (urb_priv->ed->hwTailP) & ~0xf);
  
  	td->ed = urb_priv->ed;
  	td->next_dl_td = NULL;
***************
*** 1034,1040 ****
  	ohci->hcca->done_head = 0;
  
  	while (td_list_hc) {
! 		td_list = (td_t *)td_list_hc;
  
  		if (TD_CC_GET (m32_swap (td_list->hwINFO))) {
  			lurb_priv = td_list->ed->purb;
--- 1035,1041 ----
  	ohci->hcca->done_head = 0;
  
  	while (td_list_hc) {
! 		td_list = (td_t *)VIRTUAL_ADDR(td_list_hc);
  
  		if (TD_CC_GET (m32_swap (td_list->hwINFO))) {
  			lurb_priv = td_list->ed->purb;
diff -rcN u-boot-sh4-1.3.1_stm23_0043_orig/fs/fat/fat.c u-boot-sh4-1.3.1_stm23_0043/fs/fat/fat.c
*** u-boot-sh4-1.3.1_stm23_0043_orig/fs/fat/fat.c	2007-12-06 10:21:19.000000000 +0100
--- u-boot-sh4-1.3.1_stm23_0043/fs/fat/fat.c	2010-01-30 00:30:21.000000000 +0100
***************
*** 31,36 ****
--- 31,39 ----
  #include <asm/byteorder.h>
  #include <part.h>
  
+ #define CHECK_CLUST(x, fatsize) ((x) <= 1 || \
+ 				(x) >= ((fatsize) != 32 ? 0xfff0 : 0xffffff0))
+ 
  #if defined(CONFIG_CMD_FAT)
  
  /*
***************
*** 357,363 ****
  			newclust = get_fatent(mydata, endclust);
  			if((newclust -1)!=endclust)
  				goto getit;
! 			if (newclust <= 0x0001 || newclust >= 0xfff0) {
  				FAT_DPRINT("curclust: 0x%x\n", newclust);
  				FAT_DPRINT("Invalid FAT entry\n");
  				return gotsize;
--- 360,366 ----
  			newclust = get_fatent(mydata, endclust);
  			if((newclust -1)!=endclust)
  				goto getit;
! 			if (CHECK_CLUST(newclust, mydata->fatsize)) {
  				FAT_DPRINT("curclust: 0x%x\n", newclust);
  				FAT_DPRINT("Invalid FAT entry\n");
  				return gotsize;
***************
*** 392,398 ****
  		filesize -= actsize;
  		buffer += actsize;
  		curclust = get_fatent(mydata, endclust);
! 		if (curclust <= 0x0001 || curclust >= 0xfff0) {
  			FAT_DPRINT("curclust: 0x%x\n", curclust);
  			FAT_ERROR("Invalid FAT entry\n");
  			return gotsize;
--- 395,401 ----
  		filesize -= actsize;
  		buffer += actsize;
  		curclust = get_fatent(mydata, endclust);
! 		if (CHECK_CLUST(curclust, mydata->fatsize)) {
  			FAT_DPRINT("curclust: 0x%x\n", curclust);
  			FAT_ERROR("Invalid FAT entry\n");
  			return gotsize;
***************
*** 464,470 ****
  
  		slotptr--;
  		curclust = get_fatent(mydata, curclust);
! 		if (curclust <= 0x0001 || curclust >= 0xfff0) {
  			FAT_DPRINT("curclust: 0x%x\n", curclust);
  			FAT_ERROR("Invalid FAT entry\n");
  			return -1;
--- 467,473 ----
  
  		slotptr--;
  		curclust = get_fatent(mydata, curclust);
! 		if (CHECK_CLUST(curclust, mydata->fatsize)) {
  			FAT_DPRINT("curclust: 0x%x\n", curclust);
  			FAT_ERROR("Invalid FAT entry\n");
  			return -1;
***************
*** 657,663 ****
  	    return retdent;
  	}
  	curclust = get_fatent (mydata, curclust);
! 	if (curclust <= 0x0001 || curclust >= 0xfff0) {
  	    FAT_DPRINT ("curclust: 0x%x\n", curclust);
  	    FAT_ERROR ("Invalid FAT entry\n");
  	    return NULL;
--- 660,666 ----
  	    return retdent;
  	}
  	curclust = get_fatent (mydata, curclust);
! 	if (CHECK_CLUST(curclust, mydata->fatsize)) {
  	    FAT_DPRINT ("curclust: 0x%x\n", curclust);
  	    FAT_ERROR ("Invalid FAT entry\n");
  	    return NULL;
diff -rcN u-boot-sh4-1.3.1_stm23_0043_orig/include/configs/tf7700.h u-boot-sh4-1.3.1_stm23_0043/include/configs/tf7700.h
*** u-boot-sh4-1.3.1_stm23_0043_orig/include/configs/tf7700.h	1970-01-01 01:00:00.000000000 +0100
--- u-boot-sh4-1.3.1_stm23_0043/include/configs/tf7700.h	2010-01-30 00:30:21.000000000 +0100
***************
*** 0 ****
--- 1,275 ----
+ /*
+  * (C) Copyright 2004 STMicroelectronics.
+  *
+  * Andy Sturges <andy.sturges@st.com>
+  *
+  * See file CREDITS for list of people who contributed to this
+  * project.
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License as
+  * published by the Free Software Foundation; either version 2 of
+  * the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+  * MA 02111-1307 USA
+  */
+ 
+ #ifndef __CONFIG_H
+ #define __CONFIG_H
+ 
+ /*
+  * High Level Configuration Options
+  * (easy to change)
+  */
+ 
+ #define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+ #define CONFIG_CPU_SUBTYPE_SH4_2XX	/* its an SH4-202		*/
+ 
+ #define INPUT_CLOCK_RATE 27
+ 
+ #define P_CLOCK_RATE	66000000	/* clock rate for CSP		*/
+ 
+ /*-----------------------------------------------------------------------
+  * Start addresses for the final memory configuration
+  * Assume we run out of uncached memory for the moment
+  */
+ 
+ #define CONFIG_SH_TF7700
+ #undef CONFIG_SH_SE_MODE
+ 
+ #ifdef CONFIG_SH_SE_MODE
+ #define CFG_FLASH_BASE          0xA0000000      /* FLASH (uncached) via PMB */
+ #define CFG_SDRAM_BASE          0x80000000      /* LMI-Sys via PMB */
+ #define CFG_SE_PHYSICAL_BASE    0x40000000      /* LMI-Sys Physical Address */
+ #define CFG_SE_UNACHED_BASE     0x90000000      /* LMI-Sys un-cached addr via PMB */
+ #define CFG_SE_SDRAM_WINDOW     (CFG_SDRAM_SIZE-1)
+ #else
+ #define CFG_FLASH_BASE          0xA0000000      /* FLASH in P2 region */
+ #define CFG_SDRAM_BASE          0x84000000      /* SDRAM in P1 region */
+ #endif
+ 
+ #define CFG_SDRAM_SIZE		0x08000000
+ #define CFG_RESET_ADDRESS	0xA0000000
+ 
+ #define CFG_MONITOR_LEN		0x00020000	/* Reserve 128 kB for Monitor */
+ #define CFG_MONITOR_BASE        0xa0030000
+ #define CFG_MALLOC_LEN		(4 << 20)	/* Reserve 2MB kB for malloc */
+ #define CFG_BOOTPARAMS_LEN	(64 << 10)
+ #define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+ 
+ #define CFG_MEMTEST_START	CFG_SDRAM_BASE
+ #define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (2 << 20))
+ 
+ #define CONFIG_BAUDRATE		115200
+ #define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+ 
+ #define CFG_LOAD_ADDR		0x85000000	/* default load address */
+ 
+ #define XSTR(s) STR(s)
+ #define STR(s) #s
+ 
+ #define BOARD tf7700
+ 
+ #if CFG_MONITOR_LEN == 0x00020000		/* 128 kB */
+ #	define MONITOR_SECTORS	"1:10-11"	/* 2 sectors */
+ #else						/* unknown */
+ #	error "Unable to determine sectors for monitor"
+ #endif
+ 
+ #define CONFIG_EXTRA_ENV_SETTINGS \
+ 		"board=" XSTR(BOARD) "\0" \
+ 		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+ 		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+ 		"monitor_sec=" MONITOR_SECTORS "\0" \
+ 		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+ 		"unprot=" \
+ 		  "protect off $monitor_sec\0" \
+ 		"update=" \
+ 		  "erase $monitor_sec;" \
+ 		  "cp.b $load_addr $monitor_base $monitor_len;" \
+ 		  "protect on $monitor_sec\0" \
+ 		"bootcmd=" \
+ 		  "usb reset;fatload usb 0 85000000 uImage;bootm\0" \
+ 		"bootargs=console=ttyAS0,115200 root=dev/ram0\0"
+ 
+ /*--------------------------------------------------------------
+  * Command line configuration.
+  */
+ 
+ #include <config_cmd_default.h>
+ 
+ #define CONFIG_CMD_ASKENV
+ #define CONFIG_CMD_FLASH
+ #define CONFIG_CMD_NFS
+ #define CONFIG_CMD_PING
+ 
+ //#define CONFIG_CMD_DHCP
+ #define CONFIG_CMD_IDE
+ //#define CONFIG_CMD_JFFS2
+ 
+ /*--------------------------------------------------------------
+  * Serial console info
+  */
+ 
+ #define CONFIG_STM_ASC_SERIAL	1
+ 
+ #define CONFIG_CONS_INDEX	0
+ 
+ #if (CONFIG_CONS_INDEX == 0)
+ #define CFG_STM_ASC_BASE	0xb8032000ul	/* UART2 */
+ #else
+ #define CFG_STM_ASC_BASE	0xb8033000ul	/* UART3 */
+ #endif
+ 
+ /*---------------------------------------------------------------
+  * Ethernet driver config
+  */
+ 
+ /* Config for on-chip STMAC + STE10xP PHY */
+ #define CONFIG_DRIVER_NETSTMAC
+ #define CFG_STM_STMAC_BASE		0xb8110000ul
+ #define CONFIG_STMAC_STE10XP
+ #define CONFIG_CMD_MII
+ 
+ /* default IP configuration */
+ #define CONFIG_ETHADDR 00:3e:9e:11:22:33
+ #define CONFIG_IPADDR 192.168.178.100
+ #define CONFIG_SERVERIP 192.168.178.10
+ 
+ /*  If this board does not have eeprom for ethernet address so allow the user
+  *  to set it in the environment
+  */
+ 
+ #define CONFIG_ENV_OVERWRITE
+ 
+ 
+ /*---------------------------------------------------------------
+  * USB driver config
+  */
+ 
+ /* Choose if we want USB Mass-Storage Support */
+ #define CONFIG_SH_STB7100_USB
+ 
+ #ifdef CONFIG_SH_STB7100_USB
+ #	define CONFIG_CMD_USB
+ #	define CONFIG_CMD_FAT
+ #	define CONFIG_USB_OHCI_NEW
+ #	define CONFIG_USB_STORAGE
+ #	define CFG_USB_OHCI_CPU_INIT
+ #	define CFG_USB_BASE			0xb9100000
+ #	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+ #	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+ #	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+ #	define LITTLEENDIAN
+ #endif	/* ifdef CONFIG_SH_STB7100_USB */
+ 
+ /*---------------------------------------------------------------
+  * IDE driver config
+  */
+ 
+ /* Choose one of the the following two: */
+ //#define CONFIG_SH_STB7100_IDE
+ #define CONFIG_SH_STB7100_SATA
+ 
+ #ifdef CONFIG_SH_STB7100_IDE
+ #	define CFG_PIO_MODE		4
+ #	define CFG_IDE_MAXBUS		1
+ #	define CFG_IDE_MAXDEVICE	1
+ #	define CFG_ATA_BASE_ADDR	0xA2800000
+ #	define CFG_ATA_IDE0_OFFSET	0x00200000
+ #	define CFG_ATA_REG_OFFSET	0
+ #	define CFG_ATA_DATA_OFFSET	0
+ #	define CFG_ATA_STRIDE		0x00020000
+ #	define CFG_ATA_ALT_OFFSET	-0x0100000
+ #endif	/* CONFIG_SH_STB7100_IDE */
+ 
+ #ifdef CONFIG_SH_STB7100_SATA
+ #	define CFG_PIO_MODE		4
+ #	define CFG_IDE_MAXBUS		1
+ #	define CFG_IDE_MAXDEVICE	1
+ #	define CFG_ATA_BASE_ADDR	0xB9209800
+ #	define CFG_ATA_IDE0_OFFSET	0x0
+ #	define CFG_ATA_REG_OFFSET	0x0
+ #	define CFG_ATA_DATA_OFFSET	0x0
+ #	define CFG_ATA_STRIDE		0x4
+ #	define CFG_ATA_ALT_OFFSET	0x8
+ #endif	/* CONFIG_SH_STB7100_SATA */
+ 
+ #if defined(CONFIG_SH_STB7100_IDE)  ||	\
+     defined(CONFIG_SH_STB7100_SATA) ||	\
+     defined(CONFIG_SH_STB7100_USB)
+ #	define CFG_64BIT_LBA
+ #	define CONFIG_LBA48
+ #	define CONFIG_CMD_EXT2
+ #endif
+ #	define CONFIG_DOS_PARTITION
+ 
+ /*----------------------------------------------------------------------
+  * jffs2 support
+  */
+ 
+ #if defined(CONFIG_CMD_JFFS2)
+ 
+ #define CFG_JFFS_CUSTOM_PART
+ #define CFG_JFFS_SINGLE_PART	1
+ 
+ #define CFG_JFFS2_FIRST_SECTOR 18  /* u-boot, env, kernel  */
+ #define CFG_JFFS2_FIRST_BANK 0
+ #define CFG_JFFS2_NUM_BANKS 1
+ 
+ #endif
+ 
+ /*-----------------------------------------------------------------------
+  * Miscellaneous configurable options
+  */
+ 
+ #define CFG_HUSH_PARSER		1
+ #define CFG_LONGHELP		1		/* undef to save memory		*/
+ #define CFG_PROMPT		"TF7700> "	/* Monitor Command Prompt	*/
+ #define CFG_PROMPT_HUSH_PS2	"> "
+ #define CFG_CBSIZE		1024
+ #define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+ #define CFG_BARGSIZE		CFG_CBSIZE	/* Boot Argument Buffer Size */
+ #define CFG_MAXARGS		16		/* max number of command args	*/
+ #define CFG_HZ			(P_CLOCK_RATE/1024)		/* HZ for timer ticks		*/
+ #define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+ #define CONFIG_BOOTDELAY	1		/* default delay before executing bootcmd */
+ #define CONFIG_ZERO_BOOTDELAY_CHECK
+ 
+ #define CONFIG_AUTO_COMPLETE
+ #define CONFIG_CMDLINE_EDITING
+ 
+ /*-----------------------------------------------------------------------
+  * FLASH organization
+  */
+ 
+ /* STb7100 Mboard organised as 8MB flash with 128k blocks */
+ #define CFG_FLASH_CFI_DRIVER
+ #define CFG_FLASH_CFI
+ //#define CFG_FLASH_PROTECTION	1	/* use hardware flash protection */
+ #define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks	 */
+ #define CFG_MAX_FLASH_SECT	256	/* max number of sectors on one chip */
+ #define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty  */
+ 
+ 
+ /*-----------------------------------------------------------------------
+  * NVRAM organization
+  */
+ 
+ /* Address and size of Primary Environment Sector       */
+ 
+ #define CFG_ENV_IS_IN_FLASH     1
+ #define CFG_ENV_OFFSET          0x50000
+ #define CFG_ENV_ADDR            (CFG_FLASH_BASE + CFG_ENV_OFFSET)
+ #define CFG_ENV_SIZE            0x10000
+ #define CFG_ENV_SECT_SIZE       0x10000
+ 
+ #endif	/* __CONFIG_H */
diff -rcN u-boot-sh4-1.3.1_stm23_0043_orig/lib_sh/board.c u-boot-sh4-1.3.1_stm23_0043/lib_sh/board.c
*** u-boot-sh4-1.3.1_stm23_0043_orig/lib_sh/board.c	2010-01-27 21:46:32.000000000 +0100
--- u-boot-sh4-1.3.1_stm23_0043/lib_sh/board.c	2010-01-30 00:40:51.000000000 +0100
***************
*** 116,121 ****
--- 116,129 ----
  	return (0);
  }
  
+ static int reset_term (void)
+ {
+ 	/* perform a soft reset of VT to avoid displaying garbage for
+ 	   for lower-case characters */
+ 	puts("\033[!p");
+ 	return 0;
+ }
+ 
  static int display_banner (void)
  {
  
***************
*** 146,151 ****
--- 154,178 ----
  	return (0);
  }
  
+ extern int fp_serial_init(void);
+ extern void fp_serial_tx_msg(char *data);
+ static int display_uboot_on_vfd(void)
+ {
+ 	int i;
+ 	/* FP messages to display "U-BOOT" on VFD */
+ 	char data[][10] = {{0x99, 0x10, 0x00, 0x14, 0x50, 0xbd, 0x01, 0x50, 0x08, 0x02},
+ 			   {0x99, 0x18, 0x00, 0xa8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+ 			   {0x99, 0x20, 0x00, 0x2a, 0x80, 0x02, 0x80, 0x0f, 0xf0, 0x00},
+ 			   {0x99, 0x28, 0xf0, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
+ 
+ 	fp_serial_init();
+ 
+ 	for(i = 0; i < sizeof(data)/sizeof(data[0]); i++)
+ 		fp_serial_tx_msg(data[i]);
+ 
+ 	return 0;
+ }
+ 
  void flashWriteEnable(void);
  
  /*
***************
*** 169,176 ****
--- 196,205 ----
  	env_init,		/* initialize environment */
  	init_baudrate,		/* initialze baudrate settings */
  	serial_init,		/* serial communications setup */
+ 	reset_term,             /* soft-reset VT terminal */
  	console_init_f,		/* Initial console             */
  	checkboard,
+ 	display_uboot_on_vfd,
  	display_banner,		/* say that we are here */
  	init_func_ram,
  	NULL,
diff -rcN u-boot-sh4-1.3.1_stm23_0043_orig/lib_sh/sh_linux.c u-boot-sh4-1.3.1_stm23_0043/lib_sh/sh_linux.c
*** u-boot-sh4-1.3.1_stm23_0043_orig/lib_sh/sh_linux.c	2010-01-27 21:46:31.000000000 +0100
--- u-boot-sh4-1.3.1_stm23_0043/lib_sh/sh_linux.c	2010-01-30 00:39:05.000000000 +0100
***************
*** 70,75 ****
--- 70,91 ----
  #define CURRENT_SE_MODE 29	/* 29-bit (Traditional) Mode */
  #endif	/* CONFIG_SH_SE_MODE */
  
+ extern void fp_serial_tx_msg(char *data);
+ static int display_linux_on_vfd(void)
+ {
+ 	int i;
+ 	/* FP messages to display "LINUX" on the VFD */
+ 	char data[][10] = {{0x99, 0x10, 0x00, 0x29, 0x61, 0x0d, 0x46, 0xa0, 0x00, 0x00},
+ 			   {0x99, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+ 			   {0x99, 0x20, 0x00, 0x2a, 0x00, 0x00, 0x80, 0x0a, 0xa1, 0x41},
+ 			   {0x99, 0x28, 0xa5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
+ 
+ 	for(i = 0; i < sizeof(data)/sizeof(data[0]); i++)
+ 		fp_serial_tx_msg(data[i]);
+ 
+ 	return 0;
+ }
+ 
  void do_bootm_linux (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[],
  		     ulong addr, ulong * len_ptr, int verify)
  {
***************
*** 277,282 ****
--- 293,300 ----
  	printf ("\nStarting kernel %s - 0x%08x - %d ...\n\n", COMMAND_LINE,
  		*INITRD_START, *INITRD_SIZE);
  
+ 	display_linux_on_vfd();
+ 
  	/*
  	 * remove Vpp from the FLASH, so that no further writes can occur.
  	 */
***************
*** 289,296 ****
--- 307,317 ----
  	 */
  	sh_flush_cache_all();
  
+ #ifndef CONFIG_SH_TF7700
+ 	/* On TF7700 cache invalidation leads to an exception. */
  	/* Invalidate both instruction and data caches */
  	sh_cache_set_op(SH4_CCR_OCI|SH4_CCR_ICI);
+ #endif
  
  #ifdef CONFIG_SH_SE_MODE
  	/*
diff -rcN u-boot-sh4-1.3.1_stm23_0043_orig/Makefile u-boot-sh4-1.3.1_stm23_0043/Makefile
*** u-boot-sh4-1.3.1_stm23_0043_orig/Makefile	2010-01-27 21:46:32.000000000 +0100
--- u-boot-sh4-1.3.1_stm23_0043/Makefile	2010-01-30 00:30:21.000000000 +0100
***************
*** 2671,2676 ****
--- 2671,2682 ----
  ## SuperH SH4
  #########################################################################
  
+ tf7700_config :               unconfig
+ 	@ >include/config.h
+ 	@echo "#define CONFIG_SH_STB7100 1" >>include/config.h
+ 	@echo "#define CONFIG_SH_MB411   1" >>include/config.h
+ 	@./mkconfig -a tf7700 sh sh tf7700 "" stb7100
+ 
  mb411_config :		unconfig
  	@ >include/config.h
  	@echo "#define CONFIG_SH_STB7100 1" >>include/config.h
