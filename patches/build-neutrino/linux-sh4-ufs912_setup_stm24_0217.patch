--- a/drivers/stm/stx7111_comms.c.org	2011-07-02 05:58:19.000000000 -0700
+++ b/drivers/stm/stx7111_comms.c	2011-07-03 05:30:59.771608244 -0700
@@ -211,10 +211,17 @@
 			STM_PAD_PIO_BIDIR_NAMED(2, 0, 1, "SCL"),
 			STM_PAD_PIO_BIDIR_NAMED(2, 1, 1, "SDA"),
 		},
-		.sysconfs_num = 1,
+		.sysconfs_num = 5,
 		.sysconfs = (struct stm_pad_sysconf []) {
 			/* SSC0_MUX_SEL = 0 (default assignment) */
 			STM_PAD_SYS_CFG(7, 1, 1, 0),
+
+			/* some additional sysconfig settings to enable i2c, cic and cec */
+			STM_PAD_SYS_CFG(5, 0, 0, 1), // cic
+			STM_PAD_SYS_CFG(5, 17, 17, 1), // cic
+			STM_PAD_SYS_CFG(5, 8, 8, 1), //cec
+			STM_PAD_SYS_CFG(7, 15, 15, 1), //i2c
+
 			/* spi_boot_not_comm = 0 should be set here... */
 			/* This is a signal from SPI block */
 			/* Hope this is set correctly by default */
 
--- a/arch/sh/boards/mach-mb618/setup.c.org	2012-03-08 08:58:51.000000000 -0800
+++ b/arch/sh/boards/mach-mb618/setup.c	2012-03-09 08:48:35.000000000 -0800
@@ -17,35 +17,78 @@
 #include <linux/phy.h>
 #include <linux/i2c.h>
 #include <linux/gpio.h>
+#include <linux/stm/gpio.h>
 #include <linux/gpio_keys.h>
 #include <linux/input.h>
 #include <linux/irq.h>
 #include <linux/stm/platform.h>
 #include <linux/stm/stx7111.h>
 #include <linux/stm/emi.h>
-#include <linux/stm/pci-glue.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/nand.h>
+#include <linux/stm/nand.h>
 #include <linux/mtd/physmap.h>
 #include <linux/mtd/partitions.h>
-#include <linux/spi/spi.h>
-#include <linux/spi/flash.h>
 #include <asm/irq-ilc.h>
 #include <asm/irl.h>
 #include <sound/stm.h>
 #include <mach/common.h>
+#include <linux/bpa2.h>
 
+#define MB618_PIO_PHY_RESET stm_gpio(4, 4)
 
-
-/* Whether the hardware supports NOR or NAND Flash depends on J34.
- * In position 1-2 CSA selects NAND, in position 2-3 is selects NOR.
- * Note that J30A must be in position 2-3 to select the on board Flash
- * (both NOR and NAND).
- */
-#define FLASH_NOR
-#define MB618_PIO_FLASH_VPP stm_gpio(3, 4)
-
-
+const char *LMI_IO_partalias[] = { "v4l2-coded-video-buffers", "BPA2_Region1", "v4l2-video-buffers" ,
+                                    "coredisplay-video", "gfx-memory", "BPA2_Region0", "LMI_VID", NULL };
+ 
+#ifdef CONFIG_BPA2_DIRECTFBOPTIMIZED
+/*
+0x40000000 - 0x403FFFFF - cocpu 1 ram (4mb)
+0x40400000 - 0x407FFFFF - cocpu 2 ram (4mb)
+0x40800000 - 0x47FFFFFF - linux   (120mb) 
+0x47600000 - 0x483FFFFF - bigphys ( 14mb (0x00E00000))
+0x48400000 - 0x4FFFFFFF - lmi_io  ( 124mb (0x07C00000))
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] = {
+    {
+ 	    .name  = "LMI_IO",
+ 	    .start = 0x47600000,
+ 	    .size  = 0x07C00000, /* 124 Mb */
+ 	    .flags = 0,
+ 	    .aka   = LMI_IO_partalias
+    }, 
+    {
+ 	    .name  = "bigphysarea",
+ 	    .start = 0x4F200000,
+ 	    .size  = 0x00E00000, /* 14 Mb */
+ 	    .flags = 0,
+ 	    .aka   = NULL
+    }, 
+ };
+#else
+/*
+0x40000000 - 0x403FFFFF - cocpu 1 ram (4mb)
+0x40400000 - 0x407FFFFF - cocpu 2 ram (4mb)
+0x40800000 - 0x49FFFFFF - linux   (159mb)
+0x4A000000 - 0x4B1FFFFF - bigphys ( 18mb)
+0x4B200000 - 0x4FFFFFFF - lmi_io  ( 78mb)
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] = {
+    {
+ 	    .name  = "bigphysarea",
+ 	    .start = 0x4A000000,
+ 	    .size  = 0x01200000, /* 18 Mb */
+ 	    .flags = 0,
+ 	    .aka   = NULL
+    }, 
+    {
+ 	    .name  = "LMI_IO",
+ 	    .start = 0x4B200000,
+ 	    .size  = 0x04E00000, /* 78 Mb */
+ 	    .flags = 0,
+ 	    .aka   = LMI_IO_partalias
+    }, 
+ };
+#endif
 
 static void __init mb618_setup(char** cmdline_p)
 {
@@ -53,119 +70,85 @@
 
 	stx7111_early_device_init();
 
-	stx7111_configure_asc(2, &(struct stx7111_asc_config) {
+	stx7111_configure_asc(1, &(struct stx7111_asc_config) {
 			.hw_flow_control = 1,
 			.is_console = 1, });
-	stx7111_configure_asc(3, &(struct stx7111_asc_config) {
-			.hw_flow_control = 1,
-			.is_console = 0, });
-}
-
-
-
-static struct platform_device mb618_leds = {
-	.name = "leds-gpio",
-	.id = -1,
-	.dev.platform_data = &(struct gpio_led_platform_data) {
-		.num_leds = 2,
-		.leds = (struct gpio_led[]) {
-			{
-				.name = "HB green",
-				.default_trigger = "heartbeat",
-				.gpio = stm_gpio(6, 0),
-			}, {
-				.name = "HB red",
-				.gpio = stm_gpio(6, 1),
-			},
-		},
-	},
-};
-
 
+  	bpa2_init(bpa2_parts_table, ARRAY_SIZE(bpa2_parts_table));
+}
 
-static struct gpio_keys_button mb618_buttons[] = {
+// Nor Flash Configuration
+static struct mtd_partition nor_parts[] = {
 	{
-		.code = BTN_0,
-		.gpio = stm_gpio(6, 2),
-		.desc = "SW2",
-	}, {
-		.code = BTN_1,
-		.gpio = stm_gpio(6, 3),
-		.desc = "SW3",
-	}, {
-		.code = BTN_2,
-		.gpio = stm_gpio(6, 4),
-		.desc = "SW4",
+		.name   = "NOR U-BOOT     0xA000.0000-0xA007.FFFF (512KB)",
+		.size   = 0x00080000,
+		.offset = 0
 	}, {
-		.code = BTN_3,
-		.gpio = stm_gpio(6, 5),
-		.desc = "SW5",
-	},
-};
-
-static struct platform_device mb618_button_device = {
-	.name = "gpio-keys",
-	.id = -1,
-	.num_resources = 0,
-	.dev.platform_data = &(struct gpio_keys_platform_data) {
-		.buttons = mb618_buttons,
-		.nbuttons = ARRAY_SIZE(mb618_buttons),
-	},
+		.name   = "NOR R00T       0xA008.0000-0xA03F.FFFF (3,5MB)",
+		.size   = MTDPART_SIZ_FULL,
+		.offset = MTDPART_OFS_APPEND
+	}
 };
 
-
-
-#ifdef FLASH_NOR
-/* J34 must be in the 1-2 position to enable NOR Flash */
-static void mb618_nor_set_vpp(struct map_info *info, int enable)
-{
-	gpio_set_value(MB618_PIO_FLASH_VPP, enable);
-}
-
-static struct platform_device mb618_nor_flash = {
+static struct platform_device mb618_nor_device = {
 	.name		= "physmap-flash",
 	.id		= -1,
 	.num_resources	= 1,
 	.resource	= (struct resource[]) {
-		STM_PLAT_RESOURCE_MEM(0, 32*1024*1024),
+		STM_PLAT_RESOURCE_MEM(0, 4*1024*1024),
 	},
 	.dev.platform_data = &(struct physmap_flash_data) {
 		.width		= 2,
-		.set_vpp	= mb618_nor_set_vpp,
-		.nr_parts	= 3,
-		.parts		=  (struct mtd_partition []) {
-			{
-				.name = "NOR Flash 1",
-				.size = 0x00080000,
-				.offset = 0x00000000,
-			}, {
-				.name = "NOR Flash 2",
-				.size = 0x00200000,
-				.offset = MTDPART_OFS_NXTBLK,
-			}, {
-				.name = "NOR Flash 3",
-				.size = MTDPART_SIZ_FULL,
-				.offset = MTDPART_OFS_NXTBLK,
-			},
-		},
+		.nr_parts	= ARRAY_SIZE(nor_parts),
+		.parts		= nor_parts
 	},
 };
+
+// Nand Flash Configuration
+static struct mtd_partition nand_parts[] = {
+#ifdef ORIGINAL_MTD
+	 {
+	 .name = "NAND KERNEL    0x0000.0000-0x002F.FFFF",
+	 .size = 0x300000,
+	 .offset = 0
+	 }, {
+	 .name = "NAND ROOT      0x0030.0000-0x027F.FFFF",
+	 .size = 0x2500000,
+	 .offset = 0x300000
+	 }, {
+	 .name = "NAND CONFIG    0x0280.0000-0x04FF.FFFF",
+	 .size = 0x2800000,
+	 .offset = 0x2800000
+	 }, {
+	 .name = "NAND DATA      0x0500.0000-0x07FF.FFFF",
+	 .size = MTDPART_SIZ_FULL,	/* will expand to the end of the flash */
+	 .offset = 0x05000000
+	 }
 #else
-struct stm_nand_bank_data mb618_nand_flash = {
-	.csn		= 0,
+	 {
+	 .name   = "NAND KERNEL    0x0000.0000-0x003F.FFFF (  4MB)",
+	 .size   = 0x400000,
+	 .offset = 0
+	 }, {
+	 .name   = "NAND FW        0x0040.0000-0x00BF.FFFF (  8MB)",
+	 .size   = 0x800000,
+	 .offset = MTDPART_OFS_APPEND
+	 }, {
+	 .name   = "NAND ROOT      0x00C0.0000-0x04BF.FFFF ( 64MB)",
+	 .size   = 0x4000000,
+	 .offset = MTDPART_OFS_APPEND
+	 }, {
+	 .name   = "NAND DATA      0x04C0.0000-0x07FF.FFFF ( 52MB)",
+	 .size   = MTDPART_SIZ_FULL,	/* will expand to the end of the flash */
+	 .offset = MTDPART_OFS_APPEND
+	 }
+#endif
+};
+static struct stm_nand_bank_data nand_bank_data = {
+	.csn		= 1,
+	.nr_partitions	= ARRAY_SIZE(nand_parts),
+	.partitions	= nand_parts,
 	.options	= NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT,
-	.nr_partitions	= 2,
-	.partitions	= (struct mtd_partition []) {
-		{
-			.name	= "NAND Flash 1",
-			.offset	= 0,
-			.size 	= 0x00800000
-		}, {
-			.name	= "NAND Flash 2",
-			.offset = MTDPART_OFS_NXTBLK,
-			.size	= MTDPART_SIZ_FULL
-		},
-	},
 	.timing_data	= &(struct stm_nand_timing_data) {
 		.sig_setup	= 50,		/* times in ns */
 		.sig_hold	= 50,
@@ -171,37 +154,21 @@
 		.sig_hold	= 50,
 		.CE_deassert	= 0,
 		.WE_to_RBn	= 100,
-		.wr_on		= 20,
-		.wr_off		= 50,
-		.rd_on		= 20,
-		.rd_off		= 50,
+		.wr_on		= 10,
+		.wr_off		= 30,
+		.rd_on		= 10,
+		.rd_off		= 30,
		.chip_delay	= 50,		/* in us */
 	},
+	.emi_withinbankoffset	= 0,
 };
-#endif
 
-/* Serial Flash (Board Rev D and later) */
-static struct spi_board_info mb618_serial_flash = {
-	.modalias       = "m25p80",
-	.bus_num        = 0,
-	.chip_select    = stm_gpio(6, 7),
-	.max_speed_hz   = 7000000,
-	.mode           = SPI_MODE_3,
-	.platform_data  = &(struct flash_platform_data) {
-		.name = "m25p80",
-		.type = "m25p80",
-		.nr_parts	= 2,
-		.parts = (struct mtd_partition []) {
-			{
-				.name = "Serial Flash 1",
-				.size = 0x00080000,
-				.offset = 0,
-			}, {
-				.name = "Serial Flash 2",
-				.size = MTDPART_SIZ_FULL,
-				.offset = MTDPART_OFS_NXTBLK,
-			},
-		},
+static struct platform_device mb618_nand_device = {
+	.name		= "stm-nand-emi",
+	.dev.platform_data = &(struct stm_plat_nand_emi_data){
+		.nr_banks	= 1,
+		.banks		= &nand_bank_data,
+		.emi_rbn_gpio	= -1,
 	},
 };
 
@@ -216,13 +183,13 @@
 	return 1;
 }
 
-static struct stmmac_mdio_bus_data stmmac_mdio_bus = {
+static struct stmmac_mdio_bus_data mb618_phy_private_data = {
 	.bus_id = 0,
 	.phy_reset = mb618_phy_reset,
 	.phy_mask = 0,
 };
 
-static struct platform_device epld_device = {
+static struct platform_device mb618_epld_device = {
 	.name		= "epld",
 	.id		= -1,
 	.num_resources	= 1,
@@ -239,129 +206,39 @@
 	},
 };
 
-
-
-static struct stm_plat_pci_config mb618_pci_config = {
-	/* We don't bother with INT[BCD] as they are shared with the ssc
-	 * J20-A must be removed, J20-B must be 5-6 */
-	.pci_irq = {
-		[0] = PCI_PIN_DEFAULT,
-		[1] = PCI_PIN_UNUSED,
-		[2] = PCI_PIN_UNUSED,
-		[3] = PCI_PIN_UNUSED
-	},
-	.serr_irq = PCI_PIN_DEFAULT, /* J32-F fitted */
-	.idsel_lo = 30,
-	.idsel_hi = 30,
-	.req_gnt = {
-		[0] = PCI_PIN_DEFAULT,
-		[1] = PCI_PIN_UNUSED,
-		[2] = PCI_PIN_UNUSED,
-		[3] = PCI_PIN_UNUSED
-	},
-	.pci_clk = 33333333,
-	.pci_reset_gpio = -EINVAL,	/* Reset done by EPLD on power on */
-};
-
-int pcibios_map_platform_irq(struct pci_dev *dev, u8 slot, u8 pin)
-{
-       /* We can use the standard function on this board */
-       return stx7111_pcibios_map_platform_irq(&mb618_pci_config, pin);
-}
-
 static struct platform_device *mb618_devices[] __initdata = {
-	&mb618_leds,
-	&epld_device,
-#ifdef FLASH_NOR
-	&mb618_nor_flash,
-#endif
-	&mb618_button_device,
-};
-
-/* SCART switch simple control */
-
-/* Enable CVBS output to both (TV & VCR) SCART outputs */
-static int mb618_scart_audio_init(struct i2c_client *client, void *priv)
-{
-	const char cmd[] = { 0x2, 0x11 };
-	int cmd_len = sizeof(cmd);
-
-	return i2c_master_send(client, cmd, cmd_len) != cmd_len;
-}
-
-/* Audio on SCART outputs control */
-static struct i2c_board_info mb618_scart_audio __initdata = {
-	I2C_BOARD_INFO("snd_conv_i2c", 0x4b),
-	.type = "STV6417",
-	.platform_data = &(struct snd_stm_conv_i2c_info) {
-		.group = "Analog Output",
-		.source_bus_id = "snd_pcm_player.1",
-		.channel_from = 0,
-		.channel_to = 1,
-		.format = SND_STM_FORMAT__I2S |
-				SND_STM_FORMAT__SUBFRAME_32_BITS,
-		.oversampling = 256,
-		.init = mb618_scart_audio_init,
-		.enable_supported = 1,
-		.enable_cmd = (char []){ 0x01, 0x09 },
-		.enable_cmd_len = 2,
-		.disable_cmd = (char []){ 0x01, 0x00 },
-		.disable_cmd_len = 2,
-	},
+	&mb618_epld_device,
+	&mb618_nor_device,
+	&mb618_nand_device,
 };
 
 static int __init mb618_devices_init(void)
 {
-	int peripherals_i2c_bus;
-
-	stx7111_configure_pci(&mb618_pci_config);
-
-	stx7111_configure_pwm(&(struct stx7111_pwm_config) {
-			.out0_enabled = 1,
-			.out1_enabled = 0, });
-
-	stx7111_configure_ssc_spi(0, NULL);
+	stx7111_configure_ssc_i2c(0, NULL);
 	stx7111_configure_ssc_i2c(1, NULL); /* J12=1-2, J16=1-2 */
-	peripherals_i2c_bus = stx7111_configure_ssc_i2c(2, NULL);
+	stx7111_configure_ssc_i2c(2, NULL);
 	stx7111_configure_ssc_i2c(3, NULL);
 
 	stx7111_configure_usb(&(struct stx7111_usb_config) {
 			.invert_ovrcur = 1, });
 
+	gpio_request(MB618_PIO_PHY_RESET, "PHY_RESET");
+	gpio_direction_output(MB618_PIO_PHY_RESET, STM_GPIO_DIRECTION_OUT);
+	gpio_set_value(MB618_PIO_PHY_RESET, 1);
+
 	stx7111_configure_ethernet(&(struct stx7111_ethernet_config) {
 			.mode = stx7111_ethernet_mode_mii,
 			.ext_clk = 0,
 			.phy_bus = 0,
 			.phy_addr = -1,
-			.mdio_bus_data = &stmmac_mdio_bus,
+			.mdio_bus_data = &mb618_phy_private_data,
 		});
 
-	stx7111_configure_lirc(&(struct stx7111_lirc_config) {
-#ifdef CONFIG_LIRC_STM_UHF
-			.rx_mode = stx7111_lirc_rx_mode_uhf,
-#else
-			.rx_mode = stx7111_lirc_rx_mode_ir,
-#endif
-			.tx_enabled = 1,
-			.tx_od_enabled = 0, });
-
-	gpio_request(MB618_PIO_FLASH_VPP, "Flash VPP");
-	gpio_direction_output(MB618_PIO_FLASH_VPP, 0);
-
-	i2c_register_board_info(peripherals_i2c_bus, &mb618_scart_audio, 1);
-	spi_register_board_info(&mb618_serial_flash, 1);
-
-#ifndef FLASH_NOR
 	stx7111_configure_nand(&(struct stm_nand_config) {
 			.driver = stm_nand_flex,
 			.nr_banks = 1,
-			.banks = &mb618_nand_flash,
-			.rbn.flex_connected = 1,});
-
-	/* The MTD NAND code doesn't understand the concept of VPP,
-	 * (or hardware write protect) so permanently enable it. */
-	gpio_direction_output(MB618_PIO_FLASH_VPP, 1);
-#endif
+			.banks = &nand_bank_data,
+			.rbn.flex_connected = 0,});
 
 	return platform_add_devices(mb618_devices, ARRAY_SIZE(mb618_devices));
 }
@@ -405,7 +282,7 @@
 	const int version_offset = 0;
 	int version;
 
-	epld_early_init(&epld_device);
+	epld_early_init(&mb618_epld_device);
 
 	epld_write(0, 0);	/* bank = Test */
 	epld_write(0x63, test_offset);
@@ -438,10 +315,9 @@
 }
 
 struct sh_machine_vector mv_mb618 __initmv = {
-	.mv_name		= "STx7111 Mboard",
+	.mv_name		= "STx7111 Mboard (Kathrein UFS-912)",
 	.mv_setup		= mb618_setup,
 	.mv_nr_irqs		= NR_IRQS,
 	.mv_init_irq		= mb618_init_irq,
 	.mv_ioport_map		= mb618_ioport_map,
-	STM_PCI_IO_MACHINE_VEC
 };
*** a/drivers/mtd/chips/cfi_probe.c	2011-01-02 21:05:30.000000000 +0100
--- b/cfi_probe.c	2011-01-05 20:38:36.087467593 +0100
***************
*** 221,226 ****
--- 221,242 ----
  	for (i=0; i<cfi->cfiq->NumEraseRegions; i++) {
  		cfi->cfiq->EraseRegionInfo[i] = le32_to_cpu(cfi->cfiq->EraseRegionInfo[i]);
  
+ 	/* kdhong */
+ 	printk( "CFI MFR = %x DEV = %x\n", cfi->mfr, cfi->id );
+ 
+ 	if( cfi->mfr == 0x00c2 && cfi->id == 0x227e )
+ 	{
+ 		int devsize = (1 << cfi->cfiq->DevSize) * cfi->interleave;
+ 
+ 		printk( "devsize = %x\n", devsize );
+ 
+ 		if( devsize == 0x400000 )
+ 		{
+ 			cfi->cfiq->EraseRegionInfo[i] = 0x100003f;
+ 		}
+ 	}
+ 	/* kdhong */
+ 
  #ifdef DEBUG_CFI
  		printk("  Erase Region #%d: BlockSize 0x%4.4X bytes, %d blocks\n",
  		       i, (cfi->cfiq->EraseRegionInfo[i] >> 8) & ~0xff,
--- a/drivers/mtd/nand/nand_base.c	2014-05-15 10:24:39.000000000 +0200
+++ b/drivers/mtd/nand/nand_base.c	2014-05-16 01:35:09.000000000 +0200
@@ -57,8 +57,7 @@
 struct dentry *file_erasebb;
 #endif
 
-u8 nand_erasebb;
-EXPORT_SYMBOL_GPL(nand_erasebb);
+u8 erasebb;
 
 /* Define default oob placement schemes for large and small page devices */
 static struct nand_ecclayout nand_oob_8 = {
@@ -441,14 +440,13 @@
  *
  * The function expects, that the device is already selected
  */
-int nand_check_wp(struct mtd_info *mtd)
+static int nand_check_wp(struct mtd_info *mtd)
 {
 	struct nand_chip *chip = mtd->priv;
 	/* Check the WP bit */
 	chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
 	return (chip->read_byte(mtd) & NAND_STATUS_WP) ? 0 : 1;
 }
-EXPORT_SYMBOL_GPL(nand_check_wp);
 
 /**
  * nand_block_checkbad - [GENERIC] Check if a block is marked bad
@@ -481,8 +479,8 @@
  * Send an entire "SET FEATURES" command to NAND device. This includes
  * the feature address (FA), and the set of 4 parameters to use (P1,P2,P3,P4).
  */
-static __maybe_unused int nand_get_features(struct mtd_info *mtd, int feature,
-					    uint8_t *parameters)
+static int nand_get_features(struct mtd_info *mtd, int feature,
+			     uint8_t *parameters)
 {
 	struct nand_chip *chip = mtd->priv;
 
@@ -1037,15 +1035,10 @@
 		int stat;
 
 		stat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);
-		if (stat) {
-			printk(KERN_CONT "sector %d, page %d (0x%012llx)]\n",
-			       chip->ecc.steps - eccsteps, page,
-			       (uint64_t)page << chip->page_shift);
-			if (stat < 0)
-				mtd->ecc_stats.failed++;
-			else
-				mtd->ecc_stats.corrected += stat;
-		}
+		if (stat < 0)
+			mtd->ecc_stats.failed++;
+		else
+			mtd->ecc_stats.corrected += stat;
 	}
 	return 0;
 }
@@ -1287,8 +1280,8 @@
  * @ops:	oob ops structure
  * @len:	size of oob to transfer
  */
-uint8_t *nand_transfer_oob(struct nand_chip *chip, uint8_t *oob,
-			   struct mtd_oob_ops *ops, size_t len)
+static uint8_t *nand_transfer_oob(struct nand_chip *chip, uint8_t *oob,
+				  struct mtd_oob_ops *ops, size_t len)
 {
 	switch(ops->mode) {
 
@@ -1327,7 +1320,6 @@
 	}
 	return NULL;
 }
-EXPORT_SYMBOL_GPL(nand_transfer_oob);
 
 /**
  * nand_do_read_ops - [Internal] Read data with ECC
@@ -2021,8 +2013,8 @@
  * @oob:	oob data buffer
  * @ops:	oob ops structure
  */
-uint8_t *nand_fill_oob(struct nand_chip *chip, uint8_t *oob,
-		       struct mtd_oob_ops *ops)
+static uint8_t *nand_fill_oob(struct nand_chip *chip, uint8_t *oob,
+				  struct mtd_oob_ops *ops)
 {
 	size_t len = ops->ooblen;
 
@@ -2063,7 +2055,6 @@
 	}
 	return NULL;
 }
-EXPORT_SYMBOL_GPL(nand_fill_oob);
 
 #define NOTALIGNED(x)	(x & (chip->subpagesize - 1)) != 0
 
@@ -2481,7 +2472,7 @@
 		/*
 		 * heck if we have a bad block, we do not erase bad blocks !
 		 */
-		if (!nand_erasebb &&
+		if (!erasebb &&
 		    nand_block_checkbad(mtd, ((loff_t) page) <<
 					chip->page_shift, 0, allowbbt)) {
 			printk(KERN_WARNING "%s: attempt to erase a bad block "
@@ -2591,7 +2582,7 @@
  *
  * Sync is actually a wait for chip ready function
  */
-void nand_sync(struct mtd_info *mtd)
+static void nand_sync(struct mtd_info *mtd)
 {
 	struct nand_chip *chip = mtd->priv;
 
@@ -2602,7 +2593,6 @@
 	/* Release it and go back */
 	nand_release_device(mtd);
 }
-EXPORT_SYMBOL_GPL(nand_sync);
 
 /**
  * nand_block_isbad - [MTD Interface] Check if block at offset is bad
@@ -2642,19 +2632,18 @@
  * nand_suspend - [MTD Interface] Suspend the NAND flash
  * @mtd:	MTD device structure
  */
-int nand_suspend(struct mtd_info *mtd)
+static int nand_suspend(struct mtd_info *mtd)
 {
 	struct nand_chip *chip = mtd->priv;
 
 	return nand_get_device(chip, mtd, FL_PM_SUSPENDED);
 }
-EXPORT_SYMBOL_GPL(nand_suspend);
 
 /**
  * nand_resume - [MTD Interface] Resume the NAND flash
  * @mtd:	MTD device structure
  */
-void nand_resume(struct mtd_info *mtd)
+static void nand_resume(struct mtd_info *mtd)
 {
 	struct nand_chip *chip = mtd->priv;
 
@@ -2664,7 +2653,6 @@
 		printk(KERN_ERR "%s called for a chip which is not "
 		       "in suspended state\n", __func__);
 }
-EXPORT_SYMBOL_GPL(nand_resume);
 
 /*
  * Set default functions
@@ -2711,139 +2699,6 @@
 }
 
 /*
- * sanitize ONFI strings so we can safely print them
- */
-static void sanitize_string(uint8_t *s, size_t len)
-{
-	ssize_t i;
-
-	/* null terminate */
-	s[len - 1] = 0;
-
-	/* remove non printable chars */
-	for (i = 0; i < len - 1; i++) {
-		if (s[i] < ' ' || s[i] > 127)
-			s[i] = '?';
-	}
-
-	/* remove trailing spaces */
-	s = strstrip(s);
-}
-
-static u16 onfi_crc16(u16 crc, u8 const *p, size_t len)
-{
-	int i;
-	while (len--) {
-		crc ^= *p++ << 8;
-		for (i = 0; i < 8; i++)
-			crc = (crc << 1) ^ ((crc & 0x8000) ? 0x8005 : 0);
-	}
-
-	return crc;
-}
-
-/*
- * Check if the NAND chip is ONFI compliant, returns 1 if it is, 0 otherwise
- */
-static int nand_flash_detect_onfi(struct mtd_info *mtd, struct nand_chip *chip,
-					int busw)
-{
-	struct nand_onfi_params *p = &chip->onfi_params;
-	uint16_t features;
-	uint32_t planes_per_lun;
-	int i;
-	int val;
-
-	/* try ONFI for unknow chip or LP */
-	chip->cmdfunc(mtd, NAND_CMD_READID, 0x20, -1);
-	if (chip->read_byte(mtd) != 'O' || chip->read_byte(mtd) != 'N' ||
-		chip->read_byte(mtd) != 'F' || chip->read_byte(mtd) != 'I')
-		return 0;
-
-	printk(KERN_INFO "ONFI flash detected\n");
-	chip->cmdfunc(mtd, NAND_CMD_PARAM, 0, -1);
-	for (i = 0; i < 3; i++) {
-		chip->read_buf(mtd, (uint8_t *)p, sizeof(*p));
-		if (onfi_crc16(ONFI_CRC_BASE, (uint8_t *)p, 254) ==
-				le16_to_cpu(p->crc)) {
-			printk(KERN_INFO "ONFI param page %d valid\n", i);
-			break;
-		}
-	}
-
-	if (i == 3) {
-		printk(KERN_INFO "No valid ONFI param page found (bad CRC)\n");
-		return 0;
-	}
-
-	/* check version */
-	val = le16_to_cpu(p->revision);
-	if (val & (1 << 5))
-		chip->onfi_version = 23;
-	else if (val & (1 << 4))
-		chip->onfi_version = 22;
-	else if (val & (1 << 3))
-		chip->onfi_version = 21;
-	else if (val & (1 << 2))
-		chip->onfi_version = 20;
-	else if (val & (1 << 1))
-		chip->onfi_version = 10;
-	else
-		chip->onfi_version = 0;
-
-	if (!chip->onfi_version) {
-		printk(KERN_INFO "%s: unsupported ONFI version: %d\n",
-								__func__, val);
-		return 0;
-	}
-
-	sanitize_string(p->manufacturer, sizeof(p->manufacturer));
-	sanitize_string(p->model, sizeof(p->model));
-	if (!mtd->name)
-		mtd->name = p->model;
-
-	mtd->writesize = le32_to_cpu(p->byte_per_page);
-	mtd->oobsize = le16_to_cpu(p->spare_bytes_per_page);
-	chip->luns_per_chip = p->lun_count;
-
-	/* 'interleaved_bits' should really be called 'plane_address_bits' */
-	planes_per_lun = 1 << p->interleaved_bits;
-	chip->planes_per_chip = chip->luns_per_chip * planes_per_lun;
-
-	mtd->erasesize = mtd->writesize * le32_to_cpu(p->pages_per_block);
-	chip->chipsize = (uint64_t)mtd->erasesize *
-		le32_to_cpu(p->blocks_per_lun) *
-		chip->luns_per_chip;
-
-	/* Build up chip options */
-	chip->options &= ~NAND_CHIPOPTIONS_MSK;
-	chip->options |= (NAND_NO_AUTOINCR | NAND_NO_READRDY);
-
-	features = le16_to_cpu(p->features);
-
-	if (features & (0x1 << 0))
-		chip->options |=  NAND_BUSWIDTH_16;
-	if (features & (0x1 << 1))
-		chip->options |= NAND_MULTILUN;
-	if (features & (0x1 << 3))
-		chip->options |= NAND_MULTIPLANE_PROG_ERASE;
-	if (features & (0x1 << 6))
-		chip->options |= NAND_MULTIPLANE_READ;
-
-	features = le16_to_cpu(p->opt_cmd);
-	if (features & (0x1 << 1))
-		chip->options |= NAND_CACHERD;
-	if (features & (0x1 << 0))
-		chip->options |= NAND_CACHEPRG;
-
-	/* Mimic 'cellinfo' */
-	chip->cellinfo = chip->luns_per_chip;
-	chip->cellinfo |= ((p->bits_per_cell - 1) & 0x3) << 2;
-
-	return 1;
-}
-
-/*
  * Get the flash and manufacturer id and lookup if the type is supported
  */
 static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
@@ -2851,9 +2706,8 @@
 						  int busw, int *maf_id)
 {
 	struct nand_flash_dev *type = NULL;
-	int dev_id, maf_idx, i;
-	u8 id_data[8];
-	int ret;
+	int i, dev_id, maf_idx;
+	int tmp_id, tmp_manf;
 
 	/* Select the device */
 	chip->select_chip(mtd, 0);
@@ -2877,46 +2731,76 @@
 	 * not match, ignore the device completely.
 	 */
 
-	/* Read entire ID string */
 	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
-	for (i = 0; i < 8; i++)
-		id_data[i] = chip->read_byte(mtd);
 
-	if (id_data[0] != *maf_id || id_data[1] != dev_id) {
-		pr_info("%s: second ID read did not match "
-			"%02x,%02x against %02x,%02x\n", __func__,
-			*maf_id, dev_id, id_data[0], id_data[1]);
+	/* Read manufacturer and device IDs */
+
+	tmp_manf = chip->read_byte(mtd);
+	tmp_id = chip->read_byte(mtd);
+
+	if (tmp_manf != *maf_id || tmp_id != dev_id) {
+		printk(KERN_INFO "%s: second ID read did not match "
+		       "%02x,%02x against %02x,%02x\n", __func__,
+		       *maf_id, dev_id, tmp_manf, tmp_id);
 		return ERR_PTR(-ENODEV);
 	}
 
 	/* Lookup the flash id */
-	for (type = nand_flash_ids; type->name != NULL; type++)
-		if (dev_id == type->id)
+	for (i = 0; nand_flash_ids[i].name != NULL; i++) {
+		if (dev_id == nand_flash_ids[i].id) {
+			type =  &nand_flash_ids[i];
 			break;
-
-	chip->onfi_version = 0;
-	if (!type->name || !type->pagesize) {
-		/* Check is chip is ONFI compliant */
-		ret = nand_flash_detect_onfi(mtd, chip, busw);
-		if (ret)
-			goto ident_done;
+		}
 	}
 
-	if (!type->name)
+	if (!type)
 		return ERR_PTR(-ENODEV);
 
 	if (!mtd->name)
 		mtd->name = type->name;
 
-	/* Decode ID string */
-	if (nand_decode_id(mtd, chip, type, id_data, 8) != 0) {
-		printk(KERN_INFO "Failed to decode NAND READID "
-		       "[%02x %02x %02x %02x]\n",
-		       id_data[0], id_data[1], id_data[2], id_data[3]);
-		return ERR_PTR(-EINVAL);
-	}
+	chip->chipsize = (uint64_t)type->chipsize << 20;
 
- ident_done:
+	/* Newer devices have all the information in additional id bytes */
+	if (!type->pagesize) {
+		int extid;
+		/* The 3rd id byte holds MLC / multichip data */
+		chip->cellinfo = chip->read_byte(mtd);
+		/* The 4th id byte is the important one */
+		extid = chip->read_byte(mtd);
+		/* Calc pagesize */
+		mtd->writesize = 1024 << (extid & 0x3);
+		extid >>= 2;
+		/* Calc oobsize */
+		mtd->oobsize = (8 << (extid & 0x01)) * (mtd->writesize >> 9);
+		extid >>= 2;
+		/* Calc blocksize. Blocksize is multiples of 64KiB */
+		mtd->erasesize = (64 * 1024) << (extid & 0x03);
+		extid >>= 2;
+		/* Get buswidth information */
+		busw = (extid & 0x01) ? NAND_BUSWIDTH_16 : 0;
+
+		/* Micron device: check for 4-bit on-die ECC */
+		if (*maf_id == NAND_MFR_MICRON) {
+			u8 id4, id5;
+			id4 = chip->read_byte(mtd);
+			id5 = chip->read_byte(mtd);
+
+			/* Do we have a 5-byte ID ? */
+			if (!(id4 == *maf_id && id5 == dev_id))
+				/* ECC level in id4[1:0] */
+				if ((id4 & 0x3) == 0x2)
+					chip->ecc.mode = NAND_ECC_4BITONDIE;
+		}
+	} else {
+		/*
+		 * Old devices have chip data hardcoded in the device id table
+		 */
+		mtd->erasesize = type->erasesize;
+		mtd->writesize = type->pagesize;
+		mtd->oobsize = mtd->writesize / 32;
+		busw = type->options & NAND_BUSWIDTH_16;
+	}
 
 	/* Try to identify manufacturer */
 	for (maf_idx = 0; nand_manuf_ids[maf_idx].id != 0x0; maf_idx++) {
@@ -2924,16 +2808,14 @@
 			break;
 	}
 
-	printk(KERN_INFO "NAND device: Manufacturer ID:"
-	       " 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id, dev_id,
-	       nand_manuf_ids[maf_idx].name,
-	       chip->onfi_version ? chip->onfi_params.model : type->name);
-
 	/*
 	 * Check, if buswidth is correct. Hardware drivers should set
 	 * chip correct !
 	 */
 	if (busw != (chip->options & NAND_BUSWIDTH_16)) {
+		printk(KERN_INFO "NAND device: Manufacturer ID:"
+		       " 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id,
+		       dev_id, nand_manuf_ids[maf_idx].name, mtd->name);
 		printk(KERN_WARNING "NAND bus width %d instead %d bit\n",
 		       (chip->options & NAND_BUSWIDTH_16) ? 16 : 8,
 		       busw ? 16 : 8);
@@ -2952,10 +2834,24 @@
 	else
 		chip->chip_shift = ffs((unsigned)(chip->chipsize >> 32)) + 32 - 1;
 
+	/* Set the bad block position */
+	chip->badblockpos = mtd->writesize > 512 ?
+		NAND_LARGE_BADBLOCK_POS : NAND_SMALL_BADBLOCK_POS;
+
+	/* Get chip options, preserve non chip based options */
+	chip->options &= ~NAND_CHIPOPTIONS_MSK;
+	chip->options |= type->options & NAND_CHIPOPTIONS_MSK;
+
 	/*
-	 * Detmine manufactuer's bad-block marker scheme
+	 * Set chip as a default. Board drivers can override it, if necessary
 	 */
-	nand_derive_bbm(mtd, chip, id_data);
+	chip->options |= NAND_NO_AUTOINCR;
+
+	/* Check if chip is a not a samsung device. Do not clear the
+	 * options for chips which are not having an extended id.
+	 */
+	if (*maf_id != NAND_MFR_SAMSUNG && !type->pagesize)
+		chip->options &= ~NAND_SAMSUNG_LP_OPTIONS;
 
 	/* Check for AND chips with 4 page planes */
 	if (chip->options & NAND_4PAGE_ARRAY)
@@ -2963,15 +2859,14 @@
 	else
 		chip->erase_cmd = single_erase_cmd;
 
-	/* Check for Micron '4-bit on-die ECC; device (ID4[1:0]) */
-	if (id_data[0] == NAND_MFR_MICRON && id_data[4] != NAND_MFR_MICRON &&
-	    (id_data[4] & 0x03) == 0x02)
-		chip->options |= NAND_MICRON_4BITONDIEECC;
-
 	/* Do not replace user supplied command function ! */
 	if (mtd->writesize > 512 && chip->cmdfunc == nand_command)
 		chip->cmdfunc = nand_command_lp;
 
+	printk(KERN_INFO "NAND device: Manufacturer ID:"
+	       " 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id, dev_id,
+	       nand_manuf_ids[maf_idx].name, type->name);
+
 	return type;
 }
 
@@ -3061,7 +2956,10 @@
 			chip->ecc.layout = &nand_oob_16;
 			break;
 		case 64:
-			chip->ecc.layout = &nand_oob_64;
+			if (chip->ecc.mode == NAND_ECC_4BITONDIE)
+				chip->ecc.layout = &nand_oob_64_4bitondie;
+			else
+				chip->ecc.layout = &nand_oob_64;
 			break;
 		case 128:
 			chip->ecc.layout = &nand_oob_128;
@@ -3077,13 +2975,6 @@
 		chip->write_page = nand_write_page;
 
 	/*
-	 * For Micron '4-bit on-die ECC' devices, use on-die ECC scheme instead
-	 * of default NAND_ECC_SOFT.
-	 */
-	if (chip->options & NAND_MICRON_4BITONDIEECC &&
-	    chip->ecc.mode == NAND_ECC_SOFT)
-		chip->ecc.mode = NAND_ECC_4BITONDIE;
-	/*
 	 * check ECC mode, default to software if 3byte/512byte hardware ECC is
 	 * selected and we have 256 byte pagesize fallback to software ECC
 	 */
@@ -3176,23 +3067,12 @@
 		break;
 
 	case NAND_ECC_4BITONDIE:
-		if (mtd->oobsize != 64) {
-			printk(KERN_WARNING "No 'Micron on-die ECC' layout for "
-			       "OOB size %d\n", mtd->oobsize);
-			BUG();
-		}
-		if (!(chip->options & NAND_USE_FLASH_BBT)) {
-			printk(KERN_WARNING "'Micron on-die ECC' device "
-			       "requires 'NAND_USE_FLASH_BBT' option");
-			BUG();
-		}
 		chip->ecc.read_page = nand_read_page_raw;
 		chip->ecc.write_page = nand_write_page_raw;
 		chip->ecc.read_page_raw = nand_read_page_raw;
 		chip->ecc.write_page_raw = nand_write_page_raw;
 		chip->ecc.read_oob = nand_read_oob_std;
 		chip->ecc.write_oob = nand_write_oob_std;
-		chip->ecc.layout = &nand_oob_64_4bitondie;
 		chip->ecc.size = 512;
 		chip->ecc.bytes = 8;
 
@@ -3353,8 +3233,7 @@
 static int __init nand_base_init(void)
 {
 #ifdef CONFIG_DEBUG_FS
-	file_erasebb = debugfs_create_u8("nanderasebb", 0644, NULL,
-					 &nand_erasebb);
+	file_erasebb = debugfs_create_u8("nanderasebb", 0644, NULL, &erasebb);
 #endif
 
 	led_trigger_register_simple("nand-disk", &nand_led_trigger);
--- a/include/linux/mtd/nand.h	2014-05-15 10:24:39.000000000 +0200
+++ b/include/linux/mtd/nand.h	2014-05-16 01:35:09.000000000 +0200
@@ -44,8 +44,8 @@
  * is supported now. If you add a chip with bigger oobsize/page
  * adjust this accordingly.
  */
-#define NAND_MAX_OOBSIZE	576
-#define NAND_MAX_PAGESIZE	8192
+#define NAND_MAX_OOBSIZE	128
+#define NAND_MAX_PAGESIZE	4096
 
 /*
  * Constants for hardware specific CLE/ALE/NCE function
@@ -79,7 +79,6 @@
 #define NAND_CMD_RNDIN		0x85
 #define NAND_CMD_READID		0x90
 #define NAND_CMD_ERASE2		0xd0
-#define NAND_CMD_PARAM          0xec
 #define NAND_CMD_RESET		0xff
 #define NAND_CMD_SETFEATURES    0xef
 #define NAND_CMD_GETFEATURES    0xee
@@ -177,23 +176,6 @@
 /* Chip does not allow subpage writes */
 #define NAND_NO_SUBPAGE_WRITE	0x00000200
 
-/* Device is one of 'new' xD cards that expose fake nand command set */
-#define NAND_BROKEN_XD		0x00000400
-
-/* Device behaves just like nand, but is readonly */
-#define NAND_ROM                0x00000800
-
-/* Device supports cache read function */
-#define NAND_CACHERD		0x00001000
-/* Device supports multi-plane read operations */
-#define NAND_MULTIPLANE_READ	0x00002000
-/* Deivce supports multi-plane program/erase operations */
-#define NAND_MULTIPLANE_PROG_ERASE	0x00004000
-/* Deivce supports multi-LUN operations */
-#define NAND_MULTILUN		0x00008000
-/* Micron '4-bit On-die ECC' device */
-#define NAND_MICRON_4BITONDIEECC	0x00080000
-
 
 /* Options valid for Samsung large page devices */
 #define NAND_SAMSUNG_LP_OPTIONS \
@@ -209,8 +191,7 @@
 					&& (chip->page_shift > 9))
 
 /* Mask to zero out the chip options, which come from the id table */
-#define NAND_CHIPOPTIONS_MSK	(0x0000ffff & ~NAND_NO_AUTOINCR & \
-				 NAND_MICRON_4BITONDIEECC)
+#define NAND_CHIPOPTIONS_MSK	(0x0000ffff & ~NAND_NO_AUTOINCR)
 
 /* Non chip related options */
 /* Use a flash based bad block table. This option is passed to the
@@ -230,19 +211,6 @@
 #define NAND_CI_CELLTYPE_MSK	0x0C
 
 /*
- * Factory-programmed bad-block marker (BBM) flags
- */
-#define NAND_BBM_PAGE_0		0x00000001
-#define NAND_BBM_PAGE_1		0x00000002
-#define NAND_BBM_PAGE_LAST	0x00000004
-#define NAND_BBM_PAGE_LMIN2	0x00000008
-#define NAND_BBM_PAGE_ALL	0x00000010
-#define NAND_BBM_BYTE_OOB_0	0x00000020
-#define NAND_BBM_BYTE_OOB_5	0x00000040
-#define NAND_BBM_BYTE_OOB_ALL	0x00000080
-#define NAND_BBM_BYTE_ALL	0x00000100
-
-/*
  * nand_state_t - chip states
  * Enumeration for NAND flash chip state
  */
@@ -259,104 +227,6 @@
 /* Keep gcc happy */
 struct nand_chip;
 
-struct nand_onfi_params {
-	/* rev info and features block */
-	/* 'O' 'N' 'F' 'I'  */
-	u8 sig[4];
-	__le16 revision;
-	__le16 features;
-	__le16 opt_cmd;
-	u8 reserved[22];
-
-	/* manufacturer information block */
-	char manufacturer[12];
-	char model[20];
-	u8 jedec_id;
-	__le16 date_code;
-	u8 reserved2[13];
-
-	/* memory organization block */
-	__le32 byte_per_page;
-	__le16 spare_bytes_per_page;
-	__le32 data_bytes_per_ppage;
-	__le16 spare_bytes_per_ppage;
-	__le32 pages_per_block;
-	__le32 blocks_per_lun;
-	u8 lun_count;
-	u8 addr_cycles;
-	u8 bits_per_cell;
-	__le16 bb_per_lun;
-	__le16 block_endurance;
-	u8 guaranteed_good_blocks;
-	__le16 guaranteed_block_endurance;
-	u8 programs_per_page;
-	u8 ppage_attr;
-	u8 ecc_bits;
-	u8 interleaved_bits;
-	u8 interleaved_ops;
-	u8 reserved3[13];
-
-	/* electrical parameter block */
-	u8 io_pin_capacitance_max;
-	__le16 async_timing_mode;
-	__le16 program_cache_timing_mode;
-	__le16 t_prog;
-	__le16 t_bers;
-	__le16 t_r;
-	__le16 t_ccs;
-	__le16 src_sync_timing_mode;
-	__le16 src_ssync_features;
-	__le16 clk_pin_capacitance_typ;
-	__le16 io_pin_capacitance_typ;
-	__le16 input_pin_capacitance_typ;
-	u8 input_pin_capacitance_max;
-	u8 driver_strenght_support;
-	__le16 t_int_r;
-	__le16 t_ald;
-	u8 reserved4[7];
-
-	/* vendor */
-	u8 reserved5[90];
-
-	__le16 crc;
-} __attribute__((packed));
-
-#define ONFI_CRC_BASE	0x4F4E
-
-/*
- * NAND Device Timing Specification
- *
- * All values in nano seconds, except where specified.
- */
-struct nand_timing_spec {
-	int	tR;		/* Max Page Read delay [us]*/
-	int	tCLS;		/* Min CLE setup time */
-	int	tCS;		/* Min CE setup time */
-	int	tALS;		/* Min ALE setup time */
-	int	tDS;		/* Min Data setup time */
-	int	tWP;		/* Min WE pulse width */
-	int	tCLH;		/* Min CLE hold time */
-	int	tCH;		/* Min CE hold time */
-	int	tALH;		/* Min ALE hold time */
-	int	tDH;		/* Min Data hold time */
-	int	tWB;		/* Max WE high to busy */
-	int	tWH;		/* Min WE hold time */
-	int	tWC;		/* Min Write cycle time */
-	int	tRP;		/* Min RE pulse width */
-	int	tREH;		/* Min RE high hold time */
-	int	tRC;		/* Min Read cycle time */
-	int	tREA;		/* Max Read access time */
-	int	tRHOH;		/* Min RE high to output hold */
-	int	tCEA;		/* Max CE access time */
-	int	tCOH;		/* Min CE high to output hold */
-	int	tCHZ;		/* Max CE high to output high Z */
-	int	tCSD;		/* Min CE high to ALE/CLE don't care */
-};
-
-/* ONFI define 6 timing modes */
-#define NAND_ONFI_TIMING_MODES		6
-extern struct nand_timing_spec nand_onfi_timing_specs[];
-
 /**
  * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independent devices
  * @lock:               protection lock
@@ -480,23 +350,15 @@
  * @phys_erase_shift:	[INTERN] number of address bits in a physical eraseblock
  * @bbt_erase_shift:	[INTERN] number of address bits in a bbt entry
  * @chip_shift:		[INTERN] number of address bits in one chip
- * @options:		[BOARDSPECIFIC] various chip options. They can partly
- *			be set to inform nand_scan about special functionality.
- *			See the defines for further explanation.
- * @bbm:		[INTERN] Bad block marker flags
+ * @options:		[BOARDSPECIFIC] various chip options. They can partly be set to inform nand_scan about
+ *			special functionality. See the defines for further explanation
  * @badblockpos:	[INTERN] position of the bad block marker in the oob area
- * @planes_per_chip:	[INTERN] number of planes per chip
- * @luns_per_chip:	[INTERN] number of LUNs per chip
  * @cellinfo:		[INTERN] MLC/multichip data from chip ident
  * @numchips:		[INTERN] number of physical chips
  * @chipsize:		[INTERN] the size of one chip for multichip arrays
  * @pagemask:		[INTERN] page number mask = number of (pages / chip) - 1
  * @pagebuf:		[INTERN] holds the pagenumber which is currently in data_buf
  * @subpagesize:	[INTERN] holds the subpagesize
- * @onfi_version:	[INTERN] holds the chip ONFI version (BCD encoded),
- *			non 0 if ONFI supported.
- * @onfi_params:	[INTERN] holds the ONFI page parameter when ONFI is
- *			supported, 0 otherwise.
  * @ecclayout:		[REPLACEABLE] the default ecc placement scheme
  * @bbt:		[INTERN] bad block table pointer
  * @bbt_td:		[REPLACEABLE] bad block table descriptor for flash lookup
@@ -535,7 +397,6 @@
 
 	int		chip_delay;
 	unsigned int	options;
-	unsigned int	bbm;
 
 	int		page_shift;
 	int		phys_erase_shift;
@@ -548,11 +409,6 @@
 	int		subpagesize;
 	uint8_t		cellinfo;
 	int		badblockpos;
-	int		planes_per_chip;
-	int		luns_per_chip;
-
-	int onfi_version;
-	struct nand_onfi_params	onfi_params;
 
 	nand_state_t	state;
 
@@ -587,7 +443,6 @@
 #define NAND_MFR_HYNIX		0xad
 #define NAND_MFR_MICRON		0x2c
 #define NAND_MFR_AMD		0x01
-#define NAND_MFR_MACRONIX	0xc2
 
 /**
  * struct nand_flash_dev - NAND Flash Device ID Structure
@@ -622,11 +477,6 @@
 
 extern struct nand_flash_dev nand_flash_ids[];
 extern struct nand_manufacturers nand_manuf_ids[];
-extern int nand_decode_id(struct mtd_info *mtd, struct nand_chip *chip,
-			  struct nand_flash_dev *type, uint8_t *id,
-			  int max_id_len);
-extern void nand_derive_bbm(struct mtd_info *mtd, struct nand_chip *chip,
-			    uint8_t *id);
 
 /**
  * struct nand_bbt_descr - bad block table descriptor
@@ -712,17 +562,7 @@
 extern int nand_get_device(struct nand_chip *chip,
 			   struct mtd_info *mtd, int new_state);
 extern void nand_release_device(struct mtd_info *mtd);
-extern int nand_suspend(struct mtd_info *mtd);
-extern void nand_resume(struct mtd_info *mtd);
-extern void nand_sync(struct mtd_info *mtd);
-extern uint8_t *nand_transfer_oob(struct nand_chip *chip, uint8_t *oob,
-				  struct mtd_oob_ops *ops, size_t len);
-extern int nand_check_wp(struct mtd_info *mtd);
-extern uint8_t *nand_fill_oob(struct nand_chip *chip, uint8_t *oob,
-			      struct mtd_oob_ops *ops);
-extern int nand_do_write_oob(struct mtd_info *mtd, loff_t to,
-			     struct mtd_oob_ops *ops);
-extern u8 nand_erasebb;
+
 
 /*
 * Constants for oob configuration
--- a/drivers/mtd/nand/nand_ids.c	2014-05-15 10:24:39.000000000 +0200
+++ b/drivers/mtd/nand/nand_ids.c	2009-12-03 04:51:21.000000000 +0100
@@ -73,24 +73,17 @@
 #define LP_OPTIONS (NAND_SAMSUNG_LP_OPTIONS | NAND_NO_READRDY | NAND_NO_AUTOINCR)
 #define LP_OPTIONS16 (LP_OPTIONS | NAND_BUSWIDTH_16)
 
-	/* 512 Megabit */
+	/*512 Megabit */
 	{"NAND 64MiB 1,8V 8-bit",	0xA2, 0,  64, 0, LP_OPTIONS},
-	{"NAND 64MiB 1,8V 8-bit",	0xA0, 0,  64, 0, LP_OPTIONS},
 	{"NAND 64MiB 3,3V 8-bit",	0xF2, 0,  64, 0, LP_OPTIONS},
-	{"NAND 64MiB 3,3V 8-bit",	0xD0, 0,  64, 0, LP_OPTIONS},
-	{"NAND 64MiB 3,3V 8-bit",	0xF0, 0,  64, 0, LP_OPTIONS},
 	{"NAND 64MiB 1,8V 16-bit",	0xB2, 0,  64, 0, LP_OPTIONS16},
-	{"NAND 64MiB 1,8V 16-bit",	0xB0, 0,  64, 0, LP_OPTIONS16},
 	{"NAND 64MiB 3,3V 16-bit",	0xC2, 0,  64, 0, LP_OPTIONS16},
-	{"NAND 64MiB 3,3V 16-bit",	0xC0, 0,  64, 0, LP_OPTIONS16},
 
 	/* 1 Gigabit */
 	{"NAND 128MiB 1,8V 8-bit",	0xA1, 0, 128, 0, LP_OPTIONS},
 	{"NAND 128MiB 3,3V 8-bit",	0xF1, 0, 128, 0, LP_OPTIONS},
-	{"NAND 128MiB 3,3V 8-bit",	0xD1, 0, 128, 0, LP_OPTIONS},
 	{"NAND 128MiB 1,8V 16-bit",	0xB1, 0, 128, 0, LP_OPTIONS16},
 	{"NAND 128MiB 3,3V 16-bit",	0xC1, 0, 128, 0, LP_OPTIONS16},
-	{"NAND 128MiB 1,8V 16-bit",     0xAD, 0, 128, 0, LP_OPTIONS16},
 
 	/* 2 Gigabit */
 	{"NAND 256MiB 1,8V 8-bit",	0xAA, 0, 256, 0, LP_OPTIONS},
@@ -116,36 +109,6 @@
 	{"NAND 2GiB 1,8V 16-bit",	0xB5, 0, 2048, 0, LP_OPTIONS16},
 	{"NAND 2GiB 3,3V 16-bit",	0xC5, 0, 2048, 0, LP_OPTIONS16},
 
-	/* 32 Gigabit */
-	{"NAND 4GiB 1,8V 8-bit",	0xA7, 0, 4096, 0, LP_OPTIONS},
-	{"NAND 4GiB 3,3V 8-bit",	0xD7, 0, 4096, 0, LP_OPTIONS},
-	{"NAND 4GiB 1,8V 16-bit",	0xB7, 0, 4096, 0, LP_OPTIONS16},
-	{"NAND 4GiB 3,3V 16-bit",	0xC7, 0, 4096, 0, LP_OPTIONS16},
-
-	/* 64 Gigabit */
-	{"NAND 8GiB 1,8V 8-bit",	0xAE, 0, 8192, 0, LP_OPTIONS},
-	{"NAND 8GiB 3,3V 8-bit",	0xDE, 0, 8192, 0, LP_OPTIONS},
-	{"NAND 8GiB 1,8V 16-bit",	0xBE, 0, 8192, 0, LP_OPTIONS16},
-	{"NAND 8GiB 3,3V 16-bit",	0xCE, 0, 8192, 0, LP_OPTIONS16},
-
-	/* 128 Gigabit */
-	{"NAND 16GiB 1,8V 8-bit",	0x1A, 0, 16384, 0, LP_OPTIONS},
-	{"NAND 16GiB 3,3V 8-bit",	0x3A, 0, 16384, 0, LP_OPTIONS},
-	{"NAND 16GiB 1,8V 16-bit",	0x2A, 0, 16384, 0, LP_OPTIONS16},
-	{"NAND 16GiB 3,3V 16-bit",	0x4A, 0, 16384, 0, LP_OPTIONS16},
-
-	/* 256 Gigabit */
-	{"NAND 32GiB 1,8V 8-bit",	0x1C, 0, 32768, 0, LP_OPTIONS},
-	{"NAND 32GiB 3,3V 8-bit",	0x3C, 0, 32768, 0, LP_OPTIONS},
-	{"NAND 32GiB 1,8V 16-bit",	0x2C, 0, 32768, 0, LP_OPTIONS16},
-	{"NAND 32GiB 3,3V 16-bit",	0x4C, 0, 32768, 0, LP_OPTIONS16},
-
-	/* 512 Gigabit */
-	{"NAND 64GiB 1,8V 8-bit",	0x1E, 0, 65536, 0, LP_OPTIONS},
-	{"NAND 64GiB 3,3V 8-bit",	0x3E, 0, 65536, 0, LP_OPTIONS},
-	{"NAND 64GiB 1,8V 16-bit",	0x2E, 0, 65536, 0, LP_OPTIONS16},
-	{"NAND 64GiB 3,3V 16-bit",	0x4E, 0, 65536, 0, LP_OPTIONS16},
-
 	/*
 	 * Renesas AND 1 Gigabit. Those chips do not support extended id and
 	 * have a strange page/block layout !  The chosen minimum erasesize is
@@ -177,664 +140,12 @@
 	{NAND_MFR_HYNIX, "Hynix"},
 	{NAND_MFR_MICRON, "Micron"},
 	{NAND_MFR_AMD, "AMD"},
-	{NAND_MFR_MACRONIX, "Macronix"},
 	{0x0, "Unknown"}
 };
 
 EXPORT_SYMBOL(nand_manuf_ids);
 EXPORT_SYMBOL(nand_flash_ids);
 
-/*
- * ONFI NAND Timing Mode Specifications
- *
- * Note, 'tR' field (maximum page read time) is extracted from the ONFI
- * parameter page during device probe.
- */
-struct nand_timing_spec nand_onfi_timing_specs[] = {
-	/*
-	 * ONFI Timing Mode '0' (supported on all ONFI compliant devices)
-	 */
-	[0] = {
-		.tCLS	= 50,
-		.tCS	= 70,
-		.tALS	= 50,
-		.tDS	= 40,
-		.tWP	= 50,
-		.tCLH	= 20,
-		.tCH	= 20,
-		.tALH	= 20,
-		.tDH	= 20,
-		.tWB	= 200,
-		.tWH	= 30,
-		.tWC	= 100,
-		.tRP	= 50,
-		.tREH	= 30,
-		.tRC	= 100,
-		.tREA	= 40,
-		.tRHOH	= 0,
-		.tCEA	= 100,
-		.tCOH	= 0,
-		.tCHZ	= 100,
-	},
-
-	/*
-	 * ONFI Timing Mode '1'
-	 */
-	[1] = {
-		.tCLS	= 25,
-		.tCS	= 35,
-		.tALS	= 25,
-		.tDS	= 20,
-		.tWP	= 25,
-		.tCLH	= 10,
-		.tCH	= 10,
-		.tALH	= 10,
-		.tDH	= 10,
-		.tWB	= 100,
-		.tWH	= 15,
-		.tWC	= 45,
-		.tRP	= 25,
-		.tREH	= 15,
-		.tRC	= 50,
-		.tREA	= 30,
-		.tRHOH	= 15,
-		.tCEA	= 45,
-		.tCOH	= 15,
-		.tCHZ	= 50,
-	},
-
-	/*
-	 * ONFI Timing Mode '2'
-	 */
-	[2] = {
-		.tCLS	= 15,
-		.tCS	= 25,
-		.tALS	= 15,
-		.tDS	= 15,
-		.tWP	= 17,
-		.tCLH	= 10,
-		.tCH	= 10,
-		.tALH	= 10,
-		.tDH	= 5,
-		.tWB	= 100,
-		.tWH	= 15,
-		.tWC	= 35,
-		.tRP	= 17,
-		.tREH	= 16,
-		.tRC	= 35,
-		.tREA	= 25,
-		.tRHOH	= 15,
-		.tCEA	= 30,
-		.tCOH	= 15,
-		.tCHZ	= 50,
-	},
-
-	/*
-	 * ONFI Timing Mode '3'
-	 */
-	[3] = {
-		.tCLS	= 10,
-		.tCS	= 25,
-		.tALS	= 10,
-		.tDS	= 10,
-		.tWP	= 15,
-		.tCLH	= 5,
-		.tCH	= 5,
-		.tALH	= 5,
-		.tDH	= 5,
-		.tWB	= 100,
-		.tWH	= 10,
-		.tWC	= 30,
-		.tRP	= 15,
-		.tREH	= 10,
-		.tRC	= 30,
-		.tREA	= 20,
-		.tRHOH	= 15,
-		.tCEA	= 25,
-		.tCOH	= 15,
-		.tCHZ	= 50,
-	},
-
-	/*
-	 * ONFI Timing Mode '4' (EDO only)
-	 */
-	[4] = {
-		.tCLS	= 10,
-		.tCS	= 20,
-		.tALS	= 10,
-		.tDS	= 10,
-		.tWP	= 12,
-		.tCLH	= 5,
-		.tCH	= 5,
-		.tALH	= 5,
-		.tDH	= 5,
-		.tWB	= 100,
-		.tWH	= 10,
-		.tWC	= 25,
-		.tRP	= 12,
-		.tREH	= 10,
-		.tRC	= 25,
-		.tREA	= 20,
-		.tRHOH	= 15,
-		.tCEA	= 25,
-		.tCOH	= 15,
-		.tCHZ	= 30,
-	},
-
-	/*
-	 * ONFI Timing Mode '5' (EDO only)
-	 */
-	[5] = {
-		.tCLS	= 10,
-		.tCS	= 15,
-		.tALS	= 10,
-		.tDS	= 7,
-		.tWP	= 10,
-		.tCLH	= 5,
-		.tCH	= 5,
-		.tALH	= 5,
-		.tDH	= 5,
-		.tWB	= 100,
-		.tWH	= 7,
-		.tWC	= 20,
-		.tRP	= 10,
-		.tREH	= 7,
-		.tRC	= 20,
-		.tREA	= 16,
-		.tRHOH	= 15,
-		.tCEA	= 25,
-		.tCOH	= 15,
-		.tCHZ	= 30,
-	}
-};
-EXPORT_SYMBOL(nand_onfi_timing_specs);
-
-/*
- *	Decode READID data
- */
-
-static int nand_decode_id_2(struct mtd_info *mtd,
-			    struct nand_chip *chip,
-			    struct nand_flash_dev *type,
-			    uint8_t *id, int id_len)
-{
-	mtd->writesize = type->pagesize;
-	mtd->oobsize = type->pagesize / 32;
-	chip->chipsize = ((uint64_t)type->chipsize) << 20;
-
-	/* SPANSION/AMD (S30ML-P ORNAND) has non-standard block size */
-	if (id[0] == NAND_MFR_AMD)
-		mtd->erasesize = 512 * 1024;
-	else
-		mtd->erasesize = type->erasesize;
-
-	/* Get chip options from table */
-	chip->options &= ~NAND_CHIPOPTIONS_MSK;
-	chip->options |= type->options & NAND_CHIPOPTIONS_MSK;
-	chip->options |= NAND_NO_AUTOINCR;
-	if (mtd->writesize > 512)
-		chip->options |= NAND_NO_READRDY;
-
-	/* Assume some defaults */
-	chip->cellinfo = 0;
-	chip->planes_per_chip = 1;
-	chip->planes_per_chip = 1;
-	chip->luns_per_chip = 1;
-
-	return 0;
-}
-
-static int nand_decode_id_ext(struct mtd_info *mtd,
-			      struct nand_chip *chip,
-			      struct nand_flash_dev *type,
-			      uint8_t *id, int id_len) {
-	uint8_t data;
-
-	if (id_len < 3 || id_len > 5) {
-		pr_err("[MTD][NAND]: %s: invalid ID length [%d]\n",
-		       __func__, id_len);
-		return 1;
-	}
-
-	/* Clear chip options */
-	chip->options &= ~NAND_CHIPOPTIONS_MSK;
-
-	/* ID4: Planes/Chip Size */
-	if (id[0] == NAND_MFR_HYNIX && id_len == 5 && id[4] == 0 &&
-	    (id[1] == 0xDA || id[1] == 0xCA)) {
-		/* Non-standard decode: HY27UF082G2A, HY27UF162G2A */
-		chip->planes_per_chip = 2;
-		chip->chipsize = (128 * 1024 * 1024) * chip->planes_per_chip;
-	} else if (id[0] == NAND_MFR_HYNIX && id_len == 5 &&
-		   id[1] == 0xD5 && id[4] == 0x44) {
-		/* Non-standard decode: H27UAG8T2M */
-		chip->planes_per_chip = 2;
-		chip->chipsize = (1024UL * 1024 * 1024) * chip->planes_per_chip;
-	} else if (id_len == 5) {
-		/*   - Planes per chip: ID4[3:2] */
-		data = (id[4] >> 2) & 0x3;
-		chip->planes_per_chip = 1 << data;
-
-		if (id[0] != NAND_MFR_TOSHIBA) {
-			/*   - Plane size: ID4[6:4], multiples of 8MiB */
-			data = (id[4] >> 4) & 0x7;
-			chip->chipsize = (8 * 1024 * 1024) << data;
-			chip->chipsize *= chip->planes_per_chip;
-		} else {
-			/* Toshiba ID4 does not give plane size: get chipsize
-			 * from table */
-			chip->chipsize = (((uint64_t)type->chipsize) << 20);
-		}
-	} else {
-		/* Fall-back to table */
-		chip->planes_per_chip = 1;
-		chip->chipsize = (((uint64_t)type->chipsize) << 20);
-	}
-
-	/* ID3: Page/OOB/Block Size */
-	if (id_len >= 4) {
-		/*   - Page Size: ID3[1:0] */
-		data = id[3] & 0x3;
-		mtd->writesize = 1024 << data; /* multiples of 1k */
-
-		/*   - OOB Size: ID3[2] */
-		data = (id[3] >> 2) & 0x1;
-		mtd->oobsize = 8 << data;		/* per 512 */
-		mtd->oobsize *= mtd->writesize / 512;	/* per page */
-
-		/* TC58NVG3S0F: non-standard OOB size! */
-		if (id[0] == NAND_MFR_TOSHIBA && id[1] == 0xD3 &&
-		    id[2] == 0x90 && id[3] == 0x26 && id[4] == 0x76)
-			mtd->oobsize = 232;
-
-		/*   - Block Size: ID3[5:4] */
-		data = (id[3] >> 4) & 0x3;
-		mtd->erasesize = (64 * 1024) << data; /* multiples of 64k */
-
-		/*   - Bus Width; ID3[6] */
-		if ((id[3] >> 6) & 0x1)
-			chip->options |= NAND_BUSWIDTH_16;
-	} else {
-		/* Fall-back to table */
-		mtd->writesize = type->pagesize;
-		mtd->oobsize = type->pagesize / 32;
-		if (type->options & NAND_BUSWIDTH_16)
-			chip->options |= NAND_BUSWIDTH_16;
-	}
-
-	/* Some default 'chip' options */
-	chip->options |= NAND_NO_AUTOINCR;
-	if (chip->planes_per_chip > 1)
-		chip->options |= NAND_MULTIPLANE_READ;
-
-	if (mtd->writesize > 512)
-		chip->options |= NAND_NO_READRDY;
-
-	if (id[0] == NAND_MFR_SAMSUNG && mtd->writesize > 512)
-		chip->options |= NAND_SAMSUNG_LP_OPTIONS;
-
-	/* ID2: Package/Cell/Features */
-	/*   Note, ID2 invalid, or documented as "don't care" on certain devices
-	 *   (assume some defaults)
-	 */
-	if (id_len == 4 && id[0] == NAND_MFR_HYNIX &&
-	    (id[1] == 0xF1 || id[1] == 0xC1 || id[1] == 0xA1 || id[1] == 0xAD ||
-	     id[1] == 0xDA || id[1] == 0xCA)) {
-		/* HY27{U,S}F{08,16}1G2M;
-		 * HY27UF{08,16}2G2M
-		 */
-		chip->luns_per_chip = 1;
-		chip->cellinfo = 0;
-		chip->options |= (NAND_CACHEPRG |
-				  NAND_CACHERD |
-				  NAND_COPYBACK);
-	} else if (id_len == 4 && id[0] == NAND_MFR_MICRON &&
-		   (id[1] == 0xDA || id[1] == 0xCA || id[1] == 0xDC ||
-		    id[1] == 0xCC || id[1] == 0xAA || id[1] == 0xBA)) {
-		/* MT29F2G{08,16}AAB;
-		 * MT29F4G{08,16}BAB;
-		 * MT29F2G{08,16}A{A,B}C;
-		 * MT29F4G08BAC
-		 */
-		chip->luns_per_chip = 1;
-		chip->cellinfo = 0;
-		chip->options |= (NAND_CACHEPRG |
-				  NAND_CACHERD |
-				  NAND_COPYBACK);
-	} else if (id_len == 4 && id[0] == NAND_MFR_SAMSUNG &&
-		   (id[1] == 0xF1 || id[1] == 0xA1)) {
-		/* K9F1G08{U,Q}A */
-		chip->luns_per_chip = 1;
-		chip->cellinfo = 0;
-		chip->options |= (NAND_CACHEPRG |
-				  NAND_CACHERD |
-				  NAND_COPYBACK);
-	} else {
-		/*   - LUNs: ID2[1:0] */
-		data = id[2] & 0x3;
-		chip->luns_per_chip = 0x1 << data;
-
-		/*   - Interleave: ID2[6] */
-		if ((id[2] >> 6) & 0x1)
-			chip->options |= NAND_MULTILUN;
-
-		/*   - Cache Program: ID2[7] */
-		if ((id[2] >> 7) & 0x1)
-			chip->options |= NAND_CACHEPRG;
-
-		/*   - Copy to 'cellinfo' */
-		chip->cellinfo = id[2];
-	}
-
-	return 0;
-}
-
-static int nand_decode_id_6(struct mtd_info *mtd,
-			    struct nand_chip *chip,
-			    struct nand_flash_dev *type,
-			    uint8_t *id, int id_len) {
-	uint8_t data;
-
-	if (id_len != 6) {
-		pr_err("[MTD][NAND]: %s: invalid ID length [%d]\n",
-		       __func__, id_len);
-		return 1;
-	}
-
-	chip->chipsize = (((uint64_t)type->chipsize) << 20);
-
-	/* ID4: Planes */
-	/*   - Number: ID4[3:2] */
-	data = (id[4] >> 2) & 0x3;
-	chip->planes_per_chip = 1 << data;
-
-	/* ID3: Page/OOB/Block Size */
-	/*   - Page Size:  ID3[1:0] */
-	data = id[3] & 0x3;
-	mtd->writesize = 2048 << data; /* multiples of 2k */
-
-	/*   - OOB Size: ID3[6,3:2] */
-	data = ((id[3] >> 4) & 0x4) | ((id[3] >> 2) & 0x3);
-	if (id[0] == NAND_MFR_SAMSUNG) {
-		switch (data) {
-		case 1:
-			mtd->oobsize = 128;
-			break;
-		case 2:
-			mtd->oobsize = 218;
-			break;
-		case 3:
-			mtd->oobsize = 400;
-			break;
-		case 4:
-			mtd->oobsize = 436;
-			break;
-		case 5:
-			mtd->oobsize = 640;
-			break;
-		default:
-			pr_err("[MTD][NAND]: %s: unknown OOB size\n",
-			       __func__);
-			return 1;
-			break;
-		}
-	} else {
-		switch (data) {
-		case 0:
-			mtd->oobsize = 128;
-			break;
-		case 1:
-			mtd->oobsize = 224;
-			break;
-		case 2:
-			mtd->oobsize = 448;
-			break;
-		default:
-			pr_err("[MTD][NAND]: %s: unknown OOB size\n",
-			       __func__);
-			break;
-		}
-	}
-
-	/*   - Block Size: ID3[7,5:4] */
-	data = ((id[3] >> 5) & 0x4) | ((id[3] >> 4) & 0x3);
-	switch (data) {
-	case 0:
-	case 1:
-	case 2:
-		mtd->erasesize = (128 * 1024) << data;
-		break;
-	case 3:
-		if (id[0] == NAND_MFR_SAMSUNG)
-			mtd->erasesize = (1024 * 1024);
-		else
-			mtd->erasesize = (768 * 1024);
-		break;
-	case 4:
-	case 5:
-		mtd->erasesize = (1024 * 1024) << (data - 4);
-		break;
-	default:
-		pr_err("[MTD][NAND]: %s: unknown block size\n",
-		       __func__);
-		return 1;
-		break;
-	}
-
-	/* Some default 'chip' options */
-	chip->options &= ~NAND_CHIPOPTIONS_MSK;
-	chip->options |= NAND_NO_AUTOINCR;
-	if (chip->planes_per_chip > 1)
-		chip->options |= NAND_MULTIPLANE_READ;
-
-	if (mtd->writesize > 512)
-		chip->options |= NAND_NO_READRDY;
-
-	if (id[0] == NAND_MFR_SAMSUNG && mtd->writesize > 512)
-		chip->options |= NAND_SAMSUNG_LP_OPTIONS;
-
-	/* ID2: Package/Cell/Features */
-	/*   - LUNs: ID2[1:0] */
-	data = id[2] & 0x3;
-	chip->luns_per_chip = 0x1 << data;
-
-	/*   - Interleave: ID2[6] */
-	if ((id[2] >> 6) & 0x1)
-		chip->options |= NAND_MULTILUN;
-
-	/*   - Cache Program: ID2[7] */
-	if ((id[2] >> 7) & 0x1)
-		chip->options |= NAND_CACHEPRG;
-
-	/*   - Copy to 'cellinfo' */
-	chip->cellinfo = id[2];
-
-	/* Bus Width, from table */
-	chip->options |= (type->options & NAND_BUSWIDTH_16);
-
-	return 0;
-}
-
-
-/*
- * Heuristics for manufacturer-programmed bad-block marker (BBM) schemes
- */
-void nand_derive_bbm(struct mtd_info *mtd, struct nand_chip *chip, uint8_t *id)
-{
-	int bits_per_cell = ((chip->cellinfo >> 2) & 0x3) + 1;
-
-	/*
-	 * Some special cases first...
-	 */
-
-	/* Hynix HY27US1612{1,2}B: 3rd word for x16 device! */
-	if (id[0] == NAND_MFR_HYNIX && id[1] == 0x56) {
-		chip->bbm = (NAND_BBM_PAGE_0 |
-			     NAND_BBM_PAGE_1 |
-			     NAND_BBM_BYTE_OOB_5);
-		goto set_bbt_options;
-	}
-
-	/* Hynix MLC VLP: last and last-2 pages, byte 0 */
-	if (id[0] == NAND_MFR_HYNIX && bits_per_cell == 2 &&
-	    mtd->writesize == 4096) {
-		chip->bbm = (NAND_BBM_PAGE_LAST |
-			     NAND_BBM_PAGE_LMIN2 |
-			     NAND_BBM_BYTE_OOB_0);
-		goto set_bbt_options;
-	}
-
-	/* Numonyx/ST 2K/4K pages, x8 bus use BOTH byte 0 and 5 (drivers may
-	 * need to disable 'byte 5' depending on ECC layout)
-	 */
-	if (!(chip->options & NAND_BUSWIDTH_16) &&
-	    mtd->writesize >= 2048 && id[0] == NAND_MFR_STMICRO) {
-		chip->bbm =  (NAND_BBM_PAGE_0 |
-			      NAND_BBM_BYTE_OOB_0 |
-			      NAND_BBM_BYTE_OOB_5);
-		goto set_bbt_options;
-	}
-
-	/* Samsung and Hynix MLC NAND: last page, byte 0; and 1st page for 8KiB
-	 * page devices */
-	if ((id[0] == NAND_MFR_SAMSUNG || id[0] == NAND_MFR_HYNIX) &&
-	    bits_per_cell == 2) {
-		chip->bbm = NAND_BBM_PAGE_LAST | NAND_BBM_BYTE_OOB_0;
-		if (mtd->writesize == 8192)
-			chip->bbm |= NAND_BBM_PAGE_0;
-		goto set_bbt_options;
-	}
-
-	/* Micron 2KiB page devices use 1st and 2nd page, byte 0 */
-	if (id[0] == NAND_MFR_MICRON && mtd->writesize == 2048) {
-		chip->bbm = NAND_BBM_PAGE_0 | NAND_BBM_PAGE_1 |
-			NAND_BBM_BYTE_OOB_0;
-		goto set_bbt_options;
-	}
-
-
-	/*
-	 * For the rest...
-	 */
-
-	/* Scan at least the first page */
-	chip->bbm = NAND_BBM_PAGE_0;
-	/* Also 2nd page for SLC Samsung, Hynix, Toshiba (LP), AMD/Spansion */
-	if (bits_per_cell == 1 &&
-	    (id[0] == NAND_MFR_SAMSUNG ||
-	     id[0] == NAND_MFR_HYNIX ||
-	     id[0] == NAND_MFR_AMD ||
-	     (id[0] == NAND_MFR_TOSHIBA && mtd->writesize > 512)))
-		chip->bbm |= NAND_BBM_PAGE_1;
-
-	/* SP x8 devices use 6th byte OOB; everything else uses 1st byte OOB */
-	if (mtd->writesize == 512 && !(chip->options & NAND_BUSWIDTH_16))
-		chip->bbm |= NAND_BBM_BYTE_OOB_5;
-	else
-		chip->bbm |= NAND_BBM_BYTE_OOB_0;
-
- set_bbt_options:
-	/* Set BBT chip->options, for backwards compatibility */
-	if (chip->bbm & NAND_BBM_PAGE_ALL)
-		chip->options |= NAND_BBT_SCANALLPAGES;
-
-	if (chip->bbm & NAND_BBM_PAGE_1)
-		chip->options |= NAND_BBT_SCAN2NDPAGE;
-
-	/* Set the bad block position */
-	if (mtd->writesize > 512 || (chip->options & NAND_BUSWIDTH_16))
-		chip->badblockpos = NAND_LARGE_BADBLOCK_POS;
-	else
-		chip->badblockpos = NAND_SMALL_BADBLOCK_POS;
-
-	return;
-}
-EXPORT_SYMBOL(nand_derive_bbm);
-
-/*
- * Find the length of the 'READID' string.  It is assumed that the length can be
- * determined by looking for repeated sequences, or that the device returns
- * 0x00's after the string has been returned.
- */
-static int nand_get_id_len(uint8_t *id, int max_id_len)
-{
-	int i, len;
-
-	/* Determine signature length by looking for repeats */
-	for (len = 2; len < max_id_len; len++) {
-		for (i = len; i < max_id_len; i++)
-			if (id[i] != id[i % len])
-				break;
-
-		if (i == max_id_len)
-			break;
-	}
-
-	/* No repeats found, look for trailing 0x00s */
-	if (len == max_id_len) {
-		while (len > 2 && id[len - 1] == 0x00)
-			len--;
-	}
-
-	/*
-	 * Some Toshiba devices return additional, undocumented, READID bytes
-	 * (e.g. TC58NVG3S0F).  Cap ID length to 5 bytes.
-	 */
-	if (id[0] == NAND_MFR_TOSHIBA && len > 5)
-		len = 5;
-
-	/*
-	 * Some Samsung devices return 'NAND_MFR_SAMSUNG' as a 6th READID
-	 * byte. (e.g. K9F4G08U0D). Use ID length of 5 bytes.
-	 */
-	if (id[0] == NAND_MFR_SAMSUNG && len == 6 &&
-	    id[5] == NAND_MFR_SAMSUNG && id[6] == NAND_MFR_SAMSUNG)
-		len = 5;
-
-	return len;
-}
-
-/*
- * Determine device properties by decoding the 'READID' string
- */
-int nand_decode_id(struct mtd_info *mtd,
-		   struct nand_chip *chip,
-		   struct nand_flash_dev *type,
-		   uint8_t *id, int max_id_len)
-{
-	int id_len;
-	int ret;
-
-	id_len = nand_get_id_len(id, max_id_len);
-	if (id_len == 0) {
-		pr_err("[MTD][NAND]: %s: failed to read device ID\n",
-		       __func__);
-		return 1;
-	}
-
-	/*
-	 * Decode ID string
-	 */
-	if (id_len == 2 || type->pagesize)
-		ret = nand_decode_id_2(mtd, chip, type, id, id_len);
-	else if (id_len <= 5)
-		ret = nand_decode_id_ext(mtd, chip, type, id, id_len);
-	else if (id_len == 6)
-		ret = nand_decode_id_6(mtd, chip, type, id, id_len);
-	else
-		ret = 1;
-
-	if (ret) {
-		pr_err("[MTD][NAND]: %s: failed to decode NAND "
-		       "device ID\n", __func__);
-		return ret;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(nand_decode_id);
-
-
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Thomas Gleixner <tglx@linutronix.de>");
 MODULE_DESCRIPTION("Nand device & manufacturer IDs");
--- a/drivers/mtd/maps/physmap.c	2014-05-15 10:24:39.000000000 +0200
+++ b/drivers/mtd/maps/physmap.c	2009-12-03 04:51:21.000000000 +0100
@@ -134,11 +134,6 @@
 			goto err_out;
 		}
 
-#ifdef CONFIG_MTD_COMPLEX_MAPPINGS
-		if (physmap_data->map_init)
-			physmap_data->map_init(&info->map[i]);
-		else
-#endif
 		simple_map_init(&info->map[i]);
 
 		probe_type = rom_probe_types;
--- a/drivers/mtd/nand/Kconfig	2014-05-15 10:24:39.000000000 +0200
+++ b/drivers/mtd/nand/Kconfig	2014-05-16 01:35:09.000000000 +0200
@@ -482,18 +482,6 @@
 	  This enables the driver for the NAND Flash on evaluation board based
 	  on w90p910.
 
-config MTD_NAND_STM_BCH
-	tristate "STMicroelectronics: NANDi BCH Controller"
-	help
-	  Adds support for the STMicroelectronics NANDi BCH Controller
-
-config STM_NAND_BCH_DEBUG
-	bool "NANDi BCH debug messages"
-	depends on MTD_NAND_STM_BCH
-	default n
-	help
-	  Display debug messages on the console
-
 config MTD_NAND_STM_EMI
 	tristate "STMicroelectronics: EMI 'bit-banging'"
 	depends on MTD_NAND
@@ -598,16 +586,4 @@
 	  Update the boot-mode ECC boundary from the PBL and apply to the
 	  specified NAND boot partition.
 
-config STM_NAND_SAFE_MOUNT
-	bool "STM NAND: Check for 'alien' BBTs when mounting NAND device"
-	depends on (MTD_NAND_STM_EMI || \
-		    MTD_NAND_STM_FLEX || \
-		    MTD_NAND_STM_AFM || \
-		    MTD_NAND_STM_BCH)
-	default y
-	help
-	  This option helps prevent corruption that might otherwise result from
-	  the presence of 'alien' BBTs (i.e. BBTs written by a driver different
-	  to that currently employed).
-
 endif # MTD_NAND
--- a/drivers/mtd/nand/Makefile	2014-05-15 10:24:39.000000000 +0200
+++ b/drivers/mtd/nand/Makefile	2014-05-16 01:35:09.000000000 +0200
@@ -42,7 +42,6 @@
 obj-$(CONFIG_MTD_NAND_TXX9NDFMC)	+= txx9ndfmc.o
 obj-$(CONFIG_MTD_NAND_W90P910)		+= w90p910_nand.o
 obj-$(CONFIG_MTD_NAND_NOMADIK)		+= nomadik_nand.o
-obj-$(CONFIG_MTD_NAND_STM_BCH)          += stm_nand_bch.o
 obj-$(CONFIG_MTD_NAND_STM_EMI)		+= stm_nand_emi.o
 obj-$(CONFIG_MTD_NAND_STM_FLEX)		+= stm_nand_flex.o stm_nand_ecc.o
 obj-$(CONFIG_MTD_NAND_STM_AFM)          += stm_nand_afm.o stm_nand_ecc.o
--- a/drivers/mtd/chips/cfi_cmdset_0002.c	2014-05-15 10:24:39.000000000 +0200
+++ b/drivers/mtd/chips/cfi_cmdset_0002.c	2009-12-03 04:51:21.000000000 +0100
@@ -57,8 +57,6 @@
 static int cfi_amdstd_write_buffers(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
 static int cfi_amdstd_erase_chip(struct mtd_info *, struct erase_info *);
 static int cfi_amdstd_erase_varsize(struct mtd_info *, struct erase_info *);
-static int cfi_amdstd_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
-static int cfi_amdstd_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
 static void cfi_amdstd_sync (struct mtd_info *);
 static int cfi_amdstd_suspend (struct mtd_info *);
 static void cfi_amdstd_resume (struct mtd_info *);
@@ -284,12 +282,6 @@
 	}
 }
 
-static void fixup_s29glxxxp_lock(struct mtd_info *mtd, void *param)
-{
-	mtd->lock = cfi_amdstd_lock;
-	mtd->unlock = cfi_amdstd_unlock;
-}
-
 static struct cfi_fixup cfi_fixup_table[] = {
 	{ CFI_MFR_ATMEL, CFI_ID_ANY, fixup_convert_atmel_pri, NULL },
 #ifdef AMD_BOOTLOC_BUG
@@ -306,12 +298,6 @@
 	{ CFI_MFR_AMD, 0x1301, fixup_s29gl064n_sectors, NULL, },
 	{ CFI_MFR_AMD, 0x1a00, fixup_s29gl032n_sectors, NULL, },
 	{ CFI_MFR_AMD, 0x1a01, fixup_s29gl032n_sectors, NULL, },
-
-	/* Add block lock support for S29GL---P devices */
-	{ CFI_MFR_AMD, 0x2801, fixup_s29glxxxp_lock, NULL, },
-	{ CFI_MFR_AMD, 0x2301, fixup_s29glxxxp_lock, NULL, },
-	{ CFI_MFR_AMD, 0x2201, fixup_s29glxxxp_lock, NULL, },
-	{ CFI_MFR_AMD, 0x2101, fixup_s29glxxxp_lock, NULL, },
 #if !FORCE_WORD_WRITE
 	{ CFI_MFR_ANY, CFI_ID_ANY, fixup_use_write_buffers, NULL, },
 #endif
@@ -1734,77 +1720,6 @@
 	return 0;
 }
 
-/* #define DEBUG_AMDSTD_BLOCK_XXLOCK */
-#define AMDSTD_BLOCK_LOCK		((void *) 1)
-#define AMDSTD_BLOCK_UNLOCK		((void *) 2)
-static int do_amdstd_block_xxlock(struct map_info *map, struct flchip *chip,
-				  unsigned long adr, int len, void *thunk)
-{
-	struct cfi_private *cfi = map->fldrv_priv;
-	int ret;
-
-	DEBUG(MTD_DEBUG_LEVEL3, "MTD %s(): %sLOCK 0x%08lx len %d\n",
-	      __func__, (thunk == AMDSTD_BLOCK_LOCK) ? "" : "UN", adr, len);
-
-	spin_lock(chip->mutex);
-	ret = get_chip(map, chip, adr + chip->start, FL_LOCKING);
-	if (ret)
-		goto out_unlock;
-	chip->state = FL_LOCKING;
-
-	/* DYB Command Set Entry */
-	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,
-			 cfi->device_type, NULL);
-	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi,
-			 cfi->device_type, NULL);
-	cfi_send_gen_cmd(0xE0, cfi->addr_unlock1, chip->start, map, cfi,
-			 cfi->device_type, NULL);
-
-#ifdef DEBUG_AMDSTD_BLOCK_XXLOCK
-	printk(KERN_DEBUG "%s: block lock status @ 0x%08lx = 0x%02x [BEFORE]\n",
-	       __func__, adr, cfi_read_query(map, adr));
-#endif
-
-	/* DYB Set/Clear */
-	cfi_send_gen_cmd(0xA0, cfi->addr_unlock1, chip->start, map, cfi,
-			 cfi->device_type, NULL);
-	if (thunk == AMDSTD_BLOCK_LOCK)
-		map_write(map, CMD(0x00), chip->start + adr);
-	else
-		map_write(map, CMD(0x01), chip->start + adr);
-
-#ifdef DEBUG_AMDSTD_BLOCK_XXLOCK
-	printk(KERN_DEBUG "%s: block lock status @ 0x%08lx = 0x%02x [AFTER]\n",
-	       __func__, adr, cfi_read_query(map, adr));
-#endif
-
-	/* DYB Command Set Exit */
-	cfi_send_gen_cmd(0x90, cfi->addr_unlock1, chip->start, map, cfi,
-			 cfi->device_type, NULL);
-	cfi_send_gen_cmd(0x00, cfi->addr_unlock1, chip->start, map, cfi,
-			 cfi->device_type, NULL);
-
-	chip->state = FL_READY;
-	put_chip(map, chip, adr + chip->start);
-	ret = 0;
-
-out_unlock:
-	spin_unlock(chip->mutex);
-	return ret;
-}
-
-static int cfi_amdstd_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
-{
-	return cfi_varsize_frob(mtd, do_amdstd_block_xxlock, ofs, len,
-				AMDSTD_BLOCK_LOCK);
-}
-
-static int cfi_amdstd_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
-{
-	return cfi_varsize_frob(mtd, do_amdstd_block_xxlock, ofs, len,
-				AMDSTD_BLOCK_UNLOCK);
-}
-
 static int do_atmel_lock(struct map_info *map, struct flchip *chip,
 			 unsigned long adr, int len, void *thunk)
 {
--- a/include/linux/mtd/physmap.h	2014-05-15 10:24:39.000000000 +0200
+++ b/include/linux/mtd/physmap.h	2009-12-03 04:51:21.000000000 +0100
@@ -26,9 +26,6 @@
 	unsigned int		nr_parts;
 	unsigned int		pfow_base;
 	struct mtd_partition	*parts;
-#ifdef CONFIG_MTD_COMPLEX_MAPPINGS
-	void			(*map_init)(struct map_info *);
-#endif
 };
 
 /*
--- a/drivers/mtd/nand/stm_nand_emi.c	2014-05-15 10:24:39.000000000 +0200
+++ b/drivers/mtd/nand/stm_nand_emi.c	2014-05-16 01:35:09.000000000 +0200
@@ -38,8 +38,6 @@
 #include <linux/stm/nand.h>
 #include <asm/dma.h>
 
-#include "stm_nand_bbt.h"
-
 #ifdef CONFIG_MTD_PARTITIONS
 #include <linux/mtd/partitions.h>
 #endif
@@ -485,16 +483,12 @@
 }
 
 #define GET_CLK_CYCLES(X, T)	(((X) + (T) - 1) / (T))
-
-/* Configure EMI Bank according to 'stm_nand_timing_data'
- *
- * [DEPRECATED in favour of nand_config_emi() based on 'struct nand_timing_spec'
- * data.]
- */
-static void nand_config_emi_legacy(int bank, struct stm_nand_timing_data *td)
+/* Configure EMI Bank for NAND access */
+static int nand_config_emi(int bank, struct stm_nand_timing_data *td)
 {
 	struct clk *emi_clk;
 	uint32_t emi_t_ns;
+	uint32_t emi_p_ns;
 
 	unsigned long config[4];
 
@@ -511,7 +505,7 @@
 	if (!td) {
 		printk(KERN_ERR NAME "No timing data specified in platform "
 		       "data\n");
-		return;
+		return 1;
 	}
 
 	/* Timings set in terms of EMI clock... */
@@ -524,6 +518,7 @@
 	} else {
 		emi_t_ns = 1000000000UL / clk_get_rate(emi_clk);
 	}
+	emi_p_ns = emi_t_ns / 2;
 
 	/* Convert nand timings to EMI compatible values */
 	rd_cycle = GET_CLK_CYCLES(td->rd_on + td->rd_off, emi_t_ns) + 3;
@@ -554,124 +549,25 @@
 
 	config[3] = 0x00;
 
-	pr_debug("EMI Configuration Data: {0x%08x, 0x%08x, 0x%08x, 0x%08x}\n",
-		 (unsigned int)config[0], (unsigned int)config[1],
-		 (unsigned int)config[2], (unsigned int)config[3]);
-
 	/* Configure Bank */
 	emi_bank_configure(bank, config);
 
 	/* Disable PC mode */
 	emi_config_pcmode(bank, 0);
-}
-
-/* Configure EMI Bank according to 'nand_timing_spec' */
-static void nand_config_emi(int bank, struct nand_timing_spec *spec, int relax)
-{
-	struct clk *emi_clk;
-	int tCLK;
-
-	unsigned long config[4];
-
-	uint32_t rd_cycle, rd_oee1, rd_oee2, rd_latch;
-	uint32_t wr_cycle, wr_wee1, wr_wee2;
-	uint32_t bus_release;
-	uint32_t tMAX_SETUP, tMAX_HOLD;
-
-	printk(KERN_INFO NAME ": Configuring EMI Bank %d for NAND access\n",
-	       bank);
-
-	/* Get EMI clock (default 100MHz) */
-	emi_clk = clk_get(NULL, "emi_clk");
-	if (!emi_clk || IS_ERR(emi_clk)) {
-		printk(KERN_WARNING NAME
-		       ": Failed to get EMI clock, assuming default 100MHz\n");
-		tCLK = 10;
-	} else {
-		tCLK = 1000000000 / clk_get_rate(emi_clk);
-	}
-
-	rd_cycle = (spec->tRC + tCLK - 1)/tCLK + 1 + relax;
-	rd_oee1 = 0;
-	rd_oee2 = (spec->tREH + tCLK - 1)/tCLK + relax;
-	rd_latch = (spec->tREH + tCLK - 1)/tCLK + relax;
-
-	bus_release = (spec->tCHZ + tCLK - 1)/tCLK + relax;
-
-	tMAX_SETUP = spec->tCLS;
-	if (spec->tCS > tMAX_SETUP)
-		tMAX_SETUP = spec->tCS;
-	if (spec->tALS > tMAX_SETUP)
-		tMAX_SETUP = spec->tALS;
-	if (spec->tDS > tMAX_SETUP)
-		tMAX_SETUP = spec->tDS;
-	if (spec->tWP > tMAX_SETUP)
-		tMAX_SETUP = spec->tWP;
-
-	tMAX_HOLD = spec->tCLH;
-	if (spec->tCH > tMAX_HOLD)
-		tMAX_HOLD = spec->tCH;
-	if (spec->tALH > tMAX_HOLD)
-		tMAX_HOLD = spec->tALH;
-	if (spec->tDH > tMAX_HOLD)
-		tMAX_HOLD = spec->tDH;
-	if (spec->tWH > tMAX_HOLD)
-		tMAX_HOLD = spec->tWH;
-
-	if (spec->tWC > (tMAX_SETUP + tMAX_HOLD))
-		wr_cycle = (spec->tWC + tCLK - 1)/tCLK + 1 + relax;
-	else
-		wr_cycle = (tMAX_SETUP + tMAX_HOLD + tCLK - 1)/tCLK + 1 + relax;
-	wr_wee1 = 0;
-	wr_wee2 = (tMAX_HOLD + tCLK - 1)/tCLK + relax;
-
-	config[0] = (EMI_CFG0_WE_USE_OE_CFG |
-		     EMI_CFG0_LATCH_POINT(rd_latch) |
-		     EMI_CFG0_BUS_RELEASE(bus_release) |
-		     EMI_CFG0_CS_ACTIVE(ACTIVE_CODE_RDWR) |
-		     EMI_CFG0_OE_ACTIVE(ACTIVE_CODE_RD) |
-		     EMI_CFG0_BE_ACTIVE(ACTIVE_CODE_OFF) |
-		     EMI_CFG0_PORTSIZE_8BIT |
-		     EMI_CFG0_DEVICE_NORMAL);
-
-	config[1] = (EMI_CFG1_READ_CYCLESNOTPHASE |
-		     EMI_CFG1_READ_CYCLES(rd_cycle) |
-		     EMI_CFG1_READ_OEE1(rd_oee1) |
-		     EMI_CFG1_READ_OEE2(rd_oee2));
-
-	config[2] = (EMI_CFG2_WRITE_CYCLESNOTPHASE |
-		     EMI_CFG2_WRITE_CYCLES(wr_cycle) |
-		     EMI_CFG2_WRITE_OEE1(wr_wee1) |
-		     EMI_CFG2_WRITE_OEE2(wr_wee2));
-
-	config[3] = 0;
-
-	pr_debug("EMI Configuration Data: {0x%08x, 0x%08x, 0x%08x, 0x%08x}\n",
-		 (unsigned int)config[0], (unsigned int)config[1],
-		 (unsigned int)config[2], (unsigned int)config[3]);
-
-	/* Configure Bank */
-	emi_bank_configure(bank, config);
 
-	/* Disable PC mode */
-	emi_config_pcmode(bank, 0);
+	return 0;
 }
 
 /*
  * Probe for the NAND device.
  */
-static struct stm_nand_emi * __devinit nand_probe_bank(
+static struct stm_nand_emi * __init nand_probe_bank(
 	struct stm_nand_bank_data *bank, int rbn_gpio,
-	struct platform_device *pdev)
+	const char* name)
 {
 	struct stm_nand_emi *data;
+	struct stm_nand_timing_data *tm;
 
-	/* Default EMI config data, for device probing */
-	unsigned long emi_cfg_probe[] = {
-		0x04402e99,
-		0x0a000400,
-		0x0a000400,
-		0x00000000};
 	int res = 0;
 
 	/* Allocate memory for the driver structure (and zero it) */
@@ -688,12 +584,15 @@
 		bank->emi_withinbankoffset;
 	data->emi_size = (1 << 18) + 1;
 
-	/* Configure EMI Bank for device probe */
-	emi_bank_configure(data->emi_bank, emi_cfg_probe);
-	emi_config_pcmode(data->emi_bank, 0);
+	/* Configure EMI Bank */
+	if (nand_config_emi(data->emi_bank, bank->timing_data) != 0) {
+		printk(KERN_ERR NAME ": Failed to configure EMI bank "
+		       "for NAND device\n");
+		goto out1;
+	}
 
 	/* Request IO Memory */
-	if (!request_mem_region(data->emi_base, data->emi_size, NAME)) {
+	if (!request_mem_region(data->emi_base, data->emi_size, name)) {
 		printk(KERN_ERR NAME ": Request mem 0x%x region failed\n",
 		       data->emi_base);
 		res = -ENODEV;
@@ -741,21 +640,25 @@
 	data->chip.priv = data;
 	data->mtd.priv = &data->chip;
 	data->mtd.owner = THIS_MODULE;
-	data->mtd.dev.parent = &pdev->dev;
 
 	/* Assign more sensible name (default is string from nand_ids.c!) */
-	data->mtd.name = dev_name(&pdev->dev);
+	data->mtd.name = name;
+
+	tm = bank->timing_data;
 
 	data->chip.IO_ADDR_R = data->io_base;
 	data->chip.IO_ADDR_W = data->io_base;
-	data->rbn_gpio = -1;
-	data->chip.chip_delay = 50;
+	data->chip.chip_delay = tm->chip_delay;
 	data->chip.cmd_ctrl = nand_cmd_ctrl_emi;
 
 	/* Do we have access to NAND_RBn? */
 	if (gpio_is_valid(rbn_gpio)) {
 		data->rbn_gpio = rbn_gpio;
 		data->chip.dev_ready = nand_device_ready;
+	} else {
+		data->rbn_gpio = -1;
+		if (data->chip.chip_delay == 0)
+			data->chip.chip_delay = 30;
 	}
 
 	/* Set IO routines for acessing NAND pages */
@@ -786,61 +689,13 @@
 	/* Copy chip options from platform data */
 	data->chip.options = bank->options;
 
-	data->chip.scan_bbt = stmnand_scan_bbt;
-
-	/* Scan to find existence of device */
-	if (nand_scan_ident(&data->mtd, 1) != 0) {
+	/* Scan to find existance of the device */
+	if (nand_scan(&data->mtd, 1)) {
 		printk(KERN_ERR NAME ": nand_scan failed\n");
-		res = -ENODEV;
-		goto out6;
-	}
-
-	/*
-	 * Configure timing registers
-	 */
-	if (bank->timing_spec) {
-		printk(KERN_INFO NAME ": Using platform timing data\n");
-		nand_config_emi(data->emi_bank, bank->timing_spec,
-				bank->timing_relax);
-		data->chip.chip_delay = bank->timing_spec->tR;
-	} else if (bank->timing_data) {
-		printk(KERN_INFO NAME ": Using legacy platform timing data\n");
-		nand_config_emi_legacy(data->emi_bank, bank->timing_data);
-		data->chip.chip_delay = bank->timing_data->chip_delay;
-	} else if (data->chip.onfi_version) {
-		struct nand_onfi_params *onfi = &data->chip.onfi_params;
-		int mode;
-
-		mode = fls(le16_to_cpu(onfi->async_timing_mode)) - 1;
-		/* Modes 4 and 5 (EDO) are not supported on our H/W */
-		if (mode > 3)
-			mode = 3;
-
-		printk(KERN_INFO NAME ": Using ONFI Timing Mode %d\n", mode);
-		nand_config_emi(data->emi_bank, &nand_onfi_timing_specs[mode],
-				bank->timing_relax);
-		data->chip.chip_delay = le16_to_cpu(data->chip.onfi_params.t_r);
-	} else {
-		printk(KERN_WARNING NAME ": No timing data available\n");
-	}
-
-	/* Complete scan */
-	if (nand_scan_tail(&data->mtd) != 0) {
 		res = -ENXIO;
 		goto out6;
 	}
 
-	/* If all blocks are marked bad, mount as "recovery" partition */
-	if (stmnand_blocks_all_bad(&data->mtd)) {
-		printk(KERN_ERR NAME ": initiating NAND Recovery Mode\n");
-		data->mtd.name = "NAND RECOVERY MODE";
-		res = add_mtd_device(&data->mtd);
-		if (res)
-			goto out6;
-
-		return data;
-	}
-
 #ifdef CONFIG_MTD_PARTITIONS
 	res = parse_mtd_partitions(&data->mtd, part_probes, &data->parts, 0);
 	if (res > 0) {
@@ -877,36 +732,14 @@
 	return ERR_PTR(res);
 }
 
-static void nand_remove_bank(struct stm_nand_emi *emi,
-			     struct stm_nand_bank_data *data)
-{
-	nand_release(&emi->mtd);
-
-#ifdef CONFIG_MTD_PARTITIONS
-	if (emi->parts && emi->parts != data->partitions)
-		kfree(emi->parts);
-#endif
-	iounmap(emi->io_addr);
-	iounmap(emi->io_cmd);
-#ifdef CONFIG_STM_NAND_EMI_CACHED
-	iounmap(emi->io_data);
-#endif
-	iounmap(emi->io_base);
-	release_mem_region(emi->emi_base, emi->emi_size);
-#ifdef CONFIG_STM_NAND_EMI_FDMA
-	exit_fdma_nand(emi);
-#endif
-	kfree(emi);
-}
-
-static int __devinit stm_nand_emi_probe(struct platform_device *pdev)
+static int __devinit stm_nand_emi_probe(struct platform_device *pdev)
 {
 	struct stm_plat_nand_emi_data *pdata = pdev->dev.platform_data;
-	struct stm_nand_emi_group *group;
-	struct stm_nand_emi *emi;
-	int err;
+	int res;
 	int n;
 	int rbn_gpio;
+	struct stm_nand_emi_group *group;
+	struct stm_nand_bank_data *bank;
 
 	group = kzalloc(sizeof(struct stm_nand_emi_group) +
 			(sizeof(struct stm_nand_emi *) * pdata->nr_banks),
@@ -916,8 +749,8 @@
 
 	rbn_gpio = pdata->emi_rbn_gpio;
 	if (gpio_is_valid(rbn_gpio)) {
-		err = gpio_request(rbn_gpio, "nand_RBn");
-		if (err == 0) {
+		res = gpio_request(rbn_gpio, "nand_RBn");
+		if (res == 0) {
 			gpio_direction_input(rbn_gpio);
 		} else {
 			dev_err(&pdev->dev, "nand_rbn unavailable. "
@@ -929,32 +762,16 @@
 	group->rbn_gpio = rbn_gpio;
 	group->nr_banks = pdata->nr_banks;
 
-	for (n = 0; n < pdata->nr_banks; n++) {
-		emi = nand_probe_bank(&pdata->banks[n], rbn_gpio, pdev);
-
-		if (IS_ERR(emi)) {
-			err = PTR_ERR(emi);
-			goto err1;
-		}
-
-		group->banks[n] = emi;
+	bank = pdata->banks;
+	for (n=0; n<pdata->nr_banks; n++) {
+		group->banks[n] = nand_probe_bank(bank, rbn_gpio,
+						  dev_name(&pdev->dev));
+		bank++;
 	}
 
 	platform_set_drvdata(pdev, group);
 
 	return 0;
-
- err1:
-	while (--n > 0)
-		nand_remove_bank(group->banks[n], &pdata->banks[n]);
-
-	if (gpio_is_valid(group->rbn_gpio))
-		gpio_free(group->rbn_gpio);
-
-	platform_set_drvdata(pdev, NULL);
-	kfree(group);
-
-	return err;
 }
 
 /*
@@ -963,11 +780,33 @@
 static int __devexit stm_nand_emi_remove(struct platform_device *pdev)
 {
 	struct stm_nand_emi_group *group = platform_get_drvdata(pdev);
+#ifdef CONFIG_MTD_PARTITIONS
 	struct stm_plat_nand_emi_data *pdata = pdev->dev.platform_data;
+#endif
 	int n;
 
-	for (n = 0; n < group->nr_banks; n++)
-		nand_remove_bank(group->banks[n], &pdata->banks[n]);
+	for (n=0; n<group->nr_banks; n++) {
+		struct stm_nand_emi *data = group->banks[n];
+
+		nand_release(&data->mtd);
+
+#ifdef CONFIG_MTD_PARTITIONS
+		if (data->parts && data->parts != pdata->banks[n].partitions)
+			kfree(data->parts);
+#endif
+
+		iounmap(data->io_addr);
+		iounmap(data->io_cmd);
+#ifdef CONFIG_STM_NAND_EMI_CACHED
+		iounmap(data->io_data);
+#endif
+		iounmap(data->io_base);
+		release_mem_region(data->emi_base, data->emi_size);
+#ifdef CONFIG_STM_NAND_EMI_FDMA
+		exit_fdma_nand(data);
+#endif
+		kfree(data);
+	}
 
 	if (gpio_is_valid(group->rbn_gpio))
 		gpio_free(group->rbn_gpio);

