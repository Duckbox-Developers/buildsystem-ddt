*** a/arch/sh/kernel/setup.c	2011-01-05 10:45:31.000000000 +0100
--- b/setup.c	2011-01-22 12:22:31.340928000 +0100
***************
*** 388,393 ****
--- 388,421 ----
  #endif
  #endif
  
+ 	{
+ 	char org_command_line[] = "console=ttyAS0,115200 root=/dev/mtdblock6";
+ 	char tdt_command_line[] = "console=ttyAS0,115200 root=/dev/mtdblock9 rw rootfstype=jffs2 init=/bin/devinit coprocessor_mem=4m@0x40000000,4m@0x40400000 printk=1 panic=2 stmmaceth=ethaddr:";
+ 	char mac[] = "00:00:00:00:00:00";
+ 	int command_line_len = strlen(command_line);
+ 	int org_command_line_len = strlen(org_command_line);
+ 
+ 	if(command_line_len >= org_command_line_len && !strncmp(command_line, org_command_line, org_command_line_len))
+ 	{
+ 		int i;
+ 		for(i = 0; i < (command_line_len - 7); i++)
+ 		{
+ 			if(!strncmp(command_line + i, "ethaddr", 7))
+ 			{
+ 				strlcpy(mac, command_line + i + 8, sizeof(mac));
+ 				break;
+ 			}
+ 			if(!strncmp(command_line + i, "hwaddr", 6))
+ 			{
+ 				strlcpy(mac, command_line + i + 7, sizeof(mac));
+ 				break;
+ 			}
+ 		}
+ 		strlcpy(command_line, tdt_command_line, sizeof(command_line));
+ 		strlcat(command_line, mac, sizeof(command_line));
+ 	}
+ 	}
+ 
  	/* Save unparsed command line copy for /proc/cmdline */
  	memcpy(boot_command_line, command_line, COMMAND_LINE_SIZE);
  	*cmdline_p = command_line;
--- linux-sh4/drivers/mtd/chips/cfi_util.c.org	2012-04-11 14:50:46.000000000 +0200
+++ linux-sh4/drivers/mtd/chips/cfi_util.c	2012-07-15 11:36:33.220376415 +0200
@@ -83,7 +83,7 @@
 	cfi_send_gen_cmd(0xFF, 0, base, map, cfi, cfi->device_type, NULL);
 	/* M29W128G flashes require an additional reset command
 	   when exit qry mode */
-	if ((cfi->mfr == CFI_MFR_ST) && (cfi->id == 0x227E || cfi->id == 0x7E))
+	if ((cfi->mfr == CFI_MFR_ST || cfi->mfr == 0x7F /* kdhong for EON */) && (cfi->id == 0x227E || cfi->id == 0x7E))
 		cfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);
 }
 EXPORT_SYMBOL_GPL(cfi_qry_mode_off);
--- linux-sh4/drivers/mtd/nand/nand_ids.c.org	2009-12-03 04:51:21.000000000 +0100
+++ linux-sh4/drivers/mtd/nand/nand_ids.c	2012-07-15 11:36:36.116376322 +0200
@@ -82,6 +82,7 @@
 	/* 1 Gigabit */
 	{"NAND 128MiB 1,8V 8-bit",	0xA1, 0, 128, 0, LP_OPTIONS},
 	{"NAND 128MiB 3,3V 8-bit",	0xF1, 0, 128, 0, LP_OPTIONS},
+	{"NAND 128MiB 3,3V 8-bit",	0xD1, 0, 128, 0, LP_OPTIONS},    /* added by kdhong */
 	{"NAND 128MiB 1,8V 16-bit",	0xB1, 0, 128, 0, LP_OPTIONS16},
 	{"NAND 128MiB 3,3V 16-bit",	0xC1, 0, 128, 0, LP_OPTIONS16},
 
--- a/arch/sh/boards/mach-hdk7105/setup.c	2012-07-07 18:39:46.000000000 +0200
+++ b/setup.c	2012-07-10 12:47:07.000000000 +0200
@@ -14,154 +14,222 @@
 #include <linux/platform_device.h>
 #include <linux/delay.h>
 #include <linux/io.h>
-#include <linux/leds.h>
-#include <linux/lirc.h>
 #include <linux/gpio.h>
 #include <linux/phy.h>
 #include <linux/tm1668.h>
 #include <linux/stm/platform.h>
 #include <linux/stm/stx7105.h>
-#include <linux/stm/pci-glue.h>
 #include <linux/stm/emi.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/physmap.h>
+#include <linux/stm/pci-glue.h>
 #include <linux/mtd/nand.h>
 #include <linux/mtd/partitions.h>
-#include <linux/spi/spi.h>
 #include <linux/spi/flash.h>
 #include <asm/irq-ilc.h>
+#include <linux/bpa2.h>
 
-/*
- * Flash setup depends on boot-device:
- *
- * boot-from-       | NOR                NAND	            SPI
- * ----------------------------------------------------------------------------
- * JE2 (CS routing) | 0 (EMIA->NOR_CS)   1 (EMIA->NAND_CS)  0
- *                  |   (EMIB->NOR_CS)     (EMIB->NOR_CS)     (EMIB->NOR_CS)
- *                  |   (EMIC->NAND_CS)    (EMIC->NOR_CS)     (EMIC->NAND_CS)
- * JE3 (data width) | 0 (16bit)          1 (8bit)           N/A
- * JE5 (mode 15)    | 0 (boot NOR)       1 (boot NAND)	    0 (boot SPI)
- * JE6 (mode 16)    | 0                  0                  1
- * -----------------------------------------------------------------------------
- *
- * [Jumper settings based on board v1.2-011]
- */
-
-#define HDK7105_PIO_PCI_SERR  stm_gpio(15, 4)
-#define HDK7105_PIO_PHY_RESET stm_gpio(15, 5)
-#define HDK7105_PIO_PCI_RESET stm_gpio(15, 7)
-#define HDK7105_GPIO_FLASH_WP stm_gpio(6, 4)
+#define HDK7105_PIO_PHY_RESET stm_gpio(2, 7)
+
+const char *LMI_IO_partalias[] = { "v4l2-coded-video-buffers", "BPA2_Region1", "v4l2-video-buffers" ,
+                                   "coredisplay-video", "gfx-memory", "BPA2_Region0", "LMI_VID", NULL };
 
+/* Directfb application can be greatly optimized by using a different layout. */
+//#define DIRECTFB
 
+#ifdef CONFIG_BPA2_DIRECTFBOPTIMIZED
+/*
+0x40000000 - 0x403FFFFF - cocpu 1 ram (4mb)
+0x40400000 - 0x407FFFFF - cocpu 2 ram (4mb)
+0x40800000 - 0x475FFFFF - linux   (110mb) 
+0x47600000 - 0x4F1FFFFF - lmi_io  ( 124mb (0x07C00000))
+0x4F200000 - 0x4FFFFFFF - bigphys (  14mb (0x00E00000))
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] = {
+    {
+ 	    .name  = "LMI_IO",
+ 	    .start = 0x47600000,
+ 	    .size  = 0x07C00000, /* 124 Mb */
+ 	    .flags = 0,
+ 	    .aka   = LMI_IO_partalias
+    }, 
+    {
+ 	    .name  = "bigphysarea",
+ 	    .start = 0x4F200000,
+ 	    .size  = 0x00E00000, /* 14 Mb */
+ 	    .flags = 0,
+ 	    .aka   = NULL
+    }, 
+ };
+#else
+
+/*
+0x40000000 - 0x403FFFFF - cocpu 1 ram (4mb)
+0x40400000 - 0x407FFFFF - cocpu 2 ram (4mb)
+0x40800000 - 0x47FFFFFF - linux   (120mb) 
+0x48000000 - 0x49FFFFFF - bigphys ( 32mb)
+0x4A000000 - 0x4FFFFFFF - lmi_io  ( 96mb)
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] = {
+    {
+ 	    .name  = "bigphysarea",
+ 	    .start = 0x48000000,
+ 	    .size  = 0x02000000, /* 32 Mb */
+ 	    .flags = 0,
+ 	    .aka   = NULL
+    }, 
+    {
+ 	    .name  = "LMI_IO",
+ 	    .start = 0x4A000000,
+ 	    .size  = 0x06000000, /* 96 Mb */
+ 	    .flags = 0,
+ 	    .aka   = LMI_IO_partalias
+    }, 
+ };
+#endif
 
 static void __init hdk7105_setup(char **cmdline_p)
 {
 	printk(KERN_INFO "STMicroelectronics HDK7105 "
 			"board initialisation\n");
 
-	stx7105_early_device_init();
-
-	stx7105_configure_asc(2, &(struct stx7105_asc_config) {
-			.routing.asc2 = stx7105_asc2_pio4,
-			.hw_flow_control = 1,
-			.is_console = 1, });
-	stx7105_configure_asc(3, &(struct stx7105_asc_config) {
-			.hw_flow_control = 1,
-			.is_console = 0, });
-}
-
-/* PCI configuration */
-static struct stm_plat_pci_config hdk7105_pci_config = {
-	.pci_irq = {
-		[0] = PCI_PIN_DEFAULT,
-		[1] = PCI_PIN_DEFAULT,
-		[2] = PCI_PIN_UNUSED,
-		[3] = PCI_PIN_UNUSED
-	},
-	.serr_irq = PCI_PIN_UNUSED, /* Modified in hdk7105_device_init() */
-	.idsel_lo = 30,
-	.idsel_hi = 30,
-	.req_gnt = {
-		[0] = PCI_PIN_DEFAULT,
-		[1] = PCI_PIN_UNUSED,
-		[2] = PCI_PIN_UNUSED,
-		[3] = PCI_PIN_UNUSED
-	},
-	.pci_clk = 33333333,
-	.pci_reset_gpio = HDK7105_PIO_PCI_RESET,
-};
+	#define OR32( a, b ) ( iowrite32( ( ioread32( a ) | b ), a ));
+	#define UPDATE32( a, b, c ) ( iowrite32(( ( ioread32( a ) & b ) | c ), a) );
+	#define WHILE_NE32( a, b, c ) while( ( ioread32( a ) & b ) != c );
+	#define POKE32( a, b ) iowrite32( b, a );
+
+#if 1
+
+	/* CKGA_PLL0_CFG ->setup pll0 */
+	UPDATE32(0xfe213000, 0xfff80000, 0x00001201)	// overclk
+	//	UPDATE32(0xfe213000, 0xfff80000, 0x00000f01)	// non overclk
+	
+	/* CKGA_PLL1_DIV0_CFG */
+	  POKE32(0xfe213b00, 0x00000001)
+	
+	
+	/* CKGA_PLL1_DIV1_CFG */
+	  POKE32(0xfe213b04, 0x00000001)
+	
+	
+	/* CKGA_PLL1_DIV2_CFG */
+	  POKE32(0xfe213b08, 0x00000001)
+	
+	
+	/* CKGA_PLL1_DIV3_CFG */
+	  POKE32(0xfe213b0c, 0x0000000f)
+	
+	
+	/* CKGA_PLL0LS_DIV4_CFG */
+	  POKE32(0xfe213a10, 0x00000000)
+	
+
+	/* CKGA_PLL1_DIV5_CFG */
+	  POKE32(0xfe213b14, 0x00000007)
+	
+	
+	/* CKGA_PLL0LS_DIV6_CFG	*/
+	  POKE32(0xfe213a18, 0x00000000)
+	
+	
+	/* CKGA_PLL0LS_DIV7_CFG */
+	  POKE32(0xfe213a1c, 0x00000000)
+	
+	
+	/* CKGA_PLL1_DIV8_CFG */
+	  POKE32(0xfe213b20, 0x00000003)
+	
+	
+	/* CKGA_PLL1_DIV9_CFG */
+	  POKE32(0xfe213b24, 0x00000003)
+	
+	
+	/* CKGA_PLL1_DIV10_CFG */
+	  POKE32(0xfe213b28, 0x00000003)
+	
+	
+	/* CKGA_PLL1_DIV11_CFG */
+	  POKE32(0xfe213b2c, 0x00000003)
+	
+	/* CKGA_PLL0LS_DIV12_CFG */
+	  POKE32(0xfe213a30, 0x00000001)		// overclk
+	
+	/* CKGA_PLL1_DIV12_CFG */
+	 // POKE32(0xfe213b30, 0x00000002)		// non overclk
+	
+	
+	/* CKGA_PLL1_DIV13_CFG */
+	  POKE32(0xfe213b34, 0x0000001f)
+	
+	
+	/* CKGA_PLL1_DIV14_CFG */
+	  POKE32(0xfe213b38, 0x00000017)
+	
+	
+	/* CKGA_PLL1_DIV15_CFG */
+	  POKE32(0xfe213b3c, 0x00000007)
+	
+	
+	/* CKGA_PLL1_DIV16_CFG */
+	  POKE32(0xfe213b40, 0x00000003)
+	
+	
+	/* CKGA_PLL1_DIV17_CFG */
+	  POKE32(0xfe213b44, 0x00000003)
+	
+	
+	/* CKGA_CLKOPSRC_SWITCH_CFG	*/
+		POKE32(0xfe213014, 0xa9aa59aa)	// overclk
+	//	 POKE32(0xfe213014, 0xaaaa59aa) // non overclk
+	
+	/* CKGA_CLKOPSRC_SWITCH_CFG2 */
+	  POKE32(0xfe213024, 0x0000000a)
+#endif
 
-int pcibios_map_platform_irq(struct pci_dev *dev, u8 slot, u8 pin)
-{
-        /* We can use the standard function on this board */
-	return stx7105_pcibios_map_platform_irq(&hdk7105_pci_config, pin);
-}
+	/* DDR */
 
-static struct platform_device hdk7105_leds = {
-	.name = "leds-gpio",
-	.id = 0,
-	.dev.platform_data = &(struct gpio_led_platform_data) {
-		.num_leds = 2,
-		.leds = (struct gpio_led[]) {
-			/* The schematics actually describes these PIOs
-			 * the other way round, but all tested boards
-			 * had the bi-colour LED fitted like below... */
-			{
-				.name = "RED", /* This is also frontpanel LED */
-				.gpio = stm_gpio(7, 0),
-				.active_low = 1,
-			}, {
-				.name = "GREEN",
-				.default_trigger = "heartbeat",
-				.gpio = stm_gpio(7, 1),
-				.active_low = 1,
-			},
-		},
-	},
-};
-
-static struct tm1668_key hdk7105_front_panel_keys[] = {
-	{ 0x00001000, KEY_UP, "Up (SWF2)" },
-	{ 0x00800000, KEY_DOWN, "Down (SWF7)" },
-	{ 0x00008000, KEY_LEFT, "Left (SWF6)" },
-	{ 0x00000010, KEY_RIGHT, "Right (SWF5)" },
-	{ 0x00000080, KEY_ENTER, "Enter (SWF1)" },
-	{ 0x00100000, KEY_ESC, "Escape (SWF4)" },
-};
+    int lmipl_sel_odt_int_del3_0 = 3;
+    int lmipl_dqs_valid_offset8_0 = 0;
+    int lmipl_sel_dqs_valid_del3_0 = 0;
+    int lmipl_dsq0_offset8_0 = 0x1e2;
+    int lmipl_dsq1_offset8_0 = 0x1e2;
+    int lmipl_dsq2_offset8_0 = 0x1e2;
+    int lmipl_dsq3_offset8_0 = 0x1e2;
+
+//	unsigned int sata = readl( 0xFE209000 + 0x824 );
+//	int DET = (sata & 0xf );
+	
+//	if( DET == 3 )
+	{
+		lmipl_dsq0_offset8_0 = 0x1ee;
+		lmipl_dsq1_offset8_0 = 0x1ee;
+		lmipl_dsq2_offset8_0 = 0x1ee;
+		lmipl_dsq3_offset8_0 = 0x1ee;
+	}
+	
+    unsigned int a = ((lmipl_sel_dqs_valid_del3_0<<27) | (lmipl_dsq2_offset8_0<<18) | (lmipl_dsq1_offset8_0<<9) | lmipl_dsq0_offset8_0);
+    unsigned int b = ((lmipl_sel_odt_int_del3_0<<27) | (lmipl_dqs_valid_offset8_0<<18) | lmipl_dsq3_offset8_0);
 
-static struct tm1668_character hdk7105_front_panel_characters[] = {
-	TM1668_7_SEG_HEX_DIGITS,
-	TM1668_7_SEG_HEX_DIGITS_WITH_DOT,
-	TM1668_7_SEG_SEGMENTS,
-};
+	POKE32( 0xfe0011a8, a );	
+	POKE32( 0xfe0011ac, b );	// 1dc
 
-static struct platform_device hdk7105_front_panel = {
-	.name = "tm1668",
-	.id = -1,
-	.dev.platform_data = &(struct tm1668_platform_data) {
-		.gpio_dio = stm_gpio(11, 2),
-		.gpio_sclk = stm_gpio(11, 3),
-		.gpio_stb = stm_gpio(11, 4),
-		.config = tm1668_config_6_digits_12_segments,
-
-		.keys_num = ARRAY_SIZE(hdk7105_front_panel_keys),
-		.keys = hdk7105_front_panel_keys,
-		.keys_poll_period = DIV_ROUND_UP(HZ, 5),
-
-		.brightness = 8,
-		.characters_num = ARRAY_SIZE(hdk7105_front_panel_characters),
-		.characters = hdk7105_front_panel_characters,
-		.text = "7105",
-	},
-};
+	stx7105_early_device_init();
 
+	stx7105_configure_asc(2, &(struct stx7105_asc_config) {
+			.hw_flow_control = 0,
+			.is_console = 0, });
+	stx7105_configure_asc(3, &(struct stx7105_asc_config) {
+			.hw_flow_control = 0,
+			.is_console = 1, });
 
+	bpa2_init(bpa2_parts_table, ARRAY_SIZE(bpa2_parts_table));
+}
 
 static int hdk7105_phy_reset(void *bus)
 {
-	gpio_set_value(HDK7105_PIO_PHY_RESET, 0);
-	udelay(100);
-	gpio_set_value(HDK7105_PIO_PHY_RESET, 1);
+	//gpio_set_value(HDK7105_PIO_PHY_RESET, 0);
+	//udelay(100);
+	//gpio_set_value(HDK7105_PIO_PHY_RESET, 1);
 
 	return 1;
 }
@@ -180,29 +248,110 @@
 	.resource	= (struct resource[]) {
 		{
 			.start		= 0x00000000,
-			.end		= 128*1024*1024 - 1,
+			.end		= 8*1024*1024 - 1,
 			.flags		= IORESOURCE_MEM,
 		}
 	},
 	.dev.platform_data	= &(struct physmap_flash_data) {
 		.width		= 2,
 		.set_vpp	= NULL,
-		.nr_parts	= 3,
+#ifdef ORIGINAL_MTD
+		.nr_parts	= 8,
 		.parts		=  (struct mtd_partition []) {
 			{
-				.name = "NOR Flash 1",
+				.name = "NOR Boot firmware",
 				.size = 0x00080000,
-				.offset = 0x00000000,
-			}, {
-				.name = "NOR Flash 2",
-				.size = 0x00200000,
-				.offset = MTDPART_OFS_NXTBLK,
-			}, {
-				.name = "NOR Flash 3",
-				.size = MTDPART_SIZ_FULL,
+				.offset = 0,
+			},
+			{
+				.name = "NOR BoxData",
+				.size = 0x00020000,
+				.offset = MTDPART_OFS_NXTBLK,
+			},
+			{
+				.name = "NOR Emergency Kernel",
+				.size = 0x001c0000,
+				.offset = MTDPART_OFS_NXTBLK,
+			},
+			{
+				.name = "NOR Emergency Root",
+				.size = 0x00180000,
+				.offset = MTDPART_OFS_NXTBLK,
+			},
+			{
+				.name = "NOR Box Configuration",
+				.size = 0x00020000,
+				.offset = MTDPART_OFS_NXTBLK,
+			},
+			{
+				.name = "NOR Kernel",
+				.size = 0x00260000,
+				.offset = MTDPART_OFS_NXTBLK,
+			},
+			{
+				.name = "NOR Root",
+				.size = 0x001a0000,
+				.offset = MTDPART_OFS_NXTBLK,
+			},
+			{
+				.name = "NOR 4M",
+				.size = 0x00400000,
+				.offset = 0x00400000,
+			}
+		},
+#else
+		.nr_parts	= 8,
+		.parts		=  (struct mtd_partition []) {
+			{
+				.name = "NOR  Uboot (ro)",
+				.size = 0x00060000,
+				.offset = 0,
+				.mask_flags = MTD_WRITEABLE,
+			},
+			{
+				.name = "NOR  Uboot Config (ro)",
+				.size = 0x00020000,
+				.offset = MTDPART_OFS_NXTBLK,
+				.mask_flags = MTD_WRITEABLE,
+			},
+			{
+				.name = "NOR  BoxData (ro)",
+				.size = 0x00020000,
+				.offset = MTDPART_OFS_NXTBLK,
+				.mask_flags = MTD_WRITEABLE,
+			},
+			{
+				.name = "NOR  Emergency Kernel (ro)",
+				.size = 0x001c0000,
 				.offset = MTDPART_OFS_NXTBLK,
+				.mask_flags = MTD_WRITEABLE,
+			},
+			{
+				.name = "NOR  Emergency Root (ro)",
+				.size = 0x00180000,
+				.offset = MTDPART_OFS_NXTBLK,
+				.mask_flags = MTD_WRITEABLE,
+			},
+			{
+				.name = "NOR  Box Configuration (ro)",
+				.size = 0x00020000,
+				.offset = MTDPART_OFS_NXTBLK,
+				.mask_flags = MTD_WRITEABLE,
+			},
+			{
+				/* Kernel has to be at this position in flash so no change of 
+				   uboot bootargs are necessary */
+				.name = "NOR  Kernel",
+				.offset = MTDPART_OFS_NXTBLK,
+				.size = 0x00260000,
+			},
+			{
+				.name = "NOR  Root",
+				.offset = MTDPART_OFS_NXTBLK,
+				.size = 0x001a0000,
 			}
 		},
+#endif
 	},
 };
 
@@ -210,153 +359,66 @@
 struct stm_nand_bank_data hdk7105_nand_flash = {
 	.csn		= 1,
 	.options	= NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT,
+#ifdef ORIGINAL_MTD
 	.nr_partitions	= 2,
 	.partitions	= (struct mtd_partition []) {
 		{
-			.name	= "NAND Flash 1",
+			.name	= "NAND config",
 			.offset	= 0,
-			.size 	= 0x00800000
+			.size 	= 0x02800000
 		}, {
-			.name	= "NAND Flash 2",
+			.name	= "NAND home",
 			.offset = MTDPART_OFS_NXTBLK,
 			.size	= MTDPART_SIZ_FULL
 		},
 	},
+#else
+	.nr_partitions	= 2,
+	.partitions	= (struct mtd_partition []) {
+		{
+			.name	= "NAND FW        0x0000.0000-0x007F.FFFF (  8MB)",
+			.offset	= 0,
+			.size 	= 0x00800000
+		},
+		{
+			.name	= "NAND ROOT      0x0080.0000-0x047F.FFFF ( 64MB)",
+			.offset = MTDPART_OFS_NXTBLK,
+			.size   = MTDPART_SIZ_FULL
+		}
+	},
+#endif
 	.timing_data		= &(struct stm_nand_timing_data) {
-		.sig_setup	= 50,		/* times in ns */
-		.sig_hold	= 50,
+		.sig_setup	= 60,		/* times in ns */
+		.sig_hold	= 60,
 		.CE_deassert	= 0,
-		.WE_to_RBn	= 100,
-		.wr_on		= 10,
-		.wr_off		= 40,
-		.rd_on		= 10,
-		.rd_off		= 40,
-		.chip_delay	= 30,		/* in us */
-	},
-};
-
-/* Serial Flash */
-static struct spi_board_info hdk7105_serial_flash = {
-	.modalias       = "m25p80",
-	.bus_num        = 0,
-	.chip_select    = stm_gpio(2, 4),
-	.max_speed_hz   = 7000000,
-	.mode           = SPI_MODE_3,
-	.platform_data  = &(struct flash_platform_data) {
-		.name = "m25p80",
-		.type = "m25p32",
-		.nr_parts	= 2,
-		.parts = (struct mtd_partition []) {
-			{
-				.name = "Serial Flash 1",
-				.size = 0x00080000,
-				.offset = 0,
-			}, {
-				.name = "Serial Flash 2",
-				.size = MTDPART_SIZ_FULL,
-				.offset = MTDPART_OFS_NXTBLK,
-			},
-		},
+		.WE_to_RBn	= 120,
+		.wr_on		= 20,
+		.wr_off		= 50,
+		.rd_on		= 20,
+		.rd_off		= 50,
+		.chip_delay	= 50,		/* in us */
 	},
+	.emi_withinbankoffset	= 0,
 };
 
 static struct platform_device *hdk7105_devices[] __initdata = {
-	&hdk7105_leds,
-	&hdk7105_front_panel,
 	&hdk7105_nor_flash,
 };
 
 static int __init hdk7105_device_init(void)
 {
-	struct sysconf_field *sc;
-	unsigned long nor_bank_base = 0;
-	unsigned long nor_bank_size = 0;
-
-	/* Configure Flash according to boot-device */
-	sc = sysconf_claim(SYS_STA, 1, 15, 16, "boot_device");
-	switch (sysconf_read(sc)) {
-	case 0x0:
-		/* Boot-from-NOR: */
-		pr_info("Configuring FLASH for boot-from-NOR\n");
-		/* NOR mapped to EMIA + EMIB (FMI_A26 = EMI_CSA#) */
-		nor_bank_base = emi_bank_base(0);
-		nor_bank_size = emi_bank_base(2) - nor_bank_base;
-		hdk7105_nand_flash.csn = 2;
-		break;
-	case 0x1:
-		/* Boot-from-NAND */
-		pr_info("Configuring FLASH for boot-from-NAND\n");
-		nor_bank_base = emi_bank_base(1);
-		nor_bank_size = emi_bank_base(2) - nor_bank_base;
-		hdk7105_nand_flash.csn = 0;
-		break;
-	case 0x2:
-		/* Boot-from-SPI */
-		pr_info("Configuring FLASH for boot-from-SPI\n");
-		/* NOR mapped to EMIB, with physical offset of 0x06000000! */
-		nor_bank_base = emi_bank_base(1);
-		nor_bank_size = emi_bank_base(2) - nor_bank_base;
-		hdk7105_nand_flash.csn = 2;
-		break;
-	default:
-		BUG();
-		break;
-	}
-	sysconf_release(sc);
-
-	/* Update NOR Flash base address and size: */
-	/*     - reduce visibility of NOR flash to EMI bank size */
-	if (hdk7105_nor_flash.resource[0].end > nor_bank_size - 1)
-		hdk7105_nor_flash.resource[0].end = nor_bank_size - 1;
-	/*     - update resource parameters */
-	hdk7105_nor_flash.resource[0].start += nor_bank_base;
-	hdk7105_nor_flash.resource[0].end += nor_bank_base;
-
-	/* Setup the PCI_SERR# PIO */
-	if (gpio_request(HDK7105_PIO_PCI_SERR, "PCI_SERR#") == 0) {
-		gpio_direction_input(HDK7105_PIO_PCI_SERR);
-		hdk7105_pci_config.serr_irq =
-				gpio_to_irq(HDK7105_PIO_PCI_SERR);
-		set_irq_type(hdk7105_pci_config.serr_irq, IRQ_TYPE_LEVEL_LOW);
-	} else {
-		printk(KERN_WARNING "hdk7105: Failed to claim PCI SERR PIO!\n");
-	}
-	stx7105_configure_pci(&hdk7105_pci_config);
-
 	stx7105_configure_sata(0);
 
-	stx7105_configure_pwm(&(struct stx7105_pwm_config) {
-			.out0 = stx7105_pwm_out0_pio13_0,
-			.out1 = stx7105_pwm_out1_disabled, });
-
-	/* Set SPI Boot pads as inputs to avoid contention with SSC1 */
-	gpio_request(stm_gpio(15, 0), "SPI Boot CLK");
-	gpio_direction_input(stm_gpio(15, 0));
-	gpio_request(stm_gpio(15, 1), "SPI Boot DOUT");
-	gpio_direction_input(stm_gpio(15, 1));
-	gpio_request(stm_gpio(15, 2), "SPI Boot NOTCS");
-	gpio_direction_input(stm_gpio(15, 2));
-	gpio_request(stm_gpio(15, 3), "SPI Boot DIN");
-	gpio_direction_input(stm_gpio(15, 3));
-
-	/*
-	 * Fix the reset chain so it correct to start with in case the
-	 * watchdog expires or we trigger a reset.
-	 */
-	sc = sysconf_claim(SYS_CFG, 9, 27, 28, "reset_chain");
-	sysconf_write(sc, 0);
-	/* Release the sysconf bits so the coprocessor driver can claim them */
-	sysconf_release(sc);
-
 	/* I2C_xxxA - HDMI */
 	stx7105_configure_ssc_i2c(0, &(struct stx7105_ssc_config) {
 			.routing.ssc0.sclk = stx7105_ssc0_sclk_pio2_2,
 			.routing.ssc0.mtsr = stx7105_ssc0_mtsr_pio2_3, });
-	/* SPI - SerialFLASH */
-	stx7105_configure_ssc_spi(1, &(struct stx7105_ssc_config) {
+
+	/* I2C_xxxB -  */
+	stx7105_configure_ssc_i2c(1, &(struct stx7105_ssc_config) {
 			.routing.ssc1.sclk = stx7105_ssc1_sclk_pio2_5,
-			.routing.ssc1.mtsr = stx7105_ssc1_mtsr_pio2_6,
-			.routing.ssc1.mrst = stx7105_ssc1_mrst_pio2_7});
+			.routing.ssc1.mtsr = stx7105_ssc1_mtsr_pio2_6, });
+
 	/* I2C_xxxC - JN1 (NIM), JN3, UT1 (CI chip), US2 (EEPROM) */
 	stx7105_configure_ssc_i2c(2, &(struct stx7105_ssc_config) {
 			.routing.ssc2.sclk = stx7105_ssc2_sclk_pio3_4,
@@ -388,33 +450,14 @@
 			.mdio_bus_data = &stmmac_mdio_bus,
 		});
 
-	stx7105_configure_lirc(&(struct stx7105_lirc_config) {
-#ifdef CONFIG_LIRC_STM_UHF
-			.rx_mode = stx7105_lirc_rx_mode_uhf,
-#else
-			.rx_mode = stx7105_lirc_rx_mode_ir,
-#endif
-			.tx_enabled = 0,
-			.tx_od_enabled = 0, });
-
-	stx7105_configure_audio(&(struct stx7105_audio_config) {
-			.spdif_player_output_enabled = 1, });
-
-	/*
-	 * FLASH_WP is shared between between NOR and NAND FLASH.  However,
-	 * since NAND MTD has no concept of write-protect, we permanently
-	 * disable WP.
-	 */
-	gpio_request(HDK7105_GPIO_FLASH_WP, "FLASH_WP");
-	gpio_direction_output(HDK7105_GPIO_FLASH_WP, 1);
-
 	stx7105_configure_nand(&(struct stm_nand_config) {
 			.driver = stm_nand_flex,
 			.nr_banks = 1,
 			.banks = &hdk7105_nand_flash,
 			.rbn.flex_connected = -1,});
 
-	spi_register_board_info(&hdk7105_serial_flash, 1);
+	stx7105_configure_audio(&(struct stx7105_audio_config) {
+			.spdif_player_output_enabled = 1, });
 
 	return platform_add_devices(hdk7105_devices,
 			ARRAY_SIZE(hdk7105_devices));
