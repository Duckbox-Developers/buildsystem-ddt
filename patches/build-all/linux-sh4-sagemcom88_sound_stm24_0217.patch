diff -Nur stx7105_audio.c.orig stx7105_audio.c
--- a/drivers/stm/stx7105_audio.c.orig
+++ b/drivers/stm/stx7105_audio.c
@@ -32,16 +32,33 @@
 	}
 };
 
+/* Frequency synthesizers */
+
+static struct platform_device stx7105_fsynth = {
+	.name          = "snd_fsynth",
+	.id            = -1,
+	.num_resources = 1,
+	.resource      = (struct resource []) {
+		STM_PLAT_RESOURCE_MEM(0xfe210000, 0x50),
+	},
+	.dev.platform_data = &(struct snd_stm_fsynth_info) {
+		.ver = 5,
+		.channels_from = 0,
+		.channels_to = 2,
+	},
+};
+
 /* Internal DAC */
 
-static struct platform_device stx7105_conv_dac_mem = {
-	.name          = "snd_conv_dac_mem",
+static struct platform_device stx7105_conv_int_dac = {
+	.name          = "snd_conv_int_dac",
 	.id            = -1,
 	.num_resources = 1,
 	.resource      = (struct resource []) {
 		STM_PLAT_RESOURCE_MEM(0xfe210100, 0x4),
 	},
-	.dev.platform_data = &(struct snd_stm_conv_dac_mem_info) {
+	.dev.platform_data = &(struct snd_stm_conv_int_dac_info) {
+		.ver = 4,
 		.source_bus_id = "snd_pcm_player.1",
 		.channel_from = 0,
 		.channel_to = 1,
@@ -54,6 +71,8 @@
 	.name = "PCM player #0 (HDMI)",
 	.ver = 6,
 	.card_device = 0,
+	.fsynth_bus_id = "snd_fsynth",
+	.fsynth_output = 0,
 	.channels = 8,
 	.fdma_initiator = 0,
 	.fdma_request_line = 39,
@@ -100,6 +106,8 @@
 	.name = "PCM player #1",
 	.ver = 6,
 	.card_device = 1,
+	.fsynth_bus_id = "snd_fsynth",
+	.fsynth_output = 1,
 	.channels = 2,
 	.fdma_initiator = 0,
 	.fdma_request_line = 34,
@@ -144,6 +152,8 @@
 	.name = "SPDIF player (HDMI)",
 	.ver = 4,
 	.card_device = 2,
+	.fsynth_bus_id = "snd_fsynth",
+	.fsynth_output = 2,
 	.fdma_initiator = 0,
 	.fdma_request_line = 40,
 	/* .pad_config set by stx7105_configure_audio() */
@@ -278,7 +288,8 @@
 
 static struct platform_device *stx7105_audio_devices[] __initdata = {
 	&stx7105_glue,
-	&stx7105_conv_dac_mem,
+	&stx7105_fsynth,
+	&stx7105_conv_int_dac,
 	&stx7105_pcm_player_0,
 	&stx7105_pcm_player_1,
 	&stx7105_spdif_player,
@@ -314,24 +325,22 @@
 	BUG_ON(configured);
 	configured = 1;
 
+	if (config->pcm_player_0_output >
+			stx7105_pcm_player_0_output_disabled) {
+		int unused = 3 - config->pcm_player_0_output;
+
+		stx7105_pcm_player_0_info.pad_config =
+				&stx7105_pcm_player_0_pad_config;
+
+		stx7105_pcm_player_0_pad_config.gpios_num -= unused;
+	}
+
 	if (config->spdif_player_output_enabled)
 		stx7105_spdif_player_info.pad_config =
 				&stx7105_spdif_player_pad_config;
 
 	switch (cpu_data->type) {
 	case CPU_STX7105:
-		BUG_ON(config->pcm_player_0_output ==
-				stx7105_pcm_player_0_output_8_channels);
-		if (config->pcm_player_0_output >
-				stx7105_pcm_player_0_output_disabled) {
-			int unused = stx7105_pcm_player_0_output_6_channels -
-					config->pcm_player_0_output;
-
-			stx7105_pcm_player_0_info.pad_config =
-					&stx7105_pcm_player_0_pad_config;
-
-			stx7105_pcm_player_0_pad_config.gpios_num -= unused;
-		}
 		if (config->pcm_player_1_enabled)
 			stx7105_pcm_player_1_info.pad_config =
 					&stx7105_pcm_player_1_pad_config;
--- a/include/sound/stm.h.orig
+++ b/include/sound/stm.h
@@ -188,28 +188,29 @@
 
 
 /*
- * Internal audio DAC descriptions (platform data)
+ * Audio frequency synthesizer description (platform data)
  */
 
-struct snd_stm_conv_dac_mem_info {
-	const char *source_bus_id;
-	int channel_from, channel_to;
+struct snd_stm_fsynth_info {
+	int ver;
+
+	int channels_from, channels_to;
 };
 
-struct snd_stm_conv_dac_sc_info {
+
+
+/*
+ * Internal audio DAC description (platform data)
+ */
+
+struct snd_stm_conv_int_dac_info {
+	int ver;
+
 	const char *source_bus_id;
 	int channel_from, channel_to;
-
-	struct {
-		int group;
-		int num;
-		int lsb;
-		int msb;
-	} nrst, mode, nsb, softmute, pdana, pndbg;
 };
 
 
-
 /*
  * I2S to SPDIF converter description (platform data)
  */
@@ -232,6 +233,8 @@
 	int ver;
 
 	int card_device;
+	const char *fsynth_bus_id;
+	int fsynth_output;
 
 	unsigned int channels;
 
@@ -272,6 +275,8 @@
 	int ver;
 
 	int card_device;
+	const char *fsynth_bus_id;
+	int fsynth_output;
 
 	unsigned char fdma_initiator;
 	unsigned int fdma_request_line;
diff -ruN stm.org/common.c stm/common.c
--- a/dev/null
+++ b/sound/stm/common.c	2012-10-11 11:46:27.000000000 -0700
@@ -0,0 +1,774 @@
+/*
+ *   Helpful ;-) routines for STMicroelectronics' SoCs audio drivers
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel Moll <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/mm.h>
+#include <linux/platform_device.h>
+#include <linux/bpa2.h>
+#include <linux/stm/stm-dma.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/info.h>
+#include <sound/pcm_params.h>
+#include <sound/asoundef.h>
+
+#define COMPONENT common
+#include "common.h"
+
+
+
+/*
+ * Cards management
+ */
+
+static struct snd_card *snd_stm_card;
+static int snd_stm_card_registered;
+
+struct snd_card *snd_stm_card_new(int index, const char *id,
+		struct module *module)
+{
+	int err;
+
+	if (snd_BUG_ON(snd_stm_card != NULL))
+		return NULL;
+	if (snd_BUG_ON(snd_stm_card_registered))
+		return NULL;
+
+	err = snd_card_create(index, id, module, 0, &snd_stm_card);
+	if (err)
+		return NULL;
+
+	return snd_stm_card;
+}
+EXPORT_SYMBOL(snd_stm_card_new);
+
+int snd_stm_card_register(void)
+{
+	int result;
+
+	if (snd_BUG_ON(snd_stm_card == NULL))
+		return -EINVAL;
+	if (snd_BUG_ON(snd_stm_card_registered))
+		return -EINVAL;
+
+	result = snd_card_register(snd_stm_card);
+
+	if (result == 0)
+		snd_stm_card_registered = 1;
+
+	return result;
+}
+EXPORT_SYMBOL(snd_stm_card_register);
+
+int snd_stm_card_is_registered(void)
+{
+	if (snd_BUG_ON(snd_stm_card == NULL))
+		return -EINVAL;
+
+	return snd_stm_card_registered;
+}
+EXPORT_SYMBOL(snd_stm_card_is_registered);
+
+void snd_stm_card_free(void)
+{
+	if (snd_BUG_ON(snd_stm_card == NULL))
+		return;
+	if (snd_BUG_ON(!snd_stm_card_registered))
+		return;
+
+	snd_card_free(snd_stm_card);
+
+	snd_stm_card_registered = 0;
+	snd_stm_card = NULL;
+}
+EXPORT_SYMBOL(snd_stm_card_free);
+
+struct snd_card *snd_stm_card_get(void)
+{
+	if (snd_BUG_ON(snd_stm_card == NULL))
+		return NULL;
+
+	return snd_stm_card;
+}
+EXPORT_SYMBOL(snd_stm_card_get);
+
+
+
+/*
+ * Resources management
+ */
+
+int snd_stm_memory_request(struct platform_device *pdev,
+		struct resource **mem_region, void **base_address)
+{
+	struct resource *resource;
+
+	resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!resource) {
+		snd_stm_printe("Failed to"
+				" platform_get_resource(IORESOURCE_MEM)!\n");
+		return -ENODEV;
+	}
+
+	*mem_region = request_mem_region(resource->start,
+			resource->end - resource->start + 1, pdev->name);
+	if (!*mem_region) {
+		snd_stm_printe("Failed request_mem_region(0x%08x,"
+				" 0x%08x, '%s')!\n", resource->start,
+				resource->end - resource->start + 1,
+				pdev->name);
+		return -EBUSY;
+	}
+	snd_stm_printd(0, "Memory region: 0x%08x-0x%08x\n",
+			(*mem_region)->start, (*mem_region)->end);
+
+	*base_address = ioremap(resource->start,
+			resource->end - resource->start + 1);
+	if (!*base_address) {
+		release_resource(*mem_region);
+		snd_stm_printe("Failed ioremap!\n");
+		return -EINVAL;
+	}
+
+	snd_stm_printd(0, "Base address is 0x%p.\n", *base_address);
+
+	return 0;
+}
+EXPORT_SYMBOL(snd_stm_memory_request);
+
+void snd_stm_memory_release(struct resource *mem_region,
+		void *base_address)
+{
+	iounmap(base_address);
+	release_resource(mem_region);
+}
+EXPORT_SYMBOL(snd_stm_memory_release);
+
+int snd_stm_irq_request(struct platform_device *pdev,
+		unsigned int *irq, irq_handler_t handler, void *dev_id)
+{
+	struct resource *resource;
+	int result;
+
+	resource = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!resource) {
+		snd_stm_printe("Failed to "
+				"platform_get_resource(IORESOURCE_IRQ)!\n");
+		return -ENODEV;
+	}
+	snd_stm_printd(0, "IRQ: %u\n", resource->start);
+
+	*irq = resource->start;
+
+	result = request_irq(*irq, handler, IRQF_DISABLED, pdev->name, dev_id);
+	if (result != 0) {
+		snd_stm_printe("Failed request_irq!\n");
+		return -EINVAL;
+	}
+
+	/* request_irq() enables the interrupt immediately; as it is
+	 * lethal in concurrent audio environment, we want to have
+	 * it disabled for most of the time... */
+	disable_irq(*irq);
+
+	return 0;
+}
+
+int snd_stm_fdma_request(struct platform_device *pdev, int *channel)
+{
+	static const char *fdmac_id[] = { STM_DMAC_ID, NULL };
+	static const char *fdma_cap_lb[] = { STM_DMA_CAP_LOW_BW, NULL };
+	static const char *fdma_cap_hb[] = { STM_DMA_CAP_HIGH_BW, NULL };
+
+	*channel = request_dma_bycap(fdmac_id, fdma_cap_lb, pdev->name);
+	if (*channel < 0) {
+		*channel = request_dma_bycap(fdmac_id, fdma_cap_hb, pdev->name);
+		if (*channel < 0) {
+			snd_stm_printe("Failed to request_dma_bycap()==%d!\n",
+					*channel);
+			return -ENODEV;
+		}
+	}
+	snd_stm_printd(0, "FDMA channel: %d\n", *channel);
+
+	return 0;
+}
+
+
+
+/*
+ * ALSA procfs additional entries
+ */
+
+static struct snd_info_entry *snd_stm_info_root;
+
+int snd_stm_info_create(void)
+{
+	int result = 0;
+
+	snd_stm_info_root = snd_info_create_module_entry(THIS_MODULE,
+			"stm", NULL);
+	if (snd_stm_info_root) {
+		snd_stm_info_root->mode = S_IFDIR | S_IRUGO | S_IXUGO;
+		if (snd_info_register(snd_stm_info_root) < 0) {
+			result = -EINVAL;
+			snd_info_free_entry(snd_stm_info_root);
+		}
+	} else {
+		result = -ENOMEM;
+	}
+
+	return result;
+}
+
+void snd_stm_info_dispose(void)
+{
+	if (snd_stm_info_root)
+		snd_info_free_entry(snd_stm_info_root);
+}
+
+int snd_stm_info_register(struct snd_info_entry **entry,
+		const char *name,
+		void (read)(struct snd_info_entry *, struct snd_info_buffer *),
+		void *private_data)
+{
+	int result = 0;
+
+	/* Skip the "snd_" prefix, if bus_id has been simply given */
+	if (strncmp(name, "snd_", 4) == 0)
+		name += 4;
+
+	*entry = snd_info_create_module_entry(THIS_MODULE, name,
+			snd_stm_info_root);
+	if (*entry) {
+		(*entry)->c.text.read = read;
+		(*entry)->private_data = private_data;
+		if (snd_info_register(*entry) < 0) {
+			result = -EINVAL;
+			snd_info_free_entry(*entry);
+		}
+	} else {
+		result = -EINVAL;
+	}
+	return result;
+}
+EXPORT_SYMBOL(snd_stm_info_register);
+
+void snd_stm_info_unregister(struct snd_info_entry *entry)
+{
+	if (entry)
+		snd_info_free_entry(entry);
+}
+EXPORT_SYMBOL(snd_stm_info_unregister);
+
+
+
+/*
+ * PCM buffer memory management
+ */
+
+struct snd_stm_buffer {
+	struct snd_pcm *pcm;
+
+	struct bpa2_part *bpa2_part;
+
+	int allocated;
+	struct snd_pcm_substream *substream;
+
+	snd_stm_magic_field;
+};
+
+#if defined(CONFIG_BPA2)
+static char *bpa2_part = CONFIG_SND_STM_BPA2_PARTITION_NAME;
+#else
+static char *bpa2_part = "";
+#endif
+module_param(bpa2_part, charp, S_IRUGO);
+
+struct snd_stm_buffer *snd_stm_buffer_create(struct snd_pcm *pcm,
+		struct device *device, int prealloc_size)
+{
+	struct snd_stm_buffer *buffer;
+
+	snd_stm_printd(1, "snd_stm_buffer_init(pcm=%p, prealloc_size=%d)\n",
+			pcm, prealloc_size);
+
+	if (snd_BUG_ON(!pcm))
+		return NULL;
+
+	buffer = kzalloc(sizeof(*buffer), GFP_KERNEL);
+	if (!buffer) {
+		snd_stm_printe("Can't allocate memory for a buffer "
+				"description!\n");
+		return NULL;
+	}
+	snd_stm_magic_set(buffer);
+	buffer->pcm = pcm;
+
+#if defined(CONFIG_BPA2)
+	buffer->bpa2_part = bpa2_find_part(bpa2_part);
+	if (buffer->bpa2_part) {
+		snd_stm_printd(0, "Using BPA2 partition '%s'...\n", bpa2_part);
+		return buffer;
+	}
+
+	buffer->bpa2_part = bpa2_find_part("bigphysarea");
+	if (buffer->bpa2_part) {
+		snd_stm_printd(0, "Using legacy 'bigphysarea' BPA2 "
+				"partition...\n");
+		return buffer;
+	}
+#endif
+
+	if (snd_pcm_lib_preallocate_pages_for_all(pcm,
+			SNDRV_DMA_TYPE_DEV, device,
+			prealloc_size, prealloc_size) == 0) {
+		snd_stm_printd(0, "Using pcm_lib's preallocated buffer "
+				"(%d bytes)...\n", prealloc_size);
+		return buffer;
+	}
+
+	snd_stm_printe("Can't provide any memory for buffers!\n");
+	kfree(buffer);
+	return NULL;
+}
+
+void snd_stm_buffer_dispose(struct snd_stm_buffer *buffer)
+{
+	snd_stm_printd(1, "snd_stm_buffer_dispose(buffer=%p)\n", buffer);
+
+	if (snd_BUG_ON(!buffer))
+		return;
+	if (snd_BUG_ON(!snd_stm_magic_valid(buffer)))
+		return;
+	if (snd_BUG_ON(buffer->allocated))
+		return;
+
+	/* snd_pcm_lib__preallocate*-ed buffer is freed automagically */
+
+	snd_stm_magic_clear(buffer);
+	kfree(buffer);
+}
+
+int snd_stm_buffer_is_allocated(struct snd_stm_buffer *buffer)
+{
+	snd_stm_printd(1, "snd_stm_buffer_is_allocated(buffer=%p)\n",
+			buffer);
+
+	if (snd_BUG_ON(!buffer))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(buffer)))
+		return -EINVAL;
+
+	return buffer->allocated;
+}
+
+int snd_stm_buffer_alloc(struct snd_stm_buffer *buffer,
+		struct snd_pcm_substream *substream, int size)
+{
+	snd_stm_printd(1, "snd_stm_buffer_alloc(buffer=%p, substream=%p, "
+			"size=%d)\n", buffer, substream, size);
+
+	if (snd_BUG_ON(!buffer))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(buffer)))
+		return -EINVAL;
+	if (snd_BUG_ON(buffer->allocated))
+		return -EINVAL;
+	if (snd_BUG_ON(size <= 0))
+		return -EINVAL;
+
+	if (buffer->bpa2_part) {
+#if defined(CONFIG_BPA2)
+		struct snd_pcm_runtime *runtime = substream->runtime;
+		int pages = (size + PAGE_SIZE - 1) / PAGE_SIZE;
+
+		runtime->dma_addr = bpa2_alloc_pages(buffer->bpa2_part, pages,
+				0, GFP_KERNEL);
+		if (runtime->dma_addr == 0) {
+			snd_stm_printe("Can't get %d pages from BPA2!\n",
+					pages);
+			return -ENOMEM;
+		}
+		runtime->dma_bytes = size;
+		runtime->dma_area = ioremap_nocache(runtime->dma_addr, size);
+#else
+		snd_BUG();
+#endif
+	} else {
+		if (snd_pcm_lib_malloc_pages(substream, size) < 0) {
+			snd_stm_printe("Can't allocate pages using pcm_lib!\n");
+			return -ENOMEM;
+		}
+		/* runtime->dma_* are set by snd_pcm_lib_malloc_pages()
+		 * (by snd_pcm_set_runtime_buffer() to be more specific.) */
+	}
+
+	snd_stm_printd(1, "Allocated memory: dma_addr=0x%08x, dma_area=0x%p, "
+			"dma_bytes=%u\n", substream->runtime->dma_addr,
+			substream->runtime->dma_area,
+			substream->runtime->dma_bytes);
+
+	buffer->substream = substream;
+	buffer->allocated = 1;
+
+	return 0;
+}
+
+void snd_stm_buffer_free(struct snd_stm_buffer *buffer)
+{
+	struct snd_pcm_runtime *runtime;
+
+	snd_stm_printd(1, "snd_stm_buffer_free(buffer=%p)\n", buffer);
+
+	if (snd_BUG_ON(!buffer))
+		return;
+	if (snd_BUG_ON(!snd_stm_magic_valid(buffer)))
+		return;
+	if (snd_BUG_ON(!buffer->allocated))
+		return;
+
+	runtime = buffer->substream->runtime;
+
+	snd_stm_printd(1, "Freeing dma_addr=0x%08x, dma_area=0x%p, "
+			"dma_bytes=%u\n", runtime->dma_addr,
+			runtime->dma_area, runtime->dma_bytes);
+
+	if (buffer->bpa2_part) {
+#if defined(CONFIG_BPA2)
+		iounmap(runtime->dma_area);
+
+		bpa2_free_pages(buffer->bpa2_part, runtime->dma_addr);
+		runtime->dma_area = NULL;
+		runtime->dma_addr = 0;
+		runtime->dma_bytes = 0;
+#else
+		snd_BUG();
+#endif
+	} else {
+		snd_pcm_lib_free_pages(buffer->substream);
+		/* runtime->dma_* are cleared by snd_pcm_lib_free_pages()
+		 * (by snd_pcm_set_runtime_buffer() to be more specific.) */
+	}
+
+	buffer->allocated = 0;
+	buffer->substream = NULL;
+}
+
+static int snd_stm_buffer_mmap_fault(struct vm_area_struct *area,
+				     struct vm_fault *vmf)
+{
+	/* No VMA expanding here! */
+	return VM_FAULT_SIGBUS;
+}
+
+static struct vm_operations_struct snd_stm_buffer_mmap_vm_ops = {
+	.open =   snd_pcm_mmap_data_open,
+	.close =  snd_pcm_mmap_data_close,
+	.fault =  snd_stm_buffer_mmap_fault,
+};
+
+int snd_stm_buffer_mmap(struct snd_pcm_substream *substream,
+		struct vm_area_struct *area)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	unsigned long map_offset = area->vm_pgoff << PAGE_SHIFT;
+	unsigned long phys_addr = runtime->dma_addr + map_offset;
+	unsigned long map_size = area->vm_end - area->vm_start;
+	unsigned long phys_size = runtime->dma_bytes + PAGE_SIZE -
+			runtime->dma_bytes % PAGE_SIZE;
+
+	snd_stm_printd(1, "snd_stm_buffer_mmap(substream=%p, area=%p)\n",
+			substream, area);
+
+	snd_stm_printd(1, "Mmaping %lu bytes starting from 0x%08lx "
+			"(dma_addr=0x%08x, dma_size=%u, vm_pgoff=%lu, "
+			"vm_start=0x%lx, vm_end=0x%lx)...\n", map_size,
+			phys_addr, runtime->dma_addr, runtime->dma_bytes,
+			area->vm_pgoff, area->vm_start, area->vm_end);
+
+	if (map_size > phys_size) {
+		snd_stm_printe("Trying to perform mmap larger than buffer!\n");
+		return -EINVAL;
+	}
+
+	area->vm_ops = &snd_stm_buffer_mmap_vm_ops;
+	area->vm_private_data = substream;
+	area->vm_flags |= VM_RESERVED;
+	area->vm_page_prot = pgprot_noncached(area->vm_page_prot);
+
+	if (remap_pfn_range(area, area->vm_start, phys_addr >> PAGE_SHIFT,
+			map_size, area->vm_page_prot) != 0) {
+		snd_stm_printe("Can't remap buffer!\n");
+		return -EAGAIN;
+	}
+
+	/* Must be called implicitly here... */
+	snd_pcm_mmap_data_open(area);
+
+	return 0;
+}
+
+
+
+/*
+ * Common ALSA parameters constraints
+ */
+
+/*
+#define FIXED_TRANSFER_BYTES max_transfer_bytes > 16 ? 16 : max_transfer_bytes
+#define FIXED_TRANSFER_BYTES max_transfer_bytes
+*/
+
+#if defined(FIXED_TRANSFER_BYTES)
+
+int snd_stm_pcm_transfer_bytes(unsigned int bytes_per_frame,
+		unsigned int max_transfer_bytes)
+{
+	int transfer_bytes = FIXED_TRANSFER_BYTES;
+
+	snd_stm_printd(1, "snd_stm_pcm_transfer_bytes(bytes_per_frame=%u, "
+			"max_transfer_bytes=%u) = %u (FIXED)\n",
+			bytes_per_frame, max_transfer_bytes, transfer_bytes);
+
+	return transfer_bytes;
+}
+
+int snd_stm_pcm_hw_constraint_transfer_bytes(struct snd_pcm_runtime *runtime,
+		unsigned int max_transfer_bytes)
+{
+	return snd_pcm_hw_constraint_step(runtime, 0,
+			SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
+			snd_stm_pcm_transfer_bytes(0, max_transfer_bytes));
+}
+
+#else
+
+int snd_stm_pcm_transfer_bytes(unsigned int bytes_per_frame,
+		unsigned int max_transfer_bytes)
+{
+	unsigned int transfer_bytes;
+
+	for (transfer_bytes = bytes_per_frame;
+			transfer_bytes * 2 < max_transfer_bytes;
+			transfer_bytes *= 2)
+		;
+
+	snd_stm_printd(2, "snd_stm_pcm_transfer_bytes(bytes_per_frame=%u, "
+			"max_transfer_bytes=%u) = %u\n", bytes_per_frame,
+			max_transfer_bytes, transfer_bytes);
+
+	return transfer_bytes;
+}
+
+static int snd_stm_pcm_hw_rule_transfer_bytes(struct snd_pcm_hw_params *params,
+		struct snd_pcm_hw_rule *rule)
+{
+	int changed = 0;
+	unsigned int max_transfer_bytes = (unsigned int)rule->private;
+	struct snd_interval *period_bytes = hw_param_interval(params,
+			SNDRV_PCM_HW_PARAM_PERIOD_BYTES);
+	struct snd_interval *frame_bits = hw_param_interval(params,
+			SNDRV_PCM_HW_PARAM_FRAME_BITS);
+	unsigned int transfer_bytes, n;
+
+	transfer_bytes = snd_stm_pcm_transfer_bytes(frame_bits->min / 8,
+			max_transfer_bytes);
+	n = period_bytes->min % transfer_bytes;
+	if (n != 0 || period_bytes->openmin) {
+		period_bytes->min += transfer_bytes - n;
+		changed = 1;
+	}
+
+	transfer_bytes = snd_stm_pcm_transfer_bytes(frame_bits->max / 8,
+			max_transfer_bytes);
+	n = period_bytes->max % transfer_bytes;
+	if (n != 0 || period_bytes->openmax) {
+		period_bytes->max -= n;
+		changed = 1;
+	}
+
+	if (snd_interval_checkempty(period_bytes)) {
+		period_bytes->empty = 1;
+		return -EINVAL;
+	}
+
+	return changed;
+}
+
+int snd_stm_pcm_hw_constraint_transfer_bytes(struct snd_pcm_runtime *runtime,
+		unsigned int max_transfer_bytes)
+{
+	return snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
+			snd_stm_pcm_hw_rule_transfer_bytes,
+			(void *)max_transfer_bytes,
+			SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
+			SNDRV_PCM_HW_PARAM_FRAME_BITS, -1);
+}
+
+#endif
+
+
+
+/*
+ * Common ALSA controls routines
+ */
+
+int snd_stm_ctl_boolean_info(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+
+	return 0;
+}
+EXPORT_SYMBOL(snd_stm_ctl_boolean_info);
+
+int snd_stm_ctl_iec958_info(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+
+	return 0;
+}
+
+
+int snd_stm_ctl_iec958_mask_get_con(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.iec958.status[0] = IEC958_AES0_PROFESSIONAL |
+			IEC958_AES0_NONAUDIO |
+			IEC958_AES0_CON_NOT_COPYRIGHT |
+			IEC958_AES0_CON_EMPHASIS |
+			IEC958_AES0_CON_MODE;
+	ucontrol->value.iec958.status[1] = IEC958_AES1_CON_CATEGORY |
+			IEC958_AES1_CON_ORIGINAL;
+	ucontrol->value.iec958.status[2] = IEC958_AES2_CON_SOURCE |
+			IEC958_AES2_CON_CHANNEL;
+	ucontrol->value.iec958.status[3] = IEC958_AES3_CON_FS |
+			IEC958_AES3_CON_CLOCK;
+	ucontrol->value.iec958.status[4] = IEC958_AES4_CON_MAX_WORDLEN_24 |
+			IEC958_AES4_CON_WORDLEN;
+
+	return 0;
+}
+
+int snd_stm_ctl_iec958_mask_get_pro(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.iec958.status[0] = IEC958_AES0_PROFESSIONAL |
+			IEC958_AES0_NONAUDIO |
+			IEC958_AES0_PRO_EMPHASIS |
+			IEC958_AES0_PRO_FREQ_UNLOCKED |
+			IEC958_AES0_PRO_FS;
+	ucontrol->value.iec958.status[1] = IEC958_AES1_PRO_MODE |
+			IEC958_AES1_PRO_USERBITS;
+	ucontrol->value.iec958.status[2] = IEC958_AES2_PRO_SBITS |
+			IEC958_AES2_PRO_WORDLEN;
+
+	return 0;
+}
+
+int snd_stm_iec958_cmp(const struct snd_aes_iec958 *a,
+		const struct snd_aes_iec958 *b)
+{
+	int result;
+
+	if (snd_BUG_ON(a == NULL))
+		return -EINVAL;
+	if (snd_BUG_ON(b == NULL))
+		return -EINVAL;
+
+	result = memcmp(a->status, b->status, sizeof(a->status));
+	if (result == 0)
+		result = memcmp(a->subcode, b->subcode, sizeof(a->subcode));
+	if (result == 0)
+		result = memcmp(a->dig_subframe, b->dig_subframe,
+				sizeof(a->dig_subframe));
+
+	return result;
+}
+
+
+/*
+ * Debug features
+ */
+
+/* Memory dump function */
+
+void snd_stm_hex_dump(void *data, int size)
+{
+	unsigned char *buffer = data;
+	char line[57];
+	int i;
+
+	for (i = 0; i < size; i++) {
+		if (i % 16 == 0)
+			sprintf(line, "%p", data + i);
+		sprintf(line + 8 + ((i % 16) * 3), " %02x", *buffer++);
+		if (i % 16 == 15 || i == size - 1)
+			printk(KERN_DEBUG "%s\n", line);
+	}
+}
+
+/* IEC958 structure dump */
+void snd_stm_iec958_dump(const struct snd_aes_iec958 *vuc)
+{
+	int i;
+	char line[54];
+	const unsigned char *data;
+
+	printk(KERN_DEBUG "                        "
+			"0  1  2  3  4  5  6  7  8  9\n");
+	data = vuc->status;
+	for (i = 0; i < 24; i++) {
+		if (i % 10 == 0)
+			sprintf(line, "%p status    %02d:",
+					(unsigned char *)vuc + i, i);
+		sprintf(line + 22 + ((i % 10) * 3), " %02x", *data++);
+		if (i % 10 == 9 || i == 23)
+			printk(KERN_DEBUG "%s\n", line);
+	}
+
+	data = vuc->subcode;
+	for (i = 0; i < 147; i++) {
+		if (i % 10 == 0)
+			sprintf(line, "%p subcode  %03d:",
+					(unsigned char *)vuc +
+					offsetof(struct snd_aes_iec958,
+					dig_subframe) + i, i);
+		sprintf(line + 22 + ((i % 10) * 3), " %02x", *data++);
+		if (i % 10 == 9 || i == 146)
+			printk(KERN_DEBUG "%s\n", line);
+	}
+
+	printk(KERN_DEBUG "%p dig_subframe: %02x %02x %02x %02x\n",
+			(unsigned char *)vuc +
+			offsetof(struct snd_aes_iec958, dig_subframe),
+			vuc->dig_subframe[0], vuc->dig_subframe[1],
+			vuc->dig_subframe[2], vuc->dig_subframe[3]);
+}
diff -ruN stm.org/common.h stm/common.h
--- a/drivers/stm/common.h	2014-06-17 22:22:26.000000000 -0700
+++ b/sound/stm/common.h	2012-10-11 11:51:57.000000000 -0700
@@ -19,12 +19,29 @@
 
 
 /*
- * ALSA card management
+ * Drivers initialization/cleanup
  */
 
-int snd_stm_card_register(void);
-int snd_stm_card_is_registered(void);
-struct snd_card *snd_stm_card_get(void);
+int snd_stm_drivers_register(void);
+void snd_stm_drivers_unregister(void);
+
+
+
+/*
+ * Frequency synthesizers control interface
+ */
+
+struct snd_stm_fsynth_channel;
+
+struct snd_stm_fsynth_channel *snd_stm_fsynth_get_channel(const char *bus_id,
+		int output);
+
+int snd_stm_fsynth_add_adjustement_ctl(
+		struct snd_stm_fsynth_channel *fsynth_channel,
+		struct snd_card *card, int card_device);
+
+int snd_stm_fsynth_set_frequency(struct snd_stm_fsynth_channel *fsynth_channel,
+		int frequency);
 
 
 
@@ -56,17 +73,6 @@
 int snd_stm_conv_disable(struct snd_stm_conv_group *group);
 int snd_stm_conv_mute(struct snd_stm_conv_group *group);
 int snd_stm_conv_unmute(struct snd_stm_conv_group *group);
-int snd_stm_conv_init(void);
-void snd_stm_conv_exit(void);
-
-
-/*
- * Clocks control interface
- */
-
-struct clk *snd_stm_clk_get(struct device *dev, const char *id,
-		struct snd_card *card, int card_device);
-void snd_stm_clk_put(struct clk *clk);
 
 
 
@@ -124,9 +130,26 @@
 
 
 /*
+ * ALSA card management
+ */
+
+struct snd_card *snd_stm_card_new(int index, const char *id,
+		struct module *module);
+int snd_stm_card_register(void);
+int snd_stm_card_is_registered(void);
+void snd_stm_card_free(void);
+
+struct snd_card *snd_stm_card_get(void);
+
+
+
+/*
  * ALSA procfs additional entries
  */
 
+int snd_stm_info_create(void);
+void snd_stm_info_dispose(void);
+
 int snd_stm_info_register(struct snd_info_entry **entry,
 		const char *name,
 		void (read)(struct snd_info_entry *, struct snd_info_buffer *),
@@ -154,6 +177,36 @@
 
 
 /*
+ * Core drivers initialization/exit
+ */
+
+int snd_stm_fsynth_init(void);
+void snd_stm_fsynth_exit(void);
+
+int snd_stm_conv_init(void);
+void snd_stm_conv_exit(void);
+
+int snd_stm_conv_int_dac_init(void);
+void snd_stm_conv_int_dac_exit(void);
+
+int snd_stm_conv_i2sspdif_init(void);
+void snd_stm_conv_i2sspdif_exit(void);
+
+int snd_stm_pcm_player_init(void);
+void snd_stm_pcm_player_exit(void);
+
+int snd_stm_pcm_reader_init(void);
+void snd_stm_pcm_reader_exit(void);
+
+int snd_stm_spdif_player_init(void);
+void snd_stm_spdif_player_exit(void);
+
+int snd_stm_synchro_init(void);
+void snd_stm_synchro_exit(void);
+
+
+
+/*
  * Debug features
  */
 
@@ -162,15 +215,52 @@
 void snd_stm_hex_dump(void *data, int size);
 void snd_stm_iec958_dump(const struct snd_aes_iec958 *vuc);
 
+/* Component name */
+
+#if !defined(COMPONENT)
+#error Please define COMPONENT name before including "common.h" !
+#endif
+static const char __maybe_unused *__snd_stm_component = __stringify(COMPONENT);
+
 /* Debug messages */
 
 #if defined(CONFIG_SND_DEBUG) || defined(DEBUG)
 
+#define ___concat(a, b) a##b
+#define __concat(a, b) ___concat(a, b)
+
+#if defined(DEBUG)
+static int __concat(debug_, COMPONENT) = DEBUG;
+#else
+static int __concat(debug_, COMPONENT) = -1;
+#endif
+module_param(__concat(debug_, COMPONENT), int, S_IRUGO | S_IWUSR);
+
+#if defined(CONFIG_SND_STM_DEBUG_LEVEL)
+extern int *snd_stm_debug_level;
+#define verbosity max(*snd_stm_debug_level, __concat(debug_, COMPONENT))
+#else
+#define verbosity __concat(debug_, COMPONENT)
+#endif
+
+#if defined(CONFIG_SND_VERBOSE_PRINTK)
+
 #define snd_stm_printd(level, format, args...) \
 		do { \
-			if (level <= snd_stm_debug_level) \
-				printk(KERN_DEBUG "%s:%d: " format, \
-						__FILE__, __LINE__, ##args); \
+			if (level <= verbosity) \
+				snd_printk(KERN_INFO format, ## args); \
+		} while (0)
+
+#define snd_stm_assert snd_assert
+
+#else
+
+#define snd_stm_printd(level, format, args...) \
+		do { \
+			if (level <= verbosity) \
+				printk(KERN_INFO "snd-stm:%s:%d: " format, \
+						__snd_stm_component, \
+						__LINE__, ## args); \
 		} while (0)
 
 #define snd_stm_assert(expr, args...) \
@@ -185,47 +275,51 @@
 				args; \
 			} \
 		} while (0)
+#endif
 
 #else
 
 #define snd_stm_printd(...) /* nothing */
+
 #define snd_stm_assert snd_assert
 
 #endif
 
 /* Error messages */
 
+#if defined(CONFIG_SND_VERBOSE_PRINTK)
+#define snd_stm_printe(format, args...) \
+		snd_printk(KERN_ERR format, ## args)
+#else
 #define snd_stm_printe(format, args...) \
-		printk(KERN_ERR "%s:%d: " format, __FILE__, __LINE__, ##args)
+		printk(KERN_ERR "snd-stm:%s:%d: " format, \
+				__snd_stm_component, __LINE__, ## args)
+#endif
 
 /* Magic value checking in device structures */
 
 #if defined(CONFIG_SND_DEBUG) || defined(DEBUG)
 
-#ifndef snd_stm_magic
-#define snd_stm_magic 0xf00d
-#endif
-
-enum snd_stm_magic_enum {
-	snd_stm_magic_good = 0x600d0000 | snd_stm_magic,
-	snd_stm_magic_bad = 0xbaad0000 | snd_stm_magic,
-};
-
-#define snd_stm_magic_field \
-		enum snd_stm_magic_enum __snd_stm_magic
+#define snd_stm_magic \
+		(((unsigned)(&__snd_stm_component) & 0xffff0000) >> 16 ^ \
+		((unsigned)(&__snd_stm_component) & 0xffff))
+#define snd_stm_magic_good (0x600d0000 | snd_stm_magic)
+#define snd_stm_magic_bad (0xbaad0000 | snd_stm_magic)
+#define snd_stm_magic_field unsigned __snd_stm_magic
 #define snd_stm_magic_set(object) \
-		((object)->__snd_stm_magic) = snd_stm_magic_good
+		(object)->__snd_stm_magic = snd_stm_magic_good
 #define snd_stm_magic_clear(object) \
-		((object)->__snd_stm_magic) = snd_stm_magic_bad
+		(object)->__snd_stm_magic = snd_stm_magic_bad
 #define snd_stm_magic_valid(object) \
-		((object)->__snd_stm_magic == snd_stm_magic_good)
+		snd_BUG_ON((object)->__snd_stm_magic == \
+			       snd_stm_magic_good)
 
 #else
 
-#define snd_stm_magic_field
-#define snd_stm_magic_set(object)
-#define snd_stm_magic_clear(object)
-#define snd_stm_magic_valid(object) 1
+#	define snd_stm_magic_field /* nothing */
+#	define snd_stm_magic_set(object) /* nothing */
+#	define snd_stm_magic_clear(object) /* nothing */
+#	define snd_stm_magic_valid(object) 1
 
 #endif
 
diff -ruN stm.org/conv.c stm/conv.c
--- a/drivers/stm/conv.c	2014-06-03 12:31:04.000000000 -0700
+++ b/sound/stm/conv.c	2012-10-11 11:46:27.000000000 -0700
@@ -26,14 +26,11 @@
 #include <linux/device.h>
 #include <sound/control.h>
 
+#define COMPONENT conv
 #include "common.h"
 
 
 
-extern int snd_stm_debug_level;
-
-
-
 /*
  * Converters infrastructure description
  */
@@ -76,7 +73,7 @@
 	char name[1]; /* "Expandable" */
 };
 
-#define SND_STM_BUS_ID_SIZE 30
+#define SND_STM_BUS_ID_SIZE 64
 struct snd_stm_conv_source {
 	struct list_head list;
 
@@ -94,8 +91,8 @@
 	snd_stm_magic_field;
 };
 
-static LIST_HEAD(snd_stm_conv_sources); /* Sources list */
-static DEFINE_MUTEX(snd_stm_conv_mutex); /* Big Converters Structure Lock ;-) */
+LIST_HEAD(snd_stm_conv_sources); /* Sources list */
+DEFINE_MUTEX(snd_stm_conv_mutex); /* Big Converters Structure Lock ;-) */
 
 
 
@@ -107,8 +104,10 @@
 {
 	snd_stm_printd(1, "snd_stm_conv_get_name(group=%p)\n", group);
 
-	BUG_ON(!group);
-	BUG_ON(!snd_stm_magic_valid(group));
+	if (snd_BUG_ON(!group))
+		return NULL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(group)))
+		return NULL;
 
 	return group->name;
 }
@@ -120,8 +119,10 @@
 
 	snd_stm_printd(1, "snd_stm_conv_get_format(group=%p)\n", group);
 
-	BUG_ON(!group);
-	BUG_ON(!snd_stm_magic_valid(group));
+	if (snd_BUG_ON(!group))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(group)))
+		return -EINVAL;
 
 	/* All configured converters must share the same input format -
 	 * get first of them and check the rest; if any of converters
@@ -152,8 +153,10 @@
 	snd_stm_printd(1, "snd_stm_conv_get_oversampling(group=%p)\n",
 			group);
 
-	BUG_ON(!group);
-	BUG_ON(!snd_stm_magic_valid(group));
+	if (snd_BUG_ON(!group))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(group)))
+		return -EINVAL;
 
 	/* All configured converters must share the same oversampling value -
 	 * get first of them and check the rest; if any of converters
@@ -162,8 +165,10 @@
 	list_for_each_entry(converter, &group->converters, list) {
 		int oversampling;
 
-		BUG_ON(!converter);
-		BUG_ON(!snd_stm_magic_valid(converter));
+		if (snd_BUG_ON(!converter))
+			return -EINVAL;
+		if (snd_BUG_ON(!snd_stm_magic_valid(converter)))
+			return -EINVAL;
 
 		oversampling = converter->ops->get_oversampling(
 				converter->priv);
@@ -190,17 +195,24 @@
 	snd_stm_printd(1, "snd_stm_conv_enable(group=%p, channel_from=%d, "
 			"channel_to=%d)\n", group, channel_from, channel_to);
 
-	BUG_ON(channel_to < channel_from);
-	BUG_ON(!group);
-	BUG_ON(!snd_stm_magic_valid(group));
-	BUG_ON(group->enabled);
+	if (snd_BUG_ON(!(channel_to >= channel_from)))
+		return -EINVAL;
+	if (snd_BUG_ON(!group))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(group)))
+		return -EINVAL;
+	if (snd_BUG_ON(group->enabled))
+		return -EINVAL;
 
 	group->enabled = 1;
 
 	list_for_each_entry(converter, &group->converters, list) {
-		BUG_ON(!converter);
-		BUG_ON(!snd_stm_magic_valid(converter));
-		BUG_ON(converter->enabled);
+		if (snd_BUG_ON(!converter))
+			return -EINVAL;
+		if (snd_BUG_ON(!snd_stm_magic_valid(converter)))
+			return -EINVAL;
+		if (snd_BUG_ON(converter->enabled))
+			continue;
 
 		spin_lock(&converter->status_lock);
 
@@ -236,15 +248,20 @@
 
 	snd_stm_printd(1, "snd_stm_conv_disable(group=%p)\n", group);
 
-	BUG_ON(!group);
-	BUG_ON(!snd_stm_magic_valid(group));
-	BUG_ON(!group->enabled);
+	if (snd_BUG_ON(!group))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(group)))
+		return -EINVAL;
+	if (snd_BUG_ON(!group->enabled))
+		return -EINVAL;
 
 	group->enabled = 0;
 
 	list_for_each_entry(converter, &group->converters, list) {
-		BUG_ON(!converter);
-		BUG_ON(!snd_stm_magic_valid(converter));
+		if (snd_BUG_ON(!converter))
+			return -EINVAL;
+		if (snd_BUG_ON(!snd_stm_magic_valid(converter)))
+			return -EINVAL;
 
 		spin_lock(&converter->status_lock);
 
@@ -277,16 +294,22 @@
 
 	snd_stm_printd(1, "snd_stm_conv_mute(group=%p)\n", group);
 
-	BUG_ON(!group);
-	BUG_ON(!snd_stm_magic_valid(group));
-	BUG_ON(!group->enabled);
-	BUG_ON(group->muted_by_source);
+	if (snd_BUG_ON(!group))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(group)))
+		return -EINVAL;
+	if (snd_BUG_ON(!group->enabled))
+		return -EINVAL;
+	if (snd_BUG_ON(group->muted_by_source))
+		return -EINVAL;
 
 	group->muted_by_source = 1;
 
 	list_for_each_entry(converter, &group->converters, list) {
-		BUG_ON(!converter);
-		BUG_ON(!snd_stm_magic_valid(converter));
+		if (snd_BUG_ON(!converter))
+			return -EINVAL;
+		if (snd_BUG_ON(!snd_stm_magic_valid(converter)))
+			return -EINVAL;
 
 		spin_lock(&converter->status_lock);
 
@@ -320,16 +343,22 @@
 
 	snd_stm_printd(1, "snd_stm_conv_unmute(group=%p)\n", group);
 
-	BUG_ON(!group);
-	BUG_ON(!snd_stm_magic_valid(group));
-	BUG_ON(!group->enabled);
-	BUG_ON(!group->muted_by_source);
+	if (snd_BUG_ON(!group))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(group)))
+		return -EINVAL;
+	if (snd_BUG_ON(!group->enabled))
+		return -EINVAL;
+	if (snd_BUG_ON(!group->muted_by_source))
+		return -EINVAL;
 
 	group->muted_by_source = 0;
 
 	list_for_each_entry(converter, &group->converters, list) {
-		BUG_ON(!converter);
-		BUG_ON(!snd_stm_magic_valid(converter));
+		if (snd_BUG_ON(!converter))
+			return -EINVAL;
+		if (snd_BUG_ON(!snd_stm_magic_valid(converter)))
+			return -EINVAL;
 
 		spin_lock(&converter->status_lock);
 
@@ -370,8 +399,10 @@
 	snd_stm_printd(1, "snd_stm_conv_ctl_mute_get(kcontrol=0x%p,"
 			" ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	BUG_ON(!converter);
-	BUG_ON(!snd_stm_magic_valid(converter));
+	if (snd_BUG_ON(!converter))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(converter)))
+		return -EINVAL;
 
 	spin_lock(&converter->status_lock);
 
@@ -391,9 +422,13 @@
 	snd_stm_printd(1, "snd_stm_conv_ctl_mute_put(kcontrol=0x%p,"
 			" ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	BUG_ON(!converter);
-	BUG_ON(!snd_stm_magic_valid(converter));
-	BUG_ON(!converter->ops->set_muted);
+	if (snd_BUG_ON(!converter))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(converter)))
+		return -EINVAL;
+
+	if (snd_BUG_ON(!converter->ops->set_muted))
+		return -EINVAL;
 
 	spin_lock(&converter->status_lock);
 
@@ -436,13 +471,17 @@
 	snd_stm_printd(1, "snd_stm_conv_ctl_mute_add(converter=%p)\n",
 			converter);
 
-	BUG_ON(!converter);
-	BUG_ON(!snd_stm_magic_valid(converter));
+	if (snd_BUG_ON(!converter))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(converter)))
+		return -EINVAL;
 
 	source = converter->group->source;
 
-	BUG_ON(!source);
-	BUG_ON(!snd_stm_magic_valid(source));
+	if (snd_BUG_ON(!source))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(source)))
+		return -EINVAL;
 
 	snd_stm_conv_ctl_mute.device = source->card_device;
 
@@ -475,8 +514,10 @@
 	snd_stm_printd(1, "snd_stm_conv_ctl_route_info(kcontrol=0x%p,"
 			" uinfo=0x%p)\n", kcontrol, uinfo);
 
-	BUG_ON(!source);
-	BUG_ON(!snd_stm_magic_valid(source));
+	if (snd_BUG_ON(!source))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(source)))
+		return -EINVAL;
 
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 	uinfo->count = 1;
@@ -510,8 +551,10 @@
 	snd_stm_printd(1, "snd_stm_conv_ctl_route_get(kcontrol=0x%p,"
 			" ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	BUG_ON(!source);
-	BUG_ON(!snd_stm_magic_valid(source));
+	if (snd_BUG_ON(!source))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(source)))
+		return -EINVAL;
 
 	mutex_lock(&snd_stm_conv_mutex);
 
@@ -541,8 +584,10 @@
 	snd_stm_printd(1, "snd_stm_conv_ctl_route_put(kcontrol=0x%p,"
 			" ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	BUG_ON(!source);
-	BUG_ON(!snd_stm_magic_valid(source));
+	if (snd_BUG_ON(!source))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(source)))
+		return -EINVAL;
 
 	mutex_lock(&snd_stm_conv_mutex);
 
@@ -577,8 +622,10 @@
 
 	snd_stm_printd(1, "snd_stm_conv_ctl_route_add(source=%p)\n", source);
 
-	BUG_ON(!source);
-	BUG_ON(!snd_stm_magic_valid(source));
+	if (snd_BUG_ON(!source))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(source)))
+		return -EINVAL;
 
 	snd_stm_conv_ctl_route.device = source->card_device;
 
@@ -604,7 +651,7 @@
  * Converters router implementation
  */
 
-static inline int snd_stm_conv_more_than_one_entry(const struct list_head *head)
+static int snd_stm_conv_more_than_one_entry(const struct list_head *head)
 {
 	return !list_empty(head) && !list_is_last(head->next, head);
 }
@@ -617,8 +664,10 @@
 	snd_stm_printd(1, "snd_stm_conv_get_source(bus=%p, bus_id='%s')\n",
 			bus, bus_id);
 
-	BUG_ON(!bus);
-	BUG_ON(!bus_id);
+	if (snd_BUG_ON(!bus))
+		return NULL;
+	if (snd_BUG_ON(!bus_id))
+		return NULL;
 
 	mutex_lock(&snd_stm_conv_mutex);
 
@@ -658,11 +707,16 @@
 			"channels_num=%d, card=%p, card_device=%d)\n",
 			bus, bus_id, channels_num, card, card_device);
 
-	BUG_ON(!bus);
-	BUG_ON(!bus_id);
-	BUG_ON(channels_num <= 0);
-	BUG_ON(!card);
-	BUG_ON(card_device < 0);
+	if (snd_BUG_ON(!bus))
+		return NULL;
+	if (snd_BUG_ON(!bus_id))
+		return NULL;
+	if (snd_BUG_ON(channels_num <= 0))
+		return NULL;
+	if (snd_BUG_ON(!card))
+		return NULL;
+	if (snd_BUG_ON(card_device < 0))
+		return NULL;
 
 	source = snd_stm_conv_get_source(bus, bus_id);
 	if (!source) {
@@ -670,8 +724,10 @@
 		return NULL;
 	}
 
-	BUG_ON(source->channels_num != 0);
-	BUG_ON(source->card);
+	if (snd_BUG_ON(source->channels_num != 0))
+		return NULL;
+	if (snd_BUG_ON(source->card))
+		return NULL;
 
 	source->channels_num = channels_num;
 	source->card = card;
@@ -690,10 +746,10 @@
 	list_for_each_entry(group, &source->groups, list) {
 		struct snd_stm_conv_converter *converter;
 
-		BUG_ON(!snd_stm_magic_valid(group));
+		snd_BUG_ON(!snd_stm_magic_valid(group));
 
-		list_for_each_entry(converter, &group->converters, list) {
-			BUG_ON(!snd_stm_magic_valid(converter));
+		list_for_each_entry(converter, &group->converters, list){
+			snd_BUG_ON(!snd_stm_magic_valid(converter));
 
 			if (converter->ops->set_muted &&
 					snd_stm_conv_ctl_mute_add(converter)
@@ -713,8 +769,10 @@
 	snd_stm_printd(1, "snd_stm_conv_unregister_source(source=%p)\n",
 		       source);
 
-	BUG_ON(!source);
-	BUG_ON(!snd_stm_magic_valid(source));
+	if (snd_BUG_ON(!source))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(source)))
+		return -EINVAL;
 
 	mutex_lock(&snd_stm_conv_mutex);
 
@@ -742,12 +800,16 @@
 	snd_stm_printd(1, "snd_stm_conv_get_group(source=%p, name='%s')\n",
 			source, name);
 
-	BUG_ON(!source);
-	BUG_ON(!snd_stm_magic_valid(source));
-	BUG_ON(!name);
+	if (snd_BUG_ON(!source))
+		return NULL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(source)))
+		return NULL;
+	if (snd_BUG_ON(!name))
+		return NULL;
 
 	/* Random memory fuse */
-	BUG_ON(strlen(name) > 1024);
+	if (snd_BUG_ON(strlen(name) >= 1024))
+		return NULL;
 
 	mutex_lock(&snd_stm_conv_mutex);
 
@@ -794,13 +856,17 @@
 
 	snd_stm_printd(1, "snd_stm_conv_remove_group(group=%p)\n", group);
 
-	BUG_ON(!group);
-	BUG_ON(!snd_stm_magic_valid(group));
+	if (snd_BUG_ON(!group))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(group)))
+		return -EINVAL;
 
 	source = group->source;
 
-	BUG_ON(!source);
-	BUG_ON(!snd_stm_magic_valid(source));
+	if (snd_BUG_ON(!source))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(source)))
+		return -EINVAL;
 
 	list_del(&group->list);
 
@@ -856,12 +922,17 @@
 			group_name, ops, priv, source_bus, source_bus_id,
 			source_channel_from, source_channel_to);
 
-	BUG_ON(!group_name);
-	BUG_ON(!ops);
-	BUG_ON(!source_bus);
-	BUG_ON(!source_bus_id);
-	BUG_ON(source_channel_from < 0);
-	BUG_ON(source_channel_to < source_channel_from);
+	if (snd_BUG_ON(!group_name))
+		return NULL;
+	if (snd_BUG_ON(!ops))
+		return NULL;
+	if (snd_BUG_ON(!source_bus))
+		return NULL;
+	if (snd_BUG_ON(!source_bus_id))
+		return NULL;
+	if (snd_BUG_ON((source_channel_from < 0) ||
+		       (source_channel_to < source_channel_from)))
+		return NULL;
 
 	/* Create converter description */
 
@@ -938,13 +1009,17 @@
 	snd_stm_printd(1, "snd_stm_conv_unregister_converter(converter=%p)\n",
 			converter);
 
-	BUG_ON(!converter);
-	BUG_ON(!snd_stm_magic_valid(converter));
+	if (snd_BUG_ON(!converter))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(converter)))
+		return -EINVAL;
 
 	group = converter->group;
 
-	BUG_ON(!group);
-	BUG_ON(!snd_stm_magic_valid(group));
+	if (snd_BUG_ON(!group))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(group)))
+		return -EINVAL;
 
 	mutex_lock(&snd_stm_conv_mutex);
 
@@ -970,8 +1045,10 @@
 	snd_stm_printd(1, "snd_stm_conv_get_card_device(converter=%p)\n",
 			converter);
 
-	BUG_ON(!converter);
-	BUG_ON(!snd_stm_magic_valid(converter));
+	if (snd_BUG_ON(!converter))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(converter)))
+		return -EINVAL;
 
 	return converter->group->source->card_device;
 }
@@ -983,9 +1060,13 @@
 {
 	snd_stm_printd(1, "snd_stm_conv_request_group(source=%p)\n", source);
 
-	BUG_ON(!source);
-	BUG_ON(!snd_stm_magic_valid(source));
-	BUG_ON(source->group_active);
+	if (snd_BUG_ON(!source))
+		return NULL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(source)))
+		return NULL;
+
+	if (snd_BUG_ON(source->group_active))
+		return NULL;
 
 	mutex_lock(&snd_stm_conv_mutex);
 
@@ -1000,11 +1081,18 @@
 {
 	snd_stm_printd(1, "snd_stm_conv_release_group(group=%p)\n", group);
 
-	BUG_ON(!group);
-	BUG_ON(!snd_stm_magic_valid(group));
-	BUG_ON(!group->source);
-	BUG_ON(!snd_stm_magic_valid(group->source));
-	BUG_ON(group != group->source->group_active);
+	if (snd_BUG_ON(!group))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(group)))
+		return -EINVAL;
+
+	if (snd_BUG_ON(!group->source))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(group->source)))
+		return -EINVAL;
+
+	if (snd_BUG_ON(group != group->source->group_active))
+		return -EINVAL;
 
 	mutex_lock(&snd_stm_conv_mutex);
 
@@ -1074,7 +1162,7 @@
  */
 
 
-int __init snd_stm_conv_init(void)
+int snd_stm_conv_init(void)
 {
 	/* Register converters information file in ALSA's procfs */
 
diff -ruN stm.org/conv_dummy.c stm/conv_dummy.c
--- a/drivers/stm/conv_dummy.c	2014-06-03 12:31:04.000000000 -0700
+++ b/sound/stm/conv_dummy.c	2012-10-11 11:46:27.000000000 -0700
@@ -1,7 +1,7 @@
 /*
  *   STMicroelectronics System-on-Chips' dummy DAC driver
  *
- *   Copyright (c) 2005-2011 STMicroelectronics Limited
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
  *
  *   Author: Pawel Moll <pawel.moll@st.com>
  *
@@ -26,15 +26,10 @@
 #include <linux/platform_device.h>
 #include <sound/stm.h>
 
+#define COMPONENT conv_dummy
 #include "common.h"
 
 
-
-static int snd_stm_debug_level;
-module_param_named(debug, snd_stm_debug_level, int, S_IRUGO | S_IWUSR);
-
-
-
 /*
  * Dummy converter instance structure
  */
@@ -58,8 +53,10 @@
 
 	snd_stm_printd(1, "snd_stm_conv_dummy_get_format(priv=%p)\n", priv);
 
-	BUG_ON(!conv_dummy);
-	BUG_ON(!snd_stm_magic_valid(conv_dummy));
+	if (snd_BUG_ON(!conv_dummy))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_dummy)))
+		return -EINVAL;
 
 	return conv_dummy->info->format;
 }
@@ -71,8 +68,10 @@
 	snd_stm_printd(1, "snd_stm_conv_dummy_get_oversampling(priv=%p)\n",
 			priv);
 
-	BUG_ON(!conv_dummy);
-	BUG_ON(!snd_stm_magic_valid(conv_dummy));
+	if (snd_BUG_ON(!conv_dummy))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_dummy)))
+		return -EINVAL;
 
 	return conv_dummy->info->oversampling;
 }
@@ -92,9 +91,10 @@
 {
 	struct snd_stm_conv_dummy *conv_dummy;
 
-	snd_stm_printd(0, "%s('%s')\n", __func__, dev_name(&pdev->dev));
+	snd_stm_printd(0, "--- Probing device '%s'...\n", dev_name(&pdev->dev));
 
-	BUG_ON(!pdev->dev.platform_data);
+	if (snd_BUG_ON(pdev->dev.platform_data == NULL))
+		return -EINVAL;
 
 	conv_dummy = kzalloc(sizeof(*conv_dummy), GFP_KERNEL);
 	if (!conv_dummy) {
@@ -122,6 +122,8 @@
 
 	platform_set_drvdata(pdev, conv_dummy);
 
+	snd_stm_printd(0, "--- Probed successfully!\n");
+
 	return 0;
 }
 
@@ -129,8 +131,10 @@
 {
 	struct snd_stm_conv_dummy *conv_dummy = platform_get_drvdata(pdev);
 
-	BUG_ON(!conv_dummy);
-	BUG_ON(!snd_stm_magic_valid(conv_dummy));
+	if (snd_BUG_ON(!conv_dummy))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_dummy)))
+		return -EINVAL;
 
 	snd_stm_conv_unregister_converter(conv_dummy->converter);
 
@@ -141,7 +145,9 @@
 }
 
 static struct platform_driver snd_stm_conv_dummy_driver = {
-	.driver.name = "snd_conv_dummy",
+	.driver = {
+		.name = "snd_conv_dummy",
+	},
 	.probe = snd_stm_conv_dummy_probe,
 	.remove = snd_stm_conv_dummy_remove,
 };
diff -ruN stm.org/conv_epld.c stm/conv_epld.c
--- a/drivers/stm/conv_epld.c	2014-06-03 12:31:04.000000000 -0700
+++ b/sound/stm/conv_epld.c	2012-10-11 11:46:27.000000000 -0700
@@ -1,7 +1,7 @@
 /*
  *   STMicroelectronics System-on-Chips' EPLD-controlled ADC/DAC driver
  *
- *   Copyright (c) 2005-2011 STMicroelectronics Limited
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
  *
  *   Author: Pawel Moll <pawel.moll@st.com>
  *
@@ -28,22 +28,18 @@
 #include <sound/info.h>
 #include <sound/stm.h>
 
+#define COMPONENT conv_epld
 #include "common.h"
 
 
 
-static int snd_stm_debug_level;
-module_param_named(debug, snd_stm_debug_level, int, S_IRUGO | S_IWUSR);
-
-
-
 /*
  * Internal DAC instance structure
  */
 
 struct snd_stm_conv_epld {
 	/* System informations */
-	const char *dev_name;
+	const char *bus_id;
 	struct snd_stm_conv_converter *converter;
 	struct snd_stm_conv_epld_info *info;
 
@@ -86,8 +82,10 @@
 
 	snd_stm_printd(1, "snd_stm_conv_epld_get_format(priv=%p)\n", priv);
 
-	BUG_ON(!conv_epld);
-	BUG_ON(!snd_stm_magic_valid(conv_epld));
+	if (snd_BUG_ON(!conv_epld))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_epld)))
+		return -EINVAL;
 
 	return conv_epld->info->format;
 }
@@ -99,8 +97,10 @@
 	snd_stm_printd(1, "snd_stm_conv_epld_get_oversampling(priv=%p)\n",
 			priv);
 
-	BUG_ON(!conv_epld);
-	BUG_ON(!snd_stm_magic_valid(conv_epld));
+	if (snd_BUG_ON(!conv_epld))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_epld)))
+		return -EINVAL;
 
 	return conv_epld->info->oversampling;
 }
@@ -112,16 +112,19 @@
 	snd_stm_printd(1, "snd_stm_conv_epld_enable(enabled=%d, priv=%p)\n",
 			enabled, priv);
 
-	BUG_ON(!conv_epld);
-	BUG_ON(!snd_stm_magic_valid(conv_epld));
-	BUG_ON(!conv_epld->info->enable_supported);
+	if (snd_BUG_ON(!conv_epld))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_epld)))
+		return -EINVAL;
+	if (snd_BUG_ON(!conv_epld->info->enable_supported))
+		return -EINVAL;
 
 	snd_stm_printd(1, "%sabling DAC %s's.\n", enabled ? "En" : "Dis",
-			conv_epld->dev_name);
+			conv_epld->bus_id);
 
 	snd_stm_conv_epld_set(conv_epld->info->enable_offset,
 			conv_epld->info->enable_mask,
-			enabled ? conv_epld->info->enable_value :
+			enabled ? conv_epld->info->enable_value:
 			conv_epld->info->disable_value);
 
 	return 0;
@@ -134,12 +137,15 @@
 	snd_stm_printd(1, "snd_stm_conv_epld_set_muted(muted=%d, priv=%p)\n",
 			muted, priv);
 
-	BUG_ON(!conv_epld);
-	BUG_ON(!snd_stm_magic_valid(conv_epld));
-	BUG_ON(!conv_epld->info->mute_supported);
+	if (snd_BUG_ON(!conv_epld))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_epld)))
+		return -EINVAL;
+	if (snd_BUG_ON(!conv_epld->info->mute_supported))
+		return -EINVAL;
 
 	snd_stm_printd(1, "%suting DAC %s.\n", muted ? "M" : "Unm",
-			conv_epld->dev_name);
+			conv_epld->bus_id);
 
 	snd_stm_conv_epld_set(conv_epld->info->mute_offset,
 			conv_epld->info->mute_mask,
@@ -163,10 +169,12 @@
 {
 	struct snd_stm_conv_epld *conv_epld = entry->private_data;
 
-	BUG_ON(!conv_epld);
-	BUG_ON(!snd_stm_magic_valid(conv_epld));
+	if (snd_BUG_ON(!conv_epld))
+		return;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_epld)))
+		return;
 
-	snd_iprintf(buffer, "--- %s ---\n", conv_epld->dev_name);
+	snd_iprintf(buffer, "--- %s ---\n", conv_epld->bus_id);
 
 	if (conv_epld->info->enable_supported)
 		DUMP_EPLD(conv_epld->info->enable_offset);
@@ -187,9 +195,10 @@
 	int result = 0;
 	struct snd_stm_conv_epld *conv_epld;
 
-	snd_stm_printd(0, "%s('%s')\n", __func__, dev_name(&pdev->dev));
+	snd_stm_printd(0, "--- Probing device '%s'...\n", dev_name(&pdev->dev));
 
-	BUG_ON(!pdev->dev.platform_data);
+	if (snd_BUG_ON(pdev->dev.platform_data == NULL))
+		return -EINVAL;
 
 	conv_epld = kzalloc(sizeof(*conv_epld), GFP_KERNEL);
 	if (!conv_epld) {
@@ -199,7 +208,7 @@
 		goto error_alloc;
 	}
 	snd_stm_magic_set(conv_epld);
-	conv_epld->dev_name = dev_name(&pdev->dev);
+	conv_epld->bus_id = dev_name(&pdev->dev);
 	conv_epld->info = pdev->dev.platform_data;
 
 	conv_epld->ops.get_format = snd_stm_conv_epld_get_format;
@@ -211,7 +220,8 @@
 
 	/* Get connections */
 
-	BUG_ON(!conv_epld->info->source_bus_id);
+	if (snd_BUG_ON(conv_epld->info->source_bus_id == NULL))
+		return -EINVAL;
 	snd_stm_printd(0, "This DAC is attached to PCM player '%s'.\n",
 			conv_epld->info->source_bus_id);
 	conv_epld->converter = snd_stm_conv_register_converter(
@@ -240,7 +250,7 @@
 	/* Additional procfs info */
 
 	snd_stm_info_register(&conv_epld->proc_entry,
-			conv_epld->dev_name,
+			conv_epld->bus_id,
 			snd_stm_conv_epld_read_info,
 			conv_epld);
 
@@ -248,6 +258,8 @@
 
 	platform_set_drvdata(pdev, conv_epld);
 
+	snd_stm_printd(0, "--- Probed successfully!\n");
+
 	return 0;
 
 error_attach:
@@ -261,9 +273,12 @@
 {
 	struct snd_stm_conv_epld *conv_epld = platform_get_drvdata(pdev);
 
-	BUG_ON(!conv_epld);
-	BUG_ON(!snd_stm_magic_valid(conv_epld));
+	if (snd_BUG_ON(!conv_epld))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_epld)))
+		return -EINVAL;
 
+	snd_device_free(snd_stm_card_get(), conv_epld);
 	snd_stm_conv_unregister_converter(conv_epld->converter);
 
 	/* Remove procfs entry */
@@ -289,7 +304,9 @@
 }
 
 static struct platform_driver snd_stm_conv_epld_driver = {
-	.driver.name = "snd_conv_epld",
+	.driver = {
+		.name = "snd_conv_epld",
+	},
 	.probe = snd_stm_conv_epld_probe,
 	.remove = snd_stm_conv_epld_remove,
 };
diff -ruN stm.org/conv_gpio.c stm/conv_gpio.c
--- a/drivers/stm/conv_gpio.c	2014-06-03 12:31:04.000000000 -0700
+++ b/sound/stm/conv_gpio.c	2012-10-11 11:46:27.000000000 -0700
@@ -1,7 +1,7 @@
 /*
  *   STMicroelectronics System-on-Chips' GPIO-controlled ADC/DAC driver
  *
- *   Copyright (c) 2005-2011 STMicroelectronics Limited
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
  *
  *   Author: Pawel Moll <pawel.moll@st.com>
  *
@@ -32,22 +32,18 @@
 #include <sound/info.h>
 #include <sound/stm.h>
 
+#define COMPONENT conv_gpio
 #include "common.h"
 
 
 
-static int snd_stm_debug_level;
-module_param_named(debug, snd_stm_debug_level, int, S_IRUGO | S_IWUSR);
-
-
-
 /*
  * Internal DAC instance structure
  */
 
 struct snd_stm_conv_gpio {
 	/* System informations */
-	const char *dev_name;
+	const char *bus_id;
 	struct snd_stm_conv_converter *converter;
 	struct snd_stm_conv_gpio_info *info;
 	struct snd_stm_conv_ops ops;
@@ -78,8 +74,10 @@
 
 	snd_stm_printd(1, "snd_stm_conv_gpio_work(work=%p)\n", work);
 
-	BUG_ON(!conv_gpio);
-	BUG_ON(!snd_stm_magic_valid(conv_gpio));
+	if (snd_BUG_ON(!conv_gpio))
+		return;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_gpio)))
+		return;
 
 	spin_lock(&conv_gpio->work_lock);
 
@@ -107,8 +105,10 @@
 			"enable_not_mute=%d, value=%d)\n",
 			conv_gpio, enable_not_mute, value);
 
-	BUG_ON(!conv_gpio);
-	BUG_ON(!snd_stm_magic_valid(conv_gpio));
+	if (snd_BUG_ON(!conv_gpio))
+		return;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_gpio)))
+		return;
 
 	if (conv_gpio->may_sleep) {
 		spin_lock(&conv_gpio->work_lock);
@@ -136,8 +136,10 @@
 
 	snd_stm_printd(1, "snd_stm_conv_gpio_get_format(priv=%p)\n", priv);
 
-	BUG_ON(!conv_gpio);
-	BUG_ON(!snd_stm_magic_valid(conv_gpio));
+	if (snd_BUG_ON(!conv_gpio))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_gpio)))
+		return -EINVAL;
 
 	return conv_gpio->info->format;
 }
@@ -149,8 +151,10 @@
 	snd_stm_printd(1, "snd_stm_conv_gpio_get_oversampling(priv=%p)\n",
 			priv);
 
-	BUG_ON(!conv_gpio);
-	BUG_ON(!snd_stm_magic_valid(conv_gpio));
+	if (snd_BUG_ON(!conv_gpio))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_gpio)))
+		return -EINVAL;
 
 	return conv_gpio->info->oversampling;
 }
@@ -162,12 +166,15 @@
 	snd_stm_printd(1, "snd_stm_conv_gpio_enable(enabled=%d, priv=%p)\n",
 			enabled, priv);
 
-	BUG_ON(!conv_gpio);
-	BUG_ON(!snd_stm_magic_valid(conv_gpio));
-	BUG_ON(!conv_gpio->info->enable_supported);
+	if (snd_BUG_ON(!conv_gpio))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_gpio)))
+		return -EINVAL;
+	if (snd_BUG_ON(!conv_gpio->info->enable_supported))
+		return -EINVAL;
 
 	snd_stm_printd(1, "%sabling DAC %s's.\n", enabled ? "En" : "Dis",
-			conv_gpio->dev_name);
+			conv_gpio->bus_id);
 
 	snd_stm_conv_gpio_set_value(conv_gpio, 1,
 			enabled ? conv_gpio->info->enable_value :
@@ -183,12 +190,15 @@
 	snd_stm_printd(1, "snd_stm_conv_gpio_set_muted(muted=%d, priv=%p)\n",
 			muted, priv);
 
-	BUG_ON(!conv_gpio);
-	BUG_ON(!snd_stm_magic_valid(conv_gpio));
-	BUG_ON(!conv_gpio->info->mute_supported);
+	if (snd_BUG_ON(!conv_gpio))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_gpio)))
+		return -EINVAL;
+	if (snd_BUG_ON(!conv_gpio->info->mute_supported))
+		return -EINVAL;
 
 	snd_stm_printd(1, "%suting DAC %s.\n", muted ? "M" : "Unm",
-			conv_gpio->dev_name);
+			conv_gpio->bus_id);
 
 	snd_stm_conv_gpio_set_value(conv_gpio, 0,
 			muted ? conv_gpio->info->mute_value :
@@ -208,10 +218,12 @@
 {
 	struct snd_stm_conv_gpio *conv_gpio = entry->private_data;
 
-	BUG_ON(!conv_gpio);
-	BUG_ON(!snd_stm_magic_valid(conv_gpio));
+	if (snd_BUG_ON(!conv_gpio))
+		return;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_gpio)))
+		return;
 
-	snd_iprintf(buffer, "--- %s ---\n", conv_gpio->dev_name);
+	snd_iprintf(buffer, "--- %s ---\n", conv_gpio->bus_id);
 
 	snd_iprintf(buffer, "enable_gpio(%d) = %d\n",
 			conv_gpio->info->enable_gpio,
@@ -235,9 +247,10 @@
 	int result = 0;
 	struct snd_stm_conv_gpio *conv_gpio;
 
-	snd_stm_printd(0, "%s('%s')\n", __func__, dev_name(&pdev->dev));
+	snd_stm_printd(0, "--- Probing device '%s'...\n", dev_name(&pdev->dev));
 
-	BUG_ON(!pdev->dev.platform_data);
+	if (snd_BUG_ON(pdev->dev.platform_data == NULL))
+		return -EINVAL;
 
 	conv_gpio = kzalloc(sizeof(*conv_gpio), GFP_KERNEL);
 	if (!conv_gpio) {
@@ -247,7 +260,7 @@
 		goto error_alloc;
 	}
 	snd_stm_magic_set(conv_gpio);
-	conv_gpio->dev_name = dev_name(&pdev->dev);
+	conv_gpio->bus_id = dev_name(&pdev->dev);
 	conv_gpio->info = pdev->dev.platform_data;
 
 	conv_gpio->ops.get_format = snd_stm_conv_gpio_get_format;
@@ -259,7 +272,8 @@
 
 	/* Get connections */
 
-	BUG_ON(!conv_gpio->info->source_bus_id);
+	if (snd_BUG_ON(conv_gpio->info->source_bus_id == NULL))
+		return -EINVAL;
 	snd_stm_printd(0, "This DAC is attached to PCM player '%s'.\n",
 			conv_gpio->info->source_bus_id);
 	conv_gpio->converter = snd_stm_conv_register_converter(
@@ -277,7 +291,7 @@
 
 	if (conv_gpio->info->enable_supported) {
 		result = gpio_request(conv_gpio->info->enable_gpio,
-				conv_gpio->dev_name);
+				conv_gpio->bus_id);
 		if (result != 0) {
 			snd_stm_printe("Can't reserve 'enable' GPIO line!\n");
 			goto error_gpio_request_enable;
@@ -296,7 +310,7 @@
 
 	if (conv_gpio->info->mute_supported) {
 		result = gpio_request(conv_gpio->info->mute_gpio,
-				conv_gpio->dev_name);
+				conv_gpio->bus_id);
 		if (result != 0) {
 			snd_stm_printe("Can't reserve 'mute' GPIO line!\n");
 			goto error_gpio_request_mute;
@@ -323,7 +337,7 @@
 	/* Additional procfs info */
 
 	snd_stm_info_register(&conv_gpio->proc_entry,
-			conv_gpio->dev_name,
+			conv_gpio->bus_id,
 			snd_stm_conv_gpio_read_info,
 			conv_gpio);
 
@@ -331,6 +345,8 @@
 
 	platform_set_drvdata(pdev, conv_gpio);
 
+	snd_stm_printd(0, "--- Probed successfully!\n");
+
 	return 0;
 
 error_gpio_direction_output_mute:
@@ -353,9 +369,12 @@
 {
 	struct snd_stm_conv_gpio *conv_gpio = platform_get_drvdata(pdev);
 
-	BUG_ON(!conv_gpio);
-	BUG_ON(!snd_stm_magic_valid(conv_gpio));
+	if (snd_BUG_ON(!conv_gpio))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_gpio)))
+		return -EINVAL;
 
+	snd_device_free(snd_stm_card_get(), conv_gpio);
 	snd_stm_conv_unregister_converter(conv_gpio->converter);
 
 	/* Remove procfs entry */
@@ -364,7 +383,7 @@
 
 	/* Wait for the possibly scheduled work... */
 
-	if (conv_gpio->may_sleep)
+	if (conv_gpio->may_sleep);
 		flush_scheduled_work();
 
 	/* Muting and disabling - just to be sure ;-) */
@@ -388,7 +407,9 @@
 }
 
 static struct platform_driver snd_stm_conv_gpio_driver = {
-	.driver.name = "snd_conv_gpio",
+	.driver = {
+		.name = "snd_conv_gpio",
+	},
 	.probe = snd_stm_conv_gpio_probe,
 	.remove = snd_stm_conv_gpio_remove,
 };
diff -ruN stm.org/conv_i2c.c stm/conv_i2c.c
--- a/drivers/stm/conv_i2c.c	2014-06-03 12:31:04.000000000 -0700
+++ b/sound/stm/conv_i2c.c	2012-10-11 11:46:27.000000000 -0700
@@ -1,7 +1,7 @@
 /*
  *   STMicroelectronics System-on-Chips' I2C-controlled ADC/DAC driver
  *
- *   Copyright (c) 2005-2011 STMicroelectronics Limited
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
  *
  *   Author: Pawel Moll <pawel.moll@st.com>
  *
@@ -31,15 +31,11 @@
 #include <sound/info.h>
 #include <sound/stm.h>
 
+#define COMPONENT conv_i2c
 #include "common.h"
 
 
 
-static int snd_stm_debug_level;
-module_param_named(debug, snd_stm_debug_level, int, S_IRUGO | S_IWUSR);
-
-
-
 /*
  * Internal converter instance structure
  */
@@ -78,8 +74,10 @@
 
 	snd_stm_printd(1, "snd_stm_conv_i2c_work(work=%p)\n", work);
 
-	BUG_ON(!conv_i2c);
-	BUG_ON(!snd_stm_magic_valid(conv_i2c));
+	if (snd_BUG_ON(!conv_i2c))
+		return;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_i2c)))
+		return;
 
 	spin_lock(&conv_i2c->work_lock);
 
@@ -136,8 +134,10 @@
 
 	snd_stm_printd(1, "snd_stm_conv_i2c_get_format(priv=%p)\n", priv);
 
-	BUG_ON(!conv_i2c);
-	BUG_ON(!snd_stm_magic_valid(conv_i2c));
+	if (snd_BUG_ON(!conv_i2c))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_i2c)))
+		return -EINVAL;
 
 	return conv_i2c->info->format;
 }
@@ -149,8 +149,10 @@
 	snd_stm_printd(1, "snd_stm_conv_i2c_get_oversampling(priv=%p)\n",
 			priv);
 
-	BUG_ON(!conv_i2c);
-	BUG_ON(!snd_stm_magic_valid(conv_i2c));
+	if (snd_BUG_ON(!conv_i2c))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_i2c)))
+		return -EINVAL;
 
 	return conv_i2c->info->oversampling;
 }
@@ -162,9 +164,12 @@
 	snd_stm_printd(1, "snd_stm_conv_i2c_enable(enabled=%d, priv=%p)\n",
 			enabled, priv);
 
-	BUG_ON(!conv_i2c);
-	BUG_ON(!snd_stm_magic_valid(conv_i2c));
-	BUG_ON(!conv_i2c->info->enable_supported);
+	if (snd_BUG_ON(!conv_i2c))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_i2c)))
+		return -EINVAL;
+	if (snd_BUG_ON(!conv_i2c->info->enable_supported))
+		return -EINVAL;
 
 	snd_stm_printd(1, "%sabling DAC %s's.\n", enabled ? "En" : "Dis",
 			dev_name(&conv_i2c->client->dev));
@@ -184,9 +189,12 @@
 	snd_stm_printd(1, "snd_stm_conv_i2c_set_muted(muted=%d, priv=%p)\n",
 			muted, priv);
 
-	BUG_ON(!conv_i2c);
-	BUG_ON(!snd_stm_magic_valid(conv_i2c));
-	BUG_ON(!conv_i2c->info->mute_supported);
+	if (snd_BUG_ON(!conv_i2c))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_i2c)))
+		return -EINVAL;
+	if (snd_BUG_ON(!conv_i2c->info->mute_supported))
+		return -EINVAL;
 
 	snd_stm_printd(1, "%suting DAC %s.\n", muted ? "M" : "Unm",
 			dev_name(&conv_i2c->client->dev));
@@ -205,15 +213,17 @@
  * I2C driver routines
  */
 
-static int snd_stm_conv_i2c_probe(struct i2c_client *client,
+int snd_stm_conv_i2c_probe(struct i2c_client *client,
 	const struct i2c_device_id *id)
 {
 	int result = 0;
 	struct snd_stm_conv_i2c *conv_i2c;
 
-	snd_stm_printd(0, "%s('%s')\n", __func__, dev_name(&client->dev));
+	snd_stm_printd(0, "--- Probing I2C device '%s'...\n",
+			dev_name(&client->dev));
 
-	BUG_ON(!client->dev.platform_data);
+	if (snd_BUG_ON(client->dev.platform_data == NULL))
+		return -EINVAL;
 
 	conv_i2c = kzalloc(sizeof(*conv_i2c), GFP_KERNEL);
 	if (!conv_i2c) {
@@ -248,7 +258,8 @@
 
 	/* Get connections */
 
-	BUG_ON(!conv_i2c->info->source_bus_id);
+	if (snd_BUG_ON(conv_i2c->info->source_bus_id == NULL))
+		return -EINVAL;
 	snd_stm_printd(0, "This converter is attached to '%s'.\n",
 			conv_i2c->info->source_bus_id);
 	conv_i2c->converter = snd_stm_conv_register_converter(
@@ -297,6 +308,8 @@
 
 	i2c_set_clientdata(client, conv_i2c);
 
+	snd_stm_printd(0, "--- Probed successfully!\n");
+
 	return 0;
 
 error_set_muted:
@@ -314,9 +327,12 @@
 {
 	struct snd_stm_conv_i2c *conv_i2c = i2c_get_clientdata(client);
 
-	BUG_ON(!conv_i2c);
-	BUG_ON(!snd_stm_magic_valid(conv_i2c));
+	if (snd_BUG_ON(!conv_i2c))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_i2c)))
+		return -EINVAL;
 
+	snd_device_free(snd_stm_card_get(), conv_i2c);
 	snd_stm_conv_unregister_converter(conv_i2c->converter);
 
 	/* Wait for the possibly scheduled work... */
@@ -339,7 +355,9 @@
 }
 
 static struct i2c_driver snd_stm_conv_i2c_driver = {
-	.driver.name = "snd_conv_i2c",
+	.driver = {
+		.name = "snd_conv_i2c",
+	},
 	.probe = snd_stm_conv_i2c_probe,
 	.remove = snd_stm_conv_i2c_remove,
 };
diff -ruN stm.org/conv_i2sspdif.c stm/conv_i2sspdif.c
--- a/drivers/stm/conv_i2sspdif.c	2014-06-03 12:31:04.000000000 -0700
+++ b/sound/stm/conv_i2sspdif.c	2012-10-11 11:46:27.000000000 -0700
@@ -1,7 +1,7 @@
 /*
  *   STMicroelectronics System-on-Chips' I2S to SPDIF converter driver
  *
- *   Copyright (c) 2005-2011 STMicroelectronics Limited
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
  *
  *   Author: Pawel Moll <pawel.moll@st.com>
  *
@@ -30,16 +30,12 @@
 #include <sound/info.h>
 #include <sound/stm.h>
 
+#define COMPONENT conv_i2sspdif
 #include "common.h"
 #include "reg_aud_spdifpc.h"
 
 
 
-static int snd_stm_debug_level;
-module_param_named(debug, snd_stm_debug_level, int, S_IRUGO | S_IWUSR);
-
-
-
 /*
  * Hardware-related definitions
  */
@@ -89,27 +85,6 @@
 
 #define CHA_STA_TRIES 50000
 
-static int snd_stm_conv_i2sspdif_set_cha_sta(struct snd_stm_conv_i2sspdif
-		*conv_i2sspdif, unsigned long *status)
-{
-	int j;
-
-	/* Clear the channel status update bit (only IP v4 or later) */
-	if (conv_i2sspdif->ver >= 4)
-		set__AUD_SPDIFPC_CFG__CHL_STS_UPDATE_CLR(conv_i2sspdif, 1);
-
-	/* Set the channel status */
-	for (j = 0; j < 6; j++)
-		set__AUD_SPDIFPC_CHA_STA(conv_i2sspdif, j, status[j]);
-
-	/* Verify the channel status is set */
-	for (j = 0; j < 6; j++)
-		if (get__AUD_SPDIFPC_CHA_STA(conv_i2sspdif, j) != status[j])
-			return 0;
-
-	return 1;
-}
-
 static int snd_stm_conv_i2sspdif_iec958_set(struct snd_stm_conv_i2sspdif
 		*conv_i2sspdif, struct snd_aes_iec958 *iec958)
 {
@@ -119,8 +94,10 @@
 	snd_stm_printd(1, "snd_stm_conv_i2sspdif_iec958_set(conv_i2sspdif=%p"
 			", iec958=%p)\n", conv_i2sspdif, iec958);
 
-	BUG_ON(!conv_i2sspdif);
-	BUG_ON(!snd_stm_magic_valid(conv_i2sspdif));
+	if (snd_BUG_ON(!conv_i2sspdif))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_i2sspdif)))
+		return -EINVAL;
 
 	/* I2S to SPDIF converter should be used only for playing
 	 * PCM (non compressed) data, so validity bit should be always
@@ -132,10 +109,10 @@
 	 * converter hardware, so it is better not to do this at all... */
 	set__AUD_SPDIFPC_DATA__USER_DATA_BITS(conv_i2sspdif, 0);
 
-	BUG_ON(memcmp(snd_stm_conv_i2sspdif_iec958_zeroed.subcode,
+	snd_BUG_ON(memcmp(snd_stm_conv_i2sspdif_iec958_zeroed.subcode,
 			  iec958->subcode, sizeof(iec958->subcode)) != 0);
 
-	if (conv_i2sspdif->ver < 4) {
+	if (conv_i2sspdif->ver < ver__AUD_SPDIFPC__65_3_0) {
 		/* Converter hardware by default puts every single bit of
 		 * status to separate SPDIF subframe (instead of putting
 		 * the same bit to both left and right subframes).
@@ -163,26 +140,6 @@
 
 			status[i] = word | (word << 1);
 		}
-
-		/* Set converter's channel status registers - they are realised
-		 * in such a ridiculous way that write to them is enabled only
-		 * in (about) 300us time window after CHL_STS_BUFF_EMPTY bit
-		 * is asserted... And this happens once every 2ms (only when
-		 * converter is enabled and gets data...) */
-
-		for (i = 0; i < CHA_STA_TRIES; i++) {
-
-			if (get__AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY(
-							conv_i2sspdif)) {
-
-				ok = snd_stm_conv_i2sspdif_set_cha_sta(
-								conv_i2sspdif,
-								status);
-
-				if (ok)
-					break;
-			}
-		}
 	} else {
 		/* Fortunately in some hardware there is a "sane" mode
 		 * of channel status registers operation... :-) */
@@ -192,12 +149,31 @@
 					iec958->status[i * 4 + 1] << 8 |
 					iec958->status[i * 4 + 2] << 16 |
 					iec958->status[i * 4 + 3] << 24;
-
-		/* Set converter's channel status registers */
-		ok = snd_stm_conv_i2sspdif_set_cha_sta(conv_i2sspdif, status);
 	}
 
-
+	/* Set converter's channel status registers - they are realised
+	 * in such a ridiculous way that write to them is enabled only
+	 * in (about) 300us time window after CHL_STS_BUFF_EMPTY bit
+	 * is asserted... And this happens once every 2ms (only when
+	 * converter is enabled and gets data...) */
+
+	ok = 0;
+	for (i = 0; i < CHA_STA_TRIES; i++) {
+		if (get__AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY(conv_i2sspdif)) {
+			for (j = 0; j < 6; j++)
+				set__AUD_SPDIFPC_CHA_STA(conv_i2sspdif, j,
+						status[j]);
+			ok = 1;
+			for (j = 0; j < 6; j++)
+				if (get__AUD_SPDIFPC_CHA_STA(conv_i2sspdif,
+						j) != status[j]) {
+					ok = 0;
+					break;
+				}
+			if (ok)
+				break;
+		}
+	}
 	if (!ok) {
 		snd_stm_printe("WARNING! Failed to set channel status registers"
 				" for converter %s! (tried %d times)\n",
@@ -239,8 +215,10 @@
 	snd_stm_printd(1, "snd_stm_conv_i2sspdif_oversampling("
 			"conv_i2sspdif=%p)\n", conv_i2sspdif);
 
-	BUG_ON(!conv_i2sspdif);
-	BUG_ON(!snd_stm_magic_valid(conv_i2sspdif));
+	if (snd_BUG_ON(!conv_i2sspdif))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_i2sspdif)))
+		return -EINVAL;
 
 	return DEFAULT_OVERSAMPLING;
 }
@@ -254,13 +232,17 @@
 	snd_stm_printd(1, "snd_stm_conv_i2sspdif_enable(conv_i2sspdif=%p)\n",
 			conv_i2sspdif);
 
-	BUG_ON(!conv_i2sspdif);
-	BUG_ON(!snd_stm_magic_valid(conv_i2sspdif));
-	BUG_ON(conv_i2sspdif->enabled);
+	if (snd_BUG_ON(!conv_i2sspdif))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_i2sspdif)))
+		return -EINVAL;
+	if (snd_BUG_ON(conv_i2sspdif->enabled))
+		return -EINVAL;
 
 	oversampling = snd_stm_conv_i2sspdif_oversampling(conv_i2sspdif);
-	BUG_ON(oversampling <= 0);
-	BUG_ON((oversampling % 128) != 0);
+	if (snd_BUG_ON((oversampling <= 0) ||
+		       (oversampling % 128) != 0))
+		return -EINVAL;
 
 	set__AUD_SPDIFPC_CFG(conv_i2sspdif,
 		mask__AUD_SPDIFPC_CFG__DEVICE_EN__ENABLED(conv_i2sspdif) |
@@ -279,7 +261,7 @@
 	 * of SPDIF block) - pathetic! ;-) Setting bit 6 of config register
 	 * enables a mode in which channel status bits in L/R subframes
 	 * are identical, and whole block is served... */
-	if (conv_i2sspdif->ver >= 4)
+	if (conv_i2sspdif->ver >= ver__AUD_SPDIFPC__65_3_0)
 		set__AUD_SPDIFPC_CFG__CHA_STA_BITS__FRAME(conv_i2sspdif);
 
 	spin_lock(&conv_i2sspdif->iec958_default_lock);
@@ -300,9 +282,12 @@
 	snd_stm_printd(1, "snd_stm_conv_i2sspdif_disable(conv_i2sspdif=%p)\n",
 			conv_i2sspdif);
 
-	BUG_ON(!conv_i2sspdif);
-	BUG_ON(!snd_stm_magic_valid(conv_i2sspdif));
-	BUG_ON(!conv_i2sspdif->enabled);
+	if (snd_BUG_ON(!conv_i2sspdif))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_i2sspdif)))
+		return -EINVAL;
+	if (snd_BUG_ON(!conv_i2sspdif->enabled))
+		return -EINVAL;
 
 	if (snd_stm_conv_i2sspdif_iec958_set(conv_i2sspdif,
 			&snd_stm_conv_i2sspdif_iec958_zeroed) != 0)
@@ -332,7 +317,7 @@
 {
 	snd_stm_printd(1, "snd_stm_conv_i2sspdif_get_format(priv=%p)\n", priv);
 
-	return SND_STM_FORMAT__I2S | SND_STM_FORMAT__SUBFRAME_32_BITS;
+	return (SND_STM_FORMAT__I2S | SND_STM_FORMAT__SUBFRAME_32_BITS);
 }
 
 static int snd_stm_conv_i2sspdif_get_oversampling(void *priv)
@@ -342,8 +327,10 @@
 	snd_stm_printd(1, "snd_stm_conv_i2sspdif_get_oversampling(priv=%p)\n",
 			priv);
 
-	BUG_ON(!conv_i2sspdif);
-	BUG_ON(!snd_stm_magic_valid(conv_i2sspdif));
+	if (snd_BUG_ON(!conv_i2sspdif))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_i2sspdif)))
+		return -EINVAL;
 
 	return snd_stm_conv_i2sspdif_oversampling(conv_i2sspdif);
 }
@@ -355,8 +342,10 @@
 	snd_stm_printd(1, "snd_stm_conv_i2sspdif_set_enabled(enabled=%d, "
 			"priv=%p)\n", enabled, priv);
 
-	BUG_ON(!conv_i2sspdif);
-	BUG_ON(!snd_stm_magic_valid(conv_i2sspdif));
+	if (snd_BUG_ON(!conv_i2sspdif))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_i2sspdif)))
+		return -EINVAL;
 
 	snd_stm_printd(1, "%sabling I2S to SPDIF converter '%s'.\n",
 			enabled ? "En" : "Dis",
@@ -389,8 +378,10 @@
 	snd_stm_printd(1, "snd_stm_conv_i2sspdif_ctl_default_get("
 			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	BUG_ON(!conv_i2sspdif);
-	BUG_ON(!snd_stm_magic_valid(conv_i2sspdif));
+	if (snd_BUG_ON(!conv_i2sspdif))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_i2sspdif)))
+		return -EINVAL;
 
 	spin_lock(&conv_i2sspdif->iec958_default_lock);
 	ucontrol->value.iec958 = conv_i2sspdif->iec958_default;
@@ -409,8 +400,10 @@
 	snd_stm_printd(1, "snd_stm_conv_i2sspdif_ctl_default_put("
 			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	BUG_ON(!conv_i2sspdif);
-	BUG_ON(!snd_stm_magic_valid(conv_i2sspdif));
+	if (snd_BUG_ON(!conv_i2sspdif))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_i2sspdif)))
+		return -EINVAL;
 
 	spin_lock(&conv_i2sspdif->iec958_default_lock);
 	if (snd_stm_iec958_cmp(&conv_i2sspdif->iec958_default,
@@ -464,8 +457,10 @@
 		entry->private_data;
 	int i;
 
-	BUG_ON(!conv_i2sspdif);
-	BUG_ON(!snd_stm_magic_valid(conv_i2sspdif));
+	if (snd_BUG_ON(!conv_i2sspdif))
+		return;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_i2sspdif)))
+		return;
 
 	snd_iprintf(buffer, "--- %s ---\n", dev_name(conv_i2sspdif->device));
 	snd_iprintf(buffer, "base = 0x%p\n", conv_i2sspdif->base);
@@ -500,11 +495,18 @@
 	struct snd_stm_conv_i2sspdif *conv_i2sspdif = snd_device->device_data;
 	int i;
 
-	snd_stm_printd(1, "%s(snd_device=0x%p)\n", __func__, snd_device);
+	snd_stm_printd(1, "snd_stm_conv_i2sspdif_register(snd_device=0x%p)\n",
+			snd_device);
 
-	BUG_ON(!conv_i2sspdif);
-	BUG_ON(!snd_stm_magic_valid(conv_i2sspdif));
-	BUG_ON(conv_i2sspdif->enabled);
+	if (snd_BUG_ON(!conv_i2sspdif))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_i2sspdif)))
+		return -EINVAL;
+	if (snd_BUG_ON(conv_i2sspdif->enabled))
+		return -EINVAL;
+
+	snd_stm_printd(0, "--- Registering I2S to SPDIF converter '%s'...\n",
+			dev_name(conv_i2sspdif->device));
 
 	/* Initialize converter's input & SPDIF player as disabled */
 
@@ -543,6 +545,8 @@
 		}
 	}
 
+	snd_stm_printd(0, "--- Registered successfully!\n");
+
 	return 0;
 }
 
@@ -550,11 +554,15 @@
 {
 	struct snd_stm_conv_i2sspdif *conv_i2sspdif = snd_device->device_data;
 
-	snd_stm_printd(1, "%s(snd_device=0x%p)\n", __func__, snd_device);
+	snd_stm_printd(1, "snd_stm_conv_i2sspdif_disconnect(snd_device=0x%p)\n",
+			snd_device);
 
-	BUG_ON(!conv_i2sspdif);
-	BUG_ON(!snd_stm_magic_valid(conv_i2sspdif));
-	BUG_ON(conv_i2sspdif->enabled);
+	if (snd_BUG_ON(!conv_i2sspdif))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_i2sspdif)))
+		return -EINVAL;
+	if (snd_BUG_ON(conv_i2sspdif->enabled))
+		return -EINVAL;
 
 	/* Remove procfs entry */
 
@@ -592,9 +600,10 @@
 			pdev->dev.platform_data;
 	struct snd_stm_conv_i2sspdif *conv_i2sspdif;
 
-	snd_stm_printd(0, "%s('%s')\n", __func__, dev_name(&pdev->dev));
+	snd_stm_printd(0, "--- Probing device '%s'...\n", dev_name(&pdev->dev));
 
-	BUG_ON(!conv_i2sspdif_info);
+	if (snd_BUG_ON(conv_i2sspdif_info == NULL))
+		return -EINVAL;
 
 	conv_i2sspdif = kzalloc(sizeof(*conv_i2sspdif), GFP_KERNEL);
 	if (!conv_i2sspdif) {
@@ -605,7 +614,8 @@
 	}
 	snd_stm_magic_set(conv_i2sspdif);
 	conv_i2sspdif->ver = conv_i2sspdif_info->ver;
-	BUG_ON(conv_i2sspdif->ver <= 0);
+	if (snd_BUG_ON(!conv_i2sspdif->ver <= 0))
+		return -EINVAL;
 	conv_i2sspdif->info = conv_i2sspdif_info;
 	conv_i2sspdif->device = &pdev->dev;
 	spin_lock_init(&conv_i2sspdif->iec958_default_lock);
@@ -621,7 +631,8 @@
 
 	/* Get connections */
 
-	BUG_ON(!conv_i2sspdif_info->source_bus_id);
+	if (snd_BUG_ON(conv_i2sspdif_info->source_bus_id == NULL))
+		return -EINVAL;
 	snd_stm_printd(0, "This I2S-SPDIF converter is attached to PCM player"
 			" '%s'.\n",
 			conv_i2sspdif_info->source_bus_id);
@@ -651,6 +662,8 @@
 
 	platform_set_drvdata(pdev, conv_i2sspdif);
 
+	snd_stm_printd(0, "--- Probed successfully!\n");
+
 	return result;
 
 error_device:
@@ -669,8 +682,10 @@
 	struct snd_stm_conv_i2sspdif *conv_i2sspdif =
 			platform_get_drvdata(pdev);
 
-	BUG_ON(!conv_i2sspdif);
-	BUG_ON(!snd_stm_magic_valid(conv_i2sspdif));
+	if (snd_BUG_ON(!conv_i2sspdif))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_i2sspdif)))
+		return -EINVAL;
 
 	snd_stm_conv_unregister_converter(conv_i2sspdif->converter);
 	snd_stm_memory_release(conv_i2sspdif->mem_region, conv_i2sspdif->base);
@@ -682,7 +697,9 @@
 }
 
 static struct platform_driver snd_stm_conv_i2sspdif_driver = {
-	.driver.name = "snd_conv_i2sspdif",
+	.driver = {
+		.name = "snd_conv_i2sspdif",
+	},
 	.probe = snd_stm_conv_i2sspdif_probe,
 	.remove = snd_stm_conv_i2sspdif_remove,
 };
@@ -693,19 +710,12 @@
  * Initialization
  */
 
-static int __init snd_stm_conv_i2sspdif_init(void)
+int snd_stm_conv_i2sspdif_init(void)
 {
 	return platform_driver_register(&snd_stm_conv_i2sspdif_driver);
 }
 
-static void __exit snd_stm_conv_i2sspdif_exit(void)
+void snd_stm_conv_i2sspdif_exit(void)
 {
 	platform_driver_unregister(&snd_stm_conv_i2sspdif_driver);
 }
-
-MODULE_AUTHOR("Pawel Moll <pawel.moll@st.com>");
-MODULE_DESCRIPTION("STMicroelectronics I2S to SPDIF converter driver");
-MODULE_LICENSE("GPL");
-
-module_init(snd_stm_conv_i2sspdif_init);
-module_exit(snd_stm_conv_i2sspdif_exit);
diff -ruN stm.org/conv_int_dac.c stm/conv_int_dac.c
--- a/dev/null
+++ b/sound/stm/conv_int_dac.c	2012-10-11 11:46:27.000000000 -0700
@@ -0,0 +1,361 @@
+/*
+ *   STMicroelectronics System-on-Chips' internal audio DAC driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel Moll <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <sound/core.h>
+#include <sound/info.h>
+#include <sound/stm.h>
+
+#define COMPONENT conv_int_dac
+#include "common.h"
+#include "reg_audcfg_adac.h"
+
+
+
+/*
+ * Hardware-related definitions
+ */
+
+#define FORMAT (SND_STM_FORMAT__I2S | SND_STM_FORMAT__SUBFRAME_32_BITS)
+#define OVERSAMPLING 256
+
+
+
+/*
+ * Internal DAC instance structure
+ */
+
+struct snd_stm_conv_int_dac {
+	/* System informations */
+	struct snd_stm_conv_converter *converter;
+	const char *bus_id;
+	int ver; /* IP version, used by register access macros */
+
+	/* Resources */
+	struct resource *mem_region;
+	void *base;
+
+	struct snd_info_entry *proc_entry;
+
+	snd_stm_magic_field;
+};
+
+
+
+/*
+ * Converter interface implementation
+ */
+
+static unsigned int snd_stm_conv_int_dac_get_format(void *priv)
+{
+	snd_stm_printd(1, "snd_stm_conv_int_dac_get_format(priv=%p)\n", priv);
+
+	return FORMAT;
+}
+
+static int snd_stm_conv_int_dac_get_oversampling(void *priv)
+{
+	snd_stm_printd(1, "snd_stm_conv_int_dac_get_oversampling(priv=%p)\n",
+			priv);
+
+	return OVERSAMPLING;
+}
+
+static int snd_stm_conv_int_dac_set_enabled(int enabled, void *priv)
+{
+	struct snd_stm_conv_int_dac *conv_int_dac = priv;
+
+	snd_stm_printd(1, "snd_stm_conv_int_dac_set_enabled(enabled=%d, "
+			"priv=%p)\n", enabled, priv);
+
+	if (snd_BUG_ON(!conv_int_dac))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_int_dac)))
+		return -EINVAL;
+
+	snd_stm_printd(1, "%sabling DAC %s's digital part.\n",
+			enabled ? "En" : "Dis", conv_int_dac->bus_id);
+
+	if (enabled) {
+		set__AUDCFG_ADAC_CTRL__NSB__NORMAL(conv_int_dac);
+		set__AUDCFG_ADAC_CTRL__NRST__NORMAL(conv_int_dac);
+	} else {
+		set__AUDCFG_ADAC_CTRL__NRST__RESET(conv_int_dac);
+		set__AUDCFG_ADAC_CTRL__NSB__POWER_DOWN(conv_int_dac);
+	}
+
+	return 0;
+}
+
+static int snd_stm_conv_int_dac_set_muted(int muted, void *priv)
+{
+	struct snd_stm_conv_int_dac *conv_int_dac = priv;
+
+	snd_stm_printd(1, "snd_stm_conv_int_dac_set_muted(muted=%d, priv=%p)\n",
+		       muted, priv);
+
+	if (snd_BUG_ON(!conv_int_dac))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_int_dac)))
+		return -EINVAL;
+
+	snd_stm_printd(1, "%suting DAC %s.\n", muted ? "M" : "Unm",
+			conv_int_dac->bus_id);
+
+	if (muted)
+		set__AUDCFG_ADAC_CTRL__SOFTMUTE__MUTE(conv_int_dac);
+	else
+		set__AUDCFG_ADAC_CTRL__SOFTMUTE__NORMAL(conv_int_dac);
+
+	return 0;
+}
+
+static struct snd_stm_conv_ops snd_stm_conv_int_dac_ops = {
+	.get_format = snd_stm_conv_int_dac_get_format,
+	.get_oversampling = snd_stm_conv_int_dac_get_oversampling,
+	.set_enabled = snd_stm_conv_int_dac_set_enabled,
+	.set_muted = snd_stm_conv_int_dac_set_muted,
+};
+
+
+
+/*
+ * ALSA lowlevel device implementation
+ */
+
+static void snd_stm_conv_int_dac_read_info(struct snd_info_entry *entry,
+		struct snd_info_buffer *buffer)
+{
+	struct snd_stm_conv_int_dac *conv_int_dac =
+		entry->private_data;
+
+	if (snd_BUG_ON(!conv_int_dac))
+		return;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_int_dac)))
+		return;
+
+	snd_iprintf(buffer, "--- %s ---\n", conv_int_dac->bus_id);
+	snd_iprintf(buffer, "base = 0x%p\n", conv_int_dac->base);
+
+	snd_iprintf(buffer, "AUDCFG_ADAC_CTRL (offset 0x00) = 0x%08x\n",
+			get__AUDCFG_ADAC_CTRL(conv_int_dac));
+
+	snd_iprintf(buffer, "\n");
+}
+
+static int snd_stm_conv_int_dac_register(struct snd_device *snd_device)
+{
+	struct snd_stm_conv_int_dac *conv_int_dac =
+			snd_device->device_data;
+
+	if (snd_BUG_ON(!conv_int_dac))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_int_dac)))
+		return -EINVAL;
+
+	/* Initialize DAC with digital part down, analog up and muted */
+
+	set__AUDCFG_ADAC_CTRL(conv_int_dac,
+			mask__AUDCFG_ADAC_CTRL__NRST__RESET(conv_int_dac) |
+			mask__AUDCFG_ADAC_CTRL__MODE__DEFAULT(conv_int_dac) |
+			mask__AUDCFG_ADAC_CTRL__NSB__POWER_DOWN(conv_int_dac) |
+			mask__AUDCFG_ADAC_CTRL__SOFTMUTE__MUTE(conv_int_dac) |
+			mask__AUDCFG_ADAC_CTRL__PDNANA__NORMAL(conv_int_dac) |
+			mask__AUDCFG_ADAC_CTRL__PDNBG__NORMAL(conv_int_dac));
+
+	/* Additional procfs info */
+
+	snd_stm_info_register(&conv_int_dac->proc_entry,
+			conv_int_dac->bus_id,
+			snd_stm_conv_int_dac_read_info,
+			conv_int_dac);
+
+	return 0;
+}
+
+static int __exit snd_stm_conv_int_dac_disconnect(struct snd_device *snd_device)
+{
+	struct snd_stm_conv_int_dac *conv_int_dac =
+			snd_device->device_data;
+
+	if (snd_BUG_ON(!conv_int_dac))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_int_dac)))
+		return -EINVAL;
+
+	/* Remove procfs entry */
+
+	snd_stm_info_unregister(conv_int_dac->proc_entry);
+
+	/* Global power done & mute mode */
+
+	set__AUDCFG_ADAC_CTRL(conv_int_dac,
+		mask__AUDCFG_ADAC_CTRL__NRST__RESET(conv_int_dac) |
+		mask__AUDCFG_ADAC_CTRL__MODE__DEFAULT(conv_int_dac) |
+		mask__AUDCFG_ADAC_CTRL__NSB__POWER_DOWN(conv_int_dac) |
+		mask__AUDCFG_ADAC_CTRL__SOFTMUTE__MUTE(conv_int_dac) |
+		mask__AUDCFG_ADAC_CTRL__PDNANA__POWER_DOWN(conv_int_dac) |
+		mask__AUDCFG_ADAC_CTRL__PDNBG__POWER_DOWN(conv_int_dac));
+
+	return 0;
+}
+
+static struct snd_device_ops snd_stm_conv_int_dac_snd_device_ops = {
+	.dev_register = snd_stm_conv_int_dac_register,
+	.dev_disconnect = snd_stm_conv_int_dac_disconnect,
+};
+
+
+
+/*
+ * Platform driver routines
+ */
+
+static int snd_stm_conv_int_dac_probe(struct platform_device *pdev)
+{
+	int result = 0;
+	struct snd_stm_conv_int_dac_info *conv_int_dac_info =
+			pdev->dev.platform_data;
+	struct snd_stm_conv_int_dac *conv_int_dac;
+	struct snd_card *card = snd_stm_card_get();
+
+	snd_stm_printd(0, "--- Probing device '%s'...\n", dev_name(&pdev->dev));
+
+	if (snd_BUG_ON(card == NULL))
+		return -EINVAL;
+	if (snd_BUG_ON(conv_int_dac_info == NULL))
+		return -EINVAL;
+
+	conv_int_dac = kzalloc(sizeof(*conv_int_dac), GFP_KERNEL);
+	if (!conv_int_dac) {
+		snd_stm_printe("Can't allocate memory "
+				"for a device description!\n");
+		result = -ENOMEM;
+		goto error_alloc;
+	}
+	snd_stm_magic_set(conv_int_dac);
+	conv_int_dac->ver = conv_int_dac_info->ver;
+	if (snd_BUG_ON(conv_int_dac->ver <= 0))
+		return -EINVAL;
+	conv_int_dac->bus_id = dev_name(&pdev->dev);
+
+	/* Get resources */
+
+	result = snd_stm_memory_request(pdev, &conv_int_dac->mem_region,
+			&conv_int_dac->base);
+	if (result < 0) {
+		snd_stm_printe("Memory region request failed!\n");
+		goto error_memory_request;
+	}
+
+	/* Get connections */
+
+	if (snd_BUG_ON(conv_int_dac_info->source_bus_id == NULL))
+		return -EINVAL;
+	snd_stm_printd(0, "This DAC is attached to PCM player '%s'.\n",
+			conv_int_dac_info->source_bus_id);
+	conv_int_dac->converter = snd_stm_conv_register_converter(
+			"Analog Output",
+			&snd_stm_conv_int_dac_ops, conv_int_dac,
+			&platform_bus_type, conv_int_dac_info->source_bus_id,
+			conv_int_dac_info->channel_from,
+			conv_int_dac_info->channel_to, NULL);
+	if (!conv_int_dac->converter) {
+		snd_stm_printe("Can't attach to PCM player!\n");
+		goto error_attach;
+	}
+
+	/* Create ALSA lowlevel device*/
+
+	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, conv_int_dac,
+			&snd_stm_conv_int_dac_snd_device_ops);
+	if (result < 0) {
+		snd_stm_printe("ALSA low level device creation failed!\n");
+		goto error_device;
+	}
+
+	/* Done now */
+
+	platform_set_drvdata(pdev, conv_int_dac);
+
+	snd_stm_printd(0, "--- Probed successfully!\n");
+
+	return 0;
+
+error_device:
+error_attach:
+	snd_stm_memory_release(conv_int_dac->mem_region,
+			conv_int_dac->base);
+error_memory_request:
+	snd_stm_magic_clear(conv_int_dac);
+	kfree(conv_int_dac);
+error_alloc:
+	return result;
+}
+
+static int snd_stm_conv_int_dac_remove(struct platform_device *pdev)
+{
+	struct snd_stm_conv_int_dac *conv_int_dac = platform_get_drvdata(pdev);
+
+	if (snd_BUG_ON(!conv_int_dac))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(conv_int_dac)))
+		return -EINVAL;
+
+	snd_stm_conv_unregister_converter(conv_int_dac->converter);
+	snd_stm_memory_release(conv_int_dac->mem_region,
+			conv_int_dac->base);
+
+	snd_stm_magic_clear(conv_int_dac);
+	kfree(conv_int_dac);
+
+	return 0;
+}
+
+static struct platform_driver snd_stm_conv_int_dac_driver = {
+	.driver = {
+		.name = "snd_conv_int_dac",
+	},
+	.probe = snd_stm_conv_int_dac_probe,
+	.remove = snd_stm_conv_int_dac_remove,
+};
+
+
+
+/*
+ * Initialization
+ */
+
+int snd_stm_conv_int_dac_init(void)
+{
+	return platform_driver_register(&snd_stm_conv_int_dac_driver);
+}
+
+void snd_stm_conv_int_dac_exit(void)
+{
+	platform_driver_unregister(&snd_stm_conv_int_dac_driver);
+}
diff -ruN stm.org/fsynth.c stm/fsynth.c
--- a/dev/null
+++ b/sound/stm/fsynth.c	2012-10-11 11:46:27.000000000 -0700
@@ -0,0 +1,813 @@
+/*
+ *   STMicroelectronics System-on-Chips' audio oversampling frequency
+ *   synthesizers driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Authors: Pawel Moll <pawel.moll@st.com>
+ *            Daniel Thompson <daniel.thompson@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/math64.h>
+#include <sound/core.h>
+#include <sound/info.h>
+
+#define COMPONENT fsynth
+#include "common.h"
+#include "reg_audcfg_fsyn.h"
+
+
+
+/*
+ * Hardware constants
+ */
+
+/* PLL inside the synthesizer multiplies input frequency
+ * (which is 30MHz in our case) by 8... */
+#define PLL_FREQ 8 * 30 * 1000 * 1000
+
+
+
+/*
+ * Audio frequency synthesizer structures
+ */
+
+struct snd_stm_fsynth_channel {
+	struct snd_stm_fsynth *fsynth;
+
+	int frequency;  /* Nominal */
+	int adjustment; /* Actual (achieved) */
+
+	snd_stm_magic_field;
+};
+
+struct snd_stm_fsynth {
+	/* System informations */
+	const char *bus_id;
+	int ver; /* IP version, used by register access macros */
+	int channels_max;
+
+	/* Resources */
+	struct resource *mem_region;
+	void *base;
+
+	/* Environment settings */
+	int channels_from, channels_to;
+
+	/* Runtime data */
+	struct snd_stm_fsynth_channel *channels;
+
+	struct snd_info_entry *proc_entry;
+
+	snd_stm_magic_field;
+};
+
+
+
+/*
+ * Toolbox
+ */
+
+/* Return the number of set bits in x. */
+static unsigned int population(unsigned int x)
+{
+	/* This is the traditional branch-less algorithm for population count */
+	x = x - ((x >> 1) & 0x55555555);
+	x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
+	x = (x + (x >> 4)) & 0x0f0f0f0f;
+	x = x + (x << 8);
+	x = x + (x << 16);
+
+	return x >> 24;
+}
+
+/* Return the index of the most significant set in x.
+ * The results are 'undefined' is x is 0 (0xffffffff as it happens
+ * but this is a mere side effect of the algorithm. */
+static unsigned int most_significant_set_bit(unsigned int x)
+{
+	/* propagate the MSSB right until all bits smaller than MSSB are set */
+	x = x | (x >> 1);
+	x = x | (x >> 2);
+	x = x | (x >> 4);
+	x = x | (x >> 8);
+	x = x | (x >> 16);
+
+	/* now count the number of set bits [clz is population(~x)] */
+	return population(x) - 1;
+}
+
+/* Solve the frequency synthesiser equations to provide a specified output
+ * frequency.
+ *
+ * The approach taken to solve the equation is to solve for sdiv assuming
+ * maximal values for md and one greater than maximal pe (-16 and 32768
+ * respectively) before rounding down. Once sdiv is selected we can
+ * solve for md by assuming maximal pe and rounding down. With these
+ * values pe can trivially be calculated.
+ *
+ * The function is implemented entirely with integer calculations making
+ * it suitable for use within the Linux kernel.
+ *
+ * The magic numbers within the function are derived from the Fsynth equation
+ * which is as follows:
+ *
+ * <pre>
+ *                                  32768*Fpll
+ * #1: Fout = ------------------------------------------------------
+ *                            md                        (md + 1)
+ *            (sdiv*((pe*(1 + --)) - ((pe - 32768)*(1 + --------))))
+ *                            32                           32
+ * </pre>
+ *
+ * Where:
+ *
+ *  - Fpll and Fout are frequencies in Hz
+ *  - sdiv is power of 2 between 1 and 8
+ *  - md is an integer between -1 and -16
+ *  - pe is an integer between 0 and 32767
+ *
+ * This simplifies to:
+ *
+ * <pre>
+ *                       1048576*Fpll
+ * #2: Fout = ----------------------------------
+ *            (sdiv*(1081344 - pe + (32768*md)))
+ * </pre>
+ *
+ * Rearranging:
+ *
+ * <pre>
+ *                 1048576*Fpll
+ * #3: predivide = ------------ = (sdiv*(1081344 - pe + (32768*md)))
+ *                     Fout
+ * </pre>
+ *
+ * If solve for sdiv and let pe = 32768 and md = -16 we get:
+ *
+ * <pre>
+ *                     predivide            predivide
+ * #4: sdiv = --------------------------- = ---------
+ *            (1081344 - pe + (32768*md))     524288
+ * </pre>
+ *
+ * Returning to eqn. #3, solving for md and let pe = 32768 we get:
+ *
+ * <pre>
+ *           predivide                    predivide
+ *          (--------- - 1081344 + pe)   (--------- - 1048576)
+ *             sdiv                         sdiv
+ * #5: md = -------------------------- = ---------------------
+ *                    32768                      32768
+
+ * </pre>
+ *
+ * Finally we return to #3 and rearrange for pe:
+ *
+ * <pre>
+ *              predivide
+ * #6: pe = -1*(--------- - 1081344 - (32768*md))
+ *                sdiv
+ * </pre>
+ *
+ */
+static int solve_fsynth_eqn(unsigned int Fpll, unsigned int Fout,
+		unsigned int *sdivp, int *mdp, unsigned int *pep)
+{
+	unsigned long long p, q;
+	unsigned int predivide;
+	int preshift; /* always +ve but used in subtraction */
+	unsigned int sdiv;
+	int md;
+	unsigned int pe = 1 << 14;
+
+	/* pre-divide the frequencies */
+	p = 1048576ull * Fpll;		/* <<20? */
+	q = Fout;
+
+	predivide = (unsigned int)div64_u64(p, q);
+
+	/* determine an appropriate value for the output divider using eqn. #4
+	 * with md = -16 and pe = 32768 (and round down) */
+	sdiv = predivide / 524288;
+	if (sdiv > 1) {
+		/* sdiv = fls(sdiv) - 1; // this doesn't work
+		 * for some unknown reason */
+		sdiv = most_significant_set_bit(sdiv);
+	} else
+		sdiv = 1;
+
+	/* pre-shift a common sub-expression of later calculations */
+	preshift = predivide >> sdiv;
+
+	/* determine an appropriate value for the coarse selection using eqn. #5
+	 * with pe = 32768 (and round down which for signed values means away
+	 * from zero) */
+	md = ((preshift - 1048576) / 32768) - 1;	/* >>15? */
+
+	/* calculate a value for pe that meets the output target */
+	pe = -1 * (preshift - 1081344 - (32768 * md));	/* <<15? */
+
+	/* finally give sdiv its true hardware form */
+	sdiv--;
+
+	/* special case for 58593.75Hz and harmonics...
+	 * can't quite seem to get the rounding right */
+	if (md == -17 && pe == 0) {
+		md = -16;
+		pe = 32767;
+	}
+
+	/* update the outgoing arguments */
+	*sdivp = sdiv;
+	*mdp = md;
+	*pep = pe;
+
+	snd_stm_printd(1, "SDIV == %u, MD == %d, PE == %u\n", sdiv, md, pe);
+
+	/* return 0 if all variables meet their contraints */
+	return (sdiv <= 7 && -16 <= md && md <= -1 && pe <= 32767) ? 0 : -1;
+}
+
+/*
+ *                   1048576*Fpll
+ * Fout = ----------------------------------
+ *        (sdiv*(1081344 - pe + (32768*md)))
+ *
+ * Fpll is premultiplied by 8
+ * Fout needs dividing by 256 to get real frequency
+ *
+ * small error compared to double based original
+ * i.e. for 44100 (11289600) it reports 11289610 instead of 11289610.36
+ */
+static int get_fsynth_output(unsigned int Fpll,
+		unsigned int sdiv, int md, unsigned int pe)
+{
+	long long p, q, r, s, t, u;
+
+	p = 1048576ll * Fpll;
+	q = 32768 * md;
+	r = 1081344 - pe;
+	s = r + q;
+	t = (1 << (sdiv + 1)) * s;
+	u = div64_u64(p, t);
+
+	return (int)u;
+}
+
+static int snd_stm_fsynth_channel_configure(struct snd_stm_fsynth *fsynth,
+		int channel, int frequency, int adjustment)
+{
+	int result;
+	unsigned int sdiv;
+	int md;
+	unsigned int pe;
+	int frequency_adjusted, frequency_achieved, adjustment_achieved;
+	int delta;
+
+	snd_stm_printd(1, "snd_stm_fsynth_configure(fsynth=%p, channel=%d, "
+			"frequency=%d, adjustment=%d)\n", fsynth, channel,
+			frequency, adjustment);
+
+	if (snd_BUG_ON(!fsynth))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(fsynth)))
+		return -EINVAL;
+	if (snd_BUG_ON((channel < fsynth->channels_from) ||
+		       channel > fsynth->channels_to))
+		return -EINVAL;
+
+	/*             a
+	 * F = f + --------- * f = f + d
+	 *          1000000
+	 *
+	 *         a
+	 * d = --------- * f
+	 *      1000000
+	 *
+	 * where:
+	 *   f - nominal frequency
+	 *   a - adjustment in ppm (parts per milion)
+	 *   F - frequency to be set in synthesizer
+	 *   d - delta (difference) between f and F
+	 */
+	if (adjustment < 0) {
+		/* div64_u64 operates on unsigned values... */
+		delta = -1;
+		adjustment = -adjustment;
+	} else {
+		delta = 1;
+	}
+	/* 500000 ppm is 0.5, which is used to round up values */
+	delta *= (int)div64_u64((uint64_t)frequency * (uint64_t)adjustment +
+			500000, 1000000);
+	frequency_adjusted = frequency + delta;
+
+	snd_stm_printd(1, "Setting %s channel %d to frequency %d.\n",
+			fsynth->bus_id, channel,
+			frequency_adjusted);
+
+	result = solve_fsynth_eqn(PLL_FREQ, frequency_adjusted,
+			&sdiv, &md, &pe);
+	if (result < 0) {
+		snd_stm_printe("Frequency %d can't be generated!\n",
+				frequency_adjusted);
+		return -EINVAL;
+	}
+
+	snd_stm_printd(1, "SDIV == 0x%x, MD == 0x%x, PE == 0x%x\n", sdiv,
+			(unsigned int)md & mask__AUDCFG_FSYN_MD__MD(fsynth),
+			pe);
+	set__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_IGNORED(fsynth, channel);
+	set__AUDCFG_FSYN_SDIV__SDIV(fsynth, channel, sdiv);
+	set__AUDCFG_FSYN_MD__MD(fsynth, channel, (unsigned int)md &
+			mask__AUDCFG_FSYN_MD__MD(fsynth));
+	set__AUDCFG_FSYN_PE__PE(fsynth, channel, pe);
+	set__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_USED(fsynth, channel);
+	set__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_IGNORED(fsynth, channel);
+
+	/*             a                    a
+	 * F = f + --------- * f   =>   --------- * f = F - f   ==>
+	 *          1000000              1000000
+	 *
+	 *           a        F - f               F - f
+	 * ==>   --------- = -------   ==>   a = ------- * 1000000
+	 *        1000000       f                   f
+	 *
+	 * F = f + d   ==>   d = F - f
+	 *
+	 *      f + d - f               d
+	 * a = ----------- * 1000000 = --- * 1000000
+	 *          f                   f
+	 * where:
+	 *   f - nominal frequency
+	 *   a - adjustment in ppm (parts per milion)
+	 *   F - frequency actually being generated by fsynch
+	 *   d - delta between F and f
+	 */
+	frequency_achieved = get_fsynth_output(PLL_FREQ, sdiv, md, pe);
+	delta = frequency_achieved - frequency;
+	if (delta < 0) {
+		/* div64_u64 operates on unsigned values... */
+		delta = -delta;
+		adjustment_achieved = -1;
+	} else {
+		adjustment_achieved = 1;
+	}
+	/* frequency/2 is added to round up result */
+	adjustment_achieved *= (int)div64_u64((uint64_t)delta * 1000000 +
+			frequency / 2, frequency);
+
+	snd_stm_printd(1, "Nominal frequency is %d, actual frequency is %d, "
+			"(%d ppm difference).\n", frequency,
+			frequency_achieved, adjustment_achieved);
+
+	/* Save this informations for future generations ;-) */
+	fsynth->channels[channel].frequency = frequency;
+	fsynth->channels[channel].adjustment = adjustment_achieved;
+
+	return 0;
+}
+
+
+
+/*
+ * ALSA controls
+ */
+
+static int snd_stm_fsynth_adjustment_info(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = -1000000;
+	uinfo->value.integer.max = 1000000;
+
+	return 0;
+}
+
+static int snd_stm_fsynth_adjustment_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_fsynth_channel *fsynth_channel =
+		snd_kcontrol_chip(kcontrol);
+
+	snd_stm_printd(1, "snd_stm_fsynth_adjustment_get(kcontrol=0x%p, "
+			"ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	if (snd_BUG_ON(!fsynth_channel))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(fsynth_channel)))
+		return -EINVAL;
+	if (snd_BUG_ON(!fsynth_channel->fsynth))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(fsynth_channel->fsynth)))
+		return -EINVAL;
+
+	ucontrol->value.integer.value[0] = fsynth_channel->adjustment;
+
+	return 0;
+}
+
+static int snd_stm_fsynth_adjustment_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_stm_fsynth_channel *fsynth_channel =
+		snd_kcontrol_chip(kcontrol);
+	struct snd_stm_fsynth *fsynth;
+	int channel;
+	int old_adjustement;
+
+	snd_stm_printd(1, "snd_stm_fsynth_clock_adjustment_put(kcontrol=0x%p,"
+			" ucontrol=0x%p)\n", kcontrol, ucontrol);
+
+	if (snd_BUG_ON(!fsynth_channel))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(fsynth_channel)))
+		return -EINVAL;
+
+	fsynth = fsynth_channel->fsynth;
+
+	if (snd_BUG_ON(!fsynth))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(fsynth)))
+		return -EINVAL;
+
+	channel = fsynth_channel - fsynth_channel->fsynth->channels;
+	old_adjustement = fsynth_channel->adjustment;
+
+	/* If the synthesizer hasn't been configured yet... */
+	if (fsynth_channel->frequency == 0)
+		fsynth_channel->adjustment = ucontrol->value.integer.value[0];
+	else if (snd_stm_fsynth_channel_configure(fsynth, channel,
+			fsynth_channel->frequency,
+			ucontrol->value.integer.value[0]) < 0)
+		return -EINVAL;
+
+	return old_adjustement != fsynth_channel->adjustment;
+}
+
+static struct snd_kcontrol_new snd_stm_fsynth_adjustment_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+	.name = "PCM Playback Oversampling Freq. Adjustment",
+	.info = snd_stm_fsynth_adjustment_info,
+	.get = snd_stm_fsynth_adjustment_get,
+	.put = snd_stm_fsynth_adjustment_put,
+};
+
+
+
+/*
+ * Audio frequency synthesizer public interface implementation
+ */
+static int snd_stm_fsynth_bus_id_match(struct device *device, void *bus_id)
+{
+	return strcmp(dev_name(device), bus_id) == 0;
+}
+
+struct snd_stm_fsynth_channel *snd_stm_fsynth_get_channel(const char *bus_id,
+		int output)
+{
+	struct device *device;
+
+	snd_stm_printd(1, "snd_stm_fsynth_get_channel(bus_id='%s', output=%d)"
+			"\n", bus_id, output);
+
+	device = bus_find_device(&platform_bus_type, NULL, (void *)bus_id,
+			snd_stm_fsynth_bus_id_match);
+	if (device) {
+		struct snd_stm_fsynth *fsynth = dev_get_drvdata(device);
+
+		if (snd_BUG_ON(!snd_stm_magic_valid(fsynth)))
+			return NULL;
+		if (snd_BUG_ON((output < fsynth->channels_from) ||
+			       (output > fsynth->channels_to)))
+		    return NULL;
+
+		return &fsynth->channels[output];
+	}
+
+	snd_stm_printe("Can't find '%s' frequency synthesizer "
+			"device!\n", bus_id);
+
+	return NULL;
+}
+
+int snd_stm_fsynth_set_frequency(struct snd_stm_fsynth_channel *fsynth_channel,
+		int frequency)
+{
+	snd_stm_printd(1, "snd_stm_fsynth_set_frequency(fsynth_channel=%p, "
+			"frequency=%d)\n", fsynth_channel, frequency);
+
+	if (snd_BUG_ON(!fsynth_channel))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(fsynth_channel)))
+		return -EINVAL;
+	if (snd_BUG_ON(!fsynth_channel->fsynth))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(fsynth_channel->fsynth)))
+		return -EINVAL;
+
+	return snd_stm_fsynth_channel_configure(fsynth_channel->fsynth,
+			fsynth_channel - fsynth_channel->fsynth->channels,
+			frequency, fsynth_channel->adjustment);
+}
+
+int snd_stm_fsynth_add_adjustement_ctl(
+		struct snd_stm_fsynth_channel *fsynth_channel,
+		struct snd_card *card, int card_device)
+{
+	int result;
+
+	snd_stm_printd(1, "snd_stm_fsynth_add_control(fsynth_channel=%p, "
+			"card=%p, card_device=%d)\n", fsynth_channel,
+			card, card_device);
+
+	if (snd_BUG_ON(!fsynth_channel))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(fsynth_channel)))
+		return -EINVAL;
+
+	snd_stm_fsynth_adjustment_ctl.device = card_device;
+	result = snd_ctl_add(card, snd_ctl_new1(&snd_stm_fsynth_adjustment_ctl,
+			fsynth_channel));
+	snd_stm_fsynth_adjustment_ctl.index++;
+
+	return result;
+}
+
+
+
+/*
+ * ALSA lowlevel device implementation
+ */
+
+#define DUMP_REGISTER(r, n) \
+		snd_iprintf(buffer, "AUDCFG_FSYN%d_%s (offset 0x%02x) " \
+				"= 0x%08x\n", n, __stringify(r), \
+				offset__AUDCFG_FSYN_##r(fsynth, n), \
+				get__AUDCFG_FSYN_##r(fsynth, n))
+
+static void snd_stm_fsynth_dump_registers(struct snd_info_entry *entry,
+		struct snd_info_buffer *buffer)
+{
+	struct snd_stm_fsynth *fsynth = entry->private_data;
+	int i;
+
+	if (snd_BUG_ON(!fsynth))
+		return;
+	if (snd_BUG_ON(!snd_stm_magic_valid(fsynth)))
+		return;
+
+	snd_iprintf(buffer, "--- %s ---\n", fsynth->bus_id);
+	snd_iprintf(buffer, "base = 0x%p\n", fsynth->base);
+
+	snd_iprintf(buffer, "AUDCFG_FSYN_CFG (offset 0x00) = 0x%08x\n",
+			get__AUDCFG_FSYN_CFG(fsynth));
+
+	for (i = 0; i < fsynth->channels_max; i++) {
+		DUMP_REGISTER(MD, i);
+		DUMP_REGISTER(PE, i);
+		DUMP_REGISTER(SDIV, i);
+		DUMP_REGISTER(PROGEN, i);
+	}
+
+	snd_iprintf(buffer, "\n");
+}
+
+static int snd_stm_fsynth_register(struct snd_device *snd_device)
+{
+	struct snd_stm_fsynth *fsynth = snd_device->device_data;
+	unsigned long value = 0;
+	int i;
+
+	if (snd_BUG_ON(!fsynth))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(fsynth)))
+		return -EINVAL;
+
+	snd_stm_printd(0, "--- Registering frequency synthesizer '%s'...\n",
+			fsynth->bus_id);
+
+	/* Initialize & reset synthesizer */
+
+	value |= mask__AUDCFG_FSYN_CFG__RSTP__RESET(fsynth);
+	for (i = fsynth->channels_from; i <= fsynth->channels_to; i++) {
+		snd_stm_printd(0, "Enabling synthesizer '%s' channel %d\n",
+				fsynth->bus_id, i);
+		value |= mask__AUDCFG_FSYN_CFG__PCM_CLK_SEL__FSYNTH(fsynth, i);
+		if (fsynth->ver != ver__AUDCFG_FSYN__65_2_1_2 &&
+				fsynth->ver != ver__AUDCFG_FSYN__65_3_3)
+			value |= mask__AUDCFG_FSYN_CFG__FS_EN__ENABLED(fsynth,
+					i);
+		value |= mask__AUDCFG_FSYN_CFG__NSB__ACTIVE(fsynth, i);
+	}
+	value |= mask__AUDCFG_FSYN_CFG__NPDA__NORMAL(fsynth);
+	value |= mask__AUDCFG_FSYN_CFG__NDIV__27_30_MHZ(fsynth);
+	value |= mask__AUDCFG_FSYN_CFG__BW_SEL__GOOD_REFERENCE(fsynth);
+	value |= mask__AUDCFG_FSYN_CFG__REF_CLK_IN__30_MHZ_CLOCK(fsynth);
+
+	set__AUDCFG_FSYN_CFG(fsynth, value);
+	barrier();
+
+	/* Unreset ;-) it now */
+
+	set__AUDCFG_FSYN_CFG__RSTP__RUNNING(fsynth);
+
+	/* Additional procfs info */
+
+	snd_stm_info_register(&fsynth->proc_entry, fsynth->bus_id,
+			snd_stm_fsynth_dump_registers, fsynth);
+
+	snd_stm_printd(0, "--- Registered successfully!\n");
+
+	return 0;
+}
+
+static int snd_stm_fsynth_disconnect(struct snd_device *snd_device)
+{
+	struct snd_stm_fsynth *fsynth = snd_device->device_data;
+	unsigned long value = 0;
+	int i;
+
+	if (snd_BUG_ON(!fsynth))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(fsynth)))
+		return -EINVAL;
+
+	/* Remove procfs entry */
+
+	snd_stm_info_unregister(fsynth->proc_entry);
+
+	/* Disable synthesizer */
+
+	value |= mask__AUDCFG_FSYN_CFG__RSTP__RESET(fsynth);
+	for (i = fsynth->channels_from; i <= fsynth->channels_to; i++) {
+		if (fsynth->ver != ver__AUDCFG_FSYN__65_2_1_2 &&
+				fsynth->ver != ver__AUDCFG_FSYN__65_3_3)
+			value |= mask__AUDCFG_FSYN_CFG__FS_EN__DISABLED(fsynth,
+					i);
+		value |= mask__AUDCFG_FSYN_CFG__NSB__STANDBY(fsynth, i);
+	}
+	value |= mask__AUDCFG_FSYN_CFG__NPDA__POWER_DOWN(fsynth);
+
+	set__AUDCFG_FSYN_CFG(fsynth, value);
+
+	return 0;
+}
+
+static struct snd_device_ops snd_stm_fsynth_snd_device_ops = {
+	.dev_register = snd_stm_fsynth_register,
+	.dev_disconnect = snd_stm_fsynth_disconnect,
+};
+
+
+
+/*
+ * Platform driver routines
+ */
+
+static int snd_stm_fsynth_probe(struct platform_device *pdev)
+{
+	int result = 0;
+	struct snd_stm_fsynth_info *fsynth_info = pdev->dev.platform_data;
+	struct snd_stm_fsynth *fsynth;
+	int channels_max;
+	int i;
+
+	snd_stm_printd(0, "--- Probing device '%s'...\n", dev_name(&pdev->dev));
+
+	if (snd_BUG_ON(fsynth_info == NULL))
+		return -EINVAL;
+
+	if (fsynth_info->ver < ver__AUDCFG_FSYN__65_2_1_2)
+		channels_max = 3;
+	else
+		channels_max = 4;
+
+	fsynth = kzalloc(sizeof(*fsynth) + (channels_max *
+			sizeof(*fsynth->channels)), GFP_KERNEL);
+	if (!fsynth) {
+		snd_stm_printe("Can't allocate memory "
+				"for a device description!\n");
+		result = -ENOMEM;
+		goto error_alloc;
+	}
+	snd_stm_magic_set(fsynth);
+	fsynth->ver = fsynth_info->ver;
+	if (snd_BUG_ON(fsynth->ver <= 0))
+		return -EINVAL;
+	fsynth->bus_id = dev_name(&pdev->dev);
+	fsynth->channels_max = channels_max;
+	fsynth->channels = (void *)fsynth + sizeof(*fsynth);
+	for (i = 0; i < channels_max; i++) {
+		fsynth->channels[i].fsynth = fsynth;
+		snd_stm_magic_set(&fsynth->channels[i]);
+	}
+
+	result = snd_stm_memory_request(pdev, &fsynth->mem_region,
+			&fsynth->base);
+	if (result < 0) {
+		snd_stm_printe("Memory region request failed!\n");
+		goto error_memory_request;
+	}
+
+	fsynth->channels_from = fsynth_info->channels_from;
+	fsynth->channels_to = fsynth_info->channels_to;
+	if (snd_BUG_ON((fsynth->channels_from >= fsynth->channels_to) ||
+		       (fsynth->channels_from < 0) ||
+		       (fsynth->channels_to >= channels_max)))
+		return -EINVAL;
+
+	snd_stm_printd(0, "Used synthesizer channels: %d to %d\n",
+			fsynth->channels_from, fsynth->channels_to);
+
+	/* ALSA component */
+
+	result = snd_device_new(snd_stm_card_get(), SNDRV_DEV_LOWLEVEL, fsynth,
+			&snd_stm_fsynth_snd_device_ops);
+	if (result < 0) {
+		snd_stm_printe("ALSA low level device creation failed!\n");
+		goto error_device;
+	}
+
+	/* Done now */
+
+	platform_set_drvdata(pdev, fsynth);
+
+	snd_stm_printd(0, "--- Probed successfully!\n");
+
+	return result;
+
+error_device:
+	snd_stm_memory_release(fsynth->mem_region, fsynth->base);
+error_memory_request:
+	snd_stm_magic_clear(fsynth);
+	kfree(fsynth);
+error_alloc:
+	return result;
+}
+
+static int snd_stm_fsynth_remove(struct platform_device *pdev)
+{
+	struct snd_stm_fsynth *fsynth = platform_get_drvdata(pdev);
+	int i;
+
+	if (snd_BUG_ON(!fsynth))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(fsynth)))
+		return -EINVAL;
+
+	snd_stm_memory_release(fsynth->mem_region, fsynth->base);
+
+	for (i = 0; i < fsynth->channels_max; i++) {
+		fsynth->channels[i].fsynth = fsynth;
+		snd_stm_magic_clear(&fsynth->channels[i]);
+	}
+	snd_stm_magic_clear(fsynth);
+	kfree(fsynth);
+
+	return 0;
+}
+
+static struct platform_driver snd_stm_fsynth_driver = {
+	.driver = {
+		.name = "snd_fsynth",
+	},
+	.probe = snd_stm_fsynth_probe,
+	.remove = snd_stm_fsynth_remove,
+};
+
+
+
+/*
+ * Initialization
+ */
+
+int snd_stm_fsynth_init(void)
+{
+	return platform_driver_register(&snd_stm_fsynth_driver);
+}
+
+void snd_stm_fsynth_exit(void)
+{
+	platform_driver_unregister(&snd_stm_fsynth_driver);
+}
diff -ruN stm.org/init.c stm/init.c
--- a/dev/null
+++ b/sound/stm/init.c	2012-10-11 11:46:27.000000000 -0700
@@ -0,0 +1,139 @@
+/*
+ *   STMicrolectronics System-on-Chips' audio subsystem core driver
+ *
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
+ *
+ *   Author: Pawel Moll <pawel.moll@st.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <sound/core.h>
+
+#define COMPONENT init
+#include "common.h"
+
+/* General debug level */
+#if defined(CONFIG_SND_STM_DEBUG_LEVEL)
+static int debug = CONFIG_SND_STM_DEBUG_LEVEL;
+module_param(debug, int, S_IRUGO | S_IWUSR);
+int *snd_stm_debug_level = &debug;
+EXPORT_SYMBOL(snd_stm_debug_level);
+#endif
+
+int snd_stm_drivers_register(void)
+{
+	int result;
+
+	snd_stm_printd(0, "snd_stm_core_init()\n");
+
+	result = snd_stm_info_create();
+	if (result != 0) {
+		snd_stm_printe("Procfs info creation failed!\n");
+		goto error_info;
+	}
+	result = snd_stm_fsynth_init();
+	if (result != 0) {
+		snd_stm_printe("Frequency synthesizer driver initialization"
+				" failed!\n");
+		goto error_fsynth;
+	}
+	result = snd_stm_conv_init();
+	if (result != 0) {
+		snd_stm_printe("Converters infrastructure initialization"
+				" failed!\n");
+		goto error_conv;
+	}
+	result = snd_stm_conv_int_dac_init();
+	if (result != 0) {
+		snd_stm_printe("Internal DACs driver initialization failed!\n");
+		goto error_conv_int_dac;
+	}
+	result = snd_stm_conv_i2sspdif_init();
+	if (result != 0) {
+		snd_stm_printe("I2S to SPDIF converter driver initialization"
+				" failed!\n");
+		goto error_conv_i2sspdif;
+	}
+	result = snd_stm_pcm_player_init();
+	if (result != 0) {
+		snd_stm_printe("PCM player driver initialization failed!\n");
+		goto error_pcm_player;
+	}
+	result = snd_stm_pcm_reader_init();
+	if (result != 0) {
+		snd_stm_printe("PCM reader driver initialization failed!\n");
+		goto error_pcm_reader;
+	}
+	result = snd_stm_spdif_player_init();
+	if (result != 0) {
+		snd_stm_printe("SPDIF player driver initialization failed!\n");
+		goto error_spdif_player;
+	}
+
+	return result;
+
+error_spdif_player:
+	snd_stm_pcm_reader_exit();
+error_pcm_reader:
+	snd_stm_pcm_player_exit();
+error_pcm_player:
+	snd_stm_conv_i2sspdif_exit();
+error_conv_i2sspdif:
+	snd_stm_conv_int_dac_exit();
+error_conv_int_dac:
+	snd_stm_conv_exit();
+error_conv:
+	snd_stm_fsynth_exit();
+error_fsynth:
+	snd_stm_info_dispose();
+error_info:
+	return result;
+}
+
+void snd_stm_drivers_unregister(void)
+{
+	snd_stm_printd(0, "snd_stm_core_exit()\n");
+
+	snd_stm_spdif_player_exit();
+	snd_stm_pcm_reader_exit();
+	snd_stm_pcm_player_exit();
+	snd_stm_conv_i2sspdif_exit();
+	snd_stm_conv_int_dac_exit();
+	snd_stm_conv_exit();
+	snd_stm_fsynth_exit();
+	snd_stm_info_dispose();
+}
+
+
+
+static int __init snd_stm_init(void)
+{
+	return 0;
+}
+
+static void __exit snd_stm_exit(void)
+{
+}
+
+MODULE_AUTHOR("Pawel Moll <pawel.moll@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics System-on-Chips' audio core driver");
+MODULE_LICENSE("GPL");
+
+module_init(snd_stm_init)
+module_exit(snd_stm_exit)
diff -ruN stm.org/Kconfig stm/Kconfig
--- a/drivers/stm/Kconfig	2014-06-03 12:31:04.000000000 -0700
+++ b/sound/stm/Kconfig	2012-10-11 11:46:27.000000000 -0700
@@ -1,7 +1,7 @@
 menuconfig SND_STM
 	tristate "STMicroelectronics SoCs support"
 	depends on SND
-	depends on CPU_SUBTYPE_ST40
+	depends on CPU_SUBTYPE_STX7100 || CPU_SUBTYPE_STX7105 || CPU_SUBTYPE_STX7111 || CPU_SUBTYPE_STX7141 || CPU_SUBTYPE_STX7200
 	select STM_DMA
 	select SND_PCM
 	help
@@ -18,36 +18,6 @@
 		To compile this driver as a module, choose M here: the module
 	 	will be called snd-stm.ko
 
-config SND_STM_PCM_PLAYER
-	tristate
-	depends on SND_STM
-	default n
-
-config SND_STM_PCM_READER
-	tristate
-	depends on SND_STM
-	default n
-
-config SND_STM_SPDIF_PLAYER
-	tristate
-	depends on SND_STM
-	default n
-
-config SND_STM_CONV_DAC_MEMORY_MAPPED
-	tristate
-	depends on SND_STM
-	default n
-
-config SND_STM_CONV_DAC_SYSCONF
-	tristate
-	depends on SND_STM
-	default n
-
-config SND_STM_CONV_I2S_TO_SPDIF
-	tristate
-	depends on SND_STM
-	default n
-
 config SND_STM_BPA2_PARTITION_NAME
 	string "Name of BPA2 partition to allocate buffers from"
 	depends on SND_STM
@@ -67,32 +37,28 @@
 		"snd-stm.bpa2_part=<name>", if driver is compiled into
 		kernel).
 
-comment "SOC support"
+config SND_STM_DEBUG_LEVEL
+	int "Default debug verbosity level"
 	depends on SND_STM
-
-config SND_STM_FLI75XX
-	tristate "Freeman 510/520/530/540/560 support"
-	depends on SND_STM
-	default y if CPU_SUBTYPE_FLI75XX
-	select SND_STM_PCM_PLAYER
-	select SND_STM_PCM_READER
-	select SND_STM_SPDIF_PLAYER
+	depends on SND_DEBUG
+	default 0
 	help
-		Select this to get ALSA driver for Freeman 510/520/530/540/560
-		(FLI7510/FLI7520/FLI7530/FLI7540/FLI7560) chips.
-
-		If you compile this driver as a module, it will be
-		called snd-stm-fli75xx.ko
+		Defines debug verbosity level (bigger number equals more
+		messages). This can be overridden using "debug=<n>" module
+		parameter or "snd-stm.debug=<n>" kernel command line
+		parameter. You can also change this value in runtime,
+		using /sys/module/snd_stm/parameters/debug.
+
+		There is also fine-grained debug verbosity control available -
+		just put "#define DEBUG <n>" in debugged component _before_
+		#including "common.h", or alter the value using sysfs file
+		/sys/module/snd_stm/parameter/debug_component_name (or
+		use module/kernel command line parameter ;-)...
 
 config SND_STM_STX7100
 	tristate "STx7100 and STx7109 support"
 	depends on SND_STM
 	default y if CPU_SUBTYPE_STX7100
-	select SND_STM_PCM_PLAYER
-	select SND_STM_PCM_READER
-	select SND_STM_SPDIF_PLAYER
-	select SND_STM_CONV_DAC_MEMORY_MAPPED
-	select SND_STM_CONV_I2S_TO_SPDIF
 	help
 		Select this to get ALSA driver for STx7100 and STx7109 chips.
 
@@ -100,44 +66,19 @@
 		called snd-stm-stx7100.ko
 
 config SND_STM_STX7105
-	tristate "STx7105 and STx7106 support"
+	tristate "STx7105 support"
 	depends on SND_STM
 	default y if CPU_SUBTYPE_STX7105
-	select SND_STM_PCM_PLAYER
-	select SND_STM_PCM_READER
-	select SND_STM_SPDIF_PLAYER
-	select SND_STM_CONV_DAC_MEMORY_MAPPED
-	select SND_STM_CONV_I2S_TO_SPDIF
 	help
-		Select this to get ALSA driver for STx7105 and STx7106 chips.
+		Select this to get ALSA driver for STx7105 chip.
 
 		If you compile this driver as a module, it will be
 		called snd-stm-stx7105.ko
 
-config SND_STM_STX7108
-	tristate "STx7108 support"
-	depends on SND_STM
-	default y if CPU_SUBTYPE_STX7108
-	select SND_STM_PCM_PLAYER
-	select SND_STM_PCM_READER
-	select SND_STM_SPDIF_PLAYER
-	select SND_STM_CONV_DAC_SYSCONF
-	select SND_STM_CONV_I2S_TO_SPDIF
-	help
-		Select this to get ALSA driver for STx7108 chip.
-
-		If you compile this driver as a module, it will be
-		called snd-stm-stx7108.ko
-
 config SND_STM_STX7111
 	tristate "STx7111 support"
 	depends on SND_STM
 	default y if CPU_SUBTYPE_STX7111
-	select SND_STM_PCM_PLAYER
-	select SND_STM_PCM_READER
-	select SND_STM_SPDIF_PLAYER
-	select SND_STM_CONV_DAC_MEMORY_MAPPED
-	select SND_STM_CONV_I2S_TO_SPDIF
 	help
 		Select this to get ALSA driver for STx7111 chip.
 
@@ -148,11 +89,6 @@
 	tristate "STx7141 support"
 	depends on SND_STM
 	default y if CPU_SUBTYPE_STX7141
-	select SND_STM_PCM_PLAYER
-	select SND_STM_PCM_READER
-	select SND_STM_SPDIF_PLAYER
-	select SND_STM_CONV_DAC_MEMORY_MAPPED
-	select SND_STM_CONV_I2S_TO_SPDIF
 	help
 		Select this to get ALSA driver for STx7141 chip.
 
@@ -163,20 +99,12 @@
 	tristate "STx7200 support"
 	depends on SND_STM
 	default y if CPU_SUBTYPE_STX7200
-	select SND_STM_PCM_PLAYER
-	select SND_STM_PCM_READER
-	select SND_STM_SPDIF_PLAYER
-	select SND_STM_CONV_DAC_MEMORY_MAPPED
-	select SND_STM_CONV_I2S_TO_SPDIF
 	help
 		Select this to get ALSA driver for STx7200 chip.
 
 		If you compile this driver as a module, it will be
 		called snd-stm-stx7111.ko
 
-comment "External converters"
-	depends on SND_STM
-
 config SND_STM_CONV_DUMMY
 	tristate "Dummy converter driver"
 	depends on SND_STM
diff -ruN stm.org/Makefile stm/Makefile
--- a/drivers/stm/Makefile	2014-06-03 12:31:04.000000000 -0700
+++ b/sound/stm/Makefile	2012-10-11 11:46:27.000000000 -0700
@@ -1,32 +1,7 @@
-# Core
-
-obj-$(CONFIG_SND_STM) += snd-stm-core.o
-snd-stm-core-y := core.o clock.o conv.o
-
-obj-$(CONFIG_SND_STM_PCM_PLAYER) += snd-stm-pcm-player.o
-snd-stm-pcm-player-y := pcm_player.o
-
-obj-$(CONFIG_SND_STM_PCM_READER) += snd-stm-pcm-reader.o
-snd-stm-pcm-reader-y := pcm_reader.o
-
-obj-$(CONFIG_SND_STM_SPDIF_PLAYER) += snd-stm-spdif-player.o
-snd-stm-spdif-player-y := spdif_player.o
-
-obj-$(CONFIG_SND_STM_CONV_I2S_TO_SPDIF) += snd-stm-conv-i2sspdif.o
-snd-stm-conv-i2sspdif-y := conv_i2sspdif.o
-
-obj-$(CONFIG_SND_STM_CONV_DAC_MEMORY_MAPPED) += snd-stm-conv-dac-mem.o
-snd-stm-conv-dac-mem-y := conv_dac_mem.o
-
-obj-$(CONFIG_SND_STM_CONV_DAC_SYSCONF) += snd-stm-conv-dac-sc.o
-snd-stm-conv-dac-sc-y := conv_dac_sc.o
-
-
-
-# SOCs
-
-obj-$(CONFIG_SND_STM_FLI75XX) += snd-stm-fli75xx.o
-snd-stm-fli75xx-y := fli75xx.o
+obj-$(CONFIG_SND_STM) += snd-stm.o
+snd-stm-y := init.o common.o fsynth.o
+snd-stm-y += conv.o conv_i2sspdif.o conv_int_dac.o
+snd-stm-y += pcm_player.o pcm_reader.o spdif_player.o
 
 obj-$(CONFIG_SND_STM_STX7100) += snd-stm-stx7100.o
 snd-stm-stx7100-y := stx7100.o
@@ -34,9 +9,6 @@
 obj-$(CONFIG_SND_STM_STX7105) += snd-stm-stx7105.o
 snd-stm-stx7105-y := stx7105.o
 
-obj-$(CONFIG_SND_STM_STX7108) += snd-stm-stx7108.o
-snd-stm-stx7108-y := stx7108.o
-
 obj-$(CONFIG_SND_STM_STX7111) += snd-stm-stx7111.o
 snd-stm-stx7111-y := stx7111.o
 
@@ -46,18 +18,14 @@
 obj-$(CONFIG_SND_STM_STX7200) += snd-stm-stx7200.o
 snd-stm-stx7200-y := stx7200.o
 
-
-
-# External converters
-
 obj-$(CONFIG_SND_STM_CONV_DUMMY) += snd-stm-conv-dummy.o
 snd-stm-conv-dummy-y := conv_dummy.o
 
-obj-$(CONFIG_SND_STM_CONV_EPLD) += snd-stm-conv-epld.o
-snd-stm-conv-epld-y := conv_epld.o
-
 obj-$(CONFIG_SND_STM_CONV_GPIO) += snd-stm-conv-gpio.o
 snd-stm-conv-gpio-y := conv_gpio.o
 
+obj-$(CONFIG_SND_STM_CONV_EPLD) += snd-stm-conv-epld.o
+snd-stm-conv-epld-y := conv_epld.o
+
 obj-$(CONFIG_SND_STM_CONV_I2C) += snd-stm-conv-i2c.o
 snd-stm-conv-i2c-y := conv_i2c.o
diff -ruN stm.org/pcm_player.c stm/pcm_player.c
--- a/drivers/stm/pcm_player.c	2014-06-03 12:31:04.000000000 -0700
+++ b/sound/stm/pcm_player.c	2014-05-24 02:19:13.000000000 -0700
@@ -1,7 +1,7 @@
 /*
  *   STMicroelectronics System-on-Chips' PCM player driver
  *
- *   Copyright (c) 2005-2011 STMicroelectronics Limited
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
  *
  *   Author: Pawel Moll <pawel.moll@st.com>
  *           Mark Glaisher
@@ -22,14 +22,12 @@
  *
  */
 
-#include <asm/cacheflush.h>
-#include <asm/clock.h>
 #include <linux/init.h>
 #include <linux/io.h>
 #include <linux/platform_device.h>
 #include <linux/interrupt.h>
 #include <linux/delay.h>
-#include <linux/stm/pad.h>
+#include <asm/cacheflush.h>
 #include <linux/stm/stm-dma.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -37,16 +35,12 @@
 #include <sound/info.h>
 #include <sound/pcm_params.h>
 
+#define COMPONENT pcm_player
 #include "common.h"
 #include "reg_aud_pcmout.h"
 
 
 
-static int snd_stm_debug_level;
-module_param_named(debug, snd_stm_debug_level, int, S_IRUGO | S_IWUSR);
-
-
-
 /*
  * Some hardware-related definitions
  */
@@ -79,7 +73,7 @@
 	int fdma_channel;
 
 	/* Environment settings */
-	struct clk *clock;
+	struct snd_stm_fsynth_channel *fsynth_channel;
 	struct snd_pcm_hw_constraint_list channels_constraint;
 	struct snd_stm_conv_source *conv_source;
 
@@ -91,7 +85,6 @@
 	int fdma_max_transfer_size;
 	struct stm_dma_params fdma_params;
 	struct stm_dma_req *fdma_request;
-	struct stm_pad_state *pads;
 
 	snd_stm_magic_field;
 };
@@ -111,14 +104,14 @@
 	snd_stm_printd(2, "snd_stm_pcm_player_irq_handler(irq=%d, "
 			"dev_id=0x%p)\n", irq, dev_id);
 
-	BUG_ON(!pcm_player);
-	BUG_ON(!snd_stm_magic_valid(pcm_player));
+	if (snd_BUG_ON(!pcm_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_player)))
+		return -EINVAL;
 
 	/* Get interrupt status & clear them immediately */
-	preempt_disable();
 	status = get__AUD_PCMOUT_ITS(pcm_player);
 	set__AUD_PCMOUT_ITS_CLR(pcm_player, status);
-	preempt_enable();
 
 	/* Underflow? */
 	if (unlikely(status & mask__AUD_PCMOUT_ITS__UNF__PENDING(pcm_player))) {
@@ -132,7 +125,8 @@
 			mask__AUD_PCMOUT_ITS__NSAMPLE__PENDING(pcm_player))) {
 		/* Period successfully played */
 		do {
-			BUG_ON(!pcm_player->substream);
+			if (snd_BUG_ON(!pcm_player->substream))
+				break;
 
 			snd_stm_printd(2, "Period elapsed ('%s')\n",
 					dev_name(pcm_player->device));
@@ -143,7 +137,7 @@
 	}
 
 	/* Some alien interrupt??? */
-	BUG_ON(result != IRQ_HANDLED);
+	snd_BUG_ON(result != IRQ_HANDLED);
 
 	return result;
 }
@@ -191,9 +185,10 @@
 	snd_stm_printd(1, "snd_stm_pcm_player_open(substream=0x%p)\n",
 			substream);
 
-	BUG_ON(!pcm_player);
-	BUG_ON(!snd_stm_magic_valid(pcm_player));
-	BUG_ON(!runtime);
+	if (snd_BUG_ON(!pcm_player || !runtime))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_player)))
+		return -EINVAL;
 
 	snd_pcm_set_sync(substream);  /* TODO: ??? */
 
@@ -206,7 +201,7 @@
 				dev_name(pcm_player->device),
 				snd_stm_conv_get_name(pcm_player->conv_group));
 	else
-		snd_stm_printd(1, "No converter attached to '%s'!\n",
+		snd_stm_printd(1, "Warning! No converter attached to '%s'!\n",
 				dev_name(pcm_player->device));
 
 	/* Set up constraints & pass hardware capabilities info to ALSA */
@@ -254,8 +249,10 @@
 	snd_stm_printd(1, "snd_stm_pcm_player_close(substream=0x%p)\n",
 			substream);
 
-	BUG_ON(!pcm_player);
-	BUG_ON(!snd_stm_magic_valid(pcm_player));
+	if (snd_BUG_ON(!pcm_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_player)))
+		return -EINVAL;
 
 	if (pcm_player->conv_group) {
 		snd_stm_conv_release_group(pcm_player->conv_group);
@@ -276,9 +273,10 @@
 	snd_stm_printd(1, "snd_stm_pcm_player_hw_free(substream=0x%p)\n",
 			substream);
 
-	BUG_ON(!pcm_player);
-	BUG_ON(!snd_stm_magic_valid(pcm_player));
-	BUG_ON(!runtime);
+	if (snd_BUG_ON(!pcm_player || !runtime))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_player)))
+		return -EINVAL;
 
 	/* This callback may be called more than once... */
 
@@ -318,9 +316,10 @@
 	snd_stm_printd(1, "snd_stm_pcm_player_hw_params(substream=0x%p,"
 			" hw_params=0x%p)\n", substream, hw_params);
 
-	BUG_ON(!pcm_player);
-	BUG_ON(!snd_stm_magic_valid(pcm_player));
-	BUG_ON(!runtime);
+	if (snd_BUG_ON(!pcm_player || !runtime))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_player)))
+		return -EINVAL;
 
 	/* This function may be called many times, so let's be prepared... */
 	if (snd_stm_buffer_is_allocated(pcm_player->buffer))
@@ -349,13 +348,17 @@
 	snd_stm_printd(1, "FDMA request trigger limit and transfer size set "
 			"to %d.\n", transfer_size);
 
-	BUG_ON(buffer_bytes % transfer_bytes != 0);
-	BUG_ON(transfer_size > pcm_player->fdma_max_transfer_size);
+	if (snd_BUG_ON(buffer_bytes % transfer_bytes != 0))
+		return -EINVAL;
+	if (snd_BUG_ON(transfer_size > pcm_player->fdma_max_transfer_size))
+		return -EINVAL;
 	fdma_req_config.count = transfer_size;
 
-	BUG_ON(transfer_size != 1 && transfer_size % 2 != 0);
-	BUG_ON(transfer_size >
-	       mask__AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT(pcm_player));
+	if (snd_BUG_ON(transfer_size != 1 && transfer_size % 2 != 0))
+		return -EINVAL;
+	if (snd_BUG_ON(transfer_size >
+		       mask__AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT(pcm_player)))
+		return -EINVAL;
 	set__AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT(pcm_player, transfer_size);
 
 	/* Configure FDMA transfer */
@@ -405,16 +408,17 @@
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	unsigned int format, lr_pol;
 	int oversampling, bits_in_output_frame;
-	int result;
 
 	snd_stm_printd(1, "snd_stm_pcm_player_prepare(substream=0x%p)\n",
 			substream);
 
-	BUG_ON(!pcm_player);
-	BUG_ON(!snd_stm_magic_valid(pcm_player));
-	BUG_ON(!runtime);
-	BUG_ON(runtime->period_size * runtime->channels >=
-	       MAX_SAMPLES_PER_PERIOD);
+	if (snd_BUG_ON(!pcm_player || !runtime))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_player)))
+		return -EINVAL;
+	if (snd_BUG_ON(runtime->period_size * runtime->channels >=
+		       MAX_SAMPLES_PER_PERIOD))
+		return -EINVAL;
 
 	/* Configure SPDIF synchronisation */
 
@@ -437,32 +441,25 @@
 			dev_name(pcm_player->device), runtime->rate,
 			oversampling);
 
-	BUG_ON(oversampling < 0);
+	if (snd_BUG_ON(oversampling <= 0))
+		return -EINVAL;
 
 	/* For 32 bits subframe oversampling must be a multiple of 128,
 	 * for 16 bits - of 64 */
-	BUG_ON((format & SND_STM_FORMAT__SUBFRAME_32_BITS) &&
-		(oversampling % 128 != 0));
-	BUG_ON(!(format & SND_STM_FORMAT__SUBFRAME_16_BITS) &&
-		(oversampling % 64 != 0));
+	if (snd_BUG_ON(((format & SND_STM_FORMAT__SUBFRAME_32_BITS) &&
+			(oversampling % 128 != 0)) ||
+		       (!(format & SND_STM_FORMAT__SUBFRAME_32_BITS) &&
+			(oversampling % 64 != 0))))
+		return -EINVAL;
 
 	/* Set up frequency synthesizer */
 
-	result = clk_enable(pcm_player->clock);
-	if (result != 0) {
-		snd_stm_printe("Can't enable clock for player '%s'!\n",
-				dev_name(pcm_player->device));
-		return result;
-	}
+//	printk("############### rate = %d oversampling=%d",runtime->rate,oversampling);
+//############### rate = 48000 oversampling=256
+//############### rate = 48000 oversampling=128
 
-	result = clk_set_rate(pcm_player->clock,
-				runtime->rate * oversampling);
-	if (result != 0) {
-		snd_stm_printe("Can't configure clock for player '%s'!\n",
-				dev_name(pcm_player->device));
-		clk_disable(pcm_player->clock);
-		return result;
-	}
+	snd_stm_fsynth_set_frequency(pcm_player->fsynth_channel,
+			runtime->rate * oversampling);
 
 	/* Set up player hardware */
 
@@ -480,7 +477,7 @@
 	case SND_STM_FORMAT__SUBFRAME_32_BITS:
 		snd_stm_printd(1, "- 32 bits per subframe\n");
 		set__AUD_PCMOUT_FMT__NBIT__32_BITS(pcm_player);
-		if (pcm_player->ver > 5)
+		if (pcm_player->ver > ver__AUD_PCMOUT__65_1_3)
 			set__AUD_PCMOUT_FMT__DATA_SIZE__32_BITS(pcm_player);
 		else
 			set__AUD_PCMOUT_FMT__DATA_SIZE__24_BITS(pcm_player);
@@ -601,9 +598,10 @@
 
 	/* Number of channels... */
 
-	BUG_ON(runtime->channels % 2 != 0);
-	BUG_ON(runtime->channels < 2);
-	BUG_ON(runtime->channels > 10);
+	if (snd_BUG_ON((runtime->channels % 2 != 0) ||
+		       (runtime->channels < 2) ||
+		       (runtime->channels > 10)))
+		return -EINVAL;
 
 	set__AUD_PCMOUT_FMT__NUM_CH(pcm_player, runtime->channels / 2);
 
@@ -619,8 +617,10 @@
 	snd_stm_printd(1, "snd_stm_pcm_player_start(substream=0x%p)\n",
 			substream);
 
-	BUG_ON(!pcm_player);
-	BUG_ON(!snd_stm_magic_valid(pcm_player));
+	if (snd_BUG_ON(!pcm_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_player)))
+		return -EINVAL;
 
 	/* Un-reset PCM player */
 
@@ -633,7 +633,6 @@
 	if (result != 0) {
 		snd_stm_printe("Can't launch FDMA transfer for player '%s'!\n",
 			       dev_name(pcm_player->device));
-		clk_disable(pcm_player->clock);
 		return -EINVAL;
 	}
 	while (dma_get_status(pcm_player->fdma_channel) !=
@@ -671,8 +670,10 @@
 	snd_stm_printd(1, "snd_stm_pcm_player_stop(substream=0x%p)\n",
 			substream);
 
-	BUG_ON(!pcm_player);
-	BUG_ON(!snd_stm_magic_valid(pcm_player));
+	if (snd_BUG_ON(!pcm_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_player)))
+		return -EINVAL;
 
 	/* Mute & shutdown DAC */
 
@@ -695,9 +696,7 @@
 
 	dma_stop_channel(pcm_player->fdma_channel);
 
-	/* Stop the clock & reset PCM player */
-
-	clk_disable(pcm_player->clock);
+	/* Reset PCM player */
 	set__AUD_PCMOUT_RST__SRSTP__RESET(pcm_player);
 
 	return 0;
@@ -711,8 +710,10 @@
 	snd_stm_printd(1, "snd_stm_pcm_player_pause(substream=0x%p)\n",
 			substream);
 
-	BUG_ON(!pcm_player);
-	BUG_ON(!snd_stm_magic_valid(pcm_player));
+	if (snd_BUG_ON(!pcm_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_player)))
+		return -EINVAL;
 
 	/* "Mute" player
 	 * Documentation describes this mode in a wrong way - data is _not_
@@ -731,8 +732,10 @@
 	snd_stm_printd(1, "snd_stm_pcm_player_release(substream=0x%p)\n",
 			substream);
 
-	BUG_ON(!pcm_player);
-	BUG_ON(!snd_stm_magic_valid(pcm_player));
+	if (snd_BUG_ON(!pcm_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_player)))
+		return -EINVAL;
 
 	/* "Unmute" player */
 
@@ -773,9 +776,10 @@
 	snd_stm_printd(2, "snd_stm_pcm_player_pointer(substream=0x%p)\n",
 			substream);
 
-	BUG_ON(!pcm_player);
-	BUG_ON(!snd_stm_magic_valid(pcm_player));
-	BUG_ON(!runtime);
+	if (snd_BUG_ON(!pcm_player || !runtime))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_player)))
+		return -EINVAL;
 
 	residue = get_dma_residue(pcm_player->fdma_channel);
 	hwptr = (runtime->dma_bytes - residue) % runtime->dma_bytes;
@@ -818,8 +822,10 @@
 {
 	struct snd_stm_pcm_player *pcm_player = entry->private_data;
 
-	BUG_ON(!pcm_player);
-	BUG_ON(!snd_stm_magic_valid(pcm_player));
+	if (snd_BUG_ON(!pcm_player))
+		return;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_player)))
+		return;
 
 	snd_iprintf(buffer, "--- %s ---\n", dev_name(pcm_player->device));
 	snd_iprintf(buffer, "base = 0x%p\n", pcm_player->base);
@@ -840,34 +846,44 @@
 
 static int snd_stm_pcm_player_register(struct snd_device *snd_device)
 {
+	int result;
 	struct snd_stm_pcm_player *pcm_player = snd_device->device_data;
 
-	snd_stm_printd(1, "%s(snd_device=0x%p)\n", __func__, snd_device);
+	snd_stm_printd(1, "snd_stm_pcm_player_register(snd_device=0x%p)\n",
+			snd_device);
 
-	BUG_ON(!pcm_player);
-	BUG_ON(!snd_stm_magic_valid(pcm_player));
+	if (snd_BUG_ON(!pcm_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_player)))
+		return -EINVAL;
+
+	snd_stm_printd(0, "--- Registering player '%s'...\n",
+			dev_name(pcm_player->device));
 
 	/* Set reset mode */
 
 	set__AUD_PCMOUT_RST__SRSTP__RESET(pcm_player);
 
 	/* TODO: well, hardcoded - shall anyone use it?
-	 * And what does it actually mean? */
+	 * And what it actually means? */
 
-	if (pcm_player->ver > 5)
+	if (pcm_player->ver > ver__AUD_PCMOUT__65_1_3)
 		set__AUD_PCMOUT_FMT__BACK_STALLING__DISABLED(pcm_player);
 	set__AUD_PCMOUT_CTRL__RND__NO_ROUNDING(pcm_player);
 
 	/* Get frequency synthesizer channel */
 
-	pcm_player->clock = snd_stm_clk_get(pcm_player->device,
-			"pcm_player_clk", snd_device->card,
-			pcm_player->info->card_device);
-	if (!pcm_player->clock || IS_ERR(pcm_player->clock)) {
-		snd_stm_printe("Failed to get a clock for '%s'!\n",
-				dev_name(pcm_player->device));
+	if (snd_BUG_ON(pcm_player->info->fsynth_bus_id == NULL))
+		return -EINVAL;
+	snd_stm_printd(0, "Player connected to %s's output %d.\n",
+			pcm_player->info->fsynth_bus_id,
+			pcm_player->info->fsynth_output);
+
+	pcm_player->fsynth_channel = snd_stm_fsynth_get_channel(
+			pcm_player->info->fsynth_bus_id,
+			pcm_player->info->fsynth_output);
+	if (snd_BUG_ON(pcm_player->fsynth_channel == NULL))
 		return -EINVAL;
-	}
 
 	/* Registers view in ALSA's procfs */
 
@@ -875,6 +891,17 @@
 			dev_name(pcm_player->device),
 			snd_stm_pcm_player_dump_registers, pcm_player);
 
+	/* Create ALSA controls */
+
+	result = snd_stm_fsynth_add_adjustement_ctl(pcm_player->fsynth_channel,
+			snd_device->card, pcm_player->info->card_device);
+	if (result < 0) {
+		snd_stm_printe("Failed to add fsynth adjustment control!\n");
+		return result;
+	}
+
+	snd_stm_printd(0, "--- Registered successfully!\n");
+
 	return 0;
 }
 
@@ -882,12 +909,13 @@
 {
 	struct snd_stm_pcm_player *pcm_player = snd_device->device_data;
 
-	snd_stm_printd(1, "%s(snd_device=0x%p)\n", __func__, snd_device);
-
-	BUG_ON(!pcm_player);
-	BUG_ON(!snd_stm_magic_valid(pcm_player));
+	snd_stm_printd(1, "snd_stm_pcm_player_disconnect(snd_device=0x%p)\n",
+			snd_device);
 
-	snd_stm_clk_put(pcm_player->clock);
+	if (snd_BUG_ON(!pcm_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_player)))
+		return -EINVAL;
 
 	snd_stm_info_unregister(pcm_player->proc_entry);
 
@@ -912,9 +940,12 @@
 	struct snd_card *card = snd_stm_card_get();
 	int i;
 
-	snd_stm_printd(0, "%s('%s')\n", __func__, dev_name(&pdev->dev));
+	snd_stm_printd(1, "snd_stm_pcm_player_probe(pdev=%p)\n", pdev);
 
-	BUG_ON(!card);
+	snd_stm_printd(0, "Probing device '%s'...\n", dev_name(&pdev->dev));
+
+	if (snd_BUG_ON(card == NULL))
+		return -EINVAL;
 
 	pcm_player = kzalloc(sizeof(*pcm_player), GFP_KERNEL);
 	if (!pcm_player) {
@@ -925,9 +956,11 @@
 	}
 	snd_stm_magic_set(pcm_player);
 	pcm_player->info = pdev->dev.platform_data;
-	BUG_ON(!pcm_player->info);
+	if (snd_BUG_ON(pcm_player->info == NULL))
+		return -EINVAL;
 	pcm_player->ver = pcm_player->info->ver;
-	BUG_ON(pcm_player->ver <= 0);
+	if (snd_BUG_ON(pcm_player->ver <= 0))
+		return -EINVAL;
 	pcm_player->device = &pdev->dev;
 
 	/* Get resources */
@@ -961,9 +994,9 @@
 	 * - 30 cells (120 bytes) in STx7100/9 and STx7200 cut 1.0
 	 * - 70 cells (280 bytes) in STx7111 and STx7200 cut 2.0. */
 
-	if (pcm_player->ver < 5)
+	if (pcm_player->ver < ver__AUD_PCMOUT__65_1_3)
 		pcm_player->fdma_max_transfer_size = 2;
-	else if (pcm_player->ver == 5)
+	else if (pcm_player->ver == ver__AUD_PCMOUT__65_1_3)
 		pcm_player->fdma_max_transfer_size = 20;
 	else
 		pcm_player->fdma_max_transfer_size = 30;
@@ -972,10 +1005,11 @@
 
 	snd_stm_printd(0, "Player's name is '%s'\n", pcm_player->info->name);
 
-	BUG_ON(pcm_player->info->channels <= 0);
-	BUG_ON(pcm_player->info->channels > 10);
-	BUG_ON(pcm_player->info->channels % 2 != 0);
-	if (pcm_player->ver > 1) {
+	if (snd_BUG_ON((pcm_player->info->channels <= 0) ||
+		       (pcm_player->info->channels > 10) ||
+		       (pcm_player->info->channels % 2 != 0)))
+		return -EINVAL;
+	if (pcm_player->ver > ver__AUD_PCMOUT__90_1_1) {
 		static unsigned int channels_2_10[] = { 2, 4, 6, 8, 10 };
 
 		pcm_player->channels_constraint.list = channels_2_10;
@@ -997,7 +1031,7 @@
 
 	/* STx7100 has a problem with 16/16 bits FIFO organization,
 	 * so we disable the 16 bits samples capability... */
-	if (pcm_player->ver <= 2)
+	if (pcm_player->ver <= ver__AUD_PCMOUT__90_1_3)
 		snd_stm_pcm_player_hw.formats &= ~SNDRV_PCM_FMTBIT_S16_LE;
 
 	/* Create ALSA lowlevel device */
@@ -1046,27 +1080,12 @@
 		goto error_conv_register_source;
 	}
 
-	/* Claim the pads */
-
-	if (pcm_player->info->pad_config) {
-		pcm_player->pads = stm_pad_claim(pcm_player->info->pad_config,
-				dev_name(&pdev->dev));
-		if (!pcm_player->pads) {
-			snd_stm_printe("Failed to claimed pads for '%s'!\n",
-					dev_name(&pdev->dev));
-			result = -EBUSY;
-			goto error_pad_claim;
-		}
-	}
-
 	/* Done now */
 
 	platform_set_drvdata(pdev, pcm_player);
 
 	return 0;
 
-error_pad_claim:
-	snd_stm_conv_unregister_source(pcm_player->conv_source);
 error_conv_register_source:
 	snd_stm_buffer_dispose(pcm_player->buffer);
 error_buffer_init:
@@ -1093,11 +1112,11 @@
 
 	snd_stm_printd(1, "snd_stm_pcm_player_remove(pdev=%p)\n", pdev);
 
-	BUG_ON(!pcm_player);
-	BUG_ON(!snd_stm_magic_valid(pcm_player));
+	if (snd_BUG_ON(!pcm_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_player)))
+		return -EINVAL;
 
-	if (pcm_player->pads)
-		stm_pad_release(pcm_player->pads);
 	snd_stm_conv_unregister_source(pcm_player->conv_source);
 	snd_stm_buffer_dispose(pcm_player->buffer);
 	snd_stm_fdma_release(pcm_player->fdma_channel);
@@ -1111,7 +1130,9 @@
 }
 
 static struct platform_driver snd_stm_pcm_player_driver = {
-	.driver.name = "snd_pcm_player",
+	.driver = {
+		.name = "snd_pcm_player",
+	},
 	.probe = snd_stm_pcm_player_probe,
 	.remove = snd_stm_pcm_player_remove,
 };
@@ -1122,19 +1143,12 @@
  * Initialization
  */
 
-static int __init snd_stm_pcm_player_init(void)
+int snd_stm_pcm_player_init(void)
 {
 	return platform_driver_register(&snd_stm_pcm_player_driver);
 }
 
-static void __exit snd_stm_pcm_player_exit(void)
+void snd_stm_pcm_player_exit(void)
 {
 	platform_driver_unregister(&snd_stm_pcm_player_driver);
 }
-
-MODULE_AUTHOR("Pawel Moll <pawel.moll@st.com>");
-MODULE_DESCRIPTION("STMicroelectronics PCM player driver");
-MODULE_LICENSE("GPL");
-
-module_init(snd_stm_pcm_player_init);
-module_exit(snd_stm_pcm_player_exit);
diff -ruN stm.org/pcm_reader.c stm/pcm_reader.c
--- a/drivers/stm/pcm_reader.c	2014-06-03 12:31:04.000000000 -0700
+++ b/sound/stm/pcm_reader.c	2012-10-11 11:46:27.000000000 -0700
@@ -1,7 +1,7 @@
 /*
  *   STMicroelectronics System-on-Chips' PCM reader driver
  *
- *   Copyright (c) 2005-2011 STMicroelectronics Limited
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
  *
  *   Author: Pawel Moll <pawel.moll@st.com>
  *
@@ -27,7 +27,6 @@
 #include <linux/interrupt.h>
 #include <linux/delay.h>
 #include <asm/cacheflush.h>
-#include <linux/stm/pad.h>
 #include <linux/stm/stm-dma.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -35,16 +34,12 @@
 #include <sound/info.h>
 #include <sound/pcm_params.h>
 
+#define COMPONENT pcm_reader
 #include "common.h"
 #include "reg_aud_pcmin.h"
 
 
 
-static int snd_stm_debug_level;
-module_param_named(debug, snd_stm_debug_level, int, S_IRUGO | S_IWUSR);
-
-
-
 /*
  * Some hardware-related definitions
  */
@@ -85,7 +80,6 @@
 	struct stm_dma_params *fdma_params_list;
 	struct stm_dma_req *fdma_request;
 	int running;
-	struct stm_pad_state *pads;
 
 	snd_stm_magic_field;
 };
@@ -105,14 +99,14 @@
 	snd_stm_printd(2, "snd_stm_pcm_reader_irq_handler(irq=%d, "
 			"dev_id=0x%p)\n", irq, dev_id);
 
-	BUG_ON(!pcm_reader);
-	BUG_ON(!snd_stm_magic_valid(pcm_reader));
+	if (snd_BUG_ON(!pcm_reader))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_reader)))
+		return -EINVAL;
 
 	/* Get interrupt status & clear them immediately */
-	preempt_disable();
 	status = get__AUD_PCMIN_ITS(pcm_reader);
 	set__AUD_PCMIN_ITS_CLR(pcm_reader, status);
-	preempt_enable();
 
 	/* Overflow? */
 	if (unlikely(status & mask__AUD_PCMIN_ITS__OVF__PENDING(pcm_reader))) {
@@ -125,7 +119,7 @@
 	}
 
 	/* Some alien interrupt??? */
-	BUG_ON(result != IRQ_HANDLED);
+	snd_BUG_ON(result != IRQ_HANDLED);
 
 	return result;
 }
@@ -138,8 +132,10 @@
 	snd_stm_printd(2, "snd_stm_pcm_reader_callback_node_done(param=0x%lx"
 			")\n", param);
 
-	BUG_ON(!pcm_reader);
-	BUG_ON(!snd_stm_magic_valid(pcm_reader));
+	if (snd_BUG_ON(!pcm_reader))
+		return;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_reader)))
+		return;
 
 	if (!pcm_reader->running)
 		return;
@@ -158,8 +154,10 @@
 	snd_stm_printd(2, "snd_stm_pcm_reader_callback_node_error(param=0x%lx"
 			")\n", param);
 
-	BUG_ON(!pcm_reader);
-	BUG_ON(!snd_stm_magic_valid(pcm_reader));
+	if (snd_BUG_ON(!pcm_reader))
+		return;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_reader)))
+		return;
 
 	if (!pcm_reader->running)
 		return;
@@ -209,9 +207,10 @@
 	snd_stm_printd(1, "snd_stm_pcm_reader_open(substream=0x%p)\n",
 			substream);
 
-	BUG_ON(!pcm_reader);
-	BUG_ON(!snd_stm_magic_valid(pcm_reader));
-	BUG_ON(!runtime);
+	if (snd_BUG_ON(!pcm_reader || !runtime))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_reader)))
+		return -EINVAL;
 
 	snd_pcm_set_sync(substream);  /* TODO: ??? */
 
@@ -224,7 +223,7 @@
 				dev_name(pcm_reader->device),
 				snd_stm_conv_get_name(pcm_reader->conv_group));
 	else
-		snd_stm_printd(1, "No converter attached to '%s'!\n",
+		snd_stm_printd(1, "Warning! No converter attached to '%s'!\n",
 				dev_name(pcm_reader->device));
 
 	/* Set up constraints & pass hardware capabilities info to ALSA */
@@ -272,8 +271,10 @@
 	snd_stm_printd(1, "snd_stm_pcm_reader_close(substream=0x%p)\n",
 			substream);
 
-	BUG_ON(!pcm_reader);
-	BUG_ON(!snd_stm_magic_valid(pcm_reader));
+	if (snd_BUG_ON(!pcm_reader))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_reader)))
+		return -EINVAL;
 
 	if (pcm_reader->conv_group) {
 		snd_stm_conv_release_group(pcm_reader->conv_group);
@@ -294,9 +295,10 @@
 	snd_stm_printd(1, "snd_stm_pcm_reader_hw_free(substream=0x%p)\n",
 			substream);
 
-	BUG_ON(!pcm_reader);
-	BUG_ON(!snd_stm_magic_valid(pcm_reader));
-	BUG_ON(!runtime);
+	if (snd_BUG_ON(!pcm_reader || !runtime))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_reader)))
+		return -EINVAL;
 
 	/* This callback may be called more than once... */
 
@@ -338,9 +340,10 @@
 	snd_stm_printd(1, "snd_stm_pcm_reader_hw_params(substream=0x%p,"
 			" hw_params=0x%p)\n", substream, hw_params);
 
-	BUG_ON(!pcm_reader);
-	BUG_ON(!snd_stm_magic_valid(pcm_reader));
-	BUG_ON(!runtime);
+	if (snd_BUG_ON(!pcm_reader || !runtime))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_reader)))
+		return -EINVAL;
 
 	/* This function may be called many times, so let's be prepared... */
 	if (snd_stm_buffer_is_allocated(pcm_reader->buffer))
@@ -351,7 +354,8 @@
 	buffer_bytes = params_buffer_bytes(hw_params);
 	periods = params_periods(hw_params);
 	period_bytes = buffer_bytes / periods;
-	BUG_ON(periods * period_bytes != buffer_bytes);
+	if (snd_BUG_ON(periods * period_bytes != buffer_bytes))
+		return -EINVAL;
 
 	/* Allocate buffer */
 
@@ -375,19 +379,24 @@
 
 	snd_stm_printd(1, "FDMA request trigger limit set to %d.\n",
 			transfer_size);
-	BUG_ON(buffer_bytes % transfer_bytes != 0);
-	BUG_ON(transfer_size > pcm_reader->fdma_max_transfer_size);
-	if (pcm_reader->ver > 3) {
-		BUG_ON(transfer_size != 1 && transfer_size % 2 == 0);
-		BUG_ON(transfer_size >
-		       mask__AUD_PCMIN_FMT__DMA_REQ_TRIG_LMT(pcm_reader));
+	if (snd_BUG_ON(buffer_bytes % transfer_bytes != 0))
+		return -EINVAL;
+	if (snd_BUG_ON(transfer_size > pcm_reader->fdma_max_transfer_size))
+		return -EINVAL;
+	if (pcm_reader->ver > ver__AUD_PCMIN__65_2_0) {
+		if (snd_BUG_ON(transfer_size != 1 && transfer_size % 2 != 0))
+			return -EINVAL;
+		if (snd_BUG_ON(transfer_size >
+			mask__AUD_PCMIN_FMT__DMA_REQ_TRIG_LMT(pcm_reader)))
+			return -EINVAL;
 		set__AUD_PCMIN_FMT__DMA_REQ_TRIG_LMT(pcm_reader, transfer_size);
 		set__AUD_PCMIN_FMT__BACK_STALLING__DISABLED(pcm_reader);
 
 		/* This is a workaround for a problem in early releases
 		 * of multi-channel PCM Readers with FIFO underrunning (!!!),
 		 * caused by spurious request line generation... */
-		if (pcm_reader->ver < 6 && transfer_size > 2)
+		if (pcm_reader->ver < ver__AUD_PCMIN__65_3_4 &&
+				transfer_size > 2)
 			fdma_req_config.count = transfer_size / 2;
 		else
 			fdma_req_config.count = transfer_size;
@@ -489,9 +498,10 @@
 	snd_stm_printd(1, "snd_stm_pcm_reader_prepare(substream=0x%p)\n",
 			substream);
 
-	BUG_ON(!pcm_reader);
-	BUG_ON(!snd_stm_magic_valid(pcm_reader));
-	BUG_ON(!runtime);
+	if (snd_BUG_ON(!pcm_reader || !runtime))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_reader)))
+		return -EINVAL;
 
 	/* Get format value from connected converter */
 
@@ -569,11 +579,12 @@
 
 	/* Number of channels... */
 
-	BUG_ON(runtime->channels % 2 != 0);
-	BUG_ON(runtime->channels < 2);
-	BUG_ON(runtime->channels > 10);
+	if (snd_BUG_ON(runtime->channels % 2 != 0))
+		return -EINVAL;
+	if (snd_BUG_ON(runtime->channels < 2 || runtime->channels > 10))
+		return -EINVAL;
 
-	if (pcm_reader->ver > 3)
+	if (pcm_reader->ver > ver__AUD_PCMIN__65_2_0)
 		set__AUD_PCMIN_FMT__NUM_CH(pcm_reader, runtime->channels / 2);
 
 	return 0;
@@ -588,8 +599,10 @@
 	snd_stm_printd(1, "snd_stm_pcm_reader_start(substream=0x%p)\n",
 			substream);
 
-	BUG_ON(!pcm_reader);
-	BUG_ON(!snd_stm_magic_valid(pcm_reader));
+	if (snd_BUG_ON(!pcm_reader))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_reader)))
+		return -EINVAL;
 
 	/* Un-reset PCM reader */
 
@@ -639,8 +652,10 @@
 	snd_stm_printd(1, "snd_stm_pcm_reader_stop(substream=0x%p)\n",
 			substream);
 
-	BUG_ON(!pcm_reader);
-	BUG_ON(!snd_stm_magic_valid(pcm_reader));
+	if (snd_BUG_ON(!pcm_reader))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_reader)))
+		return -EINVAL;
 
 	pcm_reader->running = 0;
 
@@ -699,9 +714,10 @@
 	snd_stm_printd(2, "snd_stm_pcm_reader_pointer(substream=0x%p)\n",
 			substream);
 
-	BUG_ON(!pcm_reader);
-	BUG_ON(!snd_stm_magic_valid(pcm_reader));
-	BUG_ON(!runtime);
+	if (snd_BUG_ON(!pcm_reader || !runtime))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_reader)))
+		return -EINVAL;
 
 	residue = get_dma_residue(pcm_reader->fdma_channel);
 	hwptr = (runtime->dma_bytes - residue) % runtime->dma_bytes;
@@ -744,8 +760,10 @@
 {
 	struct snd_stm_pcm_reader *pcm_reader = entry->private_data;
 
-	BUG_ON(!pcm_reader);
-	BUG_ON(!snd_stm_magic_valid(pcm_reader));
+	if (snd_BUG_ON(!pcm_reader))
+		return;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_reader)))
+		return;
 
 	snd_iprintf(buffer, "--- %s ---\n", dev_name(pcm_reader->device));
 	snd_iprintf(buffer, "base = 0x%p\n", pcm_reader->base);
@@ -768,17 +786,23 @@
 {
 	struct snd_stm_pcm_reader *pcm_reader = snd_device->device_data;
 
-	snd_stm_printd(1, "%s(snd_device=0x%p)\n", __func__, snd_device);
+	snd_stm_printd(1, "snd_stm_pcm_reader_register(snd_device=0x%p)\n",
+			snd_device);
 
-	BUG_ON(!pcm_reader);
-	BUG_ON(!snd_stm_magic_valid(pcm_reader));
+	if (snd_BUG_ON(!pcm_reader))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_reader)))
+		return -EINVAL;
+
+	snd_stm_printd(0, "--- Registering reader '%s'...\n",
+			dev_name(pcm_reader->device));
 
 	/* Set reset mode */
 
 	set__AUD_PCMIN_RST__RSTP__RESET(pcm_reader);
 
 	/* TODO: well, hardcoded - shall anyone use it?
-	 * And what does it actually mean? */
+	 * And what it actually means? */
 
 	set__AUD_PCMIN_CTRL__RND__NO_ROUNDING(pcm_reader);
 
@@ -788,6 +812,8 @@
 			dev_name(pcm_reader->device),
 			snd_stm_pcm_reader_dump_registers, pcm_reader);
 
+	snd_stm_printd(0, "--- Registered successfully!\n");
+
 	return 0;
 }
 
@@ -795,10 +821,13 @@
 {
 	struct snd_stm_pcm_reader *pcm_reader = snd_device->device_data;
 
-	snd_stm_printd(1, "%s(snd_device=0x%p)\n", __func__, snd_device);
+	snd_stm_printd(1, "snd_stm_pcm_reader_disconnect(snd_device=0x%p)\n",
+			snd_device);
 
-	BUG_ON(!pcm_reader);
-	BUG_ON(!snd_stm_magic_valid(pcm_reader));
+	if (snd_BUG_ON(!pcm_reader))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_reader)))
+		return -EINVAL;
 
 	snd_stm_info_unregister(pcm_reader->proc_entry);
 
@@ -823,9 +852,12 @@
 	struct snd_card *card = snd_stm_card_get();
 	int i;
 
-	snd_stm_printd(0, "%s('%s')\n", __func__, dev_name(&pdev->dev));
+	snd_stm_printd(1, "snd_stm_pcm_reader_probe(pdev=%p)\n", pdev);
 
-	BUG_ON(!card);
+	snd_stm_printd(0, "Probing device '%s'...\n", dev_name(&pdev->dev));
+
+	if (snd_BUG_ON(card == NULL))
+		return -EINVAL;
 
 	pcm_reader = kzalloc(sizeof(*pcm_reader), GFP_KERNEL);
 	if (!pcm_reader) {
@@ -836,9 +868,11 @@
 	}
 	snd_stm_magic_set(pcm_reader);
 	pcm_reader->info = pdev->dev.platform_data;
-	BUG_ON(!pcm_reader->info);
+	if (snd_BUG_ON(pcm_reader->info == NULL))
+		return -EINVAL;
 	pcm_reader->ver = pcm_reader->info->ver;
-	BUG_ON(pcm_reader->ver <= 0);
+	if (snd_BUG_ON(pcm_reader->ver <= 0))
+		return -EINVAL;
 	pcm_reader->device = &pdev->dev;
 
 	/* Get resources */
@@ -872,7 +906,7 @@
 	 * - 2 cells (8 bytes) in STx7100/9 and STx7200 cut 1.0
 	 * - 70 cells (280 bytes) in STx7111 and STx7200 cut 2.0. */
 
-	if (pcm_reader->ver < 4)
+	if (pcm_reader->ver < ver__AUD_PCMIN__65_3_1)
 		pcm_reader->fdma_max_transfer_size = 2;
 	else
 		pcm_reader->fdma_max_transfer_size = 30;
@@ -881,20 +915,22 @@
 
 	snd_stm_printd(0, "Reader's name is '%s'\n", pcm_reader->info->name);
 
-	if (pcm_reader->ver < 5) {
+	if (pcm_reader->ver < ver__AUD_PCMIN__65_3_3) {
 		/* STx7111 has a hardware bug in PCM reader in multichannels
 		 * mode, so we will just not be using it ;-) */
 		static unsigned int channels_2[] = { 2 };
 
-		BUG_ON(pcm_reader->info->channels != 2);
+		if (snd_BUG_ON(pcm_reader->info->channels != 2))
+			return -EINVAL;
 		pcm_reader->channels_constraint.list = channels_2;
 		pcm_reader->channels_constraint.count = 1;
 	} else {
 		static unsigned int channels_2_10[] = { 2, 4, 6, 8, 10 };
 
-		BUG_ON(pcm_reader->info->channels <= 0);
-		BUG_ON(pcm_reader->info->channels > 10);
-		BUG_ON(pcm_reader->info->channels % 2 != 0);
+		if (snd_BUG_ON(pcm_reader->info->channels <= 0 ||
+			       pcm_reader->info->channels > 10 ||
+			       pcm_reader->info->channels % 2 != 0))
+			return -EINVAL;
 		pcm_reader->channels_constraint.list = channels_2_10;
 		pcm_reader->channels_constraint.count =
 			pcm_reader->info->channels / 2;
@@ -950,27 +986,12 @@
 		goto error_conv_register_source;
 	}
 
-	/* Claim the pads */
-
-	if (pcm_reader->info->pad_config) {
-		pcm_reader->pads = stm_pad_claim(pcm_reader->info->pad_config,
-				dev_name(&pdev->dev));
-		if (!pcm_reader->pads) {
-			snd_stm_printe("Failed to claimed pads for '%s'!\n",
-					dev_name(&pdev->dev));
-			result = -EBUSY;
-			goto error_pad_claim;
-		}
-	}
-
 	/* Done now */
 
 	platform_set_drvdata(pdev, pcm_reader);
 
 	return 0;
 
-error_pad_claim:
-	snd_stm_conv_unregister_source(pcm_reader->conv_source);
 error_conv_register_source:
 	snd_stm_buffer_dispose(pcm_reader->buffer);
 error_buffer_create:
@@ -997,11 +1018,11 @@
 
 	snd_stm_printd(1, "snd_stm_pcm_reader_remove(pdev=%p)\n", pdev);
 
-	BUG_ON(!pcm_reader);
-	BUG_ON(!snd_stm_magic_valid(pcm_reader));
+	if (snd_BUG_ON(!pcm_reader))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(pcm_reader)))
+		return -EINVAL;
 
-	if (pcm_reader->pads)
-		stm_pad_release(pcm_reader->pads);
 	snd_stm_conv_unregister_source(pcm_reader->conv_source);
 	snd_stm_buffer_dispose(pcm_reader->buffer);
 	snd_stm_fdma_release(pcm_reader->fdma_channel);
@@ -1015,7 +1036,9 @@
 }
 
 static struct platform_driver snd_stm_pcm_reader_driver = {
-	.driver.name = "snd_pcm_reader",
+	.driver = {
+		.name = "snd_pcm_reader",
+	},
 	.probe = snd_stm_pcm_reader_probe,
 	.remove = snd_stm_pcm_reader_remove,
 };
@@ -1024,19 +1047,12 @@
  * Initialization
  */
 
-static int __init snd_stm_pcm_reader_init(void)
+int snd_stm_pcm_reader_init(void)
 {
 	return platform_driver_register(&snd_stm_pcm_reader_driver);
 }
 
-static void __exit snd_stm_pcm_reader_exit(void)
+void snd_stm_pcm_reader_exit(void)
 {
 	platform_driver_unregister(&snd_stm_pcm_reader_driver);
 }
-
-MODULE_AUTHOR("Pawel Moll <pawel.moll@st.com>");
-MODULE_DESCRIPTION("STMicroelectronics PCM reader driver");
-MODULE_LICENSE("GPL");
-
-module_init(snd_stm_pcm_reader_init);
-module_exit(snd_stm_pcm_reader_exit);
diff -ruN stm.org/reg_7105_audcfg.h stm/reg_7105_audcfg.h
--- a/dev/null
+++ b/sound/stm/reg_7105_audcfg.h	2012-10-11 11:46:27.000000000 -0700
@@ -0,0 +1,154 @@
+#ifndef __SND_STM_7105_AUDCFG_H
+#define __SND_STM_7105_AUDCFG_H
+
+
+
+/*
+ * 7105_AUDCFG_IO_CTRL
+ */
+
+#define offset__7105_AUDCFG_IO_CTRL(ip) 0x00
+#define get__7105_AUDCFG_IO_CTRL(ip) readl(ip->base + \
+	offset__7105_AUDCFG_IO_CTRL(ip))
+#define set__7105_AUDCFG_IO_CTRL(ip, value) writel(value, ip->base + \
+	offset__7105_AUDCFG_IO_CTRL(ip))
+
+/* PCM_CLK_EN */
+
+#define shift__7105_AUDCFG_IO_CTRL__PCM_CLK_EN(ip) 0
+#define mask__7105_AUDCFG_IO_CTRL__PCM_CLK_EN(ip) 0x1
+#define get__7105_AUDCFG_IO_CTRL__PCM_CLK_EN(ip) ((readl(ip->base + \
+	offset__7105_AUDCFG_IO_CTRL(ip)) >> \
+	shift__7105_AUDCFG_IO_CTRL__PCM_CLK_EN(ip)) & \
+	mask__7105_AUDCFG_IO_CTRL__PCM_CLK_EN(ip))
+#define set__7105_AUDCFG_IO_CTRL__PCM_CLK_EN(ip, value) \
+	writel((readl(ip->base + offset__7105_AUDCFG_IO_CTRL(ip)) & \
+	~(mask__7105_AUDCFG_IO_CTRL__PCM_CLK_EN(ip) << \
+	shift__7105_AUDCFG_IO_CTRL__PCM_CLK_EN(ip))) | (((value) & \
+	mask__7105_AUDCFG_IO_CTRL__PCM_CLK_EN(ip)) << \
+	shift__7105_AUDCFG_IO_CTRL__PCM_CLK_EN(ip)), ip->base + \
+	offset__7105_AUDCFG_IO_CTRL(ip))
+
+#define value__7105_AUDCFG_IO_CTRL__PCM_CLK_EN__INPUT(ip) 0x0
+#define mask__7105_AUDCFG_IO_CTRL__PCM_CLK_EN__INPUT(ip) \
+	(value__7105_AUDCFG_IO_CTRL__PCM_CLK_EN__INPUT(ip) << \
+	shift__7105_AUDCFG_IO_CTRL__PCM_CLK_EN(ip))
+#define set__7105_AUDCFG_IO_CTRL__PCM_CLK_EN__INPUT(ip) \
+	set__7105_AUDCFG_IO_CTRL__PCM_CLK_EN(ip, \
+	value__7105_AUDCFG_IO_CTRL__PCM_CLK_EN__INPUT(ip))
+
+#define value__7105_AUDCFG_IO_CTRL__PCM_CLK_EN__OUTPUT(ip) 0x1
+#define mask__7105_AUDCFG_IO_CTRL__PCM_CLK_EN__OUTPUT(ip) \
+	(value__7105_AUDCFG_IO_CTRL__PCM_CLK_EN__OUTPUT(ip) << \
+	shift__7105_AUDCFG_IO_CTRL__PCM_CLK_EN(ip))
+#define set__7105_AUDCFG_IO_CTRL__PCM_CLK_EN__OUTPUT(ip) \
+	set__7105_AUDCFG_IO_CTRL__PCM_CLK_EN(ip, \
+	value__7105_AUDCFG_IO_CTRL__PCM_CLK_EN__OUTPUT(ip))
+
+/* SPDIFHDMI_EN */
+
+#define shift__7105_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip) 3
+#define mask__7105_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip) 0x1
+#define get__7105_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip) ((readl(ip->base + \
+	offset__7105_AUDCFG_IO_CTRL(ip)) >> \
+	shift__7105_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip)) & \
+	mask__7105_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip))
+#define set__7105_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip, value) \
+	writel((readl(ip->base + offset__7105_AUDCFG_IO_CTRL(ip)) & \
+	~(mask__7105_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip) << \
+	shift__7105_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip))) | (((value) & \
+	mask__7105_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip)) << \
+	shift__7105_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip)), ip->base + \
+	offset__7105_AUDCFG_IO_CTRL(ip))
+
+#define value__7105_AUDCFG_IO_CTRL__SPDIFHDMI_EN__INPUT(ip) 0x0
+#define mask__7105_AUDCFG_IO_CTRL__SPDIFHDMI_EN__INPUT(ip) \
+	(value__7105_AUDCFG_IO_CTRL__SPDIFHDMI_EN__INPUT(ip) << \
+	shift__7105_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip))
+#define set__7105_AUDCFG_IO_CTRL__SPDIFHDMI_EN__INPUT(ip) \
+	set__7105_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip, \
+	value__7105_AUDCFG_IO_CTRL__SPDIFHDMI_EN__INPUT(ip))
+
+#define value__7105_AUDCFG_IO_CTRL__SPDIFHDMI_EN__OUTPUT(ip) 0x1
+#define mask__7105_AUDCFG_IO_CTRL__SPDIFHDMI_EN__OUTPUT(ip) \
+	(value__7105_AUDCFG_IO_CTRL__SPDIFHDMI_EN__OUTPUT(ip) << \
+	shift__7105_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip))
+#define set__7105_AUDCFG_IO_CTRL__SPDIFHDMI_EN__OUTPUT(ip) \
+	set__7105_AUDCFG_IO_CTRL__SPDIFHDMI_EN(ip, \
+	value__7105_AUDCFG_IO_CTRL__SPDIFHDMI_EN__OUTPUT(ip))
+
+/* PCMPLHDMI_EN */
+
+#define shift__7105_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip) 5
+#define mask__7105_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip) 0x1
+#define get__7105_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip) ((readl(ip->base + \
+	offset__7105_AUDCFG_IO_CTRL(ip)) >> \
+	shift__7105_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip)) & \
+	mask__7105_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip))
+#define set__7105_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip, value) \
+	writel((readl(ip->base + offset__7105_AUDCFG_IO_CTRL(ip)) & \
+	~(mask__7105_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip) << \
+	shift__7105_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip))) | (((value) & \
+	mask__7105_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip)) << \
+	shift__7105_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip)), ip->base + \
+	offset__7105_AUDCFG_IO_CTRL(ip))
+
+#define value__7105_AUDCFG_IO_CTRL__PCMPLHDMI_EN__INPUT(ip) 0x0
+#define mask__7105_AUDCFG_IO_CTRL__PCMPLHDMI_EN__INPUT(ip) \
+	(value__7105_AUDCFG_IO_CTRL__PCMPLHDMI_EN__INPUT(ip) << \
+	shift__7105_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip))
+#define set__7105_AUDCFG_IO_CTRL__PCMPLHDMI_EN__INPUT(ip) \
+	set__7105_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip, \
+	value__7105_AUDCFG_IO_CTRL__PCMPLHDMI_EN__INPUT(ip))
+
+#define value__7105_AUDCFG_IO_CTRL__PCMPLHDMI_EN__OUTPUT(ip) 0x1
+#define mask__7105_AUDCFG_IO_CTRL__PCMPLHDMI_EN__OUTPUT(ip) \
+	(value__7105_AUDCFG_IO_CTRL__PCMPLHDMI_EN__OUTPUT(ip) << \
+	shift__7105_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip))
+#define set__7105_AUDCFG_IO_CTRL__PCMPLHDMI_EN__OUTPUT(ip) \
+	set__7105_AUDCFG_IO_CTRL__PCMPLHDMI_EN(ip, \
+	value__7105_AUDCFG_IO_CTRL__PCMPLHDMI_EN__OUTPUT(ip))
+
+/* CLKREC_SEL */
+
+#define shift__7105_AUDCFG_IO_CTRL__CLKREC_SEL(ip) 9
+#define mask__7105_AUDCFG_IO_CTRL__CLKREC_SEL(ip) 0x3
+#define get__7105_AUDCFG_IO_CTRL__CLKREC_SEL(ip) ((readl(ip->base + \
+	offset__7105_AUDCFG_IO_CTRL(ip)) >> \
+	shift__7105_AUDCFG_IO_CTRL__CLKREC_SEL(ip)) & \
+	mask__7105_AUDCFG_IO_CTRL__CLKREC_SEL(ip))
+#define set__7105_AUDCFG_IO_CTRL__CLKREC_SEL(ip, value) \
+	writel((readl(ip->base + offset__7105_AUDCFG_IO_CTRL(ip)) & \
+	~(mask__7105_AUDCFG_IO_CTRL__CLKREC_SEL(ip) << \
+	shift__7105_AUDCFG_IO_CTRL__CLKREC_SEL(ip))) | (((value) & \
+	mask__7105_AUDCFG_IO_CTRL__CLKREC_SEL(ip)) << \
+	shift__7105_AUDCFG_IO_CTRL__CLKREC_SEL(ip)), ip->base + \
+	offset__7105_AUDCFG_IO_CTRL(ip))
+
+#define value__7105_AUDCFG_IO_CTRL__CLKREC_SEL__PCMPLHDMI(ip) 0x0
+#define mask__7105_AUDCFG_IO_CTRL__CLKREC_SEL__PCMPLHDMI(ip) \
+	(value__7105_AUDCFG_IO_CTRL__CLKREC_SEL__PCMPLHDMI(ip) << \
+	shift__7105_AUDCFG_IO_CTRL__CLKREC_SEL(ip))
+#define set__7105_AUDCFG_IO_CTRL__CLKREC_SEL__PCMPLHDMI(ip) \
+	set__7105_AUDCFG_IO_CTRL__CLKREC_SEL(ip, \
+	value__7105_AUDCFG_IO_CTRL__CLKREC_SEL__PCMPLHDMI(ip))
+
+#define value__7105_AUDCFG_IO_CTRL__CLKREC_SEL__SPDIFHDMI(ip) 0x1
+#define mask__7105_AUDCFG_IO_CTRL__CLKREC_SEL__SPDIFHDMI(ip) \
+	(value__7105_AUDCFG_IO_CTRL__CLKREC_SEL__SPDIFHDMI(ip) << \
+	shift__7105_AUDCFG_IO_CTRL__CLKREC_SEL(ip))
+#define set__7105_AUDCFG_IO_CTRL__CLKREC_SEL__SPDIFHDMI(ip) \
+	set__7105_AUDCFG_IO_CTRL__CLKREC_SEL(ip, \
+	value__7105_AUDCFG_IO_CTRL__CLKREC_SEL__SPDIFHDMI(ip))
+
+#define value__7105_AUDCFG_IO_CTRL__CLKREC_SEL__PCMPL1(ip) 0x2
+#define mask__7105_AUDCFG_IO_CTRL__CLKREC_SEL__PCMPL1(ip) \
+	(value__7105_AUDCFG_IO_CTRL__CLKREC_SEL__PCMPL1(ip) << \
+	shift__7105_AUDCFG_IO_CTRL__CLKREC_SEL(ip))
+#define set__7105_AUDCFG_IO_CTRL__CLKREC_SEL__PCMPL1(ip) \
+	set__7105_AUDCFG_IO_CTRL__CLKREC_SEL(ip, \
+	value__7105_AUDCFG_IO_CTRL__CLKREC_SEL__PCMPL1(ip))
+
+
+
+#endif
diff -ruN stm.org/reg_audcfg_adac.h stm/reg_audcfg_adac.h
--- a/dev/null
+++ b/sound/stm/reg_audcfg_adac.h	2012-10-11 11:46:27.000000000 -0700
@@ -0,0 +1,208 @@
+#ifndef __SND_STM_AUDCFG_ADAC_H
+#define __SND_STM_AUDCFG_ADAC_H
+
+/*
+ * IP versions
+ */
+
+/* 7100 2.0, 7100 3.0 */
+#define ver__AUDCFG_ADAC__90_1_0 1
+
+/* 7109 2.0, 7109 3.0 */
+#define ver__AUDCFG_ADAC__90_1_5_0 2
+
+/* 7200 1.0 */
+#define ver__AUDCFG_ADAC__65_3_0_0 3
+
+/* 7111, 7200 2.0 */
+#define ver__AUDCFG_ADAC__65_3_2_a 4
+
+
+
+/*
+ * AUDCFG_ADAC_CTRL
+ */
+
+#define offset__AUDCFG_ADAC_CTRL(ip) 0x00
+#define get__AUDCFG_ADAC_CTRL(ip) readl(ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip))
+#define set__AUDCFG_ADAC_CTRL(ip, value) writel(value, ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip))
+
+/* NRST */
+
+#define shift__AUDCFG_ADAC_CTRL__NRST(ip) 0
+#define mask__AUDCFG_ADAC_CTRL__NRST(ip) 0x1
+#define get__AUDCFG_ADAC_CTRL__NRST(ip) ((readl(ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip)) >> shift__AUDCFG_ADAC_CTRL__NRST(ip)) & \
+	mask__AUDCFG_ADAC_CTRL__NRST(ip))
+#define set__AUDCFG_ADAC_CTRL__NRST(ip, value) writel((readl(ip->base \
+	+ offset__AUDCFG_ADAC_CTRL(ip)) & ~(mask__AUDCFG_ADAC_CTRL__NRST(ip) \
+	<< shift__AUDCFG_ADAC_CTRL__NRST(ip))) | (((value) & \
+	mask__AUDCFG_ADAC_CTRL__NRST(ip)) << \
+	shift__AUDCFG_ADAC_CTRL__NRST(ip)), ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip))
+
+#define value__AUDCFG_ADAC_CTRL__NRST__RESET(ip) 0x0
+#define mask__AUDCFG_ADAC_CTRL__NRST__RESET(ip) \
+	(value__AUDCFG_ADAC_CTRL__NRST__RESET(ip) << \
+	shift__AUDCFG_ADAC_CTRL__NRST(ip))
+#define set__AUDCFG_ADAC_CTRL__NRST__RESET(ip) \
+	set__AUDCFG_ADAC_CTRL__NRST(ip, \
+	value__AUDCFG_ADAC_CTRL__NRST__RESET(ip))
+
+#define value__AUDCFG_ADAC_CTRL__NRST__NORMAL(ip) 0x1
+#define mask__AUDCFG_ADAC_CTRL__NRST__NORMAL(ip) \
+	(value__AUDCFG_ADAC_CTRL__NRST__NORMAL(ip) << \
+	shift__AUDCFG_ADAC_CTRL__NRST(ip))
+#define set__AUDCFG_ADAC_CTRL__NRST__NORMAL(ip) \
+	set__AUDCFG_ADAC_CTRL__NRST(ip, \
+	value__AUDCFG_ADAC_CTRL__NRST__NORMAL(ip))
+
+/* MODE */
+
+#define shift__AUDCFG_ADAC_CTRL__MODE(ip) 1
+#define mask__AUDCFG_ADAC_CTRL__MODE(ip) 0x3
+#define get__AUDCFG_ADAC_CTRL__MODE(ip) ((readl(ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip)) >> shift__AUDCFG_ADAC_CTRL__MODE(ip)) & \
+	mask__AUDCFG_ADAC_CTRL__MODE(ip))
+#define set__AUDCFG_ADAC_CTRL__MODE(ip, value) writel((readl(ip->base \
+	+ offset__AUDCFG_ADAC_CTRL(ip)) & ~(mask__AUDCFG_ADAC_CTRL__MODE(ip) \
+	<< shift__AUDCFG_ADAC_CTRL__MODE(ip))) | (((value) & \
+	mask__AUDCFG_ADAC_CTRL__MODE(ip)) << \
+	shift__AUDCFG_ADAC_CTRL__MODE(ip)), ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip))
+
+#define value__AUDCFG_ADAC_CTRL__MODE__DEFAULT(ip) 0x0
+#define mask__AUDCFG_ADAC_CTRL__MODE__DEFAULT(ip) \
+	(value__AUDCFG_ADAC_CTRL__MODE__DEFAULT(ip) << \
+	shift__AUDCFG_ADAC_CTRL__MODE(ip))
+#define set__AUDCFG_ADAC_CTRL__MODE__DEFAULT(ip) \
+	set__AUDCFG_ADAC_CTRL__MODE(ip, \
+	value__AUDCFG_ADAC_CTRL__MODE__DEFAULT(ip))
+
+/* NSB */
+
+#define shift__AUDCFG_ADAC_CTRL__NSB(ip) 3
+#define mask__AUDCFG_ADAC_CTRL__NSB(ip) 0x1
+#define get__AUDCFG_ADAC_CTRL__NSB(ip) ((readl(ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip)) >> shift__AUDCFG_ADAC_CTRL__NSB(ip)) & \
+	mask__AUDCFG_ADAC_CTRL__NSB(ip))
+#define set__AUDCFG_ADAC_CTRL__NSB(ip, value) writel((readl(ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip)) & ~(mask__AUDCFG_ADAC_CTRL__NSB(ip) << \
+	shift__AUDCFG_ADAC_CTRL__NSB(ip))) | (((value) & \
+	mask__AUDCFG_ADAC_CTRL__NSB(ip)) << shift__AUDCFG_ADAC_CTRL__NSB(ip)), \
+	ip->base + offset__AUDCFG_ADAC_CTRL(ip))
+
+#define value__AUDCFG_ADAC_CTRL__NSB__POWER_DOWN(ip) 0x0
+#define mask__AUDCFG_ADAC_CTRL__NSB__POWER_DOWN(ip) \
+	(value__AUDCFG_ADAC_CTRL__NSB__POWER_DOWN(ip) << \
+	shift__AUDCFG_ADAC_CTRL__NSB(ip))
+#define set__AUDCFG_ADAC_CTRL__NSB__POWER_DOWN(ip) \
+	set__AUDCFG_ADAC_CTRL__NSB(ip, \
+	value__AUDCFG_ADAC_CTRL__NSB__POWER_DOWN(ip))
+
+#define value__AUDCFG_ADAC_CTRL__NSB__NORMAL(ip) 0x1
+#define mask__AUDCFG_ADAC_CTRL__NSB__NORMAL(ip) \
+	(value__AUDCFG_ADAC_CTRL__NSB__NORMAL(ip) << \
+	shift__AUDCFG_ADAC_CTRL__NSB(ip))
+#define set__AUDCFG_ADAC_CTRL__NSB__NORMAL(ip) \
+	set__AUDCFG_ADAC_CTRL__NSB(ip, \
+	value__AUDCFG_ADAC_CTRL__NSB__NORMAL(ip))
+
+/* SOFTMUTE */
+
+#define shift__AUDCFG_ADAC_CTRL__SOFTMUTE(ip) 4
+#define mask__AUDCFG_ADAC_CTRL__SOFTMUTE(ip) 0x1
+#define get__AUDCFG_ADAC_CTRL__SOFTMUTE(ip) ((readl(ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip)) >> \
+	shift__AUDCFG_ADAC_CTRL__SOFTMUTE(ip)) & \
+	mask__AUDCFG_ADAC_CTRL__SOFTMUTE(ip))
+#define set__AUDCFG_ADAC_CTRL__SOFTMUTE(ip, value) \
+	writel((readl(ip->base + offset__AUDCFG_ADAC_CTRL(ip)) & \
+	~(mask__AUDCFG_ADAC_CTRL__SOFTMUTE(ip) << \
+	shift__AUDCFG_ADAC_CTRL__SOFTMUTE(ip))) | (((value) & \
+	mask__AUDCFG_ADAC_CTRL__SOFTMUTE(ip)) << \
+	shift__AUDCFG_ADAC_CTRL__SOFTMUTE(ip)), ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip))
+
+#define value__AUDCFG_ADAC_CTRL__SOFTMUTE__NORMAL(ip) 0x0
+#define mask__AUDCFG_ADAC_CTRL__SOFTMUTE__NORMAL(ip) \
+	(value__AUDCFG_ADAC_CTRL__SOFTMUTE__NORMAL(ip) << \
+	shift__AUDCFG_ADAC_CTRL__SOFTMUTE(ip))
+#define set__AUDCFG_ADAC_CTRL__SOFTMUTE__NORMAL(ip) \
+	set__AUDCFG_ADAC_CTRL__SOFTMUTE(ip, \
+	value__AUDCFG_ADAC_CTRL__SOFTMUTE__NORMAL(ip))
+
+#define value__AUDCFG_ADAC_CTRL__SOFTMUTE__MUTE(ip) 0x1
+#define mask__AUDCFG_ADAC_CTRL__SOFTMUTE__MUTE(ip) \
+	(value__AUDCFG_ADAC_CTRL__SOFTMUTE__MUTE(ip) << \
+	shift__AUDCFG_ADAC_CTRL__SOFTMUTE(ip))
+#define set__AUDCFG_ADAC_CTRL__SOFTMUTE__MUTE(ip) \
+	set__AUDCFG_ADAC_CTRL__SOFTMUTE(ip, \
+	value__AUDCFG_ADAC_CTRL__SOFTMUTE__MUTE(ip))
+
+/* PDNANA */
+
+#define shift__AUDCFG_ADAC_CTRL__PDNANA(ip) 5
+#define mask__AUDCFG_ADAC_CTRL__PDNANA(ip) 0x1
+#define get__AUDCFG_ADAC_CTRL__PDNANA(ip) ((readl(ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip)) >> shift__AUDCFG_ADAC_CTRL__PDNANA(ip)) \
+	& mask__AUDCFG_ADAC_CTRL__PDNANA(ip))
+#define set__AUDCFG_ADAC_CTRL__PDNANA(ip, value) \
+	writel((readl(ip->base + offset__AUDCFG_ADAC_CTRL(ip)) & \
+	~(mask__AUDCFG_ADAC_CTRL__PDNANA(ip) << \
+	shift__AUDCFG_ADAC_CTRL__PDNANA(ip))) | (((value) & \
+	mask__AUDCFG_ADAC_CTRL__PDNANA(ip)) << \
+	shift__AUDCFG_ADAC_CTRL__PDNANA(ip)), ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip))
+
+#define value__AUDCFG_ADAC_CTRL__PDNANA__POWER_DOWN(ip) 0x0
+#define mask__AUDCFG_ADAC_CTRL__PDNANA__POWER_DOWN(ip) \
+	(value__AUDCFG_ADAC_CTRL__PDNANA__POWER_DOWN(ip) << \
+	shift__AUDCFG_ADAC_CTRL__PDNANA(ip))
+#define set__AUDCFG_ADAC_CTRL__PDNANA__POWER_DOWN(ip) \
+	set__AUDCFG_ADAC_CTRL__PDNANA(ip, \
+	value__AUDCFG_ADAC_CTRL__PDNANA__POWER_DOWN(ip))
+
+#define value__AUDCFG_ADAC_CTRL__PDNANA__NORMAL(ip) 0x1
+#define mask__AUDCFG_ADAC_CTRL__PDNANA__NORMAL(ip) \
+	(value__AUDCFG_ADAC_CTRL__PDNANA__NORMAL(ip) << \
+	shift__AUDCFG_ADAC_CTRL__PDNANA(ip))
+#define set__AUDCFG_ADAC_CTRL__PDNANA__NORMAL(ip) \
+	set__AUDCFG_ADAC_CTRL__PDNANA(ip, \
+	value__AUDCFG_ADAC_CTRL__PDNANA__NORMAL(ip))
+
+/* PDNBG */
+
+#define shift__AUDCFG_ADAC_CTRL__PDNBG(ip) 6
+#define mask__AUDCFG_ADAC_CTRL__PDNBG(ip) 0x1
+#define get__AUDCFG_ADAC_CTRL__PDNBG(ip) ((readl(ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip)) >> shift__AUDCFG_ADAC_CTRL__PDNBG(ip)) & \
+	mask__AUDCFG_ADAC_CTRL__PDNBG(ip))
+#define set__AUDCFG_ADAC_CTRL__PDNBG(ip, value) writel((readl(ip->base \
+	+ offset__AUDCFG_ADAC_CTRL(ip)) & ~(mask__AUDCFG_ADAC_CTRL__PDNBG(ip) \
+	<< shift__AUDCFG_ADAC_CTRL__PDNBG(ip))) | (((value) & \
+	mask__AUDCFG_ADAC_CTRL__PDNBG(ip)) << \
+	shift__AUDCFG_ADAC_CTRL__PDNBG(ip)), ip->base + \
+	offset__AUDCFG_ADAC_CTRL(ip))
+
+#define value__AUDCFG_ADAC_CTRL__PDNBG__POWER_DOWN(ip) 0x0
+#define mask__AUDCFG_ADAC_CTRL__PDNBG__POWER_DOWN(ip) \
+	(value__AUDCFG_ADAC_CTRL__PDNBG__POWER_DOWN(ip) << \
+	shift__AUDCFG_ADAC_CTRL__PDNBG(ip))
+#define set__AUDCFG_ADAC_CTRL__PDNBG__POWER_DOWN(ip) \
+	set__AUDCFG_ADAC_CTRL__PDNBG(ip, \
+	value__AUDCFG_ADAC_CTRL__PDNBG__POWER_DOWN(ip))
+
+#define value__AUDCFG_ADAC_CTRL__PDNBG__NORMAL(ip) 0x1
+#define mask__AUDCFG_ADAC_CTRL__PDNBG__NORMAL(ip) \
+	(value__AUDCFG_ADAC_CTRL__PDNBG__NORMAL(ip) << \
+	shift__AUDCFG_ADAC_CTRL__PDNBG(ip))
+#define set__AUDCFG_ADAC_CTRL__PDNBG__NORMAL(ip) \
+	set__AUDCFG_ADAC_CTRL__PDNBG(ip, \
+	value__AUDCFG_ADAC_CTRL__PDNBG__NORMAL(ip))
+
+
+
+#endif
diff -ruN stm.org/reg_audcfg_fsyn.h stm/reg_audcfg_fsyn.h
--- a/dev/null
+++ b/sound/stm/reg_audcfg_fsyn.h	2012-10-11 11:46:27.000000000 -0700
@@ -0,0 +1,448 @@
+#ifndef __SND_STM_AUDCFG_FSYN_H
+#define __SND_STM_AUDCFG_FSYN_H
+
+/*
+ * IP versions
+ */
+
+/* 7100 2.0, 7100 3.0 */
+#define ver__AUDCFG_FSYN__90_1_0_3 1
+
+/* 7109 2.0, 7109 3.0 */
+#define ver__AUDCFG_FSYN__90_2_3 2
+
+/* 7200 1.0 */
+#define ver__AUDCFG_FSYN__65_2_1_2 3
+
+/* 7111 */
+#define ver__AUDCFG_FSYN__65_3_1 4
+
+/* 7200 2.0 */
+#define ver__AUDCFG_FSYN__65_3_3 5
+
+
+
+/*
+ * AUDCFG_FSYN_CFG
+ */
+
+#define offset__AUDCFG_FSYN_CFG(ip) 0x00
+#define get__AUDCFG_FSYN_CFG(ip) readl(ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip))
+#define set__AUDCFG_FSYN_CFG(ip, value) writel(value, ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip))
+
+/* RSTP */
+
+#define shift__AUDCFG_FSYN_CFG__RSTP(ip) 0
+#define mask__AUDCFG_FSYN_CFG__RSTP(ip) 0x1
+#define get__AUDCFG_FSYN_CFG__RSTP(ip) ((readl(ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip)) >> shift__AUDCFG_FSYN_CFG__RSTP(ip)) & \
+	mask__AUDCFG_FSYN_CFG__RSTP(ip))
+#define set__AUDCFG_FSYN_CFG__RSTP(ip, value) writel((readl(ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip)) & ~(mask__AUDCFG_FSYN_CFG__RSTP(ip) << \
+	shift__AUDCFG_FSYN_CFG__RSTP(ip))) | (((value) & \
+	mask__AUDCFG_FSYN_CFG__RSTP(ip)) << shift__AUDCFG_FSYN_CFG__RSTP(ip)), \
+	ip->base + offset__AUDCFG_FSYN_CFG(ip))
+
+#define value__AUDCFG_FSYN_CFG__RSTP__RUNNING(ip) 0x0
+#define mask__AUDCFG_FSYN_CFG__RSTP__RUNNING(ip) \
+	(value__AUDCFG_FSYN_CFG__RSTP__RUNNING(ip) << \
+	shift__AUDCFG_FSYN_CFG__RSTP(ip))
+#define set__AUDCFG_FSYN_CFG__RSTP__RUNNING(ip) \
+	set__AUDCFG_FSYN_CFG__RSTP(ip, \
+	value__AUDCFG_FSYN_CFG__RSTP__RUNNING(ip))
+
+#define value__AUDCFG_FSYN_CFG__RSTP__RESET(ip) 0x1
+#define mask__AUDCFG_FSYN_CFG__RSTP__RESET(ip) \
+	(value__AUDCFG_FSYN_CFG__RSTP__RESET(ip) << \
+	shift__AUDCFG_FSYN_CFG__RSTP(ip))
+#define set__AUDCFG_FSYN_CFG__RSTP__RESET(ip) \
+	set__AUDCFG_FSYN_CFG__RSTP(ip, \
+	value__AUDCFG_FSYN_CFG__RSTP__RESET(ip))
+
+/* PCM_CLK_SEL */
+
+#define shift__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip) 2
+#define mask__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip) 0xf
+#define get__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip) ((readl(ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip)) >> \
+	shift__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip)) & \
+	mask__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip))
+#define set__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip, value) \
+	writel((readl(ip->base + offset__AUDCFG_FSYN_CFG(ip)) & \
+	~(mask__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip) << \
+	shift__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip))) | (((value) & \
+	mask__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip)) << \
+	shift__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip)), ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip))
+
+#define value__AUDCFG_FSYN_CFG__PCM_CLK_SEL__EXTCLK(ip, n) (ip->ver < \
+	ver__AUDCFG_FSYN__65_2_1_2 ? (0 << n) : (ip->ver < \
+	ver__AUDCFG_FSYN__65_3_1 ? (1 << n) : (ip->ver < \
+	ver__AUDCFG_FSYN__65_3_3 ? (0 << n) : (1 << n))))
+#define mask__AUDCFG_FSYN_CFG__PCM_CLK_SEL__EXTCLK(ip, n) \
+	(value__AUDCFG_FSYN_CFG__PCM_CLK_SEL__EXTCLK(ip, n) << \
+	shift__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip))
+#define set__AUDCFG_FSYN_CFG__PCM_CLK_SEL__EXTCLK(ip, n) \
+	set__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip, \
+	value__AUDCFG_FSYN_CFG__PCM_CLK_SEL__EXTCLK(ip, n))
+
+#define value__AUDCFG_FSYN_CFG__PCM_CLK_SEL__FSYNTH(ip, n) (ip->ver < \
+	ver__AUDCFG_FSYN__65_2_1_2 ? (1 << n) : (ip->ver < \
+	ver__AUDCFG_FSYN__65_3_1 ? (0 << n) : (ip->ver < \
+	ver__AUDCFG_FSYN__65_3_3 ? (1 << n) : (0 << n))))
+#define mask__AUDCFG_FSYN_CFG__PCM_CLK_SEL__FSYNTH(ip, n) \
+	(value__AUDCFG_FSYN_CFG__PCM_CLK_SEL__FSYNTH(ip, n) << \
+	shift__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip))
+#define set__AUDCFG_FSYN_CFG__PCM_CLK_SEL__FSYNTH(ip, n) \
+	set__AUDCFG_FSYN_CFG__PCM_CLK_SEL(ip, \
+	value__AUDCFG_FSYN_CFG__PCM_CLK_SEL__FSYNTH(ip, n))
+
+/* FS_EN */
+
+#define shift__AUDCFG_FSYN_CFG__FS_EN(ip) (ip->ver < \
+	ver__AUDCFG_FSYN__65_2_1_2 ? 6 : (ip->ver < ver__AUDCFG_FSYN__65_3_1 ? \
+	-1 : (ip->ver < ver__AUDCFG_FSYN__65_3_3 ? 6 : -1)))
+#define mask__AUDCFG_FSYN_CFG__FS_EN(ip) (ip->ver < \
+	ver__AUDCFG_FSYN__65_2_1_2 ? 0x7 : (ip->ver < ver__AUDCFG_FSYN__65_3_1 \
+	? -1 : (ip->ver < ver__AUDCFG_FSYN__65_3_3 ? 0xf : -1)))
+#define get__AUDCFG_FSYN_CFG__FS_EN(ip) ((readl(ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip)) >> shift__AUDCFG_FSYN_CFG__FS_EN(ip)) & \
+	mask__AUDCFG_FSYN_CFG__FS_EN(ip))
+#define set__AUDCFG_FSYN_CFG__FS_EN(ip, value) writel((readl(ip->base \
+	+ offset__AUDCFG_FSYN_CFG(ip)) & ~(mask__AUDCFG_FSYN_CFG__FS_EN(ip) << \
+	shift__AUDCFG_FSYN_CFG__FS_EN(ip))) | (((value) & \
+	mask__AUDCFG_FSYN_CFG__FS_EN(ip)) << \
+	shift__AUDCFG_FSYN_CFG__FS_EN(ip)), ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip))
+
+#define value__AUDCFG_FSYN_CFG__FS_EN__DISABLED(ip, n) (ip->ver < \
+	ver__AUDCFG_FSYN__65_2_1_2 ? (0 << n) : (ip->ver < \
+	ver__AUDCFG_FSYN__65_3_1 ? -1 : (ip->ver < ver__AUDCFG_FSYN__65_3_3 ? \
+	(0 << n) : -1)))
+#define mask__AUDCFG_FSYN_CFG__FS_EN__DISABLED(ip, n) \
+	(value__AUDCFG_FSYN_CFG__FS_EN__DISABLED(ip, n) << \
+	shift__AUDCFG_FSYN_CFG__FS_EN(ip))
+#define set__AUDCFG_FSYN_CFG__FS_EN__DISABLED(ip, n) \
+	set__AUDCFG_FSYN_CFG__FS_EN(ip, \
+	value__AUDCFG_FSYN_CFG__FS_EN__DISABLED(ip, n))
+
+#define value__AUDCFG_FSYN_CFG__FS_EN__ENABLED(ip, n) (ip->ver < \
+	ver__AUDCFG_FSYN__65_2_1_2 ? (1 << n) : (ip->ver < \
+	ver__AUDCFG_FSYN__65_3_1 ? -1 : (ip->ver < ver__AUDCFG_FSYN__65_3_3 ? \
+	(1 << n) : -1)))
+#define mask__AUDCFG_FSYN_CFG__FS_EN__ENABLED(ip, n) \
+	(value__AUDCFG_FSYN_CFG__FS_EN__ENABLED(ip, n) << \
+	shift__AUDCFG_FSYN_CFG__FS_EN(ip))
+#define set__AUDCFG_FSYN_CFG__FS_EN__ENABLED(ip, n) \
+	set__AUDCFG_FSYN_CFG__FS_EN(ip, \
+	value__AUDCFG_FSYN_CFG__FS_EN__ENABLED(ip, n))
+
+/* NSB */
+
+#define shift__AUDCFG_FSYN_CFG__NSB(ip) 10
+#define mask__AUDCFG_FSYN_CFG__NSB(ip) 0xf
+#define get__AUDCFG_FSYN_CFG__NSB(ip) ((readl(ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip)) >> shift__AUDCFG_FSYN_CFG__NSB(ip)) & \
+	mask__AUDCFG_FSYN_CFG__NSB(ip))
+#define set__AUDCFG_FSYN_CFG__NSB(ip, value) writel((readl(ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip)) & ~(mask__AUDCFG_FSYN_CFG__NSB(ip) << \
+	shift__AUDCFG_FSYN_CFG__NSB(ip))) | (((value) & \
+	mask__AUDCFG_FSYN_CFG__NSB(ip)) << shift__AUDCFG_FSYN_CFG__NSB(ip)), \
+	ip->base + offset__AUDCFG_FSYN_CFG(ip))
+
+#define value__AUDCFG_FSYN_CFG__NSB__STANDBY(ip, n) (0 << n)
+#define mask__AUDCFG_FSYN_CFG__NSB__STANDBY(ip, n) \
+	(value__AUDCFG_FSYN_CFG__NSB__STANDBY(ip, n) << \
+	shift__AUDCFG_FSYN_CFG__NSB(ip))
+#define set__AUDCFG_FSYN_CFG__NSB__STANDBY(ip, n) \
+	set__AUDCFG_FSYN_CFG__NSB(ip, value__AUDCFG_FSYN_CFG__NSB__STANDBY(ip, \
+	n))
+
+#define value__AUDCFG_FSYN_CFG__NSB__ACTIVE(ip, n) (1 << n)
+#define mask__AUDCFG_FSYN_CFG__NSB__ACTIVE(ip, n) \
+	(value__AUDCFG_FSYN_CFG__NSB__ACTIVE(ip, n) << \
+	shift__AUDCFG_FSYN_CFG__NSB(ip))
+#define set__AUDCFG_FSYN_CFG__NSB__ACTIVE(ip, n) \
+	set__AUDCFG_FSYN_CFG__NSB(ip, value__AUDCFG_FSYN_CFG__NSB__ACTIVE(ip, \
+	n))
+
+/* NPDA */
+
+#define shift__AUDCFG_FSYN_CFG__NPDA(ip) 14
+#define mask__AUDCFG_FSYN_CFG__NPDA(ip) 0x1
+#define get__AUDCFG_FSYN_CFG__NPDA(ip) ((readl(ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip)) >> shift__AUDCFG_FSYN_CFG__NPDA(ip)) & \
+	mask__AUDCFG_FSYN_CFG__NPDA(ip))
+#define set__AUDCFG_FSYN_CFG__NPDA(ip, value) writel((readl(ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip)) & ~(mask__AUDCFG_FSYN_CFG__NPDA(ip) << \
+	shift__AUDCFG_FSYN_CFG__NPDA(ip))) | (((value) & \
+	mask__AUDCFG_FSYN_CFG__NPDA(ip)) << shift__AUDCFG_FSYN_CFG__NPDA(ip)), \
+	ip->base + offset__AUDCFG_FSYN_CFG(ip))
+
+#define value__AUDCFG_FSYN_CFG__NPDA__POWER_DOWN(ip) 0x0
+#define mask__AUDCFG_FSYN_CFG__NPDA__POWER_DOWN(ip) \
+	(value__AUDCFG_FSYN_CFG__NPDA__POWER_DOWN(ip) << \
+	shift__AUDCFG_FSYN_CFG__NPDA(ip))
+#define set__AUDCFG_FSYN_CFG__NPDA__POWER_DOWN(ip) \
+	set__AUDCFG_FSYN_CFG__NPDA(ip, \
+	value__AUDCFG_FSYN_CFG__NPDA__POWER_DOWN(ip))
+
+#define value__AUDCFG_FSYN_CFG__NPDA__NORMAL(ip) 0x1
+#define mask__AUDCFG_FSYN_CFG__NPDA__NORMAL(ip) \
+	(value__AUDCFG_FSYN_CFG__NPDA__NORMAL(ip) << \
+	shift__AUDCFG_FSYN_CFG__NPDA(ip))
+#define set__AUDCFG_FSYN_CFG__NPDA__NORMAL(ip) \
+	set__AUDCFG_FSYN_CFG__NPDA(ip, \
+	value__AUDCFG_FSYN_CFG__NPDA__NORMAL(ip))
+
+/* NDIV */
+
+#define shift__AUDCFG_FSYN_CFG__NDIV(ip) 15
+#define mask__AUDCFG_FSYN_CFG__NDIV(ip) 0x1
+#define get__AUDCFG_FSYN_CFG__NDIV(ip) ((readl(ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip)) >> shift__AUDCFG_FSYN_CFG__NDIV(ip)) & \
+	mask__AUDCFG_FSYN_CFG__NDIV(ip))
+#define set__AUDCFG_FSYN_CFG__NDIV(ip, value) writel((readl(ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip)) & ~(mask__AUDCFG_FSYN_CFG__NDIV(ip) << \
+	shift__AUDCFG_FSYN_CFG__NDIV(ip))) | (((value) & \
+	mask__AUDCFG_FSYN_CFG__NDIV(ip)) << shift__AUDCFG_FSYN_CFG__NDIV(ip)), \
+	ip->base + offset__AUDCFG_FSYN_CFG(ip))
+
+#define value__AUDCFG_FSYN_CFG__NDIV__27_30_MHZ(ip) 0x0
+#define mask__AUDCFG_FSYN_CFG__NDIV__27_30_MHZ(ip) \
+	(value__AUDCFG_FSYN_CFG__NDIV__27_30_MHZ(ip) << \
+	shift__AUDCFG_FSYN_CFG__NDIV(ip))
+#define set__AUDCFG_FSYN_CFG__NDIV__27_30_MHZ(ip) \
+	set__AUDCFG_FSYN_CFG__NDIV(ip, \
+	value__AUDCFG_FSYN_CFG__NDIV__27_30_MHZ(ip))
+
+#define value__AUDCFG_FSYN_CFG__NDIV__54_60_MHZ(ip) 0x1
+#define mask__AUDCFG_FSYN_CFG__NDIV__54_60_MHZ(ip) \
+	(value__AUDCFG_FSYN_CFG__NDIV__54_60_MHZ(ip) << \
+	shift__AUDCFG_FSYN_CFG__NDIV(ip))
+#define set__AUDCFG_FSYN_CFG__NDIV__54_60_MHZ(ip) \
+	set__AUDCFG_FSYN_CFG__NDIV(ip, \
+	value__AUDCFG_FSYN_CFG__NDIV__54_60_MHZ(ip))
+
+/* BW_SEL */
+
+#define shift__AUDCFG_FSYN_CFG__BW_SEL(ip) 16
+#define mask__AUDCFG_FSYN_CFG__BW_SEL(ip) 0x3
+#define get__AUDCFG_FSYN_CFG__BW_SEL(ip) ((readl(ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip)) >> shift__AUDCFG_FSYN_CFG__BW_SEL(ip)) & \
+	mask__AUDCFG_FSYN_CFG__BW_SEL(ip))
+#define set__AUDCFG_FSYN_CFG__BW_SEL(ip, value) writel((readl(ip->base \
+	+ offset__AUDCFG_FSYN_CFG(ip)) & ~(mask__AUDCFG_FSYN_CFG__BW_SEL(ip) \
+	<< shift__AUDCFG_FSYN_CFG__BW_SEL(ip))) | (((value) & \
+	mask__AUDCFG_FSYN_CFG__BW_SEL(ip)) << \
+	shift__AUDCFG_FSYN_CFG__BW_SEL(ip)), ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip))
+
+#define value__AUDCFG_FSYN_CFG__BW_SEL__VERY_GOOD_REFERENCE(ip) 0x0
+#define mask__AUDCFG_FSYN_CFG__BW_SEL__VERY_GOOD_REFERENCE(ip) \
+	(value__AUDCFG_FSYN_CFG__BW_SEL__VERY_GOOD_REFERENCE(ip) << \
+	shift__AUDCFG_FSYN_CFG__BW_SEL(ip))
+#define set__AUDCFG_FSYN_CFG__BW_SEL__VERY_GOOD_REFERENCE(ip) \
+	set__AUDCFG_FSYN_CFG__BW_SEL(ip, \
+	value__AUDCFG_FSYN_CFG__BW_SEL__VERY_GOOD_REFERENCE(ip))
+
+#define value__AUDCFG_FSYN_CFG__BW_SEL__GOOD_REFERENCE(ip) 0x1
+#define mask__AUDCFG_FSYN_CFG__BW_SEL__GOOD_REFERENCE(ip) \
+	(value__AUDCFG_FSYN_CFG__BW_SEL__GOOD_REFERENCE(ip) << \
+	shift__AUDCFG_FSYN_CFG__BW_SEL(ip))
+#define set__AUDCFG_FSYN_CFG__BW_SEL__GOOD_REFERENCE(ip) \
+	set__AUDCFG_FSYN_CFG__BW_SEL(ip, \
+	value__AUDCFG_FSYN_CFG__BW_SEL__GOOD_REFERENCE(ip))
+
+#define value__AUDCFG_FSYN_CFG__BW_SEL__BAD_REFERENCE(ip) 0x2
+#define mask__AUDCFG_FSYN_CFG__BW_SEL__BAD_REFERENCE(ip) \
+	(value__AUDCFG_FSYN_CFG__BW_SEL__BAD_REFERENCE(ip) << \
+	shift__AUDCFG_FSYN_CFG__BW_SEL(ip))
+#define set__AUDCFG_FSYN_CFG__BW_SEL__BAD_REFERENCE(ip) \
+	set__AUDCFG_FSYN_CFG__BW_SEL(ip, \
+	value__AUDCFG_FSYN_CFG__BW_SEL__BAD_REFERENCE(ip))
+
+#define value__AUDCFG_FSYN_CFG__BW_SEL__VERY_BAD_REFERENCE(ip) 0x3
+#define mask__AUDCFG_FSYN_CFG__BW_SEL__VERY_BAD_REFERENCE(ip) \
+	(value__AUDCFG_FSYN_CFG__BW_SEL__VERY_BAD_REFERENCE(ip) << \
+	shift__AUDCFG_FSYN_CFG__BW_SEL(ip))
+#define set__AUDCFG_FSYN_CFG__BW_SEL__VERY_BAD_REFERENCE(ip) \
+	set__AUDCFG_FSYN_CFG__BW_SEL(ip, \
+	value__AUDCFG_FSYN_CFG__BW_SEL__VERY_BAD_REFERENCE(ip))
+
+/* REF_CLK_IN */
+
+#define shift__AUDCFG_FSYN_CFG__REF_CLK_IN(ip) (ip->ver < \
+	ver__AUDCFG_FSYN__65_2_1_2 ? 23 : (ip->ver < ver__AUDCFG_FSYN__65_3_1 \
+	? 24 : (ip->ver < ver__AUDCFG_FSYN__65_3_3 ? 23 : 24)))
+#define mask__AUDCFG_FSYN_CFG__REF_CLK_IN(ip) (ip->ver < \
+	ver__AUDCFG_FSYN__65_2_1_2 ? 0x1 : (ip->ver < ver__AUDCFG_FSYN__65_3_1 \
+	? 0x1 : (ip->ver < ver__AUDCFG_FSYN__65_3_3 ? 0x3 : 0x1)))
+#define get__AUDCFG_FSYN_CFG__REF_CLK_IN(ip) ((readl(ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip)) >> \
+	shift__AUDCFG_FSYN_CFG__REF_CLK_IN(ip)) & \
+	mask__AUDCFG_FSYN_CFG__REF_CLK_IN(ip))
+#define set__AUDCFG_FSYN_CFG__REF_CLK_IN(ip, value) \
+	writel((readl(ip->base + offset__AUDCFG_FSYN_CFG(ip)) & \
+	~(mask__AUDCFG_FSYN_CFG__REF_CLK_IN(ip) << \
+	shift__AUDCFG_FSYN_CFG__REF_CLK_IN(ip))) | (((value) & \
+	mask__AUDCFG_FSYN_CFG__REF_CLK_IN(ip)) << \
+	shift__AUDCFG_FSYN_CFG__REF_CLK_IN(ip)), ip->base + \
+	offset__AUDCFG_FSYN_CFG(ip))
+
+#define value__AUDCFG_FSYN_CFG__REF_CLK_IN__FE900_CLOCK(ip) (ip->ver < \
+	ver__AUDCFG_FSYN__65_3_1 ? -1 : (ip->ver < ver__AUDCFG_FSYN__65_3_3 ? \
+	0x0 : -1))
+#define mask__AUDCFG_FSYN_CFG__REF_CLK_IN__FE900_CLOCK(ip) \
+	(value__AUDCFG_FSYN_CFG__REF_CLK_IN__FE900_CLOCK(ip) << \
+	shift__AUDCFG_FSYN_CFG__REF_CLK_IN(ip))
+#define set__AUDCFG_FSYN_CFG__REF_CLK_IN__FE900_CLOCK(ip) \
+	set__AUDCFG_FSYN_CFG__REF_CLK_IN(ip, \
+	value__AUDCFG_FSYN_CFG__REF_CLK_IN__FE900_CLOCK(ip))
+
+#define value__AUDCFG_FSYN_CFG__REF_CLK_IN__30_MHZ_CLOCK(ip) (ip->ver \
+	< ver__AUDCFG_FSYN__65_3_1 ? 0x0 : (ip->ver < ver__AUDCFG_FSYN__65_3_3 \
+	? 0x1 : 0x0))
+#define mask__AUDCFG_FSYN_CFG__REF_CLK_IN__30_MHZ_CLOCK(ip) \
+	(value__AUDCFG_FSYN_CFG__REF_CLK_IN__30_MHZ_CLOCK(ip) << \
+	shift__AUDCFG_FSYN_CFG__REF_CLK_IN(ip))
+#define set__AUDCFG_FSYN_CFG__REF_CLK_IN__30_MHZ_CLOCK(ip) \
+	set__AUDCFG_FSYN_CFG__REF_CLK_IN(ip, \
+	value__AUDCFG_FSYN_CFG__REF_CLK_IN__30_MHZ_CLOCK(ip))
+
+#define value__AUDCFG_FSYN_CFG__REF_CLK_IN__SYSCLKINALT(ip) (ip->ver < \
+	ver__AUDCFG_FSYN__65_3_1 ? 0x1 : (ip->ver < ver__AUDCFG_FSYN__65_3_3 ? \
+	0x2 : 0x1))
+#define mask__AUDCFG_FSYN_CFG__REF_CLK_IN__SYSCLKINALT(ip) \
+	(value__AUDCFG_FSYN_CFG__REF_CLK_IN__SYSCLKINALT(ip) << \
+	shift__AUDCFG_FSYN_CFG__REF_CLK_IN(ip))
+#define set__AUDCFG_FSYN_CFG__REF_CLK_IN__SYSCLKINALT(ip) \
+	set__AUDCFG_FSYN_CFG__REF_CLK_IN(ip, \
+	value__AUDCFG_FSYN_CFG__REF_CLK_IN__SYSCLKINALT(ip))
+
+
+
+/*
+ * AUDCFG_FSYN_MD
+ */
+
+#define offset__AUDCFG_FSYN_MD(ip, n) ((n + 1) * 0x10 + 0x00)
+#define get__AUDCFG_FSYN_MD(ip, n) readl(ip->base + \
+	offset__AUDCFG_FSYN_MD(ip, n))
+#define set__AUDCFG_FSYN_MD(ip, n, value) writel(value, ip->base + \
+	offset__AUDCFG_FSYN_MD(ip, n))
+
+/* MD */
+
+#define shift__AUDCFG_FSYN_MD__MD(ip) 0
+#define mask__AUDCFG_FSYN_MD__MD(ip) 0x1f
+#define get__AUDCFG_FSYN_MD__MD(ip, n) ((readl(ip->base + \
+	offset__AUDCFG_FSYN_MD(ip, n)) >> shift__AUDCFG_FSYN_MD__MD(ip)) & \
+	mask__AUDCFG_FSYN_MD__MD(ip))
+#define set__AUDCFG_FSYN_MD__MD(ip, n, value) writel((readl(ip->base + \
+	offset__AUDCFG_FSYN_MD(ip, n)) & ~(mask__AUDCFG_FSYN_MD__MD(ip) << \
+	shift__AUDCFG_FSYN_MD__MD(ip))) | (((value) & \
+	mask__AUDCFG_FSYN_MD__MD(ip)) << shift__AUDCFG_FSYN_MD__MD(ip)), \
+	ip->base + offset__AUDCFG_FSYN_MD(ip, n))
+
+
+
+/*
+ * AUDCFG_FSYN_PE
+ */
+
+#define offset__AUDCFG_FSYN_PE(ip, n) ((n + 1) * 0x10 + 0x04)
+#define get__AUDCFG_FSYN_PE(ip, n) readl(ip->base + \
+	offset__AUDCFG_FSYN_PE(ip, n))
+#define set__AUDCFG_FSYN_PE(ip, n, value) writel(value, ip->base + \
+	offset__AUDCFG_FSYN_PE(ip, n))
+
+/* PE */
+
+#define shift__AUDCFG_FSYN_PE__PE(ip) 0
+#define mask__AUDCFG_FSYN_PE__PE(ip) 0xffff
+#define get__AUDCFG_FSYN_PE__PE(ip, n) ((readl(ip->base + \
+	offset__AUDCFG_FSYN_PE(ip, n)) >> shift__AUDCFG_FSYN_PE__PE(ip)) & \
+	mask__AUDCFG_FSYN_PE__PE(ip))
+#define set__AUDCFG_FSYN_PE__PE(ip, n, value) writel((readl(ip->base + \
+	offset__AUDCFG_FSYN_PE(ip, n)) & ~(mask__AUDCFG_FSYN_PE__PE(ip) << \
+	shift__AUDCFG_FSYN_PE__PE(ip))) | (((value) & \
+	mask__AUDCFG_FSYN_PE__PE(ip)) << shift__AUDCFG_FSYN_PE__PE(ip)), \
+	ip->base + offset__AUDCFG_FSYN_PE(ip, n))
+
+
+
+/*
+ * AUDCFG_FSYN_SDIV
+ */
+
+#define offset__AUDCFG_FSYN_SDIV(ip, n) ((n + 1) * 0x10 + 0x08)
+#define get__AUDCFG_FSYN_SDIV(ip, n) readl(ip->base + \
+	offset__AUDCFG_FSYN_SDIV(ip, n))
+#define set__AUDCFG_FSYN_SDIV(ip, n, value) writel(value, ip->base + \
+	offset__AUDCFG_FSYN_SDIV(ip, n))
+
+/* SDIV */
+
+#define shift__AUDCFG_FSYN_SDIV__SDIV(ip) 0
+#define mask__AUDCFG_FSYN_SDIV__SDIV(ip) 0x7
+#define get__AUDCFG_FSYN_SDIV__SDIV(ip, n) ((readl(ip->base + \
+	offset__AUDCFG_FSYN_SDIV(ip, n)) >> shift__AUDCFG_FSYN_SDIV__SDIV(ip)) \
+	& mask__AUDCFG_FSYN_SDIV__SDIV(ip))
+#define set__AUDCFG_FSYN_SDIV__SDIV(ip, n, value) \
+	writel((readl(ip->base + offset__AUDCFG_FSYN_SDIV(ip, n)) & \
+	~(mask__AUDCFG_FSYN_SDIV__SDIV(ip) << \
+	shift__AUDCFG_FSYN_SDIV__SDIV(ip))) | (((value) & \
+	mask__AUDCFG_FSYN_SDIV__SDIV(ip)) << \
+	shift__AUDCFG_FSYN_SDIV__SDIV(ip)), ip->base + \
+	offset__AUDCFG_FSYN_SDIV(ip, n))
+
+
+
+/*
+ * AUDCFG_FSYN_PROGEN
+ */
+
+#define offset__AUDCFG_FSYN_PROGEN(ip, n) ((n + 1) * 0x10 + 0x0c)
+#define get__AUDCFG_FSYN_PROGEN(ip, n) readl(ip->base + \
+	offset__AUDCFG_FSYN_PROGEN(ip, n))
+#define set__AUDCFG_FSYN_PROGEN(ip, n, value) writel(value, ip->base + \
+	offset__AUDCFG_FSYN_PROGEN(ip, n))
+
+/* PROG_EN */
+
+#define shift__AUDCFG_FSYN_PROGEN__PROG_EN(ip) 0
+#define mask__AUDCFG_FSYN_PROGEN__PROG_EN(ip) 0x1
+#define get__AUDCFG_FSYN_PROGEN__PROG_EN(ip, n) ((readl(ip->base + \
+	offset__AUDCFG_FSYN_PROGEN(ip, n)) >> \
+	shift__AUDCFG_FSYN_PROGEN__PROG_EN(ip)) & \
+	mask__AUDCFG_FSYN_PROGEN__PROG_EN(ip))
+#define set__AUDCFG_FSYN_PROGEN__PROG_EN(ip, n, value) \
+	writel((readl(ip->base + offset__AUDCFG_FSYN_PROGEN(ip, n)) & \
+	~(mask__AUDCFG_FSYN_PROGEN__PROG_EN(ip) << \
+	shift__AUDCFG_FSYN_PROGEN__PROG_EN(ip))) | (((value) & \
+	mask__AUDCFG_FSYN_PROGEN__PROG_EN(ip)) << \
+	shift__AUDCFG_FSYN_PROGEN__PROG_EN(ip)), ip->base + \
+	offset__AUDCFG_FSYN_PROGEN(ip, n))
+
+#define value__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_IGNORED(ip) 0x0
+#define mask__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_IGNORED(ip) \
+	(value__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_IGNORED(ip) << \
+	shift__AUDCFG_FSYN_PROGEN__PROG_EN(ip))
+#define set__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_IGNORED(ip, n) \
+	set__AUDCFG_FSYN_PROGEN__PROG_EN(ip, n, \
+	value__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_IGNORED(ip))
+
+#define value__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_USED(ip) 0x1
+#define mask__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_USED(ip) \
+	(value__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_USED(ip) << \
+	shift__AUDCFG_FSYN_PROGEN__PROG_EN(ip))
+#define set__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_USED(ip, n) \
+	set__AUDCFG_FSYN_PROGEN__PROG_EN(ip, n, \
+	value__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_USED(ip))
+
+
+
+#endif
diff -ruN stm.org/reg_aud_pcmin.h stm/reg_aud_pcmin.h
--- a/drivers/stm/reg_aud_pcmin.h	2014-06-03 12:31:04.000000000 -0700
+++ b/sound/stm/reg_aud_pcmin.h	2012-10-11 11:46:27.000000000 -0700
@@ -2,6 +2,30 @@
 #define __SND_STM_AUD_PCMIN_H
 
 /*
+ * IP versions
+ */
+
+/* 7100 2.0, 7100 3.0 */
+#define ver__AUD_PCMIN__90_1_1 1
+
+/* 7109 2.0, 7109 3.0 */
+#define ver__AUD_PCMIN__90_2_0 2
+
+/* 7200 1.0 */
+#define ver__AUD_PCMIN__65_2_0 3
+
+/* 7111 */
+#define ver__AUD_PCMIN__65_3_1 4
+
+/* 7200 2.0 */
+#define ver__AUD_PCMIN__65_3_3 5
+
+/* 7200 3.0 */
+#define ver__AUD_PCMIN__65_3_4 6
+
+
+
+/*
  * AUD_PCMIN_RST
  */
 
@@ -464,9 +488,9 @@
 /* NUM_FRAMES */
 
 #define shift__AUD_PCMIN_CTRL__NUM_FRAMES(ip) (ip->ver < \
-	4 ? 4 : -1)
+	ver__AUD_PCMIN__65_3_1 ? 4 : -1)
 #define mask__AUD_PCMIN_CTRL__NUM_FRAMES(ip) (ip->ver < \
-	4 ? 0xfffffff : -1)
+	ver__AUD_PCMIN__65_3_1 ? 0xfffffff : -1)
 #define get__AUD_PCMIN_CTRL__NUM_FRAMES(ip) ((readl(ip->base + \
 	offset__AUD_PCMIN_CTRL(ip)) >> shift__AUD_PCMIN_CTRL__NUM_FRAMES(ip)) \
 	& mask__AUD_PCMIN_CTRL__NUM_FRAMES(ip))
@@ -481,9 +505,9 @@
 /* MASTER_CLK_DIV */
 
 #define shift__AUD_PCMIN_CTRL__MASTER_CLK_DIV(ip) (ip->ver < \
-	4 ? -1 : 4)
+	ver__AUD_PCMIN__65_3_1 ? -1 : 4)
 #define mask__AUD_PCMIN_CTRL__MASTER_CLK_DIV(ip) (ip->ver < \
-	4 ? -1 : 0xf)
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0xf)
 #define get__AUD_PCMIN_CTRL__MASTER_CLK_DIV(ip) ((readl(ip->base + \
 	offset__AUD_PCMIN_CTRL(ip)) >> \
 	shift__AUD_PCMIN_CTRL__MASTER_CLK_DIV(ip)) & \
@@ -590,9 +614,9 @@
 /* NFRAMES */
 
 #define shift__AUD_PCMIN_STA__NFRAMES(ip) (ip->ver < \
-	4 ? 19 : -1)
+	ver__AUD_PCMIN__65_3_1 ? 19 : -1)
 #define mask__AUD_PCMIN_STA__NFRAMES(ip) (ip->ver < \
-	4 ? 0x1 : -1)
+	ver__AUD_PCMIN__65_3_1 ? 0x1 : -1)
 #define get__AUD_PCMIN_STA__NFRAMES(ip) ((readl(ip->base + \
 	offset__AUD_PCMIN_STA(ip)) >> shift__AUD_PCMIN_STA__NFRAMES(ip)) & \
 	mask__AUD_PCMIN_STA__NFRAMES(ip))
@@ -604,7 +628,7 @@
 	offset__AUD_PCMIN_STA(ip))
 
 #define value__AUD_PCMIN_STA__NFRAMES__DONE(ip) (ip->ver < \
-	4 ? 0x1 : -1)
+	ver__AUD_PCMIN__65_3_1 ? 0x1 : -1)
 #define mask__AUD_PCMIN_STA__NFRAMES__DONE(ip) \
 	(value__AUD_PCMIN_STA__NFRAMES__DONE(ip) << \
 	shift__AUD_PCMIN_STA__NFRAMES(ip))
@@ -615,9 +639,9 @@
 /* SAMPLES_IN_FIFO */
 
 #define shift__AUD_PCMIN_STA__SAMPLES_IN_FIFO(ip) (ip->ver < \
-	4 ? -1 : 19)
+	ver__AUD_PCMIN__65_3_1 ? -1 : 19)
 #define mask__AUD_PCMIN_STA__SAMPLES_IN_FIFO(ip) (ip->ver < \
-	4 ? -1 : 0x7f)
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x7f)
 #define get__AUD_PCMIN_STA__SAMPLES_IN_FIFO(ip) ((readl(ip->base + \
 	offset__AUD_PCMIN_STA(ip)) >> \
 	shift__AUD_PCMIN_STA__SAMPLES_IN_FIFO(ip)) & \
@@ -865,9 +889,9 @@
 /* NUM_CH */
 
 #define shift__AUD_PCMIN_FMT__NUM_CH(ip) (ip->ver < \
-	4 ? -1 : 8)
+	ver__AUD_PCMIN__65_3_1 ? -1 : 8)
 #define mask__AUD_PCMIN_FMT__NUM_CH(ip) (ip->ver < \
-	4 ? -1 : 0x7)
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x7)
 #define get__AUD_PCMIN_FMT__NUM_CH(ip) ((readl(ip->base + \
 	offset__AUD_PCMIN_FMT(ip)) >> shift__AUD_PCMIN_FMT__NUM_CH(ip)) & \
 	mask__AUD_PCMIN_FMT__NUM_CH(ip))
@@ -878,7 +902,7 @@
 	ip->base + offset__AUD_PCMIN_FMT(ip))
 
 #define value__AUD_PCMIN_FMT__NUM_CH__1_CHANNEL(ip) (ip->ver < \
-	4 ? -1 : 0x1)
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x1)
 #define mask__AUD_PCMIN_FMT__NUM_CH__1_CHANNEL(ip) \
 	(value__AUD_PCMIN_FMT__NUM_CH__1_CHANNEL(ip) << \
 	shift__AUD_PCMIN_FMT__NUM_CH(ip))
@@ -887,7 +911,7 @@
 	value__AUD_PCMIN_FMT__NUM_CH__1_CHANNEL(ip))
 
 #define value__AUD_PCMIN_FMT__NUM_CH__2_CHANNELS(ip) (ip->ver < \
-	4 ? -1 : 0x2)
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x2)
 #define mask__AUD_PCMIN_FMT__NUM_CH__2_CHANNELS(ip) \
 	(value__AUD_PCMIN_FMT__NUM_CH__2_CHANNELS(ip) << \
 	shift__AUD_PCMIN_FMT__NUM_CH(ip))
@@ -896,7 +920,7 @@
 	value__AUD_PCMIN_FMT__NUM_CH__2_CHANNELS(ip))
 
 #define value__AUD_PCMIN_FMT__NUM_CH__3_CHANNELS(ip) (ip->ver < \
-	4 ? -1 : 0x3)
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x3)
 #define mask__AUD_PCMIN_FMT__NUM_CH__3_CHANNELS(ip) \
 	(value__AUD_PCMIN_FMT__NUM_CH__3_CHANNELS(ip) << \
 	shift__AUD_PCMIN_FMT__NUM_CH(ip))
@@ -905,7 +929,7 @@
 	value__AUD_PCMIN_FMT__NUM_CH__3_CHANNELS(ip))
 
 #define value__AUD_PCMIN_FMT__NUM_CH__4_CHANNELS(ip) (ip->ver < \
-	4 ? -1 : 0x4)
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x4)
 #define mask__AUD_PCMIN_FMT__NUM_CH__4_CHANNELS(ip) \
 	(value__AUD_PCMIN_FMT__NUM_CH__4_CHANNELS(ip) << \
 	shift__AUD_PCMIN_FMT__NUM_CH(ip))
@@ -914,7 +938,7 @@
 	value__AUD_PCMIN_FMT__NUM_CH__4_CHANNELS(ip))
 
 #define value__AUD_PCMIN_FMT__NUM_CH__5_CHANNELS(ip) (ip->ver < \
-	4 ? -1 : 0x5)
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x5)
 #define mask__AUD_PCMIN_FMT__NUM_CH__5_CHANNELS(ip) \
 	(value__AUD_PCMIN_FMT__NUM_CH__5_CHANNELS(ip) << \
 	shift__AUD_PCMIN_FMT__NUM_CH(ip))
@@ -925,9 +949,9 @@
 /* BACK_STALLING */
 
 #define shift__AUD_PCMIN_FMT__BACK_STALLING(ip) (ip->ver < \
-	4 ? -1 : 11)
+	ver__AUD_PCMIN__65_3_1 ? -1 : 11)
 #define mask__AUD_PCMIN_FMT__BACK_STALLING(ip) (ip->ver < \
-	4 ? -1 : 0x1)
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x1)
 #define get__AUD_PCMIN_FMT__BACK_STALLING(ip) ((readl(ip->base + \
 	offset__AUD_PCMIN_FMT(ip)) >> shift__AUD_PCMIN_FMT__BACK_STALLING(ip)) \
 	& mask__AUD_PCMIN_FMT__BACK_STALLING(ip))
@@ -940,7 +964,7 @@
 	offset__AUD_PCMIN_FMT(ip))
 
 #define value__AUD_PCMIN_FMT__BACK_STALLING__DISABLED(ip) (ip->ver < \
-	4 ? -1 : 0x0)
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x0)
 #define mask__AUD_PCMIN_FMT__BACK_STALLING__DISABLED(ip) \
 	(value__AUD_PCMIN_FMT__BACK_STALLING__DISABLED(ip) << \
 	shift__AUD_PCMIN_FMT__BACK_STALLING(ip))
@@ -949,7 +973,7 @@
 	value__AUD_PCMIN_FMT__BACK_STALLING__DISABLED(ip))
 
 #define value__AUD_PCMIN_FMT__BACK_STALLING__ENABLED(ip) (ip->ver < \
-	4 ? -1 : 0x1)
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x1)
 #define mask__AUD_PCMIN_FMT__BACK_STALLING__ENABLED(ip) \
 	(value__AUD_PCMIN_FMT__BACK_STALLING__ENABLED(ip) << \
 	shift__AUD_PCMIN_FMT__BACK_STALLING(ip))
@@ -960,9 +984,9 @@
 /* MASTER_CLKEDGE */
 
 #define shift__AUD_PCMIN_FMT__MASTER_CLKEDGE(ip) (ip->ver < \
-	4 ? -1 : 12)
+	ver__AUD_PCMIN__65_3_1 ? -1 : 12)
 #define mask__AUD_PCMIN_FMT__MASTER_CLKEDGE(ip) (ip->ver < \
-	4 ? -1 : 0x1)
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x1)
 #define get__AUD_PCMIN_FMT__MASTER_CLKEDGE(ip) ((readl(ip->base + \
 	offset__AUD_PCMIN_FMT(ip)) >> \
 	shift__AUD_PCMIN_FMT__MASTER_CLKEDGE(ip)) & \
@@ -976,7 +1000,7 @@
 	offset__AUD_PCMIN_FMT(ip))
 
 #define value__AUD_PCMIN_FMT__MASTER_CLKEDGE__RISING(ip) (ip->ver < \
-	4 ? -1 : 0x0)
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x0)
 #define mask__AUD_PCMIN_FMT__MASTER_CLKEDGE__RISING(ip) \
 	(value__AUD_PCMIN_FMT__MASTER_CLKEDGE__RISING(ip) << \
 	shift__AUD_PCMIN_FMT__MASTER_CLKEDGE(ip))
@@ -985,7 +1009,7 @@
 	value__AUD_PCMIN_FMT__MASTER_CLKEDGE__RISING(ip))
 
 #define value__AUD_PCMIN_FMT__MASTER_CLKEDGE__FALLING(ip) (ip->ver < \
-	4 ? -1 : 0x1)
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x1)
 #define mask__AUD_PCMIN_FMT__MASTER_CLKEDGE__FALLING(ip) \
 	(value__AUD_PCMIN_FMT__MASTER_CLKEDGE__FALLING(ip) << \
 	shift__AUD_PCMIN_FMT__MASTER_CLKEDGE(ip))
@@ -996,9 +1020,9 @@
 /* DMA_REQ_TRIG_LMT */
 
 #define shift__AUD_PCMIN_FMT__DMA_REQ_TRIG_LMT(ip) (ip->ver < \
-	4 ? -1 : 13)
+	ver__AUD_PCMIN__65_3_1 ? -1 : 13)
 #define mask__AUD_PCMIN_FMT__DMA_REQ_TRIG_LMT(ip) (ip->ver < \
-	4 ? -1 : 0x7f)
+	ver__AUD_PCMIN__65_3_1 ? -1 : 0x7f)
 #define get__AUD_PCMIN_FMT__DMA_REQ_TRIG_LMT(ip) ((readl(ip->base + \
 	offset__AUD_PCMIN_FMT(ip)) >> \
 	shift__AUD_PCMIN_FMT__DMA_REQ_TRIG_LMT(ip)) & \
diff -ruN stm.org/reg_aud_pcmout.h stm/reg_aud_pcmout.h
--- a/drivers/stm/reg_aud_pcmout.h	2014-06-03 12:31:04.000000000 -0700
+++ b/sound/stm/reg_aud_pcmout.h	2012-10-11 11:46:27.000000000 -0700
@@ -2,6 +2,30 @@
 #define __SND_STM_AUD_PCMOUT_H
 
 /*
+ * IP versions
+ */
+
+/* 7100 2.0 */
+#define ver__AUD_PCMOUT__90_1_1 1
+
+/* 7100 3.0 */
+#define ver__AUD_PCMOUT__90_1_3 2
+
+/* 7109 2.0 */
+#define ver__AUD_PCMOUT__90_2_0 3
+
+/* 7109 3.0 */
+#define ver__AUD_PCMOUT__90_2_1 4
+
+/* 7200 1.0 */
+#define ver__AUD_PCMOUT__65_1_3 5
+
+/* 7111, 7200 2.0 */
+#define ver__AUD_PCMOUT__65_2_2 6
+
+
+
+/*
  * AUD_PCMOUT_RST
  */
 
@@ -674,7 +698,7 @@
 
 #define shift__AUD_PCMOUT_FMT__DATA_SIZE(ip) 1
 #define mask__AUD_PCMOUT_FMT__DATA_SIZE(ip) (ip->ver < \
-	6 ? 0x3 : 0x7)
+	ver__AUD_PCMOUT__65_2_2 ? 0x3 : 0x7)
 #define get__AUD_PCMOUT_FMT__DATA_SIZE(ip) ((readl(ip->base + \
 	offset__AUD_PCMOUT_FMT(ip)) >> shift__AUD_PCMOUT_FMT__DATA_SIZE(ip)) & \
 	mask__AUD_PCMOUT_FMT__DATA_SIZE(ip))
@@ -687,7 +711,7 @@
 	offset__AUD_PCMOUT_FMT(ip))
 
 #define value__AUD_PCMOUT_FMT__DATA_SIZE__16_BITS(ip) (ip->ver < \
-	6 ? 0x3 : 0x0)
+	ver__AUD_PCMOUT__65_2_2 ? 0x3 : 0x0)
 #define mask__AUD_PCMOUT_FMT__DATA_SIZE__16_BITS(ip) \
 	(value__AUD_PCMOUT_FMT__DATA_SIZE__16_BITS(ip) << \
 	shift__AUD_PCMOUT_FMT__DATA_SIZE(ip))
@@ -696,7 +720,7 @@
 	value__AUD_PCMOUT_FMT__DATA_SIZE__16_BITS(ip))
 
 #define value__AUD_PCMOUT_FMT__DATA_SIZE__18_BITS(ip) (ip->ver < \
-	6 ? 0x2 : 0x1)
+	ver__AUD_PCMOUT__65_2_2 ? 0x2 : 0x1)
 #define mask__AUD_PCMOUT_FMT__DATA_SIZE__18_BITS(ip) \
 	(value__AUD_PCMOUT_FMT__DATA_SIZE__18_BITS(ip) << \
 	shift__AUD_PCMOUT_FMT__DATA_SIZE(ip))
@@ -705,7 +729,7 @@
 	value__AUD_PCMOUT_FMT__DATA_SIZE__18_BITS(ip))
 
 #define value__AUD_PCMOUT_FMT__DATA_SIZE__20_BITS(ip) (ip->ver < \
-	6 ? 0x1 : 0x2)
+	ver__AUD_PCMOUT__65_2_2 ? 0x1 : 0x2)
 #define mask__AUD_PCMOUT_FMT__DATA_SIZE__20_BITS(ip) \
 	(value__AUD_PCMOUT_FMT__DATA_SIZE__20_BITS(ip) << \
 	shift__AUD_PCMOUT_FMT__DATA_SIZE(ip))
@@ -714,7 +738,7 @@
 	value__AUD_PCMOUT_FMT__DATA_SIZE__20_BITS(ip))
 
 #define value__AUD_PCMOUT_FMT__DATA_SIZE__24_BITS(ip) (ip->ver < \
-	6 ? 0x0 : 0x3)
+	ver__AUD_PCMOUT__65_2_2 ? 0x0 : 0x3)
 #define mask__AUD_PCMOUT_FMT__DATA_SIZE__24_BITS(ip) \
 	(value__AUD_PCMOUT_FMT__DATA_SIZE__24_BITS(ip) << \
 	shift__AUD_PCMOUT_FMT__DATA_SIZE(ip))
@@ -723,7 +747,7 @@
 	value__AUD_PCMOUT_FMT__DATA_SIZE__24_BITS(ip))
 
 #define value__AUD_PCMOUT_FMT__DATA_SIZE__28_BITS(ip) (ip->ver < \
-	6 ? -1 : 0x4)
+	ver__AUD_PCMOUT__65_2_2 ? -1 : 0x4)
 #define mask__AUD_PCMOUT_FMT__DATA_SIZE__28_BITS(ip) \
 	(value__AUD_PCMOUT_FMT__DATA_SIZE__28_BITS(ip) << \
 	shift__AUD_PCMOUT_FMT__DATA_SIZE(ip))
@@ -732,7 +756,7 @@
 	value__AUD_PCMOUT_FMT__DATA_SIZE__28_BITS(ip))
 
 #define value__AUD_PCMOUT_FMT__DATA_SIZE__32_BITS(ip) (ip->ver < \
-	6 ? -1 : 0x5)
+	ver__AUD_PCMOUT__65_2_2 ? -1 : 0x5)
 #define mask__AUD_PCMOUT_FMT__DATA_SIZE__32_BITS(ip) \
 	(value__AUD_PCMOUT_FMT__DATA_SIZE__32_BITS(ip) << \
 	shift__AUD_PCMOUT_FMT__DATA_SIZE(ip))
@@ -743,7 +767,7 @@
 /* LR_POL */
 
 #define shift__AUD_PCMOUT_FMT__LR_POL(ip) (ip->ver < \
-	6 ? 3 : 4)
+	ver__AUD_PCMOUT__65_2_2 ? 3 : 4)
 #define mask__AUD_PCMOUT_FMT__LR_POL(ip) 0x1
 #define get__AUD_PCMOUT_FMT__LR_POL(ip) ((readl(ip->base + \
 	offset__AUD_PCMOUT_FMT(ip)) >> shift__AUD_PCMOUT_FMT__LR_POL(ip)) & \
@@ -774,7 +798,7 @@
 /* SCLK_EDGE */
 
 #define shift__AUD_PCMOUT_FMT__SCLK_EDGE(ip) (ip->ver < \
-	6 ? 4 : 5)
+	ver__AUD_PCMOUT__65_2_2 ? 4 : 5)
 #define mask__AUD_PCMOUT_FMT__SCLK_EDGE(ip) 0x1
 #define get__AUD_PCMOUT_FMT__SCLK_EDGE(ip) ((readl(ip->base + \
 	offset__AUD_PCMOUT_FMT(ip)) >> shift__AUD_PCMOUT_FMT__SCLK_EDGE(ip)) & \
@@ -788,7 +812,7 @@
 	offset__AUD_PCMOUT_FMT(ip))
 
 #define value__AUD_PCMOUT_FMT__SCLK_EDGE__RISING(ip) (ip->ver < \
-	4 ? 0x1 : 0x0)
+	ver__AUD_PCMOUT__90_2_1 ? 0x1 : 0x0)
 #define mask__AUD_PCMOUT_FMT__SCLK_EDGE__RISING(ip) \
 	(value__AUD_PCMOUT_FMT__SCLK_EDGE__RISING(ip) << \
 	shift__AUD_PCMOUT_FMT__SCLK_EDGE(ip))
@@ -797,7 +821,7 @@
 	value__AUD_PCMOUT_FMT__SCLK_EDGE__RISING(ip))
 
 #define value__AUD_PCMOUT_FMT__SCLK_EDGE__FALLING(ip) (ip->ver < \
-	4 ? 0x0 : 0x1)
+	ver__AUD_PCMOUT__90_2_1 ? 0x0 : 0x1)
 #define mask__AUD_PCMOUT_FMT__SCLK_EDGE__FALLING(ip) \
 	(value__AUD_PCMOUT_FMT__SCLK_EDGE__FALLING(ip) << \
 	shift__AUD_PCMOUT_FMT__SCLK_EDGE(ip))
@@ -808,7 +832,7 @@
 /* PADDING */
 
 #define shift__AUD_PCMOUT_FMT__PADDING(ip) (ip->ver < \
-	6 ? 5 : 6)
+	ver__AUD_PCMOUT__65_2_2 ? 5 : 6)
 #define mask__AUD_PCMOUT_FMT__PADDING(ip) 0x1
 #define get__AUD_PCMOUT_FMT__PADDING(ip) ((readl(ip->base + \
 	offset__AUD_PCMOUT_FMT(ip)) >> shift__AUD_PCMOUT_FMT__PADDING(ip)) & \
@@ -839,7 +863,7 @@
 /* ALIGN */
 
 #define shift__AUD_PCMOUT_FMT__ALIGN(ip) (ip->ver < \
-	6 ? 6 : 7)
+	ver__AUD_PCMOUT__65_2_2 ? 6 : 7)
 #define mask__AUD_PCMOUT_FMT__ALIGN(ip) 0x1
 #define get__AUD_PCMOUT_FMT__ALIGN(ip) ((readl(ip->base + \
 	offset__AUD_PCMOUT_FMT(ip)) >> shift__AUD_PCMOUT_FMT__ALIGN(ip)) & \
@@ -868,7 +892,7 @@
 /* ORDER */
 
 #define shift__AUD_PCMOUT_FMT__ORDER(ip) (ip->ver < \
-	6 ? 7 : 8)
+	ver__AUD_PCMOUT__65_2_2 ? 7 : 8)
 #define mask__AUD_PCMOUT_FMT__ORDER(ip) 0x1
 #define get__AUD_PCMOUT_FMT__ORDER(ip) ((readl(ip->base + \
 	offset__AUD_PCMOUT_FMT(ip)) >> shift__AUD_PCMOUT_FMT__ORDER(ip)) & \
@@ -898,7 +922,7 @@
 /* NUM_CH */
 
 #define shift__AUD_PCMOUT_FMT__NUM_CH(ip) (ip->ver < \
-	6 ? 8 : 9)
+	ver__AUD_PCMOUT__65_2_2 ? 8 : 9)
 #define mask__AUD_PCMOUT_FMT__NUM_CH(ip) 0x7
 #define get__AUD_PCMOUT_FMT__NUM_CH(ip) ((readl(ip->base + \
 	offset__AUD_PCMOUT_FMT(ip)) >> shift__AUD_PCMOUT_FMT__NUM_CH(ip)) & \
@@ -911,7 +935,7 @@
 	offset__AUD_PCMOUT_FMT(ip))
 
 #define value__AUD_PCMOUT_FMT__NUM_CH__1_CHANNEL(ip) (ip->ver < \
-	2 ? -1 : 0x1)
+	ver__AUD_PCMOUT__90_1_3 ? -1 : 0x1)
 #define mask__AUD_PCMOUT_FMT__NUM_CH__1_CHANNEL(ip) \
 	(value__AUD_PCMOUT_FMT__NUM_CH__1_CHANNEL(ip) << \
 	shift__AUD_PCMOUT_FMT__NUM_CH(ip))
@@ -920,7 +944,7 @@
 	value__AUD_PCMOUT_FMT__NUM_CH__1_CHANNEL(ip))
 
 #define value__AUD_PCMOUT_FMT__NUM_CH__2_CHANNELS(ip) (ip->ver < \
-	2 ? -1 : 0x2)
+	ver__AUD_PCMOUT__90_1_3 ? -1 : 0x2)
 #define mask__AUD_PCMOUT_FMT__NUM_CH__2_CHANNELS(ip) \
 	(value__AUD_PCMOUT_FMT__NUM_CH__2_CHANNELS(ip) << \
 	shift__AUD_PCMOUT_FMT__NUM_CH(ip))
@@ -929,7 +953,7 @@
 	value__AUD_PCMOUT_FMT__NUM_CH__2_CHANNELS(ip))
 
 #define value__AUD_PCMOUT_FMT__NUM_CH__3_CHANNELS(ip) (ip->ver < \
-	2 ? -1 : 0x3)
+	ver__AUD_PCMOUT__90_1_3 ? -1 : 0x3)
 #define mask__AUD_PCMOUT_FMT__NUM_CH__3_CHANNELS(ip) \
 	(value__AUD_PCMOUT_FMT__NUM_CH__3_CHANNELS(ip) << \
 	shift__AUD_PCMOUT_FMT__NUM_CH(ip))
@@ -938,7 +962,7 @@
 	value__AUD_PCMOUT_FMT__NUM_CH__3_CHANNELS(ip))
 
 #define value__AUD_PCMOUT_FMT__NUM_CH__4_CHANNELS(ip) (ip->ver < \
-	2 ? -1 : 0x4)
+	ver__AUD_PCMOUT__90_1_3 ? -1 : 0x4)
 #define mask__AUD_PCMOUT_FMT__NUM_CH__4_CHANNELS(ip) \
 	(value__AUD_PCMOUT_FMT__NUM_CH__4_CHANNELS(ip) << \
 	shift__AUD_PCMOUT_FMT__NUM_CH(ip))
@@ -947,7 +971,7 @@
 	value__AUD_PCMOUT_FMT__NUM_CH__4_CHANNELS(ip))
 
 #define value__AUD_PCMOUT_FMT__NUM_CH__5_CHANNELS(ip) (ip->ver < \
-	2 ? 0x5 : 0x5)
+	ver__AUD_PCMOUT__90_1_3 ? 0x5 : 0x5)
 #define mask__AUD_PCMOUT_FMT__NUM_CH__5_CHANNELS(ip) \
 	(value__AUD_PCMOUT_FMT__NUM_CH__5_CHANNELS(ip) << \
 	shift__AUD_PCMOUT_FMT__NUM_CH(ip))
@@ -958,9 +982,9 @@
 /* BACK_STALLING */
 
 #define shift__AUD_PCMOUT_FMT__BACK_STALLING(ip) (ip->ver < \
-	6 ? -1 : 12)
+	ver__AUD_PCMOUT__65_2_2 ? -1 : 12)
 #define mask__AUD_PCMOUT_FMT__BACK_STALLING(ip) (ip->ver < \
-	6 ? -1 : 0x1)
+	ver__AUD_PCMOUT__65_2_2 ? -1 : 0x1)
 #define get__AUD_PCMOUT_FMT__BACK_STALLING(ip) ((readl(ip->base + \
 	offset__AUD_PCMOUT_FMT(ip)) >> \
 	shift__AUD_PCMOUT_FMT__BACK_STALLING(ip)) & \
@@ -974,7 +998,7 @@
 	offset__AUD_PCMOUT_FMT(ip))
 
 #define value__AUD_PCMOUT_FMT__BACK_STALLING__DISABLED(ip) (ip->ver < \
-	6 ? -1 : 0x0)
+	ver__AUD_PCMOUT__65_2_2 ? -1 : 0x0)
 #define mask__AUD_PCMOUT_FMT__BACK_STALLING__DISABLED(ip) \
 	(value__AUD_PCMOUT_FMT__BACK_STALLING__DISABLED(ip) << \
 	shift__AUD_PCMOUT_FMT__BACK_STALLING(ip))
@@ -983,7 +1007,7 @@
 	value__AUD_PCMOUT_FMT__BACK_STALLING__DISABLED(ip))
 
 #define value__AUD_PCMOUT_FMT__BACK_STALLING__ENABLED(ip) (ip->ver < \
-	6 ? -1 : 0x1)
+	ver__AUD_PCMOUT__65_2_2 ? -1 : 0x1)
 #define mask__AUD_PCMOUT_FMT__BACK_STALLING__ENABLED(ip) \
 	(value__AUD_PCMOUT_FMT__BACK_STALLING__ENABLED(ip) << \
 	shift__AUD_PCMOUT_FMT__BACK_STALLING(ip))
@@ -994,9 +1018,9 @@
 /* DMA_REQ_TRIG_LMT */
 
 #define shift__AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT(ip) (ip->ver < \
-	6 ? 11 : 13)
+	ver__AUD_PCMOUT__65_2_2 ? 11 : 13)
 #define mask__AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT(ip) (ip->ver < \
-	6 ? 0x1f : 0x7f)
+	ver__AUD_PCMOUT__65_2_2 ? 0x1f : 0x7f)
 #define get__AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT(ip) ((readl(ip->base + \
 	offset__AUD_PCMOUT_FMT(ip)) >> \
 	shift__AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT(ip)) & \
diff -ruN stm.org/reg_aud_spdif.h stm/reg_aud_spdif.h
--- a/drivers/stm/reg_aud_spdif.h	2014-06-03 12:31:04.000000000 -0700
+++ b/sound/stm/reg_aud_spdif.h	2012-10-11 11:46:27.000000000 -0700
@@ -2,6 +2,24 @@
 #define __SND_STM_AUD_SPDIF_H
 
 /*
+ * IP versions
+ */
+
+/* 7100 2.0, 7100 3.0 */
+#define ver__AUD_SPDIF__90_1_1 1
+
+/* 7109 2.0, 7109 3.0 */
+#define ver__AUD_SPDIF__90_2_2 2
+
+/* 7200 1.0 */
+#define ver__AUD_SPDIF__65_2_0 3
+
+/* 7111, 7200 2.0 */
+#define ver__AUD_SPDIF__65_3_1 4
+
+
+
+/*
  * AUD_SPDIF_RST
  */
 
@@ -1251,9 +1269,9 @@
 /* SAMPLES_IN_FIFO */
 
 #define shift__AUD_SPDIF_STA__SAMPLES_IN_FIFO(ip) (ip->ver < \
-	4 ? -1 : 16)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 16)
 #define mask__AUD_SPDIF_STA__SAMPLES_IN_FIFO(ip) (ip->ver < \
-	4 ? -1 : 0x1f)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1f)
 #define get__AUD_SPDIF_STA__SAMPLES_IN_FIFO(ip) ((readl(ip->base + \
 	offset__AUD_SPDIF_STA(ip)) >> \
 	shift__AUD_SPDIF_STA__SAMPLES_IN_FIFO(ip)) & \
@@ -1590,7 +1608,7 @@
  * AUD_SPDIF_CONFIG
  */
 
-#define offset__AUD_SPDIF_CONFIG(ip) (ip->ver < 4 \
+#define offset__AUD_SPDIF_CONFIG(ip) (ip->ver < ver__AUD_SPDIF__65_3_1 \
 	? -1 : 0x40)
 #define get__AUD_SPDIF_CONFIG(ip) readl(ip->base + \
 	offset__AUD_SPDIF_CONFIG(ip))
@@ -1600,10 +1618,10 @@
 /* P_BIT */
 
 #define shift__AUD_SPDIF_CONFIG__P_BIT(ip) (ip->ver < \
-	4 ? -1 : 0)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0)
 
 #define value__AUD_SPDIF_CONFIG__P_BIT__MASK(ip) (ip->ver < \
-	4 ? -1 : 0x1)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
 #define mask__AUD_SPDIF_CONFIG__P_BIT__MASK(ip) \
 	(value__AUD_SPDIF_CONFIG__P_BIT__MASK(ip) << \
 	shift__AUD_SPDIF_CONFIG__P_BIT(ip))
@@ -1612,7 +1630,7 @@
 	value__AUD_SPDIF_CONFIG__P_BIT__MASK(ip))
 
 #define value__AUD_SPDIF_CONFIG__P_BIT__HW(ip) (ip->ver < \
-	4 ? -1 : 0x0)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x0)
 #define mask__AUD_SPDIF_CONFIG__P_BIT__HW(ip) \
 	(value__AUD_SPDIF_CONFIG__P_BIT__HW(ip) << \
 	shift__AUD_SPDIF_CONFIG__P_BIT(ip))
@@ -1621,7 +1639,7 @@
 	value__AUD_SPDIF_CONFIG__P_BIT__HW(ip))
 
 #define value__AUD_SPDIF_CONFIG__P_BIT__FDMA(ip) (ip->ver < \
-	4 ? -1 : 0x1)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
 #define mask__AUD_SPDIF_CONFIG__P_BIT__FDMA(ip) \
 	(value__AUD_SPDIF_CONFIG__P_BIT__FDMA(ip) << \
 	shift__AUD_SPDIF_CONFIG__P_BIT(ip))
@@ -1632,10 +1650,10 @@
 /* C_BIT */
 
 #define shift__AUD_SPDIF_CONFIG__C_BIT(ip) (ip->ver < \
-	4 ? -1 : 1)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 1)
 
 #define value__AUD_SPDIF_CONFIG__C_BIT__MASK(ip) (ip->ver < \
-	4 ? -1 : 0x1)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
 #define mask__AUD_SPDIF_CONFIG__C_BIT__MASK(ip) \
 	(value__AUD_SPDIF_CONFIG__C_BIT__MASK(ip) << \
 	shift__AUD_SPDIF_CONFIG__C_BIT(ip))
@@ -1644,7 +1662,7 @@
 	value__AUD_SPDIF_CONFIG__C_BIT__MASK(ip))
 
 #define value__AUD_SPDIF_CONFIG__C_BIT__FDMA(ip) (ip->ver < \
-	4 ? -1 : 0x0)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x0)
 #define mask__AUD_SPDIF_CONFIG__C_BIT__FDMA(ip) \
 	(value__AUD_SPDIF_CONFIG__C_BIT__FDMA(ip) << \
 	shift__AUD_SPDIF_CONFIG__C_BIT(ip))
@@ -1653,7 +1671,7 @@
 	value__AUD_SPDIF_CONFIG__C_BIT__FDMA(ip))
 
 #define value__AUD_SPDIF_CONFIG__C_BIT__HW(ip) (ip->ver < \
-	4 ? -1 : 0x1)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
 #define mask__AUD_SPDIF_CONFIG__C_BIT__HW(ip) \
 	(value__AUD_SPDIF_CONFIG__C_BIT__HW(ip) << \
 	shift__AUD_SPDIF_CONFIG__C_BIT(ip))
@@ -1664,10 +1682,10 @@
 /* U_BIT */
 
 #define shift__AUD_SPDIF_CONFIG__U_BIT(ip) (ip->ver < \
-	4 ? -1 : 2)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 2)
 
 #define value__AUD_SPDIF_CONFIG__U_BIT__MASK(ip) (ip->ver < \
-	4 ? -1 : 0x1)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
 #define mask__AUD_SPDIF_CONFIG__U_BIT__MASK(ip) \
 	(value__AUD_SPDIF_CONFIG__U_BIT__MASK(ip) << \
 	shift__AUD_SPDIF_CONFIG__U_BIT(ip))
@@ -1676,7 +1694,7 @@
 	value__AUD_SPDIF_CONFIG__U_BIT__MASK(ip))
 
 #define value__AUD_SPDIF_CONFIG__U_BIT__FDMA(ip) (ip->ver < \
-	4 ? -1 : 0x0)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x0)
 #define mask__AUD_SPDIF_CONFIG__U_BIT__FDMA(ip) \
 	(value__AUD_SPDIF_CONFIG__U_BIT__FDMA(ip) << \
 	shift__AUD_SPDIF_CONFIG__U_BIT(ip))
@@ -1685,7 +1703,7 @@
 	value__AUD_SPDIF_CONFIG__U_BIT__FDMA(ip))
 
 #define value__AUD_SPDIF_CONFIG__U_BIT__HW(ip) (ip->ver < \
-	4 ? -1 : 0x1)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
 #define mask__AUD_SPDIF_CONFIG__U_BIT__HW(ip) \
 	(value__AUD_SPDIF_CONFIG__U_BIT__HW(ip) << \
 	shift__AUD_SPDIF_CONFIG__U_BIT(ip))
@@ -1696,10 +1714,10 @@
 /* V_BIT */
 
 #define shift__AUD_SPDIF_CONFIG__V_BIT(ip) (ip->ver < \
-	4 ? -1 : 2)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 2)
 
 #define value__AUD_SPDIF_CONFIG__V_BIT__MASK(ip) (ip->ver < \
-	4 ? -1 : 0x1)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
 #define mask__AUD_SPDIF_CONFIG__V_BIT__MASK(ip) \
 	(value__AUD_SPDIF_CONFIG__V_BIT__MASK(ip) << \
 	shift__AUD_SPDIF_CONFIG__V_BIT(ip))
@@ -1708,7 +1726,7 @@
 	value__AUD_SPDIF_CONFIG__V_BIT__MASK(ip))
 
 #define value__AUD_SPDIF_CONFIG__V_BIT__FDMA(ip) (ip->ver < \
-	4 ? -1 : 0x0)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x0)
 #define mask__AUD_SPDIF_CONFIG__V_BIT__FDMA(ip) \
 	(value__AUD_SPDIF_CONFIG__V_BIT__FDMA(ip) << \
 	shift__AUD_SPDIF_CONFIG__V_BIT(ip))
@@ -1717,7 +1735,7 @@
 	value__AUD_SPDIF_CONFIG__V_BIT__FDMA(ip))
 
 #define value__AUD_SPDIF_CONFIG__V_BIT__HW(ip) (ip->ver < \
-	4 ? -1 : 0x1)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
 #define mask__AUD_SPDIF_CONFIG__V_BIT__HW(ip) \
 	(value__AUD_SPDIF_CONFIG__V_BIT__HW(ip) << \
 	shift__AUD_SPDIF_CONFIG__V_BIT(ip))
@@ -1728,9 +1746,9 @@
 /* ONE_BIT_AUDIO */
 
 #define shift__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO(ip) (ip->ver < \
-	4 ? -1 : 4)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 4)
 #define mask__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO(ip) (ip->ver < \
-	4 ? -1 : 0x1)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
 #define get__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO(ip) ((readl(ip->base + \
 	offset__AUD_SPDIF_CONFIG(ip)) >> \
 	shift__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO(ip)) & \
@@ -1744,7 +1762,7 @@
 	offset__AUD_SPDIF_CONFIG(ip))
 
 #define value__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__DISABLED(ip) (ip->ver \
-	< 4 ? -1 : 0x0)
+	< ver__AUD_SPDIF__65_3_1 ? -1 : 0x0)
 #define mask__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__DISABLED(ip) \
 	(value__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__DISABLED(ip) << \
 	shift__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO(ip))
@@ -1753,7 +1771,7 @@
 	value__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__DISABLED(ip))
 
 #define value__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__ENABLED(ip) (ip->ver < \
-	4 ? -1 : 0x1)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
 #define mask__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__ENABLED(ip) \
 	(value__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__ENABLED(ip) << \
 	shift__AUD_SPDIF_CONFIG__ONE_BIT_AUDIO(ip))
@@ -1764,9 +1782,9 @@
 /* MEM_FMT */
 
 #define shift__AUD_SPDIF_CONFIG__MEM_FMT(ip) (ip->ver < \
-	4 ? -1 : 5)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 5)
 #define mask__AUD_SPDIF_CONFIG__MEM_FMT(ip) (ip->ver < \
-	4 ? -1 : 0x1)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
 #define get__AUD_SPDIF_CONFIG__MEM_FMT(ip) ((readl(ip->base + \
 	offset__AUD_SPDIF_CONFIG(ip)) >> shift__AUD_SPDIF_CONFIG__MEM_FMT(ip)) \
 	& mask__AUD_SPDIF_CONFIG__MEM_FMT(ip))
@@ -1779,7 +1797,7 @@
 	offset__AUD_SPDIF_CONFIG(ip))
 
 #define value__AUD_SPDIF_CONFIG__MEM_FMT__16_BITS_0_BITS(ip) (ip->ver \
-	< 4 ? -1 : 0x0)
+	< ver__AUD_SPDIF__65_3_1 ? -1 : 0x0)
 #define mask__AUD_SPDIF_CONFIG__MEM_FMT__16_BITS_0_BITS(ip) \
 	(value__AUD_SPDIF_CONFIG__MEM_FMT__16_BITS_0_BITS(ip) << \
 	shift__AUD_SPDIF_CONFIG__MEM_FMT(ip))
@@ -1788,7 +1806,7 @@
 	value__AUD_SPDIF_CONFIG__MEM_FMT__16_BITS_0_BITS(ip))
 
 #define value__AUD_SPDIF_CONFIG__MEM_FMT__16_BITS_16_BITS(ip) (ip->ver \
-	< 4 ? -1 : 0x1)
+	< ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
 #define mask__AUD_SPDIF_CONFIG__MEM_FMT__16_BITS_16_BITS(ip) \
 	(value__AUD_SPDIF_CONFIG__MEM_FMT__16_BITS_16_BITS(ip) << \
 	shift__AUD_SPDIF_CONFIG__MEM_FMT(ip))
@@ -1799,9 +1817,9 @@
 /* DTS_HD */
 
 #define shift__AUD_SPDIF_CONFIG__DTS_HD(ip) (ip->ver < \
-	4 ? -1 : 6)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 6)
 #define mask__AUD_SPDIF_CONFIG__DTS_HD(ip) (ip->ver < \
-	4 ? -1 : 0x1)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
 #define get__AUD_SPDIF_CONFIG__DTS_HD(ip) ((readl(ip->base + \
 	offset__AUD_SPDIF_CONFIG(ip)) >> shift__AUD_SPDIF_CONFIG__DTS_HD(ip)) \
 	& mask__AUD_SPDIF_CONFIG__DTS_HD(ip))
@@ -1814,7 +1832,7 @@
 	offset__AUD_SPDIF_CONFIG(ip))
 
 #define value__AUD_SPDIF_CONFIG__DTS_HD__DISABLED(ip) (ip->ver < \
-	4 ? -1 : 0x0)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x0)
 #define mask__AUD_SPDIF_CONFIG__DTS_HD__DISABLED(ip) \
 	(value__AUD_SPDIF_CONFIG__DTS_HD__DISABLED(ip) << \
 	shift__AUD_SPDIF_CONFIG__DTS_HD(ip))
@@ -1823,7 +1841,7 @@
 	value__AUD_SPDIF_CONFIG__DTS_HD__DISABLED(ip))
 
 #define value__AUD_SPDIF_CONFIG__DTS_HD__ENABLED(ip) (ip->ver < \
-	4 ? -1 : 0x1)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
 #define mask__AUD_SPDIF_CONFIG__DTS_HD__ENABLED(ip) \
 	(value__AUD_SPDIF_CONFIG__DTS_HD__ENABLED(ip) << \
 	shift__AUD_SPDIF_CONFIG__DTS_HD(ip))
@@ -1834,9 +1852,9 @@
 /* BACK_STALLING */
 
 #define shift__AUD_SPDIF_CONFIG__BACK_STALLING(ip) (ip->ver < \
-	4 ? -1 : 7)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 7)
 #define mask__AUD_SPDIF_CONFIG__BACK_STALLING(ip) (ip->ver < \
-	4 ? -1 : 0x1)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
 #define get__AUD_SPDIF_CONFIG__BACK_STALLING(ip) ((readl(ip->base + \
 	offset__AUD_SPDIF_CONFIG(ip)) >> \
 	shift__AUD_SPDIF_CONFIG__BACK_STALLING(ip)) & \
@@ -1850,7 +1868,7 @@
 	offset__AUD_SPDIF_CONFIG(ip))
 
 #define value__AUD_SPDIF_CONFIG__BACK_STALLING__DISABLED(ip) (ip->ver \
-	< 4 ? -1 : 0x0)
+	< ver__AUD_SPDIF__65_3_1 ? -1 : 0x0)
 #define mask__AUD_SPDIF_CONFIG__BACK_STALLING__DISABLED(ip) \
 	(value__AUD_SPDIF_CONFIG__BACK_STALLING__DISABLED(ip) << \
 	shift__AUD_SPDIF_CONFIG__BACK_STALLING(ip))
@@ -1859,7 +1877,7 @@
 	value__AUD_SPDIF_CONFIG__BACK_STALLING__DISABLED(ip))
 
 #define value__AUD_SPDIF_CONFIG__BACK_STALLING__ENABLED(ip) (ip->ver < \
-	4 ? -1 : 0x1)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1)
 #define mask__AUD_SPDIF_CONFIG__BACK_STALLING__ENABLED(ip) \
 	(value__AUD_SPDIF_CONFIG__BACK_STALLING__ENABLED(ip) << \
 	shift__AUD_SPDIF_CONFIG__BACK_STALLING(ip))
@@ -1870,9 +1888,9 @@
 /* DMA_REQ_TRIG_LMT */
 
 #define shift__AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT(ip) (ip->ver < \
-	4 ? -1 : 8)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 8)
 #define mask__AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT(ip) (ip->ver < \
-	4 ? -1 : 0x1f)
+	ver__AUD_SPDIF__65_3_1 ? -1 : 0x1f)
 #define get__AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT(ip) ((readl(ip->base + \
 	offset__AUD_SPDIF_CONFIG(ip)) >> \
 	shift__AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT(ip)) & \
diff -ruN stm.org/reg_aud_spdifpc.h stm/reg_aud_spdifpc.h
--- a/drivers/stm/reg_aud_spdifpc.h	2014-06-03 12:31:04.000000000 -0700
+++ b/sound/stm/reg_aud_spdifpc.h	2012-10-11 11:46:27.000000000 -0700
@@ -2,6 +2,24 @@
 #define __SND_STM_AUD_SPDIFPC_H
 
 /*
+ * IP versions
+ */
+
+/* 7100 2.0, 7100 3.0 */
+#define ver__AUD_SPDIFPC__90_1_0 1
+
+/* 7109 2.0, 7109 3.0 */
+#define ver__AUD_SPDIFPC__90_1_1 2
+
+/* 7200 1.0 */
+#define ver__AUD_SPDIFPC__65_1_2 3
+
+/* 7111, 7200 2.0 */
+#define ver__AUD_SPDIFPC__65_3_0 4
+
+
+
+/*
  * AUD_SPDIFPC_CFG
  */
 
@@ -177,21 +195,11 @@
 	value__AUD_SPDIFPC_CFG__REQ_ACK_EN__ENABLED(ip))
 
 /* CHA_STA_BITS */
-#define shift__AUD_SPDIFPC_CFG__CHL_STS_UPDATE_CLR(ip) 9
-#define mask__AUD_SPDIFPC_CFG__CHL_STS_UPDATE_CLR(ip) 0x1
-
-#define set__AUD_SPDIFPC_CFG__CHL_STS_UPDATE_CLR(ip, value) \
-	writel((readl(ip->base + offset__AUD_SPDIFPC_CFG(ip)) & \
-	~(mask__AUD_SPDIFPC_CFG__CHL_STS_UPDATE_CLR(ip) << \
-	shift__AUD_SPDIFPC_CFG__CHL_STS_UPDATE_CLR(ip))) | (((value) & \
-	mask__AUD_SPDIFPC_CFG__CHL_STS_UPDATE_CLR(ip)) << \
-	shift__AUD_SPDIFPC_CFG__CHL_STS_UPDATE_CLR(ip)), ip->base + \
-	offset__AUD_SPDIFPC_CFG(ip))
 
 #define shift__AUD_SPDIFPC_CFG__CHA_STA_BITS(ip) (ip->ver < \
-	4 ? -1 : 6)
+	ver__AUD_SPDIFPC__65_3_0 ? -1 : 6)
 #define mask__AUD_SPDIFPC_CFG__CHA_STA_BITS(ip) (ip->ver < \
-	4 ? -1 : 0x1)
+	ver__AUD_SPDIFPC__65_3_0 ? -1 : 0x1)
 #define get__AUD_SPDIFPC_CFG__CHA_STA_BITS(ip) ((readl(ip->base + \
 	offset__AUD_SPDIFPC_CFG(ip)) >> \
 	shift__AUD_SPDIFPC_CFG__CHA_STA_BITS(ip)) & \
@@ -205,7 +213,7 @@
 	offset__AUD_SPDIFPC_CFG(ip))
 
 #define value__AUD_SPDIFPC_CFG__CHA_STA_BITS__SUBFRAME(ip) (ip->ver < \
-	4 ? -1 : 0x0)
+	ver__AUD_SPDIFPC__65_3_0 ? -1 : 0x0)
 #define mask__AUD_SPDIFPC_CFG__CHA_STA_BITS__SUBFRAME(ip) \
 	(value__AUD_SPDIFPC_CFG__CHA_STA_BITS__SUBFRAME(ip) << \
 	shift__AUD_SPDIFPC_CFG__CHA_STA_BITS(ip))
@@ -214,7 +222,7 @@
 	value__AUD_SPDIFPC_CFG__CHA_STA_BITS__SUBFRAME(ip))
 
 #define value__AUD_SPDIFPC_CFG__CHA_STA_BITS__FRAME(ip) (ip->ver < \
-	4 ? -1 : 0x1)
+	ver__AUD_SPDIFPC__65_3_0 ? -1 : 0x1)
 #define mask__AUD_SPDIFPC_CFG__CHA_STA_BITS__FRAME(ip) \
 	(value__AUD_SPDIFPC_CFG__CHA_STA_BITS__FRAME(ip) << \
 	shift__AUD_SPDIFPC_CFG__CHA_STA_BITS(ip))
diff -ruN stm.org/spdif_player.c stm/spdif_player.c
--- a/drivers/stm/spdif_player.c	2014-06-03 12:31:04.000000000 -0700
+++ b/sound/stm/spdif_player.c	2012-10-11 11:46:27.000000000 -0700
@@ -1,7 +1,7 @@
 /*
  *   STMicroelectronics System-on-Chips' SPDIF player driver
  *
- *   Copyright (c) 2005-2011 STMicroelectronics Limited
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
  *
  *   Author: Pawel Moll <pawel.moll@st.com>
  *
@@ -21,14 +21,12 @@
  *
  */
 
-#include <asm/cacheflush.h>
-#include <asm/clock.h>
 #include <linux/init.h>
 #include <linux/io.h>
 #include <linux/platform_device.h>
 #include <linux/interrupt.h>
 #include <linux/delay.h>
-#include <linux/stm/pad.h>
+#include <asm/cacheflush.h>
 #include <linux/stm/stm-dma.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -37,16 +35,12 @@
 #include <sound/info.h>
 #include <sound/asoundef.h>
 
+#define COMPONENT spdif_player
 #include "common.h"
 #include "reg_aud_spdif.h"
 
 
 
-static int snd_stm_debug_level;
-module_param_named(debug, snd_stm_debug_level, int, S_IRUGO | S_IWUSR);
-
-
-
 /*
  * Some hardware-related definitions
  */
@@ -97,7 +91,7 @@
 	int fdma_channel;
 
 	/* Environment settings */
-	struct clk *clock;
+	struct snd_stm_fsynth_channel *fsynth_channel;
 	struct snd_stm_conv_source *conv_source;
 
 	/* Default settings (controlled by controls ;-) */
@@ -115,7 +109,6 @@
 	struct snd_stm_spdif_player_settings stream_settings;
 	int stream_iec958_status_cnt;
 	int stream_iec958_subcode_cnt;
-	struct stm_pad_state *pads;
 
 	snd_stm_magic_field;
 };
@@ -135,14 +128,14 @@
 	snd_stm_printd(2, "snd_stm_spdif_player_irq_handler(irq=%d, "
 			"dev_id=0x%p)\n", irq, dev_id);
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
+	if (snd_BUG_ON(!spdif_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
 
 	/* Get interrupt status & clear them immediately */
-	preempt_disable();
 	status = get__AUD_SPDIF_ITS(spdif_player);
 	set__AUD_SPDIF_ITS_CLR(spdif_player, status);
-	preempt_enable();
 
 	if (unlikely(status &
 			mask__AUD_SPDIF_ITS__UNF__PENDING(spdif_player))) {
@@ -156,7 +149,8 @@
 			mask__AUD_SPDIF_ITS__NSAMPLE__PENDING(spdif_player))) {
 		/* Period successfully played */
 		do {
-			BUG_ON(!spdif_player->substream);
+			if (snd_BUG_ON(!spdif_player->substream))
+				break;
 
 			snd_stm_printd(2, "Period elapsed ('%s')\n",
 					dev_name(spdif_player->device));
@@ -167,7 +161,7 @@
 	}
 
 	/* Some alien interrupt??? */
-	BUG_ON(result != IRQ_HANDLED);
+	snd_BUG_ON(result != IRQ_HANDLED);
 
 	return result;
 }
@@ -259,9 +253,8 @@
 	snd_stm_printd(1, "snd_stm_spdif_player_open(substream=0x%p)\n",
 			substream);
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
-	BUG_ON(!runtime);
+	if (snd_BUG_ON(!spdif_player || !spdif_player || !runtime))
+		return -EINVAL;
 
 	snd_pcm_set_sync(substream);  /* TODO: ??? */
 
@@ -275,7 +268,7 @@
 				snd_stm_conv_get_name(
 				spdif_player->conv_group));
 	else
-		snd_stm_printd(1, "No converter attached to '%s'!\n",
+		snd_stm_printd(1, "Warning! No converter attached to '%s'!\n",
 				dev_name(spdif_player->device));
 
 	/* Get default data */
@@ -325,8 +318,10 @@
 	snd_stm_printd(1, "snd_stm_spdif_player_close(substream=0x%p)\n",
 			substream);
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
+	if (snd_BUG_ON(!spdif_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
 
 	if (spdif_player->conv_group) {
 		snd_stm_conv_release_group(spdif_player->conv_group);
@@ -347,9 +342,10 @@
 	snd_stm_printd(1, "snd_stm_spdif_player_hw_free(substream=0x%p)\n",
 			substream);
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
-	BUG_ON(!runtime);
+	if (snd_BUG_ON(!spdif_player || !runtime))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
 
 	/* This callback may be called more than once... */
 
@@ -390,9 +386,10 @@
 	snd_stm_printd(1, "snd_stm_spdif_player_hw_params(substream=0x%p,"
 			" hw_params=0x%p)\n", substream, hw_params);
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
-	BUG_ON(!runtime);
+	if (snd_BUG_ON(!spdif_player || !runtime))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
 
 	/* This function may be called many times, so let's be prepared... */
 	if (snd_stm_buffer_is_allocated(spdif_player->buffer))
@@ -421,16 +418,20 @@
 	snd_stm_printd(1, "FDMA request trigger limit and transfer size set "
 			"to %d.\n", transfer_size);
 
-	BUG_ON(buffer_bytes % transfer_bytes != 0);
-	BUG_ON(transfer_size > spdif_player->fdma_max_transfer_size);
+	if (snd_BUG_ON(buffer_bytes % transfer_bytes != 0))
+		return -EINVAL;
+	if (snd_BUG_ON(transfer_size > spdif_player->fdma_max_transfer_size))
+		return -EINVAL;
 	fdma_req_config.count = transfer_size;
 
-	if (spdif_player->ver >= 4) {
+	if (spdif_player->ver >= ver__AUD_SPDIF__65_3_1) {
 		/* FDMA request trigger control was introduced in
 		 * STx7111... */
-		BUG_ON(transfer_size != 1 && transfer_size % 2 != 0);
-		BUG_ON(transfer_size >
-		       mask__AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT(spdif_player));
+		if (snd_BUG_ON(transfer_size != 1 && transfer_size % 2 != 0))
+			return -EINVAL;
+		if (snd_BUG_ON(transfer_size >
+			       mask__AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT(spdif_player)))
+		    return -EINVAL;
 		set__AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT(spdif_player,
 				transfer_size);
 	}
@@ -484,16 +485,17 @@
 	int oversampling;
 	unsigned long status;
 	struct snd_aes_iec958 *iec958;
-	int result;
 
 	snd_stm_printd(1, "snd_stm_spdif_player_prepare(substream=0x%p)\n",
 			substream);
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
-	BUG_ON(!runtime);
-	BUG_ON(runtime->period_size * runtime->channels >=
-	       MAX_SAMPLES_PER_PERIOD);
+	if (snd_BUG_ON(!spdif_player || !runtime))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
+	if (snd_BUG_ON(runtime->period_size * runtime->channels >=
+		       MAX_SAMPLES_PER_PERIOD))
+		return -EINVAL;
 
 	/* Configure SPDIF-PCM synchronisation */
 
@@ -505,8 +507,9 @@
 		unsigned int format = snd_stm_conv_get_format(
 				spdif_player->conv_group);
 
-		BUG_ON((format & SND_STM_FORMAT__MASK) !=
-		       SND_STM_FORMAT__SPDIF);
+		if (snd_BUG_ON((format & SND_STM_FORMAT__MASK) !=
+			       SND_STM_FORMAT__SPDIF))
+			return -EINVAL;
 
 		oversampling = snd_stm_conv_get_oversampling(
 				spdif_player->conv_group);
@@ -520,29 +523,18 @@
 			dev_name(spdif_player->device), runtime->rate,
 			oversampling);
 
-	BUG_ON(oversampling <= 0);
+	if (snd_BUG_ON(oversampling <= 0))
+		return -EINVAL;
 
 	/* Allowed oversampling values (SPDIF subframe is 32 bits long,
 	 * so oversampling must be multiple of 128... */
-	BUG_ON(oversampling % 128 != 0);
+	if (snd_BUG_ON(oversampling % 128 != 0))
+		return -EINVAL;
 
 	/* Set up frequency synthesizer */
 
-	result = clk_enable(spdif_player->clock);
-	if (result != 0) {
-		snd_stm_printe("Can't enable clock for player '%s'!\n",
-				dev_name(spdif_player->device));
-		return result;
-	}
-
-	result = clk_set_rate(spdif_player->clock,
-				runtime->rate * oversampling);
-	if (result != 0) {
-		snd_stm_printe("Can't configure clock for player '%s'!\n",
-				dev_name(spdif_player->device));
-		clk_disable(spdif_player->clock);
-		return result;
-	}
+	snd_stm_fsynth_set_frequency(spdif_player->fsynth_channel,
+			runtime->rate * oversampling);
 
 	/* Configure SPDIF player frequency divider
 	 *
@@ -634,8 +626,10 @@
 	snd_stm_printd(1, "snd_stm_spdif_player_start(substream=0x%p)\n",
 			substream);
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
+	if (snd_BUG_ON(!spdif_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
 
 	/* Un-reset SPDIF player */
 
@@ -689,8 +683,10 @@
 	snd_stm_printd(1, "snd_stm_spdif_player_stop(substream=0x%p)\n",
 			substream);
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
+	if (snd_BUG_ON(!spdif_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
 
 	/* Mute & shutdown converter */
 
@@ -713,9 +709,8 @@
 
 	dma_stop_channel(spdif_player->fdma_channel);
 
-	/* Stop the clock and reset SPDIF player */
+	/* Reset SPDIF player */
 
-	clk_disable(spdif_player->clock);
 	set__AUD_SPDIF_RST__SRSTP__RESET(spdif_player);
 
 	return 0;
@@ -729,8 +724,10 @@
 	snd_stm_printd(1, "snd_stm_spdif_player_pause(substream=0x%p)\n",
 			substream);
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
+	if (snd_BUG_ON(!spdif_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
 
 	/* "Mute" player
 	 * Documentation describes this mode in a wrong way - data is _not_
@@ -753,8 +750,10 @@
 	snd_stm_printd(1, "snd_stm_spdif_player_release(substream=0x%p)\n",
 			substream);
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
+	if (snd_BUG_ON(!spdif_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
 
 	/* "Unmute" player */
 
@@ -799,9 +798,10 @@
 	snd_stm_printd(2, "snd_stm_spdif_player_pointer(substream=0x%p)\n",
 			substream);
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
-	BUG_ON(!runtime);
+	if (snd_BUG_ON(!spdif_player || !runtime))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
 
 	residue = get_dma_residue(spdif_player->fdma_channel);
 	hwptr = (runtime->dma_bytes - residue) % runtime->dma_bytes;
@@ -832,8 +832,10 @@
 {
 	unsigned char data;
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
+	if (snd_BUG_ON(!spdif_player))
+		return;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return;
 
 	/* Clean VUC bits */
 	*left_subframe &= ~VUC_MASK;
@@ -881,10 +883,12 @@
 			"channel=%d, pos=%lu, buf=0x%p, count=%lu)\n",
 			substream, channel, pos, src, count);
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
-	BUG_ON(!runtime);
-	BUG_ON(channel != -1); /* Interleaved buffer */
+	if (snd_BUG_ON(!spdif_player || !runtime))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
+	if (snd_BUG_ON(channel != -1))
+		return -EINVAL; /* Interleaved buffer */
 
 	if (spdif_player->stream_settings.input_mode ==
 			SNDRV_STM_SPDIF_INPUT_MODE_NORMAL) {
@@ -966,10 +970,12 @@
 			"channel=%d, pos=%lu, count=%lu)\n",
 			substream, channel, pos, count);
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
-	BUG_ON(!runtime);
-	BUG_ON(channel != -1); /* Interleaved buffer */
+	if (snd_BUG_ON(!spdif_player || !runtime))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
+	if (snd_BUG_ON(channel != -1))
+		return -EINVAL; /* Interleaved buffer */
 
 	if (spdif_player->stream_settings.input_mode ==
 			SNDRV_STM_SPDIF_INPUT_MODE_NORMAL) {
@@ -1024,8 +1030,10 @@
 	snd_stm_printd(1, "snd_stm_spdif_player_ctl_default_get("
 			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
+	if (snd_BUG_ON(!spdif_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
 
 	spin_lock(&spdif_player->default_settings_lock);
 	ucontrol->value.iec958 = spdif_player->default_settings.iec958;
@@ -1043,8 +1051,10 @@
 	snd_stm_printd(1, "snd_stm_spdif_player_ctl_default_put("
 			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
+	if (snd_BUG_ON(!spdif_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
 
 	spin_lock(&spdif_player->default_settings_lock);
 	if (snd_stm_iec958_cmp(&spdif_player->default_settings.iec958,
@@ -1070,8 +1080,10 @@
 	snd_stm_printd(1, "snd_stm_spdif_player_ctl_raw_get(kcontrol=0x%p, "
 			"ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
+	if (snd_BUG_ON(!spdif_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
 
 	spin_lock(&spdif_player->default_settings_lock);
 	ucontrol->value.integer.value[0] =
@@ -1092,8 +1104,10 @@
 	snd_stm_printd(1, "snd_stm_spdif_player_ctl_raw_put(kcontrol=0x%p, "
 			"ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
+	if (snd_BUG_ON(!spdif_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
 
 	if (ucontrol->value.integer.value[0])
 		input_mode = SNDRV_STM_SPDIF_INPUT_MODE_RAW;
@@ -1120,8 +1134,10 @@
 	snd_stm_printd(1, "snd_stm_spdif_player_ctl_encoded_get(kcontrol=0x%p, "
 			" ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
+	if (snd_BUG_ON(!spdif_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
 
 	spin_lock(&spdif_player->default_settings_lock);
 	ucontrol->value.integer.value[0] =
@@ -1142,8 +1158,10 @@
 	snd_stm_printd(1, "snd_stm_spdif_player_ctl_encoded_put(kcontrol=0x%p,"
 			" ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
+	if (snd_BUG_ON(!spdif_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
 
 	if (ucontrol->value.integer.value[0])
 		encoding_mode = SNDRV_STM_SPDIF_ENCODING_MODE_ENCODED;
@@ -1179,8 +1197,10 @@
 	snd_stm_printd(1, "snd_stm_spdif_player_ctl_preamble_get(kcontrol=0x%p"
 			", ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
+	if (snd_BUG_ON(!spdif_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
 
 	spin_lock(&spdif_player->default_settings_lock);
 	memcpy(ucontrol->value.bytes.data,
@@ -1200,8 +1220,10 @@
 	snd_stm_printd(1, "snd_stm_spdif_player_ctl_preamble_put(kcontrol=0x%p"
 			", ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
+	if (snd_BUG_ON(!spdif_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
 
 	spin_lock(&spdif_player->default_settings_lock);
 	if (memcmp(spdif_player->default_settings.iec61937_preamble,
@@ -1233,8 +1255,10 @@
 	snd_stm_printd(1, "snd_stm_spdif_player_ctl_audio_repetition_get("
 			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
+	if (snd_BUG_ON(!spdif_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
 
 	spin_lock(&spdif_player->default_settings_lock);
 	ucontrol->value.integer.value[0] =
@@ -1253,8 +1277,10 @@
 	snd_stm_printd(1, "snd_stm_spdif_player_ctl_audio_repetition_put("
 			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
+	if (snd_BUG_ON(!spdif_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
 
 	spin_lock(&spdif_player->default_settings_lock);
 	if (spdif_player->default_settings.iec61937_audio_repetition !=
@@ -1276,8 +1302,10 @@
 	snd_stm_printd(1, "snd_stm_spdif_player_ctl_pause_repetition_get("
 			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
+	if (snd_BUG_ON(!spdif_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
 
 	spin_lock(&spdif_player->default_settings_lock);
 	ucontrol->value.integer.value[0] =
@@ -1296,8 +1324,10 @@
 	snd_stm_printd(1, "snd_stm_spdif_player_ctl_pause_repetition_put("
 			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
+	if (snd_BUG_ON(!spdif_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
 
 	spin_lock(&spdif_player->default_settings_lock);
 	if (spdif_player->default_settings.iec61937_pause_repetition !=
@@ -1383,8 +1413,10 @@
 {
 	struct snd_stm_spdif_player *spdif_player = entry->private_data;
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
+	if (snd_BUG_ON(!spdif_player))
+		return;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return;
 
 	snd_iprintf(buffer, "--- %s ---\n", dev_name(spdif_player->device));
 	snd_iprintf(buffer, "base = 0x%p\n", spdif_player->base);
@@ -1405,7 +1437,7 @@
 	DUMP_REGISTER(CL2_CR2_UV);
 	DUMP_REGISTER(PAU_LAT);
 	DUMP_REGISTER(BST_FL);
-	if (spdif_player->ver >= 4)
+	if (spdif_player->ver >= ver__AUD_SPDIF__65_3_1)
 		DUMP_REGISTER(CONFIG);
 
 	snd_iprintf(buffer, "\n");
@@ -1417,17 +1449,23 @@
 	struct snd_stm_spdif_player *spdif_player = snd_device->device_data;
 	int i;
 
-	snd_stm_printd(1, "%s(snd_device=0x%p)\n", __func__, snd_device);
+	snd_stm_printd(1, "snd_stm_spdif_player_register(snd_device=0x%p)\n",
+			snd_device);
+
+	if (snd_BUG_ON(!spdif_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
+	snd_stm_printd(0, "--- Registering player '%s'...\n",
+			dev_name(spdif_player->device));
 
 	/* Initialize hardware (format etc.) */
 
 	set__AUD_SPDIF_RST__SRSTP__RESET(spdif_player);
 
 	/* TODO: well, hardcoded - shall anyone use it?
-	 * and what does it actually mean? */
+	 * And what it actually means? */
 	set__AUD_SPDIF_CTRL__RND__NO_ROUNDING(spdif_player);
 
 	set__AUD_SPDIF_CTRL__IDLE__NORMAL(spdif_player);
@@ -1438,14 +1476,17 @@
 
 	/* Get frequency synthesizer channel */
 
-	spdif_player->clock = snd_stm_clk_get(spdif_player->device,
-			"spdif_player_clk", snd_device->card,
-			spdif_player->info->card_device);
-	if (!spdif_player->clock || IS_ERR(spdif_player->clock)) {
-		snd_stm_printe("Failed to get a clock for '%s'!\n",
-				dev_name(spdif_player->device));
+	if (snd_BUG_ON(spdif_player->info->fsynth_bus_id == NULL))
+		return -EINVAL;
+	snd_stm_printd(0, "Player connected to %s's output %d.\n",
+			spdif_player->info->fsynth_bus_id,
+			spdif_player->info->fsynth_output);
+
+	spdif_player->fsynth_channel = snd_stm_fsynth_get_channel(
+			spdif_player->info->fsynth_bus_id,
+			spdif_player->info->fsynth_output);
+	if (snd_BUG_ON(spdif_player->fsynth_channel == NULL))
 		return -EINVAL;
-	}
 
 	/* Registers view in ALSA's procfs */
 
@@ -1453,7 +1494,15 @@
 			dev_name(spdif_player->device),
 			snd_stm_spdif_player_dump_registers, spdif_player);
 
-	/* Create SPDIF ALSA controls */
+	/* Create ALSA controls */
+
+	result = snd_stm_fsynth_add_adjustement_ctl(
+			spdif_player->fsynth_channel, snd_device->card,
+			spdif_player->info->card_device);
+	if (result < 0) {
+		snd_stm_printe("Failed to add fsynth adjustment control!\n");
+		return result;
+	}
 
 	for (i = 0; i < ARRAY_SIZE(snd_stm_spdif_player_ctls); i++) {
 		snd_stm_spdif_player_ctls[i].device =
@@ -1468,6 +1517,8 @@
 		snd_stm_spdif_player_ctls[i].index++;
 	}
 
+	snd_stm_printd(0, "--- Registered successfully!\n");
+
 	return 0;
 }
 
@@ -1475,12 +1526,13 @@
 {
 	struct snd_stm_spdif_player *spdif_player = snd_device->device_data;
 
-	snd_stm_printd(1, "%s(snd_device=0x%p)\n", __func__, snd_device);
-
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
+	snd_stm_printd(1, "snd_stm_spdif_player_disconnect(snd_device=0x%p)\n",
+			snd_device);
 
-	snd_stm_clk_put(spdif_player->clock);
+	if (snd_BUG_ON(!spdif_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
 
 	snd_stm_info_unregister(spdif_player->proc_entry);
 
@@ -1505,9 +1557,12 @@
 	struct snd_card *card = snd_stm_card_get();
 	int buffer_bytes_max;
 
-	snd_stm_printd(0, "%s('%s')\n", __func__, dev_name(&pdev->dev));
+	snd_stm_printd(1, "snd_stm_spdif_player_probe(pdev=%p)\n", pdev);
+
+	snd_stm_printd(0, "Probing device '%s'...\n", dev_name(&pdev->dev));
 
-	BUG_ON(!card);
+	if (snd_BUG_ON(card == NULL))
+		return -EINVAL;
 
 	spdif_player = kzalloc(sizeof(*spdif_player), GFP_KERNEL);
 	if (!spdif_player) {
@@ -1518,9 +1573,11 @@
 	}
 	snd_stm_magic_set(spdif_player);
 	spdif_player->info = pdev->dev.platform_data;
-	BUG_ON(!spdif_player->info);
+	if (snd_BUG_ON(spdif_player->info == NULL))
+		return -EINVAL;
 	spdif_player->ver = spdif_player->info->ver;
-	BUG_ON(spdif_player->ver <= 0);
+	if (snd_BUG_ON(spdif_player->ver <= 0))
+		return -EINVAL;
 	spdif_player->device = &pdev->dev;
 
 	spin_lock_init(&spdif_player->default_settings_lock);
@@ -1556,9 +1613,9 @@
 	 * - 6 cells (24 bytes) in STx7100/9 and STx7200 cut 1.0
 	 * - 30 cells (120 bytes) in STx7111 and STx7200 cut 2.0. */
 
-	if (spdif_player->ver < 3)
+	if (spdif_player->ver < ver__AUD_SPDIF__65_2_0)
 		spdif_player->fdma_max_transfer_size = 2;
-	else if (spdif_player->ver == 3)
+	else if (spdif_player->ver == ver__AUD_SPDIF__65_2_0)
 		spdif_player->fdma_max_transfer_size = 4;
 	else
 		spdif_player->fdma_max_transfer_size = 20;
@@ -1614,28 +1671,12 @@
 		goto error_conv_register_source;
 	}
 
-	/* Claim the pads */
-
-	if (spdif_player->info->pad_config) {
-		spdif_player->pads = stm_pad_claim(
-				spdif_player->info->pad_config,
-				dev_name(&pdev->dev));
-		if (!spdif_player->pads) {
-			snd_stm_printe("Failed to claimed pads for '%s'!\n",
-					dev_name(&pdev->dev));
-			result = -EBUSY;
-			goto error_pad_claim;
-		}
-	}
-
 	/* Done now */
 
 	platform_set_drvdata(pdev, spdif_player);
 
 	return 0;
 
-error_pad_claim:
-	snd_stm_conv_unregister_source(spdif_player->conv_source);
 error_conv_register_source:
 	snd_stm_buffer_dispose(spdif_player->buffer);
 error_buffer_create:
@@ -1662,11 +1703,11 @@
 
 	snd_stm_printd(1, "snd_stm_spdif_player_remove(pdev=%p)\n", pdev);
 
-	BUG_ON(!spdif_player);
-	BUG_ON(!snd_stm_magic_valid(spdif_player));
+	if (snd_BUG_ON(!spdif_player))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(spdif_player)))
+		return -EINVAL;
 
-	if (spdif_player->pads)
-		stm_pad_release(spdif_player->pads);
 	snd_stm_conv_unregister_source(spdif_player->conv_source);
 	snd_stm_buffer_dispose(spdif_player->buffer);
 	snd_stm_fdma_release(spdif_player->fdma_channel);
@@ -1680,7 +1721,9 @@
 }
 
 static struct platform_driver snd_stm_spdif_player_driver = {
-	.driver.name = "snd_spdif_player",
+	.driver = {
+		.name = "snd_spdif_player",
+	},
 	.probe = snd_stm_spdif_player_probe,
 	.remove = snd_stm_spdif_player_remove,
 };
@@ -1691,19 +1734,12 @@
  * Initialization
  */
 
-static int __init snd_stm_spdif_player_init(void)
+int snd_stm_spdif_player_init(void)
 {
 	return platform_driver_register(&snd_stm_spdif_player_driver);
 }
 
-static void __exit snd_stm_spdif_player_exit(void)
+void snd_stm_spdif_player_exit(void)
 {
 	platform_driver_unregister(&snd_stm_spdif_player_driver);
 }
-
-MODULE_AUTHOR("Pawel Moll <pawel.moll@st.com>");
-MODULE_DESCRIPTION("STMicroelectronics SPDIF player driver");
-MODULE_LICENSE("GPL");
-
-module_init(snd_stm_spdif_player_init);
-module_exit(snd_stm_spdif_player_exit);
diff -ruN stm.org/stx7105.c stm/stx7105.c
--- a/drivers/stm/stx7105.c	2014-06-03 12:31:04.000000000 -0700
+++ b/sound/stm/stx7105.c	2012-10-11 11:46:27.000000000 -0700
@@ -1,7 +1,7 @@
 /*
- *   STMicrolectronics STx7105 ans STx7106 audio glue driver
+ *   STMicrolectronics STx7105 audio subsystem driver
  *
- *   Copyright (c) 2005-2011 STMicroelectronics Limited
+ *   Copyright (c) 2005-2007 STMicroelectronics Limited
  *
  *   Author: Pawel Moll <pawel.moll@st.com>
  *
@@ -28,12 +28,23 @@
 #include <linux/io.h>
 #include <sound/core.h>
 
+#define COMPONENT stx7105
 #include "common.h"
+#include "reg_7105_audcfg.h"
 
 
 
-static int snd_stm_debug_level;
-module_param_named(debug, snd_stm_debug_level, int, S_IRUGO | S_IWUSR);
+/*
+ * ALSA module parameters
+ */
+
+static int index = -1; /* First available index */
+static char *id = "STx7105"; /* Default card ID */
+
+module_param(index, int, 0444);
+MODULE_PARM_DESC(index, "Index value for STx7105 audio subsystem card.");
+module_param(id, charp, 0444);
+MODULE_PARM_DESC(id, "ID string for STx7105 audio subsystem card.");
 
 
 
@@ -41,22 +52,9 @@
  * Audio glue driver implementation
  */
 
-#define IO_CTRL(base)		((base) + 0x00)
-#define PCM_CLK_EN		0
-#define PCM_CLK_EN__INPUT	(0 << PCM_CLK_EN)
-#define PCM_CLK_EN__OUTPUT	(1 << PCM_CLK_EN)
-#define SPDIFHDMI_EN		3
-#define SPDIFHDMI_EN__INPUT	(0 << SPDIFHDMI_EN)
-#define SPDIFHDMI_EN__OUTPUT	(1 << SPDIFHDMI_EN)
-#define PCMPLHDMI_EN		5
-#define PCMPLHDMI_EN__INPUT	(0 << PCMPLHDMI_EN)
-#define PCMPLHDMI_EN__OUTPUT	(1 << PCMPLHDMI_EN)
-#define CLKREC_SEL		9
-#define CLKREC_SEL__PCMPLHDMI	(0 << CLKREC_SEL)
-#define CLKREC_SEL__SPDIFHDMI	(1 << CLKREC_SEL)
-#define CLKREC_SEL__PCMPL1	(2 << CLKREC_SEL)
-
 struct snd_stm_stx7105_glue {
+	int ver;
+
 	struct resource *mem_region;
 	void *base;
 
@@ -70,23 +68,78 @@
 {
 	struct snd_stm_stx7105_glue *stx7105_glue = entry->private_data;
 
-	BUG_ON(!stx7105_glue);
-	BUG_ON(!snd_stm_magic_valid(stx7105_glue));
+	if (snd_BUG_ON(!stx7105_glue))
+		return;
+	if (snd_BUG_ON(!snd_stm_magic_valid(stx7105_glue)))
+		return;
 
 	snd_iprintf(buffer, "--- snd_stx7105_glue ---\n");
-	snd_iprintf(buffer, "IO_CTRL (0x%p) = 0x%08x\n",
-			IO_CTRL(stx7105_glue->base),
-			readl(IO_CTRL(stx7105_glue->base)));
+	snd_iprintf(buffer, "base = 0x%p\n", stx7105_glue->base);
+
+	snd_iprintf(buffer, "AUDCFG_IO_CTRL (offset 0x00) = 0x%08x\n",
+			get__7105_AUDCFG_IO_CTRL(stx7105_glue));
 
 	snd_iprintf(buffer, "\n");
 }
 
+static int __init snd_stm_stx7105_glue_register(struct snd_device *snd_device)
+{
+	struct snd_stm_stx7105_glue *stx7105_glue = snd_device->device_data;
+
+	if (snd_BUG_ON(!stx7105_glue))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(stx7105_glue)))
+		return -EINVAL;
+
+	/* Enable audio outputs */
+
+	set__7105_AUDCFG_IO_CTRL(stx7105_glue,
+		mask__7105_AUDCFG_IO_CTRL__PCMPLHDMI_EN__OUTPUT(stx7105_glue) |
+		mask__7105_AUDCFG_IO_CTRL__SPDIFHDMI_EN__OUTPUT(stx7105_glue) |
+		mask__7105_AUDCFG_IO_CTRL__PCM_CLK_EN__OUTPUT(stx7105_glue));
+
+	/* Additional procfs info */
+
+	snd_stm_info_register(&stx7105_glue->proc_entry, "stx7105_glue",
+			snd_stm_stx7105_glue_dump_registers, stx7105_glue);
+
+	return 0;
+}
+
+static int __exit snd_stm_stx7105_glue_disconnect(struct snd_device *snd_device)
+{
+	struct snd_stm_stx7105_glue *stx7105_glue = snd_device->device_data;
+
+	if (snd_BUG_ON(!stx7105_glue))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(stx7105_glue)))
+		return -EINVAL;
+
+	/* Remove procfs entry */
+
+	snd_stm_info_unregister(stx7105_glue->proc_entry);
+
+	/* Disable audio outputs */
+
+	set__7105_AUDCFG_IO_CTRL(stx7105_glue,
+		mask__7105_AUDCFG_IO_CTRL__PCMPLHDMI_EN__OUTPUT(stx7105_glue) |
+		mask__7105_AUDCFG_IO_CTRL__SPDIFHDMI_EN__OUTPUT(stx7105_glue) |
+		mask__7105_AUDCFG_IO_CTRL__PCM_CLK_EN__OUTPUT(stx7105_glue));
+
+	return 0;
+}
+
+static struct snd_device_ops snd_stm_stx7105_glue_snd_device_ops = {
+	.dev_register = snd_stm_stx7105_glue_register,
+	.dev_disconnect = snd_stm_stx7105_glue_disconnect,
+};
+
 static int __init snd_stm_stx7105_glue_probe(struct platform_device *pdev)
 {
 	int result = 0;
 	struct snd_stm_stx7105_glue *stx7105_glue;
 
-	snd_stm_printd(0, "%s('%s')\n", __func__, dev_name(&pdev->dev));
+	snd_stm_printd(0, "--- Probing device '%s'...\n", dev_name(&pdev->dev));
 
 	stx7105_glue = kzalloc(sizeof(*stx7105_glue), GFP_KERNEL);
 	if (!stx7105_glue) {
@@ -104,18 +157,25 @@
 		goto error_memory_request;
 	}
 
-	/* Enable audio outputs */
-	writel(PCMPLHDMI_EN__OUTPUT | SPDIFHDMI_EN__OUTPUT |
-			PCM_CLK_EN__OUTPUT, IO_CTRL(stx7105_glue->base));
+	/* ALSA component */
 
-	/* Additional procfs info */
-	snd_stm_info_register(&stx7105_glue->proc_entry, "stx7105_glue",
-			snd_stm_stx7105_glue_dump_registers, stx7105_glue);
+	result = snd_device_new(snd_stm_card_get(), SNDRV_DEV_LOWLEVEL,
+			stx7105_glue, &snd_stm_stx7105_glue_snd_device_ops);
+	if (result < 0) {
+		snd_stm_printe("ALSA low level device creation failed!\n");
+		goto error_device;
+	}
+
+	/* Done now */
 
 	platform_set_drvdata(pdev, stx7105_glue);
 
+	snd_stm_printd(0, "--- Probed successfully!\n");
+
 	return result;
 
+error_device:
+	snd_stm_memory_release(stx7105_glue->mem_region, stx7105_glue->base);
 error_memory_request:
 	snd_stm_magic_clear(stx7105_glue);
 	kfree(stx7105_glue);
@@ -125,19 +185,13 @@
 
 static int __exit snd_stm_stx7105_glue_remove(struct platform_device *pdev)
 {
-	struct snd_stm_stx7105_glue *stx7105_glue = platform_get_drvdata(pdev);
-
-	snd_stm_printd(0, "%s('%s')\n", __func__, dev_name(&pdev->dev));
+	struct snd_stm_stx7105_glue *stx7105_glue =
+			platform_get_drvdata(pdev);
 
-	BUG_ON(!stx7105_glue);
-	BUG_ON(!snd_stm_magic_valid(stx7105_glue));
-
-	/* Remove procfs entry */
-	snd_stm_info_unregister(stx7105_glue->proc_entry);
-
-	/* Disable audio outputs */
-	writel(PCMPLHDMI_EN__INPUT | SPDIFHDMI_EN__INPUT |
-			PCM_CLK_EN__INPUT, IO_CTRL(stx7105_glue->base));
+	if (snd_BUG_ON(!stx7105_glue))
+		return -EINVAL;
+	if (snd_BUG_ON(!snd_stm_magic_valid(stx7105_glue)))
+		return -EINVAL;
 
 	snd_stm_memory_release(stx7105_glue->mem_region, stx7105_glue->base);
 
@@ -148,7 +202,9 @@
 }
 
 static struct platform_driver snd_stm_stx7105_glue_driver = {
-	.driver.name = "snd_stx7105_glue",
+	.driver = {
+		.name = "snd_stx7105_glue",
+	},
 	.probe = snd_stm_stx7105_glue_probe,
 	.remove = snd_stm_stx7105_glue_remove,
 };
@@ -162,22 +218,40 @@
 static int __init snd_stm_stx7105_init(void)
 {
 	int result;
+	struct snd_card *card;
 
-	snd_stm_printd(0, "%s()\n", __func__);
+	snd_stm_printd(0, "snd_stm_stx7105_init()\n");
 
-	if (cpu_data->type != CPU_STX7105 && cpu_data->type != CPU_STX7106) {
-		snd_stm_printe("Not supported (other than STx7105 or STx7106)"
-				" SOC detected!\n");
+	if (cpu_data->type != CPU_STX7105) {
+		snd_stm_printe("Not supported (other than STx7105) SOC "
+				"detected!\n");
 		result = -EINVAL;
 		goto error_soc_type;
 	}
 
+	card = snd_stm_card_new(index, id, THIS_MODULE);
+	if (card == NULL) {
+		snd_stm_printe("ALSA card creation failed!\n");
+		result = -ENOMEM;
+		goto error_card_new;
+	}
+	strcpy(card->driver, "STx7105");
+	strcpy(card->shortname, "STx7105 audio subsystem");
+	snprintf(card->longname, 79, "STMicroelectronics STx7105 cut %d "
+			"SOC audio subsystem", cpu_data->cut_major);
+
 	result = platform_driver_register(&snd_stm_stx7105_glue_driver);
 	if (result != 0) {
 		snd_stm_printe("Failed to register audio glue driver!\n");
 		goto error_glue_driver_register;
 	}
 
+	result = snd_stm_drivers_register();
+	if (result != 0) {
+		snd_stm_printe("Drivers registration failed!\n");
+		goto error_drivers_register;
+	}
+
 	result = snd_stm_card_register();
 	if (result != 0) {
 		snd_stm_printe("Failed to register ALSA cards!\n");
@@ -187,21 +261,28 @@
 	return 0;
 
 error_card_register:
+	snd_stm_drivers_unregister();
+error_drivers_register:
 	platform_driver_unregister(&snd_stm_stx7105_glue_driver);
 error_glue_driver_register:
+	snd_stm_card_free();
+error_card_new:
 error_soc_type:
 	return result;
 }
 
 static void __exit snd_stm_stx7105_exit(void)
 {
-	snd_stm_printd(0, "%s()\n", __func__);
+	snd_stm_printd(0, "snd_stm_stx7105_exit()\n");
+
+	snd_stm_card_free();
 
+	snd_stm_drivers_unregister();
 	platform_driver_unregister(&snd_stm_stx7105_glue_driver);
 }
 
 MODULE_AUTHOR("Pawel Moll <pawel.moll@st.com>");
-MODULE_DESCRIPTION("STMicroelectronics STx7105 and STx7106 audio driver");
+MODULE_DESCRIPTION("STMicroelectronics STx7105 audio driver");
 MODULE_LICENSE("GPL");
 
 module_init(snd_stm_stx7105_init);
